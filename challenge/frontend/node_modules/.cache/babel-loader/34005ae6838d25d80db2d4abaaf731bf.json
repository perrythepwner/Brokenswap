{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n */\n\n/**\n * @typedef Point\n *   unist point, where `line` and `column` can be `undefined`.\n * @property {number | undefined} line\n *   Line.\n * @property {number | undefined} column\n *   Column.\n * @property {number | undefined} [offset]\n *   Offset.\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get a line/column-based `point` from `offset`.\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {Point}\n *   Point, line/column are undefined for invalid or out of bounds input.\n *\n * @callback ToOffset\n *   Get an offset from a line/column-based `point`.\n * @param {Point | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number}\n *   Offset or `-1` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get a line/column-based `point` from `offset`.\n * @property {ToOffset} toOffset\n *   Get an offset from a line/column-based `point`.\n */\n\n/**\n * Index the given document so you can translate between line/column and offset\n * based positional info.\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file);\n  /** @type {Array<number>} */\n  const indices = [];\n  const search = /\\r?\\n|\\r/g;\n  while (search.test(value)) {\n    indices.push(search.lastIndex);\n  }\n  indices.push(value.length + 1);\n  return {\n    toPoint,\n    toOffset\n  };\n\n  /** @type {ToPoint} */\n  function toPoint(offset) {\n    let index = -1;\n    if (typeof offset === 'number' && offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          };\n        }\n      }\n    }\n    return {\n      line: undefined,\n      column: undefined,\n      offset: undefined\n    };\n  }\n\n  /** @type {ToOffset} */\n  function toOffset(point) {\n    const line = point && point.line;\n    const column = point && point.column;\n    if (typeof line === 'number' && typeof column === 'number' && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\n      const offset = (indices[line - 2] || 0) + column - 1 || 0;\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset;\n      }\n    }\n    return -1;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}