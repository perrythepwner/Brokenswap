{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst mini_kit_1 = require(\"@celo/contractkit/lib/mini-kit\");\nconst wallet_walletconnect_1 = require(\"@celo/wallet-walletconnect\");\nconst bignumber_js_1 = require(\"bignumber.js\");\nconst constants_1 = require(\"../constants\");\nconst logger_1 = require(\"../utils/logger\");\nconst common_1 = require(\"./common\");\nclass WalletConnectConnector extends common_1.AbstractConnector {\n  constructor(network, manualNetworkMode, feeCurrency, options) {\n    let autoOpen = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let getDeeplinkUrl = arguments.length > 5 ? arguments[5] : undefined;\n    let version = arguments.length > 6 ? arguments[6] : undefined;\n    let walletId = arguments.length > 7 ? arguments[7] : undefined;\n    super();\n    this.network = network;\n    this.feeCurrency = feeCurrency;\n    this.options = options;\n    this.autoOpen = autoOpen;\n    this.getDeeplinkUrl = getDeeplinkUrl;\n    this.version = version;\n    this.walletId = walletId;\n    this.initialised = false;\n    this.type = constants_1.WalletTypes.WalletConnect;\n    this.onCallRequest = (error, payload) => {\n      (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'onCallRequest', payload, error ? \"Error \".concat(error.name, \" \").concat(error.message) : '');\n      if (error) {\n        (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-call-request', payload, error);\n        this.emit(common_1.ConnectorEvents.WC_ERROR, error);\n      }\n    };\n    this.onSessionEvent = (_error, data) => {\n      var _a, _b;\n      (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-session-event', (_b = (_a = data === null || data === void 0 ? void 0 : data.params) === null || _a === void 0 ? void 0 : _a.event) === null || _b === void 0 ? void 0 : _b.name, data);\n      if (_error) {\n        this.emit(common_1.ConnectorEvents.WC_ERROR, _error);\n        return;\n      }\n      switch (data === null || data === void 0 ? void 0 : data.params.event.name) {\n        case 'accountsChanged':\n          {\n            if (Array.isArray(data === null || data === void 0 ? void 0 : data.params.event.data) && (data === null || data === void 0 ? void 0 : data.params.event.data[0])) {\n              return this.onAddressChange(data === null || data === void 0 ? void 0 : data.params.event.data[0]);\n            }\n            break;\n          }\n        case 'chainChanged':\n          {\n            // from https://docs.walletconnect.com/2.0/web/web3wallet/wallet-usage#chainchanged\n            const chainId = data.params.chainId.split('eip155:')[1];\n            this.emit(common_1.ConnectorEvents.WALLET_CHAIN_CHANGED, Number(chainId));\n            break;\n          }\n        default:\n          (0, logger_1.getApplicationLogger)().warn('unsupported session_event received', data === null || data === void 0 ? void 0 : data.params.event.name);\n      }\n    };\n    this.onSessionUpdated = (error, data) => __awaiter(this, void 0, void 0, function* () {\n      (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-session-update', data);\n      if (error) {\n        this.emit(common_1.ConnectorEvents.WC_ERROR, error);\n      }\n      try {\n        // either there will be data or an error\n        if (data) {\n          // session update is called when the wallet connects to the dapp.\n          // it might also be called to just update the session, however this is fine\n          // since the onConnect event just updates values in reducer and if they are the same\n          // it will not trigger a re-render.\n          yield this.onConnected(data);\n        }\n      } catch (e) {\n        (0, logger_1.getApplicationLogger)().error('wallet-connect', 'on-session-update', e);\n        this.emit(common_1.ConnectorEvents.WC_ERROR, e);\n      }\n    });\n    this.onSessionDeleted = (_error, data) => __awaiter(this, void 0, void 0, function* () {\n      (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-session-delete', data, _error);\n      // since dapps send the event both when they initiate disconnection and\n      // when responding to disconnection requests, check if dapp initiated the\n      // connection to avoid closing twice.\n      try {\n        yield this.close();\n      } catch (e) {\n        (0, logger_1.getApplicationLogger)().warn(e);\n      }\n    });\n    this.updateFeeCurrency = common_1.updateFeeCurrency.bind(this);\n    const wallet = new wallet_walletconnect_1.WalletConnectWallet(Object.assign(Object.assign({}, options), {\n      chainId: network.chainId\n    }));\n    this.kit = (0, mini_kit_1.newKit)(network.rpcUrl, wallet);\n  }\n  // this is called automatically and is what gives us the uri for the qr code to be scanned\n  initialise() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initialised) {\n        return this;\n      }\n      const wallet = this.kit.getWallet();\n      wallet.on('session_update', this.onSessionUpdated);\n      wallet.on('session_event', this.onSessionEvent);\n      wallet.on('session_delete', this.onSessionDeleted);\n      wallet.on('session_request', this.onCallRequest);\n      try {\n        yield this.handleUri(wallet);\n      } catch (e) {\n        (0, logger_1.getApplicationLogger)().error('Error handling uri', e);\n      }\n      try {\n        yield wallet.init();\n      } catch (e) {\n        (0, logger_1.getApplicationLogger)().error('error wallet init', e);\n      }\n      const [address] = wallet.getAccounts();\n      const defaultAccount = yield this.fetchWalletAddressForAccount(address);\n      this.kit.connection.defaultAccount = defaultAccount;\n      this.initialised = true;\n      this.emit(common_1.ConnectorEvents.WC_INITIALISED);\n      return this;\n    });\n  }\n  handleUri(wallet) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const uri = yield wallet.getUri();\n      if (uri) {\n        this.emit(common_1.ConnectorEvents.WC_URI_RECEIVED, uri);\n      }\n      if (uri && this.autoOpen) {\n        const deepLink = this.getDeeplinkUrl ? this.getDeeplinkUrl(uri) : uri;\n        if (deepLink) {\n          location.href = deepLink;\n        }\n      }\n    });\n  }\n  startNetworkChangeFromApp(network) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this.kit.getWallet();\n        const previousAddress = (_a = this.kit.connection.defaultAccount) === null || _a === void 0 ? void 0 : _a.slice();\n        if (this.initialised) {\n          // if not initialised, we don't need to switch networks\n          const success = yield wallet.switchToChain(Object.assign(Object.assign({}, network), {\n            networkId: network.chainId\n          }));\n          (0, logger_1.getApplicationLogger)().debug('[startNetworkChangeFromApp] success?', success);\n        }\n        this.restartKit(network);\n        const newAddress = this.kit.connection.defaultAccount;\n        this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);\n        // its theoretically possible that a wallet will change address when switching networks\n        if (previousAddress !== newAddress) {\n          this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, newAddress);\n        }\n      } catch (e) {\n        this.emit(common_1.ConnectorEvents.NETWORK_CHANGE_FAILED, e);\n      }\n    });\n  }\n  restartKit(network) {\n    const wallet = this.kit.getWallet();\n    this.network = network; // must set to prevent loop\n    try {\n      this.kit.connection.stop(); // this blows up if its already stopped\n    } finally {\n      this.kit = (0, mini_kit_1.newKit)(network.rpcUrl, wallet);\n      // ensure we have a default account set\n      this.kit.connection.defaultAccount = wallet.getAccounts()[0];\n    }\n  }\n  // for when the wallet is already on the desired network and the kit / dapp need to catch up.\n  continueNetworkUpdateFromWallet(network) {\n    this.restartKit(network);\n    this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);\n  }\n  supportsFeeCurrency() {\n    // If on WC 1 it will not work due to fields being dropped\n    if (!this.version || this.version === 1) {\n      return false;\n    }\n    // TODO when V2 is used again check based on wallet?\n    return true;\n  }\n  onAddressChange(address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.kit.connection.defaultAccount = yield this.fetchWalletAddressForAccount(address);\n      this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, address);\n    });\n  }\n  onConnected(data) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      // first look for an account on the current chain if not found use the first one\n      const accountForChain = data.params.namespaces.eip155.accounts.find(eipChainAccount => {\n        return eipChainAccount.split(':')[1] === this.network.chainId.toString();\n      }) || data.params.namespaces.eip155.accounts[0];\n      const [_eip, chainId, account] = (_a = accountForChain === null || accountForChain === void 0 ? void 0 : accountForChain.split(':')) !== null && _a !== void 0 ? _a : [];\n      const walletAddress = yield this.fetchWalletAddressForAccount(account);\n      if (!walletAddress) {\n        this.emit(common_1.ConnectorEvents.WC_ERROR, new Error('No account found'));\n        return; // in rare case that no account is found\n      }\n\n      if (this.kit.connection.defaultAccount !== walletAddress) {\n        this.kit.connection.defaultAccount = walletAddress;\n      }\n      this.emit(common_1.ConnectorEvents.CONNECTED, {\n        walletType: this.type,\n        walletId: this.walletId,\n        walletChainId: parseInt(chainId),\n        networkName: this.network.name,\n        address: walletAddress\n      });\n    });\n  }\n  fetchWalletAddressForAccount(address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!address) {\n        return undefined;\n      }\n      const accounts = yield this.kit.contracts.getAccounts();\n      const walletAddress = yield accounts.getWalletAddress(address);\n      return new bignumber_js_1.BigNumber(walletAddress).isZero() ? address : walletAddress;\n    });\n  }\n  close(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      (0, logger_1.getApplicationLogger)().log('wallet-connect', 'close', message);\n      try {\n        this.initialised = false;\n        const wallet = this.kit.getWallet();\n        yield wallet.close();\n        this.kit.connection.stop();\n      } finally {\n        this.disconnect();\n      }\n    });\n  }\n}\nexports.default = WalletConnectConnector;","map":null,"metadata":{},"sourceType":"script"}