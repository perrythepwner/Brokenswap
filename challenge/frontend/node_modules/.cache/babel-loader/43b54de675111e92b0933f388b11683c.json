{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;\nconst node_1 = require(\"../node\");\nconst gindex_1 = require(\"../gindex\");\nexports.ERR_INVALID_NAV = \"Invalid tree navigation\";\nfunction createSingleProof(rootNode, index) {\n  const witnesses = [];\n  let node = rootNode;\n  for (const i of gindex_1.gindexIterator(index)) {\n    if (i) {\n      if (node.isLeaf()) throw new Error(exports.ERR_INVALID_NAV);\n      witnesses.push(node.left.root);\n      node = node.right;\n    } else {\n      if (node.isLeaf()) throw new Error(exports.ERR_INVALID_NAV);\n      witnesses.push(node.right.root);\n      node = node.left;\n    }\n  }\n  return [node.root, witnesses.reverse()];\n}\nexports.createSingleProof = createSingleProof;\nfunction createNodeFromSingleProof(gindex, leaf, witnesses) {\n  let node = node_1.LeafNode.fromRoot(leaf);\n  const w = witnesses.slice().reverse();\n  while (gindex > 1) {\n    const sibling = node_1.LeafNode.fromRoot(w.pop());\n    if (gindex % BigInt(2) === BigInt(0)) {\n      node = new node_1.BranchNode(node, sibling);\n    } else {\n      node = new node_1.BranchNode(sibling, node);\n    }\n    gindex = gindex / BigInt(2);\n  }\n  return node;\n}\nexports.createNodeFromSingleProof = createNodeFromSingleProof;","map":null,"metadata":{},"sourceType":"script"}