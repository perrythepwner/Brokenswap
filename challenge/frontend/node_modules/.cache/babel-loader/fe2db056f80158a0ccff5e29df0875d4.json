{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BooleanType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/**\n * Boolean: True or False\n * - Notation: `boolean`\n */\nclass BooleanType extends basic_1.BasicType {\n  constructor(opts) {\n    var _opts$typeName;\n    super();\n    this.byteLength = 1;\n    this.itemsPerChunk = 32;\n    this.fixedSize = 1;\n    this.minSize = 1;\n    this.maxSize = 1;\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"boolean\";\n  }\n  static named(opts) {\n    return new (named_1.namedClass(BooleanType, opts.typeName))(opts);\n  }\n  defaultValue() {\n    return false;\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value ? 1 : 0;\n    return offset + 1;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    switch (data.uint8Array[start]) {\n      case 1:\n        return true;\n      case 0:\n        return false;\n      default:\n        throw new Error(\"Boolean: invalid value: \".concat(data.uint8Array[start]));\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    // TODO: Assumes LeafNode has 4 byte uints are primary unit\n    output.uint8Array[offset] = node.getUint(4, 0);\n    return offset + 1;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = data.uint8Array[start];\n    if (value > 1) {\n      throw Error(\"Boolean: invalid value \".concat(value));\n    }\n    return persistent_merkle_tree_1.LeafNode.fromUint32(value);\n  }\n  // Fast tree opts\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(4, 0) === 1;\n  }\n  tree_setToNode(leafNode, value) {\n    leafNode.setUint(4, 0, value ? 1 : 0);\n  }\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = index % this.itemsPerChunk;\n    return leafNode.getUint(1, offsetBytes) !== 0;\n  }\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = index % this.itemsPerChunk;\n    leafNode.setUint(1, offsetBytes, value ? 1 : 0);\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"boolean\") {\n      throw Error(\"JSON invalid type \".concat(typeof json, \" expected boolean\"));\n    }\n    return json;\n  }\n  toJson(value) {\n    return value;\n  }\n}\nexports.BooleanType = BooleanType;","map":null,"metadata":{},"sourceType":"script"}