{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nvar _asyncToGenerator = require(\"/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CoinbaseWalletProvider = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst DiagnosticLogger_1 = require(\"../connection/DiagnosticLogger\");\nconst errors_1 = require(\"../errors\");\nconst Session_1 = require(\"../relay/Session\");\nconst WalletSDKRelayAbstract_1 = require(\"../relay/WalletSDKRelayAbstract\");\nconst Web3Method_1 = require(\"../relay/Web3Method\");\nconst Web3Response_1 = require(\"../relay/Web3Response\");\nconst util_1 = require(\"../util\");\nconst eth_eip712_util_1 = __importDefault(require(\"../vendor-js/eth-eip712-util\"));\nconst FilterPolyfill_1 = require(\"./FilterPolyfill\");\nconst JSONRPC_1 = require(\"./JSONRPC\");\nconst SubscriptionManager_1 = require(\"./SubscriptionManager\");\nconst DEFAULT_CHAIN_ID_KEY = \"DefaultChainId\";\nconst DEFAULT_JSON_RPC_URL = \"DefaultJsonRpcUrl\";\nclass CoinbaseWalletProvider extends safe_event_emitter_1.default {\n  constructor(options) {\n    var _a, _b;\n    super();\n    this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);\n    this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);\n    this._relay = null;\n    this._addresses = [];\n    this.hasMadeFirstChainChangedEmission = false;\n    this.setProviderInfo = this.setProviderInfo.bind(this);\n    this.updateProviderInfo = this.updateProviderInfo.bind(this);\n    this.getChainId = this.getChainId.bind(this);\n    this.setAppInfo = this.setAppInfo.bind(this);\n    this.enable = this.enable.bind(this);\n    this.close = this.close.bind(this);\n    this.send = this.send.bind(this);\n    this.sendAsync = this.sendAsync.bind(this);\n    this.request = this.request.bind(this);\n    this._setAddresses = this._setAddresses.bind(this);\n    this.scanQRCode = this.scanQRCode.bind(this);\n    this.genericRequest = this.genericRequest.bind(this);\n    this._chainIdFromOpts = options.chainId;\n    this._jsonRpcUrlFromOpts = options.jsonRpcUrl;\n    this._overrideIsMetaMask = options.overrideIsMetaMask;\n    this._relayProvider = options.relayProvider;\n    this._storage = options.storage;\n    this._relayEventManager = options.relayEventManager;\n    this.diagnostic = options.diagnosticLogger;\n    this.reloadOnDisconnect = true;\n    this.isCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;\n    this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;\n    this.qrUrl = options.qrUrl;\n    const chainId = this.getChainId();\n    const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));\n    // indicate that we've connected, for EIP-1193 compliance\n    this.emit(\"connect\", {\n      chainIdStr\n    });\n    const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);\n    if (cachedAddresses) {\n      const addresses = cachedAddresses.split(\" \");\n      if (addresses[0] !== \"\") {\n        this._addresses = addresses.map(address => (0, util_1.ensureAddressString)(address));\n        this.emit(\"accountsChanged\", addresses);\n      }\n    }\n    this._subscriptionManager.events.on(\"notification\", notification => {\n      this.emit(\"message\", {\n        type: notification.method,\n        data: notification.params\n      });\n    });\n    if (this._isAuthorized()) {\n      void this.initializeRelay();\n    }\n    window.addEventListener(\"message\", event => {\n      var _a;\n      // Used to verify the source and window are correct before proceeding\n      if (event.origin !== location.origin || event.source !== window) {\n        return;\n      }\n      if (event.data.type !== \"walletLinkMessage\") return; // compatibility with CBW extension\n      if (event.data.data.action === \"dappChainSwitched\") {\n        const _chainId = event.data.data.chainId;\n        const jsonRpcUrl = (_a = event.data.data.jsonRpcUrl) !== null && _a !== void 0 ? _a : this.jsonRpcUrl;\n        this.updateProviderInfo(jsonRpcUrl, Number(_chainId));\n      }\n      if (event.data.data.action === \"addressChanged\") {\n        this._setAddresses([event.data.data.address]);\n      }\n    });\n  }\n  /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */\n  get selectedAddress() {\n    return this._addresses[0] || undefined;\n  }\n  /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */\n  get networkVersion() {\n    return this.getChainId().toString(10);\n  }\n  /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */\n  get chainId() {\n    return (0, util_1.prepend0x)(this.getChainId().toString(16));\n  }\n  get isWalletLink() {\n    // backward compatibility\n    return true;\n  }\n  /**\n   * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return\n   * true for this method.\n   */\n  get isMetaMask() {\n    return this._overrideIsMetaMask;\n  }\n  get host() {\n    return this.jsonRpcUrl;\n  }\n  get connected() {\n    return true;\n  }\n  isConnected() {\n    return true;\n  }\n  get jsonRpcUrl() {\n    var _a;\n    return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : this._jsonRpcUrlFromOpts;\n  }\n  set jsonRpcUrl(value) {\n    this._storage.setItem(DEFAULT_JSON_RPC_URL, value);\n  }\n  disableReloadOnDisconnect() {\n    this.reloadOnDisconnect = false;\n  }\n  setProviderInfo(jsonRpcUrl, chainId) {\n    if (!this.isCoinbaseBrowser) {\n      this._chainIdFromOpts = chainId;\n      this._jsonRpcUrlFromOpts = jsonRpcUrl;\n    }\n    this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());\n  }\n  updateProviderInfo(jsonRpcUrl, chainId) {\n    this.jsonRpcUrl = jsonRpcUrl;\n    // emit chainChanged event if necessary\n    const originalChainId = this.getChainId();\n    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));\n    const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;\n    if (chainChanged || !this.hasMadeFirstChainChangedEmission) {\n      this.emit(\"chainChanged\", this.getChainId());\n      this.hasMadeFirstChainChangedEmission = true;\n    }\n  }\n  watchAsset(type, address, symbol, decimals, image, chainId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const relay = yield _this.initializeRelay();\n      const result = yield relay.watchAsset(type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;\n      return !!result.result;\n    })();\n  }\n  addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n      if ((0, util_1.ensureIntNumber)(chainId) === _this2.getChainId()) {\n        return false;\n      }\n      const relay = yield _this2.initializeRelay();\n      const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());\n      if (!_this2._isAuthorized() && !isWhitelistedNetworkOrStandalone) {\n        yield relay.requestEthereumAccounts().promise;\n      }\n      const res = yield relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;\n      if (((_a = res.result) === null || _a === void 0 ? void 0 : _a.isApproved) === true) {\n        _this2.updateProviderInfo(rpcUrls[0], chainId);\n      }\n      return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;\n    })();\n  }\n  switchEthereumChain(chainId) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const relay = yield _this3.initializeRelay();\n      const res = yield relay.switchEthereumChain(chainId.toString(10), _this3.selectedAddress || undefined).promise;\n      // backward compatibility\n      if ((0, Web3Response_1.isErrorResponse)(res) && res.errorCode) {\n        if (res.errorCode === errors_1.standardErrorCodes.provider.unsupportedChain) {\n          throw errors_1.standardErrors.provider.unsupportedChain(chainId);\n        } else {\n          throw errors_1.standardErrors.provider.custom({\n            message: res.errorMessage,\n            code: res.errorCode\n          });\n        }\n      }\n      const switchResponse = res.result;\n      if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {\n        _this3.updateProviderInfo(switchResponse.rpcUrl, chainId);\n      }\n    })();\n  }\n  setAppInfo(appName, appLogoUrl) {\n    void this.initializeRelay().then(relay => relay.setAppInfo(appName, appLogoUrl));\n  }\n  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */\n  enable() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      (_a = _this4.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {\n        method: \"provider::enable\",\n        addresses_length: _this4._addresses.length,\n        sessionIdHash: _this4._relay ? Session_1.Session.hash(_this4._relay.session.id) : undefined\n      });\n      if (_this4._isAuthorized()) {\n        return [..._this4._addresses];\n      }\n      return yield _this4.send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);\n    })();\n  }\n  close() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const relay = yield _this5.initializeRelay();\n      relay.resetAndReload();\n    })();\n  }\n  send(requestOrMethod, callbackOrParams) {\n    // send<T>(method, params): Promise<T>\n    try {\n      const result = this._send(requestOrMethod, callbackOrParams);\n      if (result instanceof Promise) {\n        return result.catch(error => {\n          throw (0, errors_1.serializeError)(error, requestOrMethod);\n        });\n      }\n    } catch (error) {\n      throw (0, errors_1.serializeError)(error, requestOrMethod);\n    }\n  }\n  _send(requestOrMethod, callbackOrParams) {\n    if (typeof requestOrMethod === \"string\") {\n      const method = requestOrMethod;\n      const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== undefined ? [callbackOrParams] : [];\n      const request = {\n        jsonrpc: \"2.0\",\n        id: 0,\n        method,\n        params\n      };\n      return this._sendRequestAsync(request).then(res => res.result);\n    }\n    // send(JSONRPCRequest | JSONRPCRequest[], callback): void\n    if (typeof callbackOrParams === \"function\") {\n      const request = requestOrMethod;\n      const callback = callbackOrParams;\n      return this._sendAsync(request, callback);\n    }\n    // send(JSONRPCRequest[]): JSONRPCResponse[]\n    if (Array.isArray(requestOrMethod)) {\n      const requests = requestOrMethod;\n      return requests.map(r => this._sendRequest(r));\n    }\n    // send(JSONRPCRequest): JSONRPCResponse\n    const req = requestOrMethod;\n    return this._sendRequest(req);\n  }\n  sendAsync(request, callback) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return _this6._sendAsync(request, callback).catch(error => {\n          throw (0, errors_1.serializeError)(error, request);\n        });\n      } catch (error) {\n        return Promise.reject((0, errors_1.serializeError)(error, request));\n      }\n    })();\n  }\n  _sendAsync(request, callback) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof callback !== \"function\") {\n        throw new Error(\"callback is required\");\n      }\n      // send(JSONRPCRequest[], callback): void\n      if (Array.isArray(request)) {\n        const arrayCb = callback;\n        _this7._sendMultipleRequestsAsync(request).then(responses => arrayCb(null, responses)).catch(err => arrayCb(err, null));\n        return;\n      }\n      // send(JSONRPCRequest, callback): void\n      const cb = callback;\n      return _this7._sendRequestAsync(request).then(response => cb(null, response)).catch(err => cb(err, null));\n    })();\n  }\n  request(args) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        return _this8._request(args).catch(error => {\n          throw (0, errors_1.serializeError)(error, args.method);\n        });\n      } catch (error) {\n        return Promise.reject((0, errors_1.serializeError)(error, args.method));\n      }\n    })();\n  }\n  _request(args) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n        throw errors_1.standardErrors.rpc.invalidRequest({\n          message: \"Expected a single, non-array, object argument.\",\n          data: args\n        });\n      }\n      const {\n        method,\n        params\n      } = args;\n      if (typeof method !== \"string\" || method.length === 0) {\n        throw errors_1.standardErrors.rpc.invalidRequest({\n          message: \"'args.method' must be a non-empty string.\",\n          data: args\n        });\n      }\n      if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n        throw errors_1.standardErrors.rpc.invalidRequest({\n          message: \"'args.params' must be an object or array if provided.\",\n          data: args\n        });\n      }\n      const newParams = params === undefined ? [] : params;\n      // Coinbase Wallet Requests\n      const id = _this9._relayEventManager.makeRequestId();\n      const result = yield _this9._sendRequestAsync({\n        method,\n        params: newParams,\n        jsonrpc: \"2.0\",\n        id\n      });\n      return result.result;\n    })();\n  }\n  scanQRCode(match) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const relay = yield _this10.initializeRelay();\n      const res = yield relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;\n      if (typeof res.result !== \"string\") {\n        throw (0, errors_1.serializeError)((_a = res.errorMessage) !== null && _a !== void 0 ? _a : \"result was not a string\", Web3Method_1.Web3Method.scanQRCode);\n      }\n      return res.result;\n    })();\n  }\n  genericRequest(data, action) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const relay = yield _this11.initializeRelay();\n      const res = yield relay.genericRequest(data, action).promise;\n      if (typeof res.result !== \"string\") {\n        throw (0, errors_1.serializeError)((_a = res.errorMessage) !== null && _a !== void 0 ? _a : \"result was not a string\", Web3Method_1.Web3Method.generic);\n      }\n      return res.result;\n    })();\n  }\n  selectProvider(providerOptions) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const relay = yield _this12.initializeRelay();\n      const res = yield relay.selectProvider(providerOptions).promise;\n      if (typeof res.result !== \"string\") {\n        throw (0, errors_1.serializeError)((_a = res.errorMessage) !== null && _a !== void 0 ? _a : \"result was not a string\", Web3Method_1.Web3Method.selectProvider);\n      }\n      return res.result;\n    })();\n  }\n  supportsSubscriptions() {\n    return false;\n  }\n  subscribe() {\n    throw new Error(\"Subscriptions are not supported\");\n  }\n  unsubscribe() {\n    throw new Error(\"Subscriptions are not supported\");\n  }\n  disconnect() {\n    return true;\n  }\n  _sendRequest(request) {\n    const response = {\n      jsonrpc: \"2.0\",\n      id: request.id\n    };\n    const {\n      method\n    } = request;\n    response.result = this._handleSynchronousMethods(request);\n    if (response.result === undefined) {\n      throw new Error(\"Coinbase Wallet does not support calling \".concat(method, \" synchronously without \") + \"a callback. Please provide a callback parameter to call \".concat(method, \" \") + \"asynchronously.\");\n    }\n    return response;\n  }\n  _setAddresses(addresses, _) {\n    if (!Array.isArray(addresses)) {\n      throw new Error(\"addresses is not an array\");\n    }\n    const newAddresses = addresses.map(address => (0, util_1.ensureAddressString)(address));\n    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {\n      return;\n    }\n    this._addresses = newAddresses;\n    this.emit(\"accountsChanged\", this._addresses);\n    this._storage.setItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(\" \"));\n  }\n  _sendRequestAsync(request) {\n    return new Promise((resolve, reject) => {\n      try {\n        const syncResult = this._handleSynchronousMethods(request);\n        if (syncResult !== undefined) {\n          return resolve({\n            jsonrpc: \"2.0\",\n            id: request.id,\n            result: syncResult\n          });\n        }\n        const filterPromise = this._handleAsynchronousFilterMethods(request);\n        if (filterPromise !== undefined) {\n          filterPromise.then(res => resolve(Object.assign(Object.assign({}, res), {\n            id: request.id\n          }))).catch(err => reject(err));\n          return;\n        }\n        const subscriptionPromise = this._handleSubscriptionMethods(request);\n        if (subscriptionPromise !== undefined) {\n          subscriptionPromise.then(res => resolve({\n            jsonrpc: \"2.0\",\n            id: request.id,\n            result: res.result\n          })).catch(err => reject(err));\n          return;\n        }\n      } catch (err) {\n        return reject(err);\n      }\n      this._handleAsynchronousMethods(request).then(res => res && resolve(Object.assign(Object.assign({}, res), {\n        id: request.id\n      }))).catch(err => reject(err));\n    });\n  }\n  _sendMultipleRequestsAsync(requests) {\n    return Promise.all(requests.map(r => this._sendRequestAsync(r)));\n  }\n  _handleSynchronousMethods(request) {\n    const {\n      method\n    } = request;\n    const params = request.params || [];\n    switch (method) {\n      case JSONRPC_1.JSONRPCMethod.eth_accounts:\n        return this._eth_accounts();\n      case JSONRPC_1.JSONRPCMethod.eth_coinbase:\n        return this._eth_coinbase();\n      case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:\n        return this._eth_uninstallFilter(params);\n      case JSONRPC_1.JSONRPCMethod.net_version:\n        return this._net_version();\n      case JSONRPC_1.JSONRPCMethod.eth_chainId:\n        return this._eth_chainId();\n      default:\n        return undefined;\n    }\n  }\n  _handleAsynchronousMethods(request) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        method\n      } = request;\n      const params = request.params || [];\n      switch (method) {\n        case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:\n          return _this13._eth_requestAccounts();\n        case JSONRPC_1.JSONRPCMethod.eth_sign:\n          return _this13._eth_sign(params);\n        case JSONRPC_1.JSONRPCMethod.eth_ecRecover:\n          return _this13._eth_ecRecover(params);\n        case JSONRPC_1.JSONRPCMethod.personal_sign:\n          return _this13._personal_sign(params);\n        case JSONRPC_1.JSONRPCMethod.personal_ecRecover:\n          return _this13._personal_ecRecover(params);\n        case JSONRPC_1.JSONRPCMethod.eth_signTransaction:\n          return _this13._eth_signTransaction(params);\n        case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:\n          return _this13._eth_sendRawTransaction(params);\n        case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:\n          return _this13._eth_sendTransaction(params);\n        case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:\n          return _this13._eth_signTypedData_v1(params);\n        case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:\n          return _this13._throwUnsupportedMethodError();\n        case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:\n          return _this13._eth_signTypedData_v3(params);\n        case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:\n        case JSONRPC_1.JSONRPCMethod.eth_signTypedData:\n          return _this13._eth_signTypedData_v4(params);\n        case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:\n          return _this13._cbwallet_arbitrary(params);\n        case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:\n          return _this13._wallet_addEthereumChain(params);\n        case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:\n          return _this13._wallet_switchEthereumChain(params);\n        case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:\n          return _this13._wallet_watchAsset(params);\n      }\n      const relay = yield _this13.initializeRelay();\n      return relay.makeEthereumJSONRPCRequest(request, _this13.jsonRpcUrl);\n    })();\n  }\n  _handleAsynchronousFilterMethods(request) {\n    const {\n      method\n    } = request;\n    const params = request.params || [];\n    switch (method) {\n      case JSONRPC_1.JSONRPCMethod.eth_newFilter:\n        return this._eth_newFilter(params);\n      case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:\n        return this._eth_newBlockFilter();\n      case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:\n        return this._eth_newPendingTransactionFilter();\n      case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:\n        return this._eth_getFilterChanges(params);\n      case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:\n        return this._eth_getFilterLogs(params);\n    }\n    return undefined;\n  }\n  _handleSubscriptionMethods(request) {\n    switch (request.method) {\n      case JSONRPC_1.JSONRPCMethod.eth_subscribe:\n      case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:\n        return this._subscriptionManager.handleRequest(request);\n    }\n    return undefined;\n  }\n  _isKnownAddress(addressString) {\n    try {\n      const addressStr = (0, util_1.ensureAddressString)(addressString);\n      const lowercaseAddresses = this._addresses.map(address => (0, util_1.ensureAddressString)(address));\n      return lowercaseAddresses.includes(addressStr);\n    } catch (_a) {}\n    return false;\n  }\n  _ensureKnownAddress(addressString) {\n    var _a;\n    if (!this._isKnownAddress(addressString)) {\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);\n      throw new Error(\"Unknown Ethereum address\");\n    }\n  }\n  _prepareTransactionParams(tx) {\n    const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;\n    if (!fromAddress) {\n      throw new Error(\"Ethereum address is unavailable\");\n    }\n    this._ensureKnownAddress(fromAddress);\n    const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;\n    const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);\n    const data = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer.alloc(0);\n    const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;\n    const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;\n    const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;\n    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;\n    const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;\n    const chainId = this.getChainId();\n    return {\n      fromAddress,\n      toAddress,\n      weiValue,\n      data,\n      nonce,\n      gasPriceInWei,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      gasLimit,\n      chainId\n    };\n  }\n  _isAuthorized() {\n    return this._addresses.length > 0;\n  }\n  _requireAuthorization() {\n    if (!this._isAuthorized()) {\n      throw errors_1.standardErrors.provider.unauthorized({});\n    }\n  }\n  _throwUnsupportedMethodError() {\n    throw errors_1.standardErrors.provider.unsupportedMethod({});\n  }\n  _signEthereumMessage(message, address, addPrefix, typedDataJson) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      _this14._ensureKnownAddress(address);\n      try {\n        const relay = yield _this14.initializeRelay();\n        const res = yield relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;\n        return {\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: res.result\n        };\n      } catch (err) {\n        if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n          throw errors_1.standardErrors.provider.userRejectedRequest(\"User denied message signature\");\n        }\n        throw err;\n      }\n    })();\n  }\n  _ethereumAddressFromSignedMessage(message, signature, addPrefix) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const relay = yield _this15.initializeRelay();\n      const res = yield relay.ethereumAddressFromSignedMessage(message, signature, addPrefix).promise;\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: res.result\n      };\n    })();\n  }\n  _eth_accounts() {\n    return [...this._addresses];\n  }\n  _eth_coinbase() {\n    return this.selectedAddress || null;\n  }\n  _net_version() {\n    return this.getChainId().toString(10);\n  }\n  _eth_chainId() {\n    return (0, util_1.hexStringFromIntNumber)(this.getChainId());\n  }\n  getChainId() {\n    const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);\n    if (!chainIdStr) {\n      return (0, util_1.ensureIntNumber)(this._chainIdFromOpts);\n    }\n    const chainId = parseInt(chainIdStr, 10);\n    return (0, util_1.ensureIntNumber)(chainId);\n  }\n  _eth_requestAccounts() {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      (_a = _this16.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {\n        method: \"provider::_eth_requestAccounts\",\n        addresses_length: _this16._addresses.length,\n        sessionIdHash: _this16._relay ? Session_1.Session.hash(_this16._relay.session.id) : undefined\n      });\n      if (_this16._isAuthorized()) {\n        return Promise.resolve({\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: _this16._addresses\n        });\n      }\n      let res;\n      try {\n        const relay = yield _this16.initializeRelay();\n        res = yield relay.requestEthereumAccounts().promise;\n      } catch (err) {\n        if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n          throw errors_1.standardErrors.provider.userRejectedRequest(\"User denied account authorization\");\n        }\n        throw err;\n      }\n      if (!res.result) {\n        throw new Error(\"accounts received is empty\");\n      }\n      _this16._setAddresses(res.result);\n      if (!_this16.isCoinbaseBrowser) {\n        yield _this16.switchEthereumChain(_this16.getChainId());\n      }\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: _this16._addresses\n      };\n    })();\n  }\n  _eth_sign(params) {\n    this._requireAuthorization();\n    const address = (0, util_1.ensureAddressString)(params[0]);\n    const message = (0, util_1.ensureBuffer)(params[1]);\n    return this._signEthereumMessage(message, address, false);\n  }\n  _eth_ecRecover(params) {\n    const message = (0, util_1.ensureBuffer)(params[0]);\n    const signature = (0, util_1.ensureBuffer)(params[1]);\n    return this._ethereumAddressFromSignedMessage(message, signature, false);\n  }\n  _personal_sign(params) {\n    this._requireAuthorization();\n    const message = (0, util_1.ensureBuffer)(params[0]);\n    const address = (0, util_1.ensureAddressString)(params[1]);\n    return this._signEthereumMessage(message, address, true);\n  }\n  _personal_ecRecover(params) {\n    const message = (0, util_1.ensureBuffer)(params[0]);\n    const signature = (0, util_1.ensureBuffer)(params[1]);\n    return this._ethereumAddressFromSignedMessage(message, signature, true);\n  }\n  _eth_signTransaction(params) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      _this17._requireAuthorization();\n      const tx = _this17._prepareTransactionParams(params[0] || {});\n      try {\n        const relay = yield _this17.initializeRelay();\n        const res = yield relay.signEthereumTransaction(tx).promise;\n        return {\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: res.result\n        };\n      } catch (err) {\n        if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n          throw errors_1.standardErrors.provider.userRejectedRequest(\"User denied transaction signature\");\n        }\n        throw err;\n      }\n    })();\n  }\n  _eth_sendRawTransaction(params) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const signedTransaction = (0, util_1.ensureBuffer)(params[0]);\n      const relay = yield _this18.initializeRelay();\n      const res = yield relay.submitEthereumTransaction(signedTransaction, _this18.getChainId()).promise;\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: res.result\n      };\n    })();\n  }\n  _eth_sendTransaction(params) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      _this19._requireAuthorization();\n      const tx = _this19._prepareTransactionParams(params[0] || {});\n      try {\n        const relay = yield _this19.initializeRelay();\n        const res = yield relay.signAndSubmitEthereumTransaction(tx).promise;\n        return {\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: res.result\n        };\n      } catch (err) {\n        if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n          throw errors_1.standardErrors.provider.userRejectedRequest(\"User denied transaction signature\");\n        }\n        throw err;\n      }\n    })();\n  }\n  _eth_signTypedData_v1(params) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      _this20._requireAuthorization();\n      const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);\n      const address = (0, util_1.ensureAddressString)(params[1]);\n      _this20._ensureKnownAddress(address);\n      const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({\n        data: typedData\n      });\n      const typedDataJSON = JSON.stringify(typedData, null, 2);\n      return _this20._signEthereumMessage(message, address, false, typedDataJSON);\n    })();\n  }\n  _eth_signTypedData_v3(params) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      _this21._requireAuthorization();\n      const address = (0, util_1.ensureAddressString)(params[0]);\n      const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);\n      _this21._ensureKnownAddress(address);\n      const message = eth_eip712_util_1.default.hashForSignTypedData_v3({\n        data: typedData\n      });\n      const typedDataJSON = JSON.stringify(typedData, null, 2);\n      return _this21._signEthereumMessage(message, address, false, typedDataJSON);\n    })();\n  }\n  _eth_signTypedData_v4(params) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      _this22._requireAuthorization();\n      const address = (0, util_1.ensureAddressString)(params[0]);\n      const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);\n      _this22._ensureKnownAddress(address);\n      const message = eth_eip712_util_1.default.hashForSignTypedData_v4({\n        data: typedData\n      });\n      const typedDataJSON = JSON.stringify(typedData, null, 2);\n      return _this22._signEthereumMessage(message, address, false, typedDataJSON);\n    })();\n  }\n  /** @deprecated */\n  _cbwallet_arbitrary(params) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const action = params[0];\n      const data = params[1];\n      if (typeof data !== \"string\") {\n        throw new Error(\"parameter must be a string\");\n      }\n      if (typeof action !== \"object\" || action === null) {\n        throw new Error(\"parameter must be an object\");\n      }\n      const result = yield _this23.genericRequest(action, data);\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result\n      };\n    })();\n  }\n  _wallet_addEthereumChain(params) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c, _d;\n      const request = params[0];\n      if (((_a = request.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n        return {\n          jsonrpc: \"2.0\",\n          id: 0,\n          error: {\n            code: 2,\n            message: \"please pass in at least 1 rpcUrl\"\n          }\n        };\n      }\n      if (!request.chainName || request.chainName.trim() === \"\") {\n        throw errors_1.standardErrors.rpc.invalidParams(\"chainName is a required field\");\n      }\n      if (!request.nativeCurrency) {\n        throw errors_1.standardErrors.rpc.invalidParams(\"nativeCurrency is a required field\");\n      }\n      const chainIdNumber = parseInt(request.chainId, 16);\n      const success = yield _this24.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);\n      if (success) {\n        return {\n          jsonrpc: \"2.0\",\n          id: 0,\n          result: null\n        };\n      } else {\n        return {\n          jsonrpc: \"2.0\",\n          id: 0,\n          error: {\n            code: 2,\n            message: \"unable to add ethereum chain\"\n          }\n        };\n      }\n    })();\n  }\n  _wallet_switchEthereumChain(params) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const request = params[0];\n      yield _this25.switchEthereumChain(parseInt(request.chainId, 16));\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: null\n      };\n    })();\n  }\n  _wallet_watchAsset(params) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const request = Array.isArray(params) ? params[0] : params;\n      if (!request.type) {\n        throw errors_1.standardErrors.rpc.invalidParams(\"Type is required\");\n      }\n      if ((request === null || request === void 0 ? void 0 : request.type) !== \"ERC20\") {\n        throw errors_1.standardErrors.rpc.invalidParams(\"Asset of type '\".concat(request.type, \"' is not supported\"));\n      }\n      if (!(request === null || request === void 0 ? void 0 : request.options)) {\n        throw errors_1.standardErrors.rpc.invalidParams(\"Options are required\");\n      }\n      if (!(request === null || request === void 0 ? void 0 : request.options.address)) {\n        throw errors_1.standardErrors.rpc.invalidParams(\"Address is required\");\n      }\n      const chainId = _this26.getChainId();\n      const {\n        address,\n        symbol,\n        image,\n        decimals\n      } = request.options;\n      const res = yield _this26.watchAsset(request.type, address, symbol, decimals, image, chainId);\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: res\n      };\n    })();\n  }\n  _eth_uninstallFilter(params) {\n    const filterId = (0, util_1.ensureHexString)(params[0]);\n    return this._filterPolyfill.uninstallFilter(filterId);\n  }\n  _eth_newFilter(params) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const param = params[0];\n      const filterId = yield _this27._filterPolyfill.newFilter(param);\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: filterId\n      };\n    })();\n  }\n  _eth_newBlockFilter() {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const filterId = yield _this28._filterPolyfill.newBlockFilter();\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: filterId\n      };\n    })();\n  }\n  _eth_newPendingTransactionFilter() {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const filterId = yield _this29._filterPolyfill.newPendingTransactionFilter();\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: filterId\n      };\n    })();\n  }\n  _eth_getFilterChanges(params) {\n    const filterId = (0, util_1.ensureHexString)(params[0]);\n    return this._filterPolyfill.getFilterChanges(filterId);\n  }\n  _eth_getFilterLogs(params) {\n    const filterId = (0, util_1.ensureHexString)(params[0]);\n    return this._filterPolyfill.getFilterLogs(filterId);\n  }\n  initializeRelay() {\n    if (this._relay) {\n      return Promise.resolve(this._relay);\n    }\n    return this._relayProvider().then(relay => {\n      relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));\n      relay.setChainCallback((chainId, jsonRpcUrl) => {\n        this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));\n      });\n      relay.setDappDefaultChainCallback(this._chainIdFromOpts);\n      this._relay = relay;\n      return relay;\n    });\n  }\n}\nexports.CoinbaseWalletProvider = CoinbaseWalletProvider;","map":null,"metadata":{},"sourceType":"script"}