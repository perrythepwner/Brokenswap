{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst treePostProcessFromProofNode_1 = require(\"../util/proof/treePostProcessFromProofNode\");\nconst abstract_1 = require(\"./abstract\");\nexports.LENGTH_GINDEX = BigInt(3);\n/** Dedicated property to cache hashTreeRoot of immutable CompositeType values */\nconst symbolCachedPermanentRoot = Symbol(\"ssz_cached_permanent_root\");\n/* eslint-disable @typescript-eslint/member-ordering  */\n/**\n * Represents a composite type as defined in the spec:\n * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#composite-types\n */\nclass CompositeType extends abstract_1.Type {\n  constructor(\n  /**\n   * Caches `hashTreeRoot()` result for struct values.\n   *\n   * WARNING: Must only be used for immutable values. The cached root is never discarded\n   */\n  cachePermanentRootStruct) {\n    super();\n    this.cachePermanentRootStruct = cachePermanentRootStruct;\n    this.isBasic = false;\n  }\n  /** New instance of a recursive zero'ed value converted to Tree View */\n  defaultView() {\n    return this.toView(this.defaultValue());\n  }\n  /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */\n  defaultViewDU() {\n    return this.toViewDU(this.defaultValue());\n  }\n  /**\n   * Deserialize binary data to a Tree View.\n   * @see {@link CompositeType.getView}\n   */\n  deserializeToView(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const node = this.tree_deserializeFromBytes({\n      uint8Array: data,\n      dataView\n    }, 0, data.length);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Deserialize binary data to a Deferred Update Tree View.\n   * @see {@link CompositeType.getViewDU}\n   */\n  deserializeToViewDU(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const node = this.tree_deserializeFromBytes({\n      uint8Array: data,\n      dataView\n    }, 0, data.length);\n    return this.getViewDU(node);\n  }\n  /**\n   * Transform value to a View.\n   * @see {@link CompositeType.getView}\n   */\n  toView(value) {\n    const node = this.value_toTree(value);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Transform value to a ViewDU.\n   * @see {@link CompositeType.getViewDU}\n   */\n  toViewDU(value) {\n    const node = this.value_toTree(value);\n    return this.getViewDU(node);\n  }\n  /**\n   * Transform value to a View.\n   * @see {@link CompositeType.getView}\n   */\n  toValueFromView(view) {\n    const node = this.commitView(view);\n    return this.tree_toValue(node);\n  }\n  /**\n   * Transform value to a ViewDU.\n   * @see {@link CompositeType.getViewDU}\n   */\n  toValueFromViewDU(view) {\n    const node = this.commitViewDU(view);\n    return this.tree_toValue(node);\n  }\n  /**\n   * Transform a ViewDU to a View.\n   * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n   */\n  toViewFromViewDU(view) {\n    const node = this.commitViewDU(view);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Transform a View to a ViewDU.\n   * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n   */\n  toViewDUFromView(view) {\n    const node = this.commitView(view);\n    return this.getViewDU(node);\n  }\n  // Merkleize API\n  hashTreeRoot(value) {\n    // Return cached mutable root if any\n    if (this.cachePermanentRootStruct) {\n      const cachedRoot = value[symbolCachedPermanentRoot];\n      if (cachedRoot) {\n        return cachedRoot;\n      }\n    }\n    const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);\n    if (this.cachePermanentRootStruct) {\n      value[symbolCachedPermanentRoot] = root;\n    }\n    return root;\n  }\n  // For debugging and testing this feature\n  getCachedPermanentRoot(value) {\n    return value[symbolCachedPermanentRoot];\n  }\n  // Proofs API\n  /**\n   * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.\n   * @see {@link CompositeType.getView}\n   */\n  createFromProof(proof, root) {\n    const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;\n    const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);\n    if (root !== undefined && !byteArray_1.byteArrayEquals(rootNode.root, root)) {\n      throw new Error(\"Proof does not match trusted root\");\n    }\n    return this.getView(new persistent_merkle_tree_1.Tree(rootNode));\n  }\n  /** INTERNAL METHOD: For view's API, create proof from a tree */\n  tree_createProof(node, jsonPaths) {\n    const gindexes = this.tree_createProofGindexes(node, jsonPaths);\n    return persistent_merkle_tree_1.createProof(node, {\n      type: persistent_merkle_tree_1.ProofType.treeOffset,\n      gindices: gindexes\n    });\n  }\n  /** INTERNAL METHOD: For view's API, create proof from a tree */\n  tree_createProofGindexes(node, jsonPaths) {\n    const gindexes = [];\n    for (const jsonPath of jsonPaths) {\n      const {\n        type,\n        gindex\n      } = this.getPathInfo(jsonPath);\n      if (!isCompositeType(type)) {\n        gindexes.push(gindex);\n      } else {\n        // if the path subtype is composite, include the gindices of all the leaves\n        const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : undefined);\n        for (const gindex of leafGindexes) {\n          gindexes.push(gindex);\n        }\n      }\n    }\n    return gindexes;\n  }\n  /**\n   * Navigate to a subtype & gindex using a path\n   */\n  getPathInfo(path) {\n    const gindices = [];\n    let type = this;\n    for (const prop of path) {\n      if (type.isBasic) {\n        throw new Error(\"Invalid path: cannot navigate beyond a basic type\");\n      }\n      const gindex = type.getPropertyGindex(prop);\n      // else stop navigating\n      if (gindex !== null) {\n        gindices.push(gindex);\n        type = type.getPropertyType(prop);\n      }\n    }\n    return {\n      type,\n      gindex: persistent_merkle_tree_1.concatGindices(gindices)\n    };\n  }\n  /**\n   * INTERNAL METHOD: post process `Ç¸ode` instance created from a proof and return either the same node,\n   * and a new node representing the same data is a different `Node` instance. Currently used exclusively\n   * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.\n   */\n  tree_fromProofNode(node) {\n    return {\n      node,\n      done: false\n    };\n  }\n}\nexports.CompositeType = CompositeType;\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\nexports.isCompositeType = isCompositeType;","map":null,"metadata":{},"sourceType":"script"}