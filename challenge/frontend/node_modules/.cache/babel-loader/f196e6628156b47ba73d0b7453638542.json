{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContainerNodeStructType = void 0;\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"./container\");\nconst named_1 = require(\"../util/named\");\nconst containerNodeStruct_1 = require(\"../view/containerNodeStruct\");\nconst containerNodeStruct_2 = require(\"../viewDU/containerNodeStruct\");\nconst branchNodeStruct_1 = require(\"../branchNodeStruct\");\n/**\n * ContainerNodeStruct: ordered heterogeneous collection of values.\n * - Notation: Custom name per instance\n *\n * A ContainerNodeStruct is identical to a Container type except that it represents tree data with a custom\n * BranchNodeStruct node. This special branch node represents the data of its entire sub tree as a value, instead\n * of a tree of nodes. This approach is a tradeoff:\n *\n * - More memory efficient\n * - Faster reads, since it doesn't require parsing merkleized data\n * - Slower hashing, since it has to merkleize the entire value everytime and has not intermediary hashing cache\n *\n * This tradeoff is good for data that is read often, written rarely, and consumes a lot of memory (i.e. Validator)\n */\nclass ContainerNodeStructType extends container_1.ContainerType {\n  constructor(fields, opts) {\n    var _opts$typeName;\n    super(fields, _objectSpread(_objectSpread({\n      // Overwrite default \"Container\" typeName\n      // Render detailed typeName. Consumers should overwrite since it can get long\n      typeName: (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : container_1.renderContainerTypeName(fields, \"ContainerNodeStruct\")\n    }, opts), {}, {\n      getContainerTreeViewClass: containerNodeStruct_1.getContainerTreeViewClass,\n      getContainerTreeViewDUClass: containerNodeStruct_2.getContainerTreeViewDUClass\n    }));\n    this.fields = fields;\n    // ContainerNodeStructType TreeViews don't handle recursive mutable TreeViews like ContainerType does.\n    // Using ContainerNodeStructType for fields that have mutable views (like a ListBasic), will result in\n    // unnexpected behaviour if those child views are mutated.\n    //\n    // For example, this example below won't persist the pushed values to the list:\n    // ```ts\n    // const type = ContainerNodeStructType({a: new ListBasicType(byteType, 1)});\n    // const view = type.defaultViewDU();\n    // view.a.push(0)\n    // ```\n    // because the ListBasicViewDU in view.a will never propagate the changes upwards to its ContainerNodeStructType.\n    for (const {\n      fieldName,\n      fieldType\n    } of this.fieldsEntries) {\n      if (composite_1.isCompositeType(fieldType) && fieldType.isViewMutable) {\n        throw Error(\"ContainerNodeStructType field '\".concat(fieldName, \"' \").concat(fieldType.typeName, \" view is mutable\"));\n      }\n    }\n  }\n  static named(fields, opts) {\n    return new (named_1.namedClass(container_1.ContainerType, opts.typeName))(fields, opts);\n  }\n  tree_serializedSize(node) {\n    return this.value_serializedSize(node.value);\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const {\n      value\n    } = node;\n    return this.value_serializeToBytes(output, offset, value);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const value = this.value_deserializeFromBytes(data, start, end);\n    return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);\n  }\n  // Proofs\n  // ContainerNodeStructType can only parse proofs that contain all the data.\n  // TODO: Support converting a partial tree to a partial value\n  getPropertyGindex() {\n    return null;\n  }\n  // Post process tree to convert regular BranchNode to BranchNodeStruct\n  // TODO: Optimize conversions\n  tree_fromProofNode(node) {\n    // TODO: Figure out from `node` alone if it contains complete data.\n    // Otherwise throw a nice error \"ContainerNodeStruct type requires proofs for all its data\"\n    const uint8Array = new Uint8Array(super.tree_serializedSize(node));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    super.tree_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, node);\n    const value = this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n    return {\n      node: new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value),\n      done: true\n    };\n  }\n  // Overwrites for fast conversion node <-> value\n  tree_toValue(node) {\n    return node.value;\n  }\n  value_toTree(value) {\n    return new branchNodeStruct_1.BranchNodeStruct(this.valueToTree.bind(this), value);\n  }\n  // TODO: Optimize conversion\n  valueToTree(value) {\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return super.tree_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n}\nexports.ContainerNodeStructType = ContainerNodeStructType;","map":null,"metadata":{},"sourceType":"script"}