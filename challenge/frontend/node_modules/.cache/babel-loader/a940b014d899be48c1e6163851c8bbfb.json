{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;\nconst multi_1 = require(\"./multi\");\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar ProofType;\n(function (ProofType) {\n  ProofType[\"single\"] = \"single\";\n  ProofType[\"treeOffset\"] = \"treeOffset\";\n  ProofType[\"multi\"] = \"multi\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [ProofType.single, ProofType.treeOffset, ProofType.multi // 2\n];\n\nfunction createProof(rootNode, input) {\n  switch (input.type) {\n    case ProofType.single:\n      {\n        const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n        return {\n          type: ProofType.single,\n          gindex: input.gindex,\n          leaf,\n          witnesses\n        };\n      }\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n    case ProofType.multi:\n      {\n        const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n        return {\n          type: ProofType.multi,\n          leaves,\n          witnesses,\n          gindices\n        };\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n      return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n    case ProofType.treeOffset:\n      return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n    case ProofType.multi:\n      return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n    case ProofType.treeOffset:\n      {\n        const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n        output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n        treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n        return output;\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n  const proofType = exports.ProofTypeSerialized[data[0]];\n  if (!proofType) {\n    throw new Error(\"Invalid proof type\");\n  }\n  switch (proofType) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.deserializeProof = deserializeProof;","map":null,"metadata":{},"sourceType":"script"}