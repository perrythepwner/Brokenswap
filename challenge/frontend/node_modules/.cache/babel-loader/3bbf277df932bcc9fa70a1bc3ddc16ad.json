{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/* eslint-disable @typescript-eslint/member-ordering */\nconst MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);\nconst BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);\nconst BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);\nconst BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);\n// const BIGINT_64_MAX = BigInt(\"0xffffffffffffffff\");\nconst NUMBER_2_POW_32 = 2 ** 32;\nconst NUMBER_32_MAX = 0xffffffff;\nexports.uintNumberByteLens = [1, 2, 4, 8];\nexports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintNumber is represented as the Javascript primitive value 'Number'.\n *\n * The Number type is a double-precision 64-bit binary format IEEE 754 value (numbers between -(2^53 − 1) and\n * 2^53 − 1). It also has the symbolic value: +Infinity.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. Some values are spec'ed as Uint64 but\n * practically they will never exceed 53 bits, such as any unit time or simple counters. This type is an optimization\n * for these cases, as UintNumber64 can represent any value between 0 and 2^53−1 as well as the max value 2^64-1.\n */\nclass UintNumberType extends basic_1.BasicType {\n  constructor(byteLength, opts) {\n    var _opts$typeName;\n    super();\n    this.byteLength = byteLength;\n    if (byteLength > 8) {\n      throw Error(\"UintNumber byteLength limit is 8\");\n    }\n    if (Math.log2(byteLength) % 1 !== 0) {\n      throw Error(\"byteLength must be a power of 2\");\n    }\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"uint\".concat(byteLength * 8);\n    if (opts !== null && opts !== void 0 && opts.clipInfinity) this.typeName += \"Inf\";\n    if (opts !== null && opts !== void 0 && opts.setBitwiseOR) this.typeName += \"OR\";\n    this.itemsPerChunk = 32 / this.byteLength;\n    this.fixedSize = byteLength;\n    this.minSize = byteLength;\n    this.maxSize = byteLength;\n    this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);\n    this.clipInfinity = (opts === null || opts === void 0 ? void 0 : opts.clipInfinity) === true;\n    this.setBitwiseOR = (opts === null || opts === void 0 ? void 0 : opts.setBitwiseOR) === true;\n  }\n  static named(byteLength, opts) {\n    return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);\n  }\n  defaultValue() {\n    return 0;\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(_ref, offset, value) {\n    let {\n      dataView\n    } = _ref;\n    switch (this.byteLength) {\n      case 1:\n        dataView.setInt8(offset, value);\n        break;\n      case 2:\n        dataView.setUint16(offset, value, true);\n        break;\n      case 4:\n        dataView.setUint32(offset, value, true);\n        break;\n      case 8:\n        if (value === Infinity) {\n          // TODO: Benchmark if it's faster to set BIGINT_64_MAX once\n          dataView.setUint32(offset, 0xffffffff);\n          dataView.setUint32(offset + 4, 0xffffffff);\n        } else {\n          dataView.setUint32(offset, value & 0xffffffff, true);\n          dataView.setUint32(offset + 4, value / NUMBER_2_POW_32 & 0xffffffff, true);\n        }\n        break;\n    }\n    return offset + this.byteLength;\n  }\n  value_deserializeFromBytes(_ref2, start, end) {\n    let {\n      dataView\n    } = _ref2;\n    this.assertValidSize(end - start);\n    switch (this.byteLength) {\n      case 1:\n        return dataView.getUint8(start);\n      case 2:\n        return dataView.getUint16(start, true);\n      case 4:\n        return dataView.getUint32(start, true);\n      case 8:\n        {\n          const a = dataView.getUint32(start, true);\n          const b = dataView.getUint32(start + 4, true);\n          if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {\n            return Infinity;\n          } else {\n            return b * NUMBER_2_POW_32 + a;\n          }\n        }\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const value = node.getUint(this.byteLength, 0, this.clipInfinity);\n    this.value_serializeToBytes(output, offset, value);\n    return offset + this.byteLength;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = this.value_deserializeFromBytes(data, start, end);\n    const node = persistent_merkle_tree_1.LeafNode.fromZero();\n    node.setUint(this.byteLength, 0, value, this.clipInfinity);\n    return node;\n  }\n  // Fast Tree access\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(this.byteLength, 0, this.clipInfinity);\n  }\n  tree_setToNode(leafNode, value) {\n    this.tree_setToPackedNode(leafNode, 0, value);\n  }\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);\n  }\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    // TODO: Benchmark the cost of this if, and consider using a different class\n    if (this.setBitwiseOR) {\n      leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);\n    } else {\n      leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);\n    }\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json === \"number\") {\n      return json;\n    } else if (typeof json === \"string\") {\n      if (this.clipInfinity && json === this.maxDecimalStr) {\n        // Allow to handle max possible number\n        return Infinity;\n      } else {\n        const num = parseInt(json, 10);\n        if (isNaN(num)) {\n          throw Error(\"JSON invalid number isNaN\");\n        } else if (num > Number.MAX_SAFE_INTEGER) {\n          // Throw to prevent decimal precision errors downstream\n          throw Error(\"JSON invalid number > MAX_SAFE_INTEGER\");\n        } else {\n          return num;\n        }\n      }\n    } else if (typeof json === \"bigint\") {\n      if (json > MAX_SAFE_INTEGER_BN) {\n        // Throw to prevent decimal precision errors downstream\n        throw Error(\"JSON invalid number > MAX_SAFE_INTEGER_BN\");\n      } else {\n        return Number(json);\n      }\n    } else {\n      throw Error(\"JSON invalid type \".concat(typeof json, \" expected number\"));\n    }\n  }\n  toJson(value) {\n    if (value === Infinity) {\n      return this.maxDecimalStr;\n    } else {\n      return value.toString(10);\n    }\n  }\n}\nexports.UintNumberType = UintNumberType;\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintBigint is represented as the Javascript primitive value 'BigInt'.\n *\n * The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision.\n * With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. For Uint values under 53 bits use UintNumber.\n * For other values that may exceed 53 bits, use UintBigint.\n */\nclass UintBigintType extends basic_1.BasicType {\n  constructor(byteLength, opts) {\n    var _opts$typeName2;\n    super();\n    this.byteLength = byteLength;\n    if (byteLength > 32) {\n      throw Error(\"UintBigint byteLength limit is 32\");\n    }\n    if (Math.log2(byteLength) % 1 !== 0) {\n      throw Error(\"byteLength must be a power of 2\");\n    }\n    this.typeName = (_opts$typeName2 = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName2 !== void 0 ? _opts$typeName2 : \"uintBigint\".concat(byteLength * 8);\n    this.byteLength = byteLength;\n    this.itemsPerChunk = 32 / this.byteLength;\n    this.fixedSize = byteLength;\n    this.minSize = byteLength;\n    this.maxSize = byteLength;\n  }\n  static named(byteLength, opts) {\n    return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);\n  }\n  defaultValue() {\n    return BigInt(0);\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(_ref3, offset, value) {\n    let {\n      dataView\n    } = _ref3;\n    switch (this.byteLength) {\n      case 1:\n        dataView.setInt8(offset, Number(value));\n        break;\n      case 2:\n        dataView.setUint16(offset, Number(value), true);\n        break;\n      case 4:\n        dataView.setUint32(offset, Number(value), true);\n        break;\n      case 8:\n        dataView.setBigUint64(offset, value, true);\n        break;\n      default:\n        {\n          for (let i = 0; i < this.byteLength; i += 8) {\n            if (i > 0) value = value / BIGINT_2_POW_64;\n            const lo = BigInt.asUintN(64, value);\n            dataView.setBigUint64(offset + i, lo, true);\n          }\n        }\n    }\n    return offset + this.byteLength;\n  }\n  value_deserializeFromBytes(_ref4, start, end) {\n    let {\n      dataView\n    } = _ref4;\n    const size = end - start;\n    if (size !== this.byteLength) {\n      throw Error(\"Invalid size \".concat(size, \" expected \").concat(this.byteLength));\n    }\n    // Note: pre-assigning the right function at the constructor to avoid this switch is not faster\n    switch (this.byteLength) {\n      case 1:\n        return BigInt(dataView.getUint8(start));\n      case 2:\n        return BigInt(dataView.getUint16(start, true));\n      case 4:\n        return BigInt(dataView.getUint32(start, true));\n      case 8:\n        return dataView.getBigUint64(start, true);\n      case 16:\n        {\n          const a = dataView.getBigUint64(start, true);\n          const b = dataView.getBigUint64(start + 8, true);\n          return b * BIGINT_2_POW_64 + a;\n        }\n      case 32:\n        {\n          const a = dataView.getBigUint64(start, true);\n          const b = dataView.getBigUint64(start + 8, true);\n          const c = dataView.getBigUint64(start + 16, true);\n          const d = dataView.getBigUint64(start + 24, true);\n          return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;\n        }\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const value = node.getUintBigint(this.byteLength, 0);\n    this.value_serializeToBytes(output, offset, value);\n    return offset + this.byteLength;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const size = end - start;\n    if (size !== this.byteLength) {\n      throw Error(\"Invalid size \".concat(size, \" expected \").concat(this.byteLength));\n    }\n    const value = this.value_deserializeFromBytes(data, start, end);\n    const node = persistent_merkle_tree_1.LeafNode.fromZero();\n    node.setUintBigint(this.byteLength, 0, value);\n    return node;\n  }\n  // Fast Tree access\n  tree_getFromNode(leafNode) {\n    return leafNode.getUintBigint(this.byteLength, 0);\n  }\n  /** Mutates node to set value */\n  tree_setToNode(leafNode, value) {\n    this.tree_setToPackedNode(leafNode, 0, value);\n  }\n  /** EXAMPLE of `tree_getFromNode` */\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    return leafNode.getUintBigint(this.byteLength, offsetBytes);\n  }\n  /** Mutates node to set value */\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    // TODO: Not-optimized, copy pasted from UintNumberType\n    leafNode.setUintBigint(this.byteLength, offsetBytes, value);\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json === \"bigint\") {\n      return json;\n    } else if (typeof json === \"string\" || typeof json === \"number\") {\n      return BigInt(json);\n    } else {\n      throw Error(\"JSON invalid type \".concat(typeof json, \" expected bigint\"));\n    }\n  }\n  toJson(value) {\n    return value.toString(10);\n  }\n}\nexports.UintBigintType = UintBigintType;","map":null,"metadata":{},"sourceType":"script"}