{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectWallet = void 0;\nconst base_1 = require(\"@celo/base\");\nconst wallet_remote_1 = require(\"@celo/wallet-remote\");\nconst sign_client_1 = __importDefault(require(\"@walletconnect/sign-client\"));\nconst utils_1 = require(\"@walletconnect/utils\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst events_1 = __importDefault(require(\"events\"));\nconst constants_1 = require(\"./constants\");\nconst types_1 = require(\"./types\");\nconst utils_2 = require(\"./utils\");\nconst canceler_1 = __importDefault(require(\"./utils/canceler\"));\nconst wc_signer_1 = require(\"./wc-signer\");\nconst debug = (0, debug_1.default)('kit:wallet:wallet-connect-wallet');\n/**\n * Session establishment happens out of band so after somehow\n * communicating the connection URI (often via QR code) we can\n * continue with the setup process\n */\nfunction waitForTruthy(getValue, signal) {\n  let waitDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n  return __awaiter(this, void 0, void 0, function* () {\n    if (signal.canceled || getValue()) {\n      return;\n    }\n    yield (0, base_1.sleep)(waitDuration);\n    return waitForTruthy(getValue, signal, waitDuration);\n  });\n}\nconst defaultInitOptions = {\n  logger: process.env.NODE_ENV === 'production' ? 'error' : 'debug',\n  metadata: {\n    name: 'react-celo',\n    description: \"Celo's react-celo is a library to help developers and validators to interact with the celo-blockchain.\",\n    url: 'https://github.com/celo-org/celo-monorepo/tree/master/packages/sdk/contractkit',\n    icons: ['https://avatars.githubusercontent.com/u/37552875?s=200&v=4']\n  }\n};\nconst requiredNamespaces = {\n  eip155: {\n    chains: [],\n    methods: [types_1.SupportedMethods.signTransaction],\n    events: ['accountsChanged']\n  }\n};\nconst optionalNamespaces = {\n  eip155: {\n    chains: ['eip155:44787', 'eip155:42220', 'eip155:17323', 'eip155:62320' // baklava\n    ],\n\n    methods: Object.values(types_1.SupportedMethods),\n    events: ['chainChanged', 'accountsChanged']\n  }\n};\nclass WalletConnectWallet extends wallet_remote_1.RemoteWallet {\n  constructor(_ref) {\n    let {\n      init,\n      projectId,\n      chainId\n    } = _ref;\n    super();\n    this.emitter = new events_1.default();\n    this.signers = new Map();\n    this.on = (event, fn) => {\n      this.emitter.on(event, fn);\n    };\n    this.emit = (event, error, data) => {\n      console.info('emit', event, error, data);\n      this.emitter.emit(event, error, data);\n    };\n    this.onSessionProposal = session => {\n      this.emit('session_proposal', null, session);\n    };\n    this.onSessionUpdated = session => {\n      var _a;\n      const {\n        topic,\n        params: {\n          namespaces\n        }\n      } = session;\n      const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);\n      this.session = Object.assign(Object.assign({}, _session), {\n        namespaces\n      });\n      this.emit('session_update', null, session);\n    };\n    this.onSessionExtended = session => {\n      var _a;\n      const {\n        topic\n      } = session;\n      const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);\n      this.session = Object.assign({}, _session);\n      this.emit('session_extend', null, session);\n    };\n    this.onSessionExpire = _ref2 => {\n      let {\n        topic\n      } = _ref2;\n      var _a, _b, _c;\n      // can you be connected to a topic that isnt the main topic? how to just disconnect that topic?\n      if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {\n        void this.close();\n      } else if ((_b = this.client) === null || _b === void 0 ? void 0 : _b.pairing.values) {\n        const sessionForTopic = this.client.pairing.values.find(connection => connection.topic === topic);\n        console.warn('received session expired for topic', topic, 'which is not the topic of session', (_c = this.session) === null || _c === void 0 ? void 0 : _c.topic, 'session with such topic in storage', sessionForTopic || 'false');\n      }\n    };\n    this.onSessionDeleted = session => {\n      this.emit('session_delete', null, session);\n      void this.close().catch(e => {\n        console.error('error closing session', e);\n      });\n    };\n    this.onSessionEvent = event => {\n      this.emit('session_event', null, event);\n    };\n    this.onSessionPing = ping => {\n      this.emit('session_ping', null, ping);\n    };\n    this.onSessionRequest = request => {\n      this.emit('session_request', null, request);\n    };\n    this.close = () => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (!this.client) {\n        throw new Error('Wallet must be initialized before calling close()');\n      }\n      this.canceler.cancel();\n      const reason = (0, utils_1.getSdkError)('USER_DISCONNECTED');\n      const connections = this.client.pairing.values;\n      this.session && this.client.session.delete((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic, reason);\n      yield Promise.all(connections.map(connection => {\n        try {\n          console.info('closing wc connection', connection, reason);\n          return this.client.disconnect({\n            topic: connection.topic,\n            reason\n          });\n        } catch (e) {\n          console.error('Error closing wc connection', connection, reason, e);\n        }\n      }));\n      // ensures pairing is deleted so wallet doesnt have a lingering one.\n      if (((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) && this.client.pairing) {\n        yield (_c = this.client.pairing) === null || _c === void 0 ? void 0 : _c.delete(this.session.topic, reason);\n      }\n      this.client = undefined;\n      this.session = undefined;\n    });\n    this.canceler = new canceler_1.default();\n    this.initOptions = Object.assign(Object.assign(Object.assign({}, defaultInitOptions), init), {\n      projectId\n    });\n    this.chainId = chainId;\n    void this.getWalletConnectClient().then(client => __awaiter(this, void 0, void 0, function* () {\n      this.client = client;\n      this.setupListeners();\n      // when we're in certain environments (like the browser) the\n      // WalletConnect client will handle retrieving old sessions.\n      if (client.session) {\n        const session = client.session.getAll().sort((a, b) => b.expiry - a.expiry).find(x => x.acknowledged && x.expiry * 1000 > Date.now());\n        if (session) {\n          try {\n            yield client.extend({\n              topic: session.topic\n            });\n          } catch (e) {\n            debug('session resurrection, extend failed, wallet most likely refuses session extensions', e);\n          }\n          this.session = session;\n          // It might be better not to emit an event here. after all this is a fake event anyway.\n          this.emit('session_update', null, {\n            id: 0,\n            topic: session.topic,\n            params: {\n              namespaces: session.namespaces\n            }\n          });\n        }\n      }\n    })).catch(e => {\n      debug('session resurrection failed', e);\n      this.emit('session_update', e);\n    });\n  }\n  hasSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield waitForTruthy(() => !!this.session, this.canceler.status);\n    });\n  }\n  setupListeners() {\n    if (!this.client) return;\n    this.client.on('session_proposal', this.onSessionProposal);\n    this.client.on('session_update', this.onSessionUpdated);\n    this.client.on('session_delete', this.onSessionDeleted);\n    // currently when disconnecting the pairing from the offical wc w implementation\n    // https://react-wallet.walletconnect.com/pairings our dapp does not disconnect.\n    this.client.pairing.core.events.on('wc_pairingDeleted', this.onSessionDeleted);\n    this.client.core.on('subscription_deleted', this.onSessionDeleted);\n    this.client.pairing.core.on('wc_pairingDeleted', this.onSessionDeleted);\n    this.client.on('session_extend', this.onSessionExtended);\n    this.client.on('session_event', this.onSessionEvent);\n    this.client.on('session_expire', this.onSessionExpire);\n    this.client.on('session_ping', this.onSessionPing);\n    this.client.on('session_request', this.onSessionRequest);\n  }\n  /**\n   * Pulled out to allow mocking\n   */\n  getWalletConnectClient() {\n    return sign_client_1.default.init(this.initOptions);\n  }\n  switchToChain(params) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.client) {\n        return true;\n      }\n      // check if session already has the desired chain in it by checking accounts and chains\n      const accountSessions = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces) === null || _b === void 0 ? void 0 : _b.eip155) === null || _c === void 0 ? void 0 : _c.accounts) === null || _d === void 0 ? void 0 : _d.filter(eip155ChainAccount => this.chainId.toString() === (0, utils_2.parseAddress)(eip155ChainAccount).networkId);\n      const chainSessions = (_f = (_e = this.session) === null || _e === void 0 ? void 0 : _e.namespaces.eip155.chains) === null || _f === void 0 ? void 0 : _f.filter(prefixedChain => prefixedChain === \"eip155:\".concat(params.chainId));\n      if (!(accountSessions === null || accountSessions === void 0 ? void 0 : accountSessions.length) && !(chainSessions === null || chainSessions === void 0 ? void 0 : chainSessions.length)) {\n        const accounts = this.session.namespaces.eip155.accounts;\n        // update the chain data in the session.\n        // this is necessary since we only require the current chain when connecting and some wallets\n        //  might not notice the optional namespace chains and thus not include them on the namespaces when connecting even if they do in fact support them\n        try {\n          const updatingSession = {\n            topic: this.session.topic,\n            namespaces: {\n              eip155: {\n                accounts: accounts.concat(accounts.map(account => {\n                  return \"eip155:\".concat(params.chainId, \":\").concat((0, utils_2.parseAddress)(account).address);\n                })),\n                chains: (((_g = this.session) === null || _g === void 0 ? void 0 : _g.namespaces.eip155.chains) || []).concat([\"eip155:\".concat(params.chainId)]),\n                methods: this.session.namespaces.eip155.methods,\n                events: this.session.namespaces.eip155.events\n              }\n            }\n          };\n          const resp = yield (_h = this.client) === null || _h === void 0 ? void 0 : _h.update(updatingSession);\n          yield resp === null || resp === void 0 ? void 0 : resp.acknowledged();\n          // ensure we have the new data on the local session.\n          this.onSessionUpdated({\n            id: 0,\n            topic: updatingSession.topic,\n            params: {\n              namespaces: updatingSession.namespaces\n            }\n          });\n          return true;\n        } catch (e) {\n          console.error(\"switchToChain failed, wallet likely does not support \".concat(params.chainId), e);\n          return false;\n        }\n      }\n      this.chainId = params.chainId;\n      yield this.loadAccountSigners();\n      return true;\n    });\n  }\n  /**\n   * Get the URI needed for out of band session establishment\n   */\n  getUri() {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.client = this.client || (yield this.getWalletConnectClient());\n      if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.acknowledged) && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.expiry) && ((_c = this.session) === null || _c === void 0 ? void 0 : _c.expiry) * 1000 > Date.now()) {\n        return;\n      }\n      this.setupListeners();\n      // wallets will literally fail if they don't support a chainId in the required namespaces\n      // likewise wallets return an error if they dont support a method in the required namespaces\n      // therefore required really is required and we add new chain to namespaces when switching chains. see switchToChain\n      const {\n        uri,\n        approval\n      } = yield this.client.connect({\n        requiredNamespaces: {\n          eip155: Object.assign(Object.assign({}, requiredNamespaces.eip155), {\n            chains: [\"eip155:\".concat(this.chainId)]\n          })\n        },\n        optionalNamespaces\n      });\n      void approval().then(session => {\n        console.info('approved session', session);\n        this.session = session;\n        this.emit('session_update', null, {\n          id: 1,\n          topic: session.topic,\n          params: {\n            namespaces: session.namespaces\n          }\n        });\n      }).catch(err => {\n        this.emit('session_update', err);\n      });\n      return uri;\n    });\n  }\n  loadAccountSigners() {\n    return __awaiter(this, void 0, void 0, function* () {\n      /**\n       * Session establishment happens out of band so after somehow\n       * communicating the connection URI (often via QR code) we can\n       * continue with the setup process\n       */\n      yield waitForTruthy(() => !!this.session, this.canceler.status);\n      if (this.canceler.status.canceled) {\n        // This will be true if this.canceler.cancel() was called earlier\n        throw constants_1.CANCELED;\n      }\n      const addressToSigner = new Map();\n      const allNamespaceAccounts = Object.values(this.session.namespaces).map(namespace => namespace.accounts).flat();\n      // namespace.accounts is an array of chain prefixed addresses,\n      // we should not be assuming that every address can work for every chain. but instead filtering based on chain prefix.\n      allNamespaceAccounts.filter(addressLike => {\n        const {\n          networkId\n        } = (0, utils_2.parseAddress)(addressLike);\n        return networkId === String(this.chainId); // chain id matches this.chainId\n      }).forEach(addressLike => {\n        const {\n          address\n        } = (0, utils_2.parseAddress)(addressLike);\n        const signer = new wc_signer_1.WalletConnectSigner(this.client, this.session, address, String(this.chainId));\n        addressToSigner.set(address, signer);\n        this.addSigner(address, signer);\n      });\n      // note the parent of this class has  a private signers map at addressSigners. which is what addSigner and GetSigner access\n      this.signers = addressToSigner;\n      return addressToSigner;\n    });\n  }\n  /**\n   * Gets the signer based on the 'from' field in the tx body\n   * @param txParams Transaction to sign\n   * @dev overrides WalletBase.signTransaction\n   */\n  signTransaction(txParams) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fromAddress = txParams.from.toString();\n      const signer = this.getSigner(fromAddress);\n      return signer.signRawTransaction(txParams);\n    });\n  }\n}\nexports.WalletConnectWallet = WalletConnectWallet;","map":null,"metadata":{},"sourceType":"script"}