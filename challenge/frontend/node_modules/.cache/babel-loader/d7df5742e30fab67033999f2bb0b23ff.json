{"ast":null,"code":"'use strict';\n\nconst HTML = require('../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\n\n//Element utils\n\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\nfunction isImpliedEndTagRequired(tn) {\n  switch (tn.length) {\n    case 1:\n      return tn === $.P;\n    case 2:\n      return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;\n    case 3:\n      return tn === $.RTC;\n    case 6:\n      return tn === $.OPTION;\n    case 8:\n      return tn === $.OPTGROUP;\n  }\n  return false;\n}\nfunction isImpliedEndTagRequiredThoroughly(tn) {\n  switch (tn.length) {\n    case 1:\n      return tn === $.P;\n    case 2:\n      return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI || tn === $.TD || tn === $.TH || tn === $.TR;\n    case 3:\n      return tn === $.RTC;\n    case 5:\n      return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;\n    case 6:\n      return tn === $.OPTION;\n    case 7:\n      return tn === $.CAPTION;\n    case 8:\n      return tn === $.OPTGROUP || tn === $.COLGROUP;\n  }\n  return false;\n}\nfunction isScopingElement(tn, ns) {\n  switch (tn.length) {\n    case 2:\n      if (tn === $.TD || tn === $.TH) {\n        return ns === NS.HTML;\n      } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {\n        return ns === NS.MATHML;\n      }\n      break;\n    case 4:\n      if (tn === $.HTML) {\n        return ns === NS.HTML;\n      } else if (tn === $.DESC) {\n        return ns === NS.SVG;\n      }\n      break;\n    case 5:\n      if (tn === $.TABLE) {\n        return ns === NS.HTML;\n      } else if (tn === $.MTEXT) {\n        return ns === NS.MATHML;\n      } else if (tn === $.TITLE) {\n        return ns === NS.SVG;\n      }\n      break;\n    case 6:\n      return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;\n    case 7:\n      return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;\n    case 8:\n      return tn === $.TEMPLATE && ns === NS.HTML;\n    case 13:\n      return tn === $.FOREIGN_OBJECT && ns === NS.SVG;\n    case 14:\n      return tn === $.ANNOTATION_XML && ns === NS.MATHML;\n  }\n  return false;\n}\n\n//Stack of open elements\nclass OpenElementStack {\n  constructor(document, treeAdapter) {\n    this.stackTop = -1;\n    this.items = [];\n    this.current = document;\n    this.currentTagName = null;\n    this.currentTmplContent = null;\n    this.tmplCount = 0;\n    this.treeAdapter = treeAdapter;\n  }\n\n  //Index of element\n  _indexOf(element) {\n    let idx = -1;\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.items[i] === element) {\n        idx = i;\n        break;\n      }\n    }\n    return idx;\n  }\n\n  //Update current element\n  _isInTemplate() {\n    return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;\n  }\n  _updateCurrentElement() {\n    this.current = this.items[this.stackTop];\n    this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);\n    this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;\n  }\n\n  //Mutations\n  push(element) {\n    this.items[++this.stackTop] = element;\n    this._updateCurrentElement();\n    if (this._isInTemplate()) {\n      this.tmplCount++;\n    }\n  }\n  pop() {\n    this.stackTop--;\n    if (this.tmplCount > 0 && this._isInTemplate()) {\n      this.tmplCount--;\n    }\n    this._updateCurrentElement();\n  }\n  replace(oldElement, newElement) {\n    const idx = this._indexOf(oldElement);\n    this.items[idx] = newElement;\n    if (idx === this.stackTop) {\n      this._updateCurrentElement();\n    }\n  }\n  insertAfter(referenceElement, newElement) {\n    const insertionIdx = this._indexOf(referenceElement) + 1;\n    this.items.splice(insertionIdx, 0, newElement);\n    if (insertionIdx === ++this.stackTop) {\n      this._updateCurrentElement();\n    }\n  }\n  popUntilTagNamePopped(tagName) {\n    while (this.stackTop > -1) {\n      const tn = this.currentTagName;\n      const ns = this.treeAdapter.getNamespaceURI(this.current);\n      this.pop();\n      if (tn === tagName && ns === NS.HTML) {\n        break;\n      }\n    }\n  }\n  popUntilElementPopped(element) {\n    while (this.stackTop > -1) {\n      const poppedElement = this.current;\n      this.pop();\n      if (poppedElement === element) {\n        break;\n      }\n    }\n  }\n  popUntilNumberedHeaderPopped() {\n    while (this.stackTop > -1) {\n      const tn = this.currentTagName;\n      const ns = this.treeAdapter.getNamespaceURI(this.current);\n      this.pop();\n      if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6 && ns === NS.HTML) {\n        break;\n      }\n    }\n  }\n  popUntilTableCellPopped() {\n    while (this.stackTop > -1) {\n      const tn = this.currentTagName;\n      const ns = this.treeAdapter.getNamespaceURI(this.current);\n      this.pop();\n      if (tn === $.TD || tn === $.TH && ns === NS.HTML) {\n        break;\n      }\n    }\n  }\n  popAllUpToHtmlElement() {\n    //NOTE: here we assume that root <html> element is always first in the open element stack, so\n    //we perform this fast stack clean up.\n    this.stackTop = 0;\n    this._updateCurrentElement();\n  }\n  clearBackToTableContext() {\n    while (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {\n      this.pop();\n    }\n  }\n  clearBackToTableBodyContext() {\n    while (this.currentTagName !== $.TBODY && this.currentTagName !== $.TFOOT && this.currentTagName !== $.THEAD && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {\n      this.pop();\n    }\n  }\n  clearBackToTableRowContext() {\n    while (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {\n      this.pop();\n    }\n  }\n  remove(element) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      if (this.items[i] === element) {\n        this.items.splice(i, 1);\n        this.stackTop--;\n        this._updateCurrentElement();\n        break;\n      }\n    }\n  }\n\n  //Search\n  tryPeekProperlyNestedBodyElement() {\n    //Properly nested <body> element (should be second element in stack).\n    const element = this.items[1];\n    return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;\n  }\n  contains(element) {\n    return this._indexOf(element) > -1;\n  }\n  getCommonAncestor(element) {\n    let elementIdx = this._indexOf(element);\n    return --elementIdx >= 0 ? this.items[elementIdx] : null;\n  }\n  isRootHtmlElementCurrent() {\n    return this.stackTop === 0 && this.currentTagName === $.HTML;\n  }\n\n  //Element in scope\n  hasInScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if (tn === tagName && ns === NS.HTML) {\n        return true;\n      }\n      if (isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  hasNumberedHeaderInScope() {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if ((tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) && ns === NS.HTML) {\n        return true;\n      }\n      if (isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  hasInListItemScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if (tn === tagName && ns === NS.HTML) {\n        return true;\n      }\n      if ((tn === $.UL || tn === $.OL) && ns === NS.HTML || isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  hasInButtonScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if (tn === tagName && ns === NS.HTML) {\n        return true;\n      }\n      if (tn === $.BUTTON && ns === NS.HTML || isScopingElement(tn, ns)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  hasInTableScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if (ns !== NS.HTML) {\n        continue;\n      }\n      if (tn === tagName) {\n        return true;\n      }\n      if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {\n        return false;\n      }\n    }\n    return true;\n  }\n  hasTableBodyContextInTableScope() {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if (ns !== NS.HTML) {\n        continue;\n      }\n      if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {\n        return true;\n      }\n      if (tn === $.TABLE || tn === $.HTML) {\n        return false;\n      }\n    }\n    return true;\n  }\n  hasInSelectScope(tagName) {\n    for (let i = this.stackTop; i >= 0; i--) {\n      const tn = this.treeAdapter.getTagName(this.items[i]);\n      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n      if (ns !== NS.HTML) {\n        continue;\n      }\n      if (tn === tagName) {\n        return true;\n      }\n      if (tn !== $.OPTION && tn !== $.OPTGROUP) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  //Implied end tags\n  generateImpliedEndTags() {\n    while (isImpliedEndTagRequired(this.currentTagName)) {\n      this.pop();\n    }\n  }\n  generateImpliedEndTagsThoroughly() {\n    while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {\n      this.pop();\n    }\n  }\n  generateImpliedEndTagsWithExclusion(exclusionTagName) {\n    while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {\n      this.pop();\n    }\n  }\n}\nmodule.exports = OpenElementStack;","map":null,"metadata":{},"sourceType":"script"}