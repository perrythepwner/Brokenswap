{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;\nconst node_1 = require(\"./node\");\nconst zeroNode_1 = require(\"./zeroNode\");\nfunction subtreeFillToDepth(bottom, depth) {\n  let node = bottom;\n  while (depth > 0) {\n    node = new node_1.BranchNode(node, node);\n    depth--;\n  }\n  return node;\n}\nexports.subtreeFillToDepth = subtreeFillToDepth;\nfunction subtreeFillToLength(bottom, depth, length) {\n  const maxLength = 1 << depth;\n  if (length > maxLength) throw new Error(\"ERR_TOO_MANY_NODES\");\n  if (length === maxLength) return subtreeFillToDepth(bottom, depth);\n  if (depth === 0) {\n    if (length === 1) return bottom;else throw new Error(\"ERR_NAVIGATION\");\n  }\n  if (depth === 1) {\n    return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));\n  }\n  const pivot = maxLength >> 1;\n  if (length <= pivot) {\n    return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));\n  } else {\n    return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));\n  }\n}\nexports.subtreeFillToLength = subtreeFillToLength;\n/**\n * WARNING: Mutates the provided nodes array.\n * TODO: Don't mutate the nodes array.\n */\nfunction subtreeFillToContents(nodes, depth) {\n  const maxLength = 2 ** depth;\n  if (nodes.length > maxLength) {\n    throw new Error(\"nodes.length \".concat(nodes.length, \" over maxIndex at depth \").concat(depth));\n  }\n  if (nodes.length === 0) {\n    return zeroNode_1.zeroNode(depth);\n  }\n  if (depth === 0) {\n    return nodes[0];\n  }\n  if (depth === 1) {\n    return nodes.length > 1 ?\n    // All nodes at depth 1 available\n    new node_1.BranchNode(nodes[0], nodes[1]) :\n    // Pad with zero node\n    new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0));\n  }\n  let count = nodes.length;\n  for (let d = depth; d > 0; d--) {\n    const countRemainder = count % 2;\n    const countEven = count - countRemainder;\n    // For each depth level compute the new BranchNodes and overwrite the nodes array\n    for (let i = 0; i < countEven; i += 2) {\n      nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n    }\n    if (countRemainder > 0) {\n      nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));\n    }\n    // If there was remainer, 2 nodes are added to the count\n    count = countEven / 2 + countRemainder;\n  }\n  return nodes[0];\n}\nexports.subtreeFillToContents = subtreeFillToContents;","map":null,"metadata":{},"sourceType":"script"}