{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useCeloMethods = void 0;\nconst react_1 = require(\"react\");\nconst react_device_detect_1 = require(\"react-device-detect\");\nconst connectors_1 = require(\"./connectors\");\nconst constants_1 = require(\"./constants\");\nconst use_contracts_cache_1 = require(\"./hooks/use-contracts-cache\");\nconst colors_1 = require(\"./utils/colors\");\nconst logger_1 = require(\"./utils/logger\");\nconst network_watcher_1 = __importDefault(require(\"./utils/network-watcher\"));\nconst persistor_1 = __importDefault(require(\"./utils/persistor\"));\nconst updater_1 = require(\"./utils/updater\");\nfunction useCeloMethods(_ref, dispatch, buildContractsCache) {\n  var _this = this;\n  let {\n    connector,\n    networks,\n    network,\n    manualNetworkMode\n  } = _ref;\n  const initConnector = (0, react_1.useCallback)((nextConnector, lastUsedAddress) => __awaiter(this, void 0, void 0, function* () {\n    try {\n      // need to set the event listeners here before initialise()\n      (0, updater_1.updater)(nextConnector, dispatch);\n      (0, persistor_1.default)(nextConnector);\n      (0, network_watcher_1.default)(nextConnector, networks, manualNetworkMode);\n      const initialisedConnector = yield nextConnector.initialise(lastUsedAddress);\n      dispatch('initialisedConnector', initialisedConnector);\n    } catch (e) {\n      if (typeof e === 'symbol') {\n        (0, logger_1.getApplicationLogger)().debug('[initConnector]', 'Ignoring error initializing connector with reason', e.description);\n        throw e;\n      }\n      (0, logger_1.getApplicationLogger)().error('[initConnector]', 'Error initializing connector', nextConnector.type, e);\n      const error = e instanceof Error ? e : new Error('Failed to initialise connector');\n      dispatch('setConnectorInitError', error);\n      throw e;\n    }\n  }), [dispatch, networks, manualNetworkMode]);\n  const disconnect = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {\n    yield connector.close();\n    const passiveConnector = new connectors_1.UnauthenticatedConnector(network);\n    yield initConnector(passiveConnector);\n  }), [connector, network, initConnector]);\n  // This is just to be used to for users to explicitly change\n  // the network. It doesn't work for all wallets.\n  const updateNetwork = (0, react_1.useCallback)(function (newNetwork) {\n    let dappOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(_this, void 0, void 0, function* () {\n      (0, logger_1.getApplicationLogger)().debug('[updateNetwork]', newNetwork, connector.type);\n      if (dappOnly && connector.continueNetworkUpdateFromWallet) {\n        connector.continueNetworkUpdateFromWallet(newNetwork);\n      } else if (constants_1.STATIC_NETWORK_WALLETS.includes(connector.type)) {\n        throw new Error(\"The connected wallet's network must be changed from the wallet.\");\n      }\n      yield connector.startNetworkChangeFromApp(newNetwork);\n    });\n  }, [connector]);\n  const connect = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {\n    const connectionResultPromise = new Promise(resolve => {\n      dispatch('setConnectionCallback', resolve);\n    });\n    const newConnector = yield connectionResultPromise;\n    dispatch('setConnectionCallback', null);\n    if (newConnector === false) {\n      throw new Error('Connection cancelled');\n    }\n    return newConnector;\n  }), [dispatch]);\n  const getConnectedKit = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {\n    let initialisedConnection = connector;\n    if (connector.type === constants_1.WalletTypes.Unauthenticated) {\n      initialisedConnection = yield connect();\n    } else if (!initialisedConnection.initialised) {\n      yield initConnector(initialisedConnection);\n    }\n    return initialisedConnection.kit;\n  }), [connect, connector, initConnector]);\n  const updateFeeCurrency = (0, react_1.useCallback)(newFeeCurrency => __awaiter(this, void 0, void 0, function* () {\n    try {\n      if (connector.supportsFeeCurrency() && connector.updateFeeCurrency) {\n        yield connector.updateFeeCurrency(newFeeCurrency);\n        dispatch('setFeeCurrency', newFeeCurrency);\n      }\n    } catch (error) {\n      (0, logger_1.getApplicationLogger)().warn('[updateFeeCurrency]', 'updating Fee Currency not supported by this wallet or network', error);\n    }\n  }), [connector, dispatch]);\n  const updateTheme = (0, react_1.useCallback)(theme => {\n    if (!theme) return dispatch('setTheme', null);\n    if (process.env.NODE_ENV !== 'production') {\n      (0, colors_1.fixTheme)(theme);\n      (0, colors_1.contrastCheck)(theme);\n    }\n    dispatch('setTheme', theme);\n  }, [dispatch]);\n  const performActions = (0, react_1.useCallback)(function () {\n    for (var _len = arguments.length, operations = new Array(_len), _key = 0; _key < _len; _key++) {\n      operations[_key] = arguments[_key];\n    }\n    return __awaiter(_this, void 0, void 0, function* () {\n      const kit = yield getConnectedKit();\n      dispatch('setPendingActionCount', operations.length);\n      const results = [];\n      for (const op of operations) {\n        try {\n          // When on mobile direct user to their wallet app.\n          if (react_device_detect_1.isMobile && connector.getDeeplinkUrl) {\n            const url = connector.getDeeplinkUrl('');\n            if (url) window.open(url, '_blank');\n          }\n          results.push(yield op(kit));\n        } catch (e) {\n          dispatch('setPendingActionCount', 0);\n          throw e;\n        }\n        dispatch('decrementPendingActionCount');\n      }\n      return results;\n    });\n  }, [getConnectedKit, dispatch, connector]);\n  const contractsCache = (0, use_contracts_cache_1.useContractsCache)(buildContractsCache, connector);\n  const resetInitError = (0, react_1.useCallback)(() => {\n    dispatch('setConnectorInitError', null);\n  }, [dispatch]);\n  return {\n    destroy: disconnect,\n    disconnect,\n    initConnector,\n    resetInitError,\n    updateNetwork,\n    connect,\n    getConnectedKit,\n    performActions,\n    updateFeeCurrency,\n    contractsCache,\n    updateTheme\n  };\n}\nexports.useCeloMethods = useCeloMethods;","map":null,"metadata":{},"sourceType":"script"}