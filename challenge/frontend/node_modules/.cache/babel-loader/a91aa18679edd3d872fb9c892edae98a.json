{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst case_1 = __importDefault(require(\"case\"));\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"../view/container\");\nconst container_2 = require(\"../viewDU/container\");\n/**\n * Container: ordered heterogeneous collection of values\n * - Notation: Custom name per instance\n */\nclass ContainerType extends composite_1.CompositeType {\n  constructor(fields, opts) {\n    var _opts$typeName, _opts$getContainerTre, _opts$getContainerTre2, _opts$getContainerTre3, _opts$getContainerTre4;\n    super(opts === null || opts === void 0 ? void 0 : opts.cachePermanentRootStruct);\n    this.fields = fields;\n    this.opts = opts;\n    this.isList = false;\n    this.isViewMutable = true;\n    // Render detailed typeName. Consumers should overwrite since it can get long\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : renderContainerTypeName(fields);\n    this.maxChunkCount = Object.keys(fields).length;\n    this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Precalculated data for faster serdes\n    this.fieldsEntries = [];\n    for (const fieldName of Object.keys(fields)) {\n      this.fieldsEntries.push({\n        fieldName,\n        fieldType: this.fields[fieldName],\n        jsonKey: precomputeJsonKey(fieldName, opts === null || opts === void 0 ? void 0 : opts.casingMap, opts === null || opts === void 0 ? void 0 : opts.jsonCase),\n        gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length))\n      });\n    }\n    if (this.fieldsEntries.length === 0) {\n      throw Error(\"Container must have > 0 fields\");\n    }\n    // Precalculate for Proofs API\n    this.fieldsGindex = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));\n    }\n    // To resolve JSON paths in fieldName notation and jsonKey notation\n    this.jsonKeyToFieldName = {};\n    for (const {\n      fieldName,\n      jsonKey\n    } of this.fieldsEntries) {\n      this.jsonKeyToFieldName[jsonKey] = fieldName;\n    }\n    const {\n      minLen,\n      maxLen,\n      fixedSize\n    } = precomputeSizes(fields);\n    this.minSize = minLen;\n    this.maxSize = maxLen;\n    this.fixedSize = fixedSize;\n    const {\n      isFixedLen,\n      fieldRangesFixedLen,\n      variableOffsetsPosition,\n      fixedEnd\n    } = precomputeSerdesData(fields);\n    this.isFixedLen = isFixedLen;\n    this.fieldRangesFixedLen = fieldRangesFixedLen;\n    this.variableOffsetsPosition = variableOffsetsPosition;\n    this.fixedEnd = fixedEnd;\n    // TODO: This options are necessary for ContainerNodeStruct to override this.\n    // Refactor this constructor to allow customization without pollutin the options\n    this.TreeView = (_opts$getContainerTre = opts === null || opts === void 0 || (_opts$getContainerTre2 = opts.getContainerTreeViewClass) === null || _opts$getContainerTre2 === void 0 ? void 0 : _opts$getContainerTre2.call(opts, this)) !== null && _opts$getContainerTre !== void 0 ? _opts$getContainerTre : container_1.getContainerTreeViewClass(this);\n    this.TreeViewDU = (_opts$getContainerTre3 = opts === null || opts === void 0 || (_opts$getContainerTre4 = opts.getContainerTreeViewDUClass) === null || _opts$getContainerTre4 === void 0 ? void 0 : _opts$getContainerTre4.call(opts, this)) !== null && _opts$getContainerTre3 !== void 0 ? _opts$getContainerTre3 : container_2.getContainerTreeViewDUClass(this);\n  }\n  static named(fields, opts) {\n    return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);\n  }\n  defaultValue() {\n    const value = {};\n    for (const {\n      fieldName,\n      fieldType\n    } of this.fieldsEntries) {\n      value[fieldName] = fieldType.defaultValue();\n    }\n    return value;\n  }\n  getView(tree) {\n    return new this.TreeView(this, tree);\n  }\n  getViewDU(node, cache) {\n    return new this.TreeViewDU(this, node, cache);\n  }\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n  commitView(view) {\n    return view.node;\n  }\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n  // Serialization + deserialization\n  // -------------------------------\n  // Containers can mix fixed length and variable length data.\n  //\n  // Fixed part                         Variable part\n  // [field1 offset][field2 data       ][field1 data               ]\n  // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]\n  value_serializedSize(value) {\n    let totalSize = 0;\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      // Offset (4 bytes) + size\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;\n    }\n    return totalSize;\n  }\n  value_serializeToBytes(output, offset, value) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4;\n        // write serialized element to variable section\n        variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);\n      } else {\n        fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);\n      }\n    }\n    return variableIndex;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const value = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n    return value;\n  }\n  tree_serializedSize(node) {\n    let totalSize = 0;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n      // Offset (4 bytes) + size\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;\n    }\n    return totalSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4;\n        // write serialized element to variable section\n        variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);\n      } else {\n        fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);\n      }\n    }\n    return variableIndex;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const nodes = new Array(this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n    return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);\n  }\n  // Merkleization\n  getRoots(struct) {\n    const roots = new Array(this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      roots[i] = fieldType.hashTreeRoot(struct[fieldName]);\n    }\n    return roots;\n  }\n  // Proofs\n  // getPropertyGindex\n  // getPropertyType\n  // tree_getLeafGindices\n  getPropertyGindex(prop) {\n    var _this$fieldsGindex$pr;\n    const gindex = (_this$fieldsGindex$pr = this.fieldsGindex[prop]) !== null && _this$fieldsGindex$pr !== void 0 ? _this$fieldsGindex$pr : this.fieldsGindex[this.jsonKeyToFieldName[prop]];\n    if (gindex === undefined) throw Error(\"Unknown container property \".concat(prop));\n    return gindex;\n  }\n  getPropertyType(prop) {\n    var _this$fields$prop;\n    const type = (_this$fields$prop = this.fields[prop]) !== null && _this$fields$prop !== void 0 ? _this$fields$prop : this.fields[this.jsonKeyToFieldName[prop]];\n    if (type === undefined) throw Error(\"Unknown container property \".concat(prop));\n    return type;\n  }\n  getIndexProperty(index) {\n    if (index >= this.fieldsEntries.length) {\n      return null;\n    }\n    return this.fieldsEntries[index].fieldName;\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    const gindices = [];\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldGindex = this.fieldsGindex[fieldName];\n      const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);\n      if (fieldType.isBasic) {\n        gindices.push(fieldGindexFromRoot);\n      } else {\n        const compositeType = fieldType;\n        if (fieldType.fixedSize === null) {\n          if (!rootNode) {\n            throw new Error(\"variable type requires tree argument to get leaves\");\n          }\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));\n        } else {\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));\n        }\n      }\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw Error(\"JSON must be of type object\");\n    }\n    if (json === null) {\n      throw Error(\"JSON must not be null\");\n    }\n    const value = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      const jsonValue = json[jsonKey];\n      if (jsonValue === undefined) {\n        throw Error(\"JSON expected key \".concat(jsonKey, \" is undefined\"));\n      }\n      value[fieldName] = fieldType.fromJson(jsonValue);\n    }\n    return value;\n  }\n  toJson(value) {\n    const json = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      json[jsonKey] = fieldType.toJson(value[fieldName]);\n    }\n    return json;\n  }\n  clone(value) {\n    const newValue = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      newValue[fieldName] = fieldType.clone(value[fieldName]);\n    }\n    return newValue;\n  }\n  equals(a, b) {\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      if (!fieldType.equals(a[fieldName], b[fieldName])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.\n   * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].\n   * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen\n   * - For variable size fields does a first pass over the fixed section to read offsets\n   */\n  getFieldRanges(data, start, end) {\n    if (this.variableOffsetsPosition.length === 0) {\n      // Validate fixed length container\n      const size = end - start;\n      if (size !== this.fixedEnd) {\n        throw Error(\"\".concat(this.typeName, \" size \").concat(size, \" not equal fixed size \").concat(this.fixedEnd));\n      }\n      return this.fieldRangesFixedLen;\n    }\n    // Read offsets in one pass\n    const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);\n    offsets.push(end - start); // The offsets are relative to the start\n    // Merge fieldRangesFixedLen + offsets in one array\n    let variableIdx = 0;\n    let fixedIdx = 0;\n    const fieldRanges = new Array(this.isFixedLen.length);\n    for (let i = 0; i < this.isFixedLen.length; i++) {\n      if (this.isFixedLen[i]) {\n        // push from fixLen ranges ++\n        fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];\n      } else {\n        // push from varLen ranges ++\n        fieldRanges[i] = {\n          start: offsets[variableIdx],\n          end: offsets[variableIdx + 1]\n        };\n        variableIdx++;\n      }\n    }\n    return fieldRanges;\n  }\n}\nexports.ContainerType = ContainerType;\n/**\n * Returns the byte ranges of all variable size fields.\n */\nfunction readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {\n  // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n  // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes\n  // Note: `fixedSizes[i] = null` if that field has variable length\n  const size = end - start;\n  // with the fixed sizes, we can read the offsets, and store for our single pass\n  const offsets = new Array(variableOffsetsPosition.length);\n  for (let i = 0; i < variableOffsetsPosition.length; i++) {\n    const offset = data.getUint32(start + variableOffsetsPosition[i], true);\n    // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size\n    if (offset > size) {\n      throw new Error(\"Offset out of bounds \".concat(offset, \" > \").concat(size));\n    }\n    if (i === 0) {\n      if (offset !== fixedEnd) {\n        throw new Error(\"First offset must equal to fixedEnd \".concat(offset, \" != \").concat(fixedEnd));\n      }\n    } else {\n      if (offset < offsets[i - 1]) {\n        throw new Error(\"Offsets must be increasing \".concat(offset, \" < \").concat(offsets[i - 1]));\n      }\n    }\n    offsets[i] = offset;\n  }\n  return offsets;\n}\n/**\n * Precompute fixed and variable offsets position for faster deserialization.\n * @returns Does a single pass over all fields and returns:\n * - isFixedLen: If field index [i] is fixed length\n * - fieldRangesFixedLen: For fields with fixed length, their range of bytes\n * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields\n * - fixedEnd: End of the fixed size range\n * -\n */\nfunction precomputeSerdesData(fields) {\n  const isFixedLen = [];\n  const fieldRangesFixedLen = [];\n  const variableOffsetsPosition = [];\n  let pointerFixed = 0;\n  for (const fieldType of Object.values(fields)) {\n    isFixedLen.push(fieldType.fixedSize !== null);\n    if (fieldType.fixedSize === null) {\n      // Variable length\n      variableOffsetsPosition.push(pointerFixed);\n      pointerFixed += 4;\n    } else {\n      fieldRangesFixedLen.push({\n        start: pointerFixed,\n        end: pointerFixed + fieldType.fixedSize\n      });\n      pointerFixed += fieldType.fixedSize;\n    }\n  }\n  return {\n    isFixedLen,\n    fieldRangesFixedLen,\n    variableOffsetsPosition,\n    fixedEnd: pointerFixed\n  };\n}\n/**\n * Precompute sizes of the Container doing one pass over fields\n */\nfunction precomputeSizes(fields) {\n  let minLen = 0;\n  let maxLen = 0;\n  let fixedSize = 0;\n  for (const fieldType of Object.values(fields)) {\n    minLen += fieldType.minSize;\n    maxLen += fieldType.maxSize;\n    if (fieldType.fixedSize === null) {\n      // +4 for the offset\n      minLen += 4;\n      maxLen += 4;\n      fixedSize = null;\n    } else if (fixedSize !== null) {\n      fixedSize += fieldType.fixedSize;\n    }\n  }\n  return {\n    minLen,\n    maxLen,\n    fixedSize\n  };\n}\n/**\n * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.\n * To transform JSON payloads to a casing that is different from the type's defined use external tooling.\n */\nfunction precomputeJsonKey(fieldName, casingMap, jsonCase) {\n  if (casingMap) {\n    const keyFromCaseMap = casingMap[fieldName];\n    if (keyFromCaseMap === undefined) {\n      throw Error(\"casingMap[\".concat(fieldName, \"] not defined\"));\n    }\n    return keyFromCaseMap;\n  } else if (jsonCase) {\n    if (jsonCase === \"eth2\") {\n      const snake = case_1.default.snake(fieldName);\n      return snake.replace(/(\\d)$/, \"_$1\");\n    } else {\n      return case_1.default[jsonCase](fieldName);\n    }\n  } else {\n    return fieldName;\n  }\n}\nexports.precomputeJsonKey = precomputeJsonKey;\n/**\n * Render field typeNames for a detailed typeName of this Container\n */\nfunction renderContainerTypeName(fields) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Container\";\n  const fieldNames = Object.keys(fields);\n  const fieldTypeNames = fieldNames.map(fieldName => \"\".concat(fieldName, \": \").concat(fields[fieldName].typeName)).join(\", \");\n  return \"\".concat(prefix, \"({\").concat(fieldTypeNames, \"})\");\n}\nexports.renderContainerTypeName = renderContainerTypeName;","map":null,"metadata":{},"sourceType":"script"}