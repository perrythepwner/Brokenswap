{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n'use strict';\n\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar EthersTransactionUtils = require('@ethersproject/transactions');\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n  this.requestManager = options.requestManager;\n  // reference to eth.accounts\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n  this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager;\n  // reference to eth.accounts\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n  if (!this.inputFormatter) {\n    return args;\n  }\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n  return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n    promiseResolved = false,\n    canUnsubscribe = true,\n    timeoutCount = 0,\n    confirmationCount = 0,\n    intervalId = null,\n    lastBlock = null,\n    receiptJSON = '',\n    gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n    isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to,\n    hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n  // add custom send Methods\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Method({\n    name: 'getTransactionByHash',\n    call: 'eth_getTransactionByHash',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionFormatter\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })];\n  // attach methods to this._ethereumCall\n  var _ethereumCall = {};\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  });\n  // fire \"receipt\" and confirmation events and resolve after\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n          }\n        };\n      }\n      // if we have a valid receipt we don't need to send a request\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)\n      // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      })\n      // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (receipt) {\n          if (!receipt || !receipt.blockHash) {\n            throw new Error('Receipt missing or blockHash null');\n          }\n          // apply extra formatters\n          if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n            receipt = method.extraFormatters.receiptFormatter(receipt);\n          }\n          // check if confirmation listener exists\n          if (defer.eventEmitter.listeners('confirmation').length > 0) {\n            var block;\n            // If there was an immediately retrieved receipt, it's already\n            // been confirmed by the direct call to checkConfirmation needed\n            // for parity instant-seal\n            if (existingReceipt === undefined || confirmationCount !== 0) {\n              // Get latest block to emit with confirmation\n              var latestBlock = yield _ethereumCall.getBlockByNumber('latest');\n              var latestBlockHash = latestBlock ? latestBlock.hash : null;\n              if (isPolling) {\n                // Check if actually a new block is existing on polling\n                if (lastBlock) {\n                  block = yield _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                  if (block) {\n                    lastBlock = block;\n                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                  }\n                } else {\n                  block = yield _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                }\n              } else {\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              }\n            }\n            if (isPolling && block || !isPolling) {\n              confirmationCount++;\n            }\n            canUnsubscribe = false;\n            if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n              // add 1 so we account for conf 0\n              sub.unsubscribe();\n              defer.eventEmitter.removeAllListeners();\n            }\n          }\n          return receipt;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }())\n      // CHECK for CONTRACT DEPLOYMENT\n      .then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (receipt) {\n          if (isContractDeployment && !promiseResolved) {\n            if (!receipt.contractAddress) {\n              if (canUnsubscribe) {\n                sub.unsubscribe();\n                promiseResolved = true;\n              }\n              utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              return;\n            }\n            var code;\n            try {\n              code = yield _ethereumCall.getCode(receipt.contractAddress);\n            } catch (err) {\n              // ignore;\n            }\n            if (!code) {\n              return;\n            }\n            // If deployment is status.true and there was a real\n            // bytecode string, assume it was successful.\n            var deploymentSuccess = receipt.status === true && hasBytecode;\n            if (deploymentSuccess || code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt);\n              // if contract, return instance instead of receipt\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              }\n              // need to remove listeners, as they aren't removed automatically when succesfull\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n            }\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n            promiseResolved = true;\n          }\n          return receipt;\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }())\n      // CHECK for normal tx check for receipt only\n      .then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (receipt) {\n          if (!isContractDeployment && !promiseResolved) {\n            if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n              defer.eventEmitter.emit('receipt', receipt);\n              defer.resolve(receipt);\n              // need to remove listeners, as they aren't removed automatically when succesfull\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              receiptJSON = JSON.stringify(receipt, null, 2);\n              if (receipt.status === false || receipt.status === '0x0') {\n                try {\n                  var revertMessage = null;\n                  if (method.handleRevert && (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                    var txReplayOptions = payload.params[0];\n                    // If send was raw, fetch the transaction and reconstitute the\n                    // original params so they can be replayed with `eth_call`\n                    if (method.call === 'eth_sendRawTransaction') {\n                      var rawTransactionHex = payload.params[0];\n                      var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                      txReplayOptions = formatters.inputTransactionFormatter({\n                        data: parsedTx.data,\n                        to: parsedTx.to,\n                        from: parsedTx.from,\n                        gas: parsedTx.gasLimit.toHexString(),\n                        gasPrice: parsedTx.gasPrice.toHexString(),\n                        value: parsedTx.value.toHexString()\n                      });\n                    }\n                    // Get revert reason string with eth_call\n                    revertMessage = yield method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                    if (revertMessage) {\n                      // Only throw a revert error if a revert reason is existing\n                      utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    } else {\n                      throw false; // Throw false and let the try/catch statement handle the error correctly after\n                    }\n                  } else {\n                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                  }\n                } catch (error) {\n                  // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                  utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                }\n              } else {\n                // Throw OOG if status is not existing and provided gas and used gas are equal\n                utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              }\n            }\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n            promiseResolved = true;\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }())\n      // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++;\n        // check to see if we are http polling\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  };\n  // start watching for confirmation depending on the support features of the provider\n  var startWatching = function (existingReceipt) {\n    const startInterval = () => {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    };\n    if (!this.requestManager.provider.on) {\n      startInterval();\n    } else {\n      _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n        if (err || !blockHeader) {\n          // fall back to polling\n          startInterval();\n        } else {\n          checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        }\n      });\n    }\n  }.bind(this);\n  // first check if we already have a confirmed transaction\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null;\n  // is index given\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from];\n    // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from;\n    // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n  return wallet;\n};\nMethod.prototype.buildCall = function () {\n  var method = this,\n    isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction',\n    // || method.call === 'personal_sendTransaction'\n    isCall = method.call === 'eth_call';\n  // actual send function\n  var send = function send() {\n    var defer = promiEvent(!isSendTx),\n      payload = method.toPayload(Array.prototype.slice.call(arguments));\n    // CALLBACK function\n    var sendTxCallback = function sendTxCallback(err, result) {\n      if (method.handleRevert && isCall && method.abiCoder) {\n        var reasonData;\n        // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n        // Geth >= 1.9.15 attaches the reason data to an error object.\n        // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n        if (!err && method.isRevertReasonString(result)) {\n          reasonData = result.substring(10);\n        } else if (err && err.data) {\n          reasonData = err.data.substring(10);\n        }\n        if (reasonData) {\n          var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n          var signature = 'Error(String)';\n          utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n            reason: reason,\n            signature: signature\n          });\n          return;\n        }\n      }\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n      if (result instanceof Error) {\n        err = result;\n      }\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      }\n      // return PROMISE\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        }\n        // return PROMIEVENT\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n        method._confirmTransaction(defer, result, payload);\n      }\n    };\n    // SENDS the SIGNED SIGNATURE\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet;\n        // ETH_SENDTRANSACTION\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts);\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var txOptions = _.omit(tx, 'from');\n            if (method.defaultChain && !txOptions.chain) {\n              txOptions.chain = method.defaultChain;\n            }\n            if (method.defaultHardfork && !txOptions.hardfork) {\n              txOptions.hardfork = method.defaultHardfork;\n            }\n            if (method.defaultCommon && !txOptions.common) {\n              txOptions.common = method.defaultCommon;\n            }\n            method.accounts.signTransaction(txOptions, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                try {\n                  defer.eventEmitter.emit('error', err);\n                } catch (err) {\n                  // Ignore userland error prevent it to bubble up within web3.\n                }\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n              defer.reject(err);\n            });\n            return;\n          }\n          // ETH_SIGN\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts);\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n      return method.requestManager.send(payload, sendTxCallback);\n    };\n    // Send the actual transaction\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n        if (isSendTx) {\n          setTimeout(() => {\n            defer.eventEmitter.emit('sending', payload);\n          }, 0);\n        }\n        sendRequest(payload, method);\n      });\n    } else {\n      if (isSendTx) {\n        setTimeout(() => {\n          defer.eventEmitter.emit('sending', payload);\n        }, 0);\n      }\n      sendRequest(payload, method);\n    }\n    if (isSendTx) {\n      setTimeout(() => {\n        defer.eventEmitter.emit('sent', payload);\n      }, 0);\n    }\n    return defer.eventEmitter;\n  };\n  // necessary to attach things to the method\n  send.method = method;\n  // necessary for batch requests\n  send.request = this.request.bind(this);\n  return send;\n};\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    new Method({\n      name: 'call',\n      call: 'eth_call',\n      params: 2,\n      abiCoder: self.abiCoder,\n      handleRevert: true\n    }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function () {\n      resolve(false);\n    }).catch(function (error) {\n      if (error.reason) {\n        resolve({\n          reason: error.reason,\n          signature: error.signature\n        });\n      } else {\n        reject(error);\n      }\n    });\n  });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n  return _.isString(data) && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\nmodule.exports = Method;","map":null,"metadata":{},"sourceType":"script"}