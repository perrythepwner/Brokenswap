{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayCompositeTreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayCompositeTreeView extends abstract_1.TreeView {\n  constructor(type, tree) {\n    super();\n    this.type = type;\n    this.tree = tree;\n  }\n  /**\n   * Number of elements in the array. Equal to the Uint32 value of the Tree's length node\n   */\n  get length() {\n    return this.type.tree_getLength(this.tree.rootNode);\n  }\n  /**\n   * Returns the View's Tree rootNode\n   */\n  get node() {\n    return this.tree.rootNode;\n  }\n  /**\n   * Get element at `index`. Returns a view of the Composite element type\n   */\n  get(index) {\n    // TODO: Optimize without bitstring\n    const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);\n    const subtree = this.tree.getSubtree(gindex);\n    return this.type.elementType.getView(subtree);\n  }\n  /**\n   * Get element at `index`. Returns a view of the Composite element type.\n   * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.\n   */\n  getReadonly(index) {\n    // TODO: Optimize without bitstring\n    const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);\n    // tree.getSubtree but without the hook\n    const subtree = new persistent_merkle_tree_1.Tree(this.tree.getNode(gindex));\n    return this.type.elementType.getView(subtree);\n  }\n  /**\n   * Set Composite element type `view` at `index`\n   */\n  set(index, view) {\n    const length = this.length;\n    if (index >= length) {\n      throw Error(\"Error setting index over length \".concat(index, \" > \").concat(length));\n    }\n    const node = this.type.elementType.commitView(view);\n    this.tree.setNodeAtDepth(this.type.depth, index, node);\n  }\n  /**\n   * Returns an array of views of all elements in the array, from index zero to `this.length - 1`.\n   * The returned views don't have a parent hook to this View's Tree, so changes in the returned views won't be\n   * propagated upwards. To get linked element Views use `this.get()`\n   */\n  getAllReadonly() {\n    const length = this.length;\n    const chunksNode = this.type.tree_getChunksNode(this.node);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);\n    const views = new Array(length);\n    for (let i = 0; i < length; i++) {\n      // TODO: Optimize\n      views[i] = this.type.elementType.getView(new persistent_merkle_tree_1.Tree(nodes[i]));\n    }\n    return views;\n  }\n  /**\n   * Returns an array of values of all elements in the array, from index zero to `this.length - 1`.\n   * The returned values are not Views so any changes won't be propagated upwards.\n   * To get linked element Views use `this.get()`\n   */\n  getAllReadonlyValues() {\n    const length = this.length;\n    const chunksNode = this.type.tree_getChunksNode(this.node);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      values[i] = this.type.elementType.tree_toValue(nodes[i]);\n    }\n    return values;\n  }\n}\nexports.ArrayCompositeTreeView = ArrayCompositeTreeView;","map":null,"metadata":{},"sourceType":"script"}