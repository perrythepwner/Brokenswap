{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n */\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport {\n  constructor() {\n    var _this = this;\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n    this.send = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (cla, ins, p1, p2) {\n        let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Buffer.alloc(0);\n        let statusList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [StatusCodes.OK];\n        if (data.length >= 256) {\n          throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n        }\n        const response = yield _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n        const sw = response.readUInt16BE(response.length - 2);\n        if (!statusList.some(s => s === sw)) {\n          throw new TransportStatusError(sw);\n        }\n        return response;\n      });\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this.exchangeBusyPromise = void 0;\n    this.exchangeAtomicImpl = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (f) {\n        if (_this.exchangeBusyPromise) {\n          throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n        }\n        let resolveBusy;\n        const busyPromise = new Promise(r => {\n          resolveBusy = r;\n        });\n        _this.exchangeBusyPromise = busyPromise;\n        let unresponsiveReached = false;\n        const timeout = setTimeout(() => {\n          unresponsiveReached = true;\n          _this.emit(\"unresponsive\");\n        }, _this.unresponsiveTimeout);\n        try {\n          const res = yield f();\n          if (unresponsiveReached) {\n            _this.emit(\"responsive\");\n          }\n          return res;\n        } finally {\n          clearTimeout(timeout);\n          if (resolveBusy) resolveBusy();\n          _this.exchangeBusyPromise = null;\n        }\n      });\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    this._appAPIlock = null;\n  }\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n\n  setScrambleKey(_key) {}\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n\n  close() {\n    return Promise.resolve();\n  }\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create() {\n    let openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n    let listenTimeout = arguments.length > 1 ? arguments[1] : undefined;\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    var _this2 = this;\n    return /*#__PURE__*/_asyncToGenerator(function* () {\n      const {\n        _appAPIlock\n      } = _this2;\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n      try {\n        _this2._appAPIlock = methodName;\n        _this2.setScrambleKey(scrambleKey);\n        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return yield f.apply(ctx, args);\n      } finally {\n        _this2._appAPIlock = null;\n      }\n    });\n  }\n}\nTransport.isSupported = void 0;\nTransport.list = void 0;\nTransport.listen = void 0;\nTransport.open = void 0;\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";","map":null,"metadata":{},"sourceType":"module"}