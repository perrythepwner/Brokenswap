{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;\nconst as_sha256_1 = require(\"@chainsafe/as-sha256\");\nconst zeros_1 = require(\"./zeros\");\nfunction hash64(bytes32A, bytes32B) {\n  return as_sha256_1.digest2Bytes32(bytes32A, bytes32B);\n}\nexports.hash64 = hash64;\nfunction merkleize(chunks, padFor) {\n  const layerCount = bitLength(nextPowerOf2(padFor) - 1);\n  if (chunks.length == 0) {\n    return zeros_1.zeroHash(layerCount);\n  }\n  let chunkCount = chunks.length;\n  // Instead of pushing on all padding zero chunks at the leaf level\n  // we push on zero hash chunks at the highest possible level to avoid over-hashing\n  for (let l = 0; l < layerCount; l++) {\n    const padCount = chunkCount % 2;\n    const paddedChunkCount = chunkCount + padCount;\n    // if the chunks.length is odd\n    // we need to push on the zero-hash of that level to merkleize that level\n    for (let i = 0; i < padCount; i++) {\n      chunks[chunkCount + i] = zeros_1.zeroHash(l);\n    }\n    for (let i = 0; i < paddedChunkCount; i += 2) {\n      chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);\n    }\n    chunkCount = paddedChunkCount / 2;\n  }\n  return chunks[0];\n}\nexports.merkleize = merkleize;\n/**\n * Split a long Uint8Array into Uint8Array of exactly 32 bytes\n */\nfunction splitIntoRootChunks(longChunk) {\n  const chunkCount = Math.ceil(longChunk.length / 32);\n  const chunks = new Array(chunkCount);\n  for (let i = 0; i < chunkCount; i++) {\n    const chunk = new Uint8Array(32);\n    chunk.set(longChunk.slice(i * 32, (i + 1) * 32));\n    chunks[i] = chunk;\n  }\n  return chunks;\n}\nexports.splitIntoRootChunks = splitIntoRootChunks;\n/** @ignore */\nfunction mixInLength(root, length) {\n  const lengthBuf = Buffer.alloc(32);\n  lengthBuf.writeUIntLE(length, 0, 6);\n  return hash64(root, lengthBuf);\n}\nexports.mixInLength = mixInLength;\n// x2 faster than bitLengthStr() which uses Number.toString(2)\nfunction bitLength(i) {\n  if (i === 0) {\n    return 0;\n  }\n  return Math.floor(Math.log2(i)) + 1;\n}\nexports.bitLength = bitLength;\n/**\n * Given maxChunkCount return the chunkDepth\n * ```\n * n: [0,1,2,3,4,5,6,7,8,9]\n * d: [0,0,1,2,2,3,3,3,3,4]\n * ```\n */\nfunction maxChunksToDepth(n) {\n  if (n === 0) return 0;\n  return Math.ceil(Math.log2(n));\n}\nexports.maxChunksToDepth = maxChunksToDepth;\n/** @ignore */\nfunction nextPowerOf2(n) {\n  return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\nexports.nextPowerOf2 = nextPowerOf2;","map":null,"metadata":{},"sourceType":"script"}