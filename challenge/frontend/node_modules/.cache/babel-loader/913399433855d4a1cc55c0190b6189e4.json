{"ast":null,"code":"import _asyncToGenerator from \"/app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport Yt, { EventEmitter as N } from \"events\";\nimport Gt from \"@walletconnect/keyvaluestorage\";\nimport { HEARTBEAT_EVENTS as Y, HeartBeat as Ht } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger as f, getLoggerContext as E, pino as ye, getDefaultLoggerOptions as me } from \"@walletconnect/logger\";\nimport { IMessageTracker as Jt, IPublisher as Wt, ISubscriber as Xt, IRelayer as Qt, IStore as Zt, IJsonRpcHistory as ei, IExpirer as ti, IVerify as ii, ICore as si } from \"@walletconnect/types\";\nimport { safeJsonStringify as ri, safeJsonParse as ni } from \"@walletconnect/safe-json\";\nimport * as G from \"@walletconnect/relay-auth\";\nimport { getInternalError as l, mapToObj as be, objToMap as fe, generateKeyPair as ai, generateRandomBytes32 as ie, deriveSymKey as oi, hashKey as hi, validateEncoding as ci, isTypeOneEnvelope as Ee, encrypt as ui, validateDecoding as li, decrypt as di, deserialize as we, decodeTypeByte as gi, BASE16 as pi, hashMessage as se, getRelayProtocolName as re, createExpiringPromise as k, getRelayProtocolApi as H, isUndefined as ne, getSdkError as K, isValidArray as Di, isOnline as ve, formatRelayRpcUrl as yi, subscribeToNetworkChange as mi, isProposalStruct as bi, isSessionStruct as fi, TYPE_1 as Ei, calcExpiry as J, formatUri as wi, parseUri as vi, createDelayedPromise as Ii, engineEvent as ae, isExpired as Ie, isValidParams as oe, isValidUrl as Ci, isValidString as Ri, parseExpirerTarget as _i, formatTopicTarget as Si, formatIdTarget as Ti, isReactNative as Pi, isBrowser as xi, isNode as Oi } from \"@walletconnect/utils\";\nimport { toString as Ai } from \"uint8arrays\";\nimport { ONE_DAY as U, SIX_HOURS as zi, ONE_SECOND as Ce, THIRTY_DAYS as W, FIVE_SECONDS as Re, THIRTY_SECONDS as _e, toMiliseconds as L, TEN_SECONDS as Ni, Watch as Ui, FIVE_MINUTES as Se } from \"@walletconnect/time\";\nimport { JsonRpcProvider as Li } from \"@walletconnect/jsonrpc-provider\";\nimport { getBigIntRpcId as Fi, isJsonRpcRequest as Te, isJsonRpcResponse as Pe, formatJsonRpcResult as xe, formatJsonRpcRequest as Oe, formatJsonRpcError as $i, isJsonRpcResult as Mi, isJsonRpcError as Ae } from \"@walletconnect/jsonrpc-utils\";\nimport ki from \"@walletconnect/jsonrpc-ws-connection\";\nimport Ki from \"lodash.isequal\";\nfunction Bi(r, e) {\n  if (r.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n  for (var s = 0; s < r.length; s++) {\n    var n = r.charAt(s),\n      a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = s;\n  }\n  var o = r.length,\n    h = r.charAt(0),\n    u = Math.log(o) / Math.log(256),\n    d = Math.log(256) / Math.log(o);\n  function p(c) {\n    if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (c.length === 0) return \"\";\n    for (var m = 0, z = 0, I = 0, _ = c.length; I !== _ && c[I] === 0;) I++, m++;\n    for (var S = (_ - I) * d + 1 >>> 0, b = new Uint8Array(S); I !== _;) {\n      for (var T = c[I], A = 0, C = S - 1; (T !== 0 || A < z) && C !== -1; C--, A++) T += 256 * b[C] >>> 0, b[C] = T % o >>> 0, T = T / o >>> 0;\n      if (T !== 0) throw new Error(\"Non-zero carry\");\n      z = A, I++;\n    }\n    for (var x = S - z; x !== S && b[x] === 0;) x++;\n    for (var j = h.repeat(m); x < S; ++x) j += r.charAt(b[x]);\n    return j;\n  }\n  function y(c) {\n    if (typeof c != \"string\") throw new TypeError(\"Expected String\");\n    if (c.length === 0) return new Uint8Array();\n    var m = 0;\n    if (c[m] !== \" \") {\n      for (var z = 0, I = 0; c[m] === h;) z++, m++;\n      for (var _ = (c.length - m) * u + 1 >>> 0, S = new Uint8Array(_); c[m];) {\n        var b = t[c.charCodeAt(m)];\n        if (b === 255) return;\n        for (var T = 0, A = _ - 1; (b !== 0 || T < I) && A !== -1; A--, T++) b += o * S[A] >>> 0, S[A] = b % 256 >>> 0, b = b / 256 >>> 0;\n        if (b !== 0) throw new Error(\"Non-zero carry\");\n        I = T, m++;\n      }\n      if (c[m] !== \" \") {\n        for (var C = _ - I; C !== _ && S[C] === 0;) C++;\n        for (var x = new Uint8Array(z + (_ - C)), j = z; C !== _;) x[j++] = S[C++];\n        return x;\n      }\n    }\n  }\n  function M(c) {\n    var m = y(c);\n    if (m) return m;\n    throw new Error(\"Non-\".concat(e, \" character\"));\n  }\n  return {\n    encode: p,\n    decodeUnsafe: y,\n    decode: M\n  };\n}\nvar Vi = Bi,\n  qi = Vi;\nconst ze = r => {\n    if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\") return r;\n    if (r instanceof ArrayBuffer) return new Uint8Array(r);\n    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  ji = r => new TextEncoder().encode(r),\n  Yi = r => new TextDecoder().decode(r);\nclass Gi {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return \"\".concat(this.prefix).concat(this.baseEncode(e));\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Hi {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(\"Unable to decode multibase string \".concat(JSON.stringify(e), \", \").concat(this.name, \" decoder only supports inputs prefixed with \").concat(this.prefix));\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Ne(this, e);\n  }\n}\nclass Ji {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Ne(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(\"Unable to decode multibase string \".concat(JSON.stringify(e), \", only inputs prefixed with \").concat(Object.keys(this.decoders), \" are supported\"));\n  }\n}\nconst Ne = (r, e) => new Ji(_objectSpread(_objectSpread({}, r.decoders || {\n  [r.prefix]: r\n}), e.decoders || {\n  [e.prefix]: e\n}));\nclass Wi {\n  constructor(e, t, i, s) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = s, this.encoder = new Gi(e, t, i), this.decoder = new Hi(e, t, s);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst X = _ref => {\n    let {\n      name: r,\n      prefix: e,\n      encode: t,\n      decode: i\n    } = _ref;\n    return new Wi(r, e, t, i);\n  },\n  B = _ref2 => {\n    let {\n      prefix: r,\n      name: e,\n      alphabet: t\n    } = _ref2;\n    const {\n      encode: i,\n      decode: s\n    } = qi(t, e);\n    return X({\n      prefix: r,\n      name: e,\n      encode: i,\n      decode: n => ze(s(n))\n    });\n  },\n  Xi = (r, e, t, i) => {\n    const s = {};\n    for (let d = 0; d < e.length; ++d) s[e[d]] = d;\n    let n = r.length;\n    for (; r[n - 1] === \"=\";) --n;\n    const a = new Uint8Array(n * t / 8 | 0);\n    let o = 0,\n      h = 0,\n      u = 0;\n    for (let d = 0; d < n; ++d) {\n      const p = s[r[d]];\n      if (p === void 0) throw new SyntaxError(\"Non-\".concat(i, \" character\"));\n      h = h << t | p, o += t, o >= 8 && (o -= 8, a[u++] = 255 & h >> o);\n    }\n    if (o >= t || 255 & h << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  Qi = (r, e, t) => {\n    const i = e[e.length - 1] === \"=\",\n      s = (1 << t) - 1;\n    let n = \"\",\n      a = 0,\n      o = 0;\n    for (let h = 0; h < r.length; ++h) for (o = o << 8 | r[h], a += 8; a > t;) a -= t, n += e[s & o >> a];\n    if (a && (n += e[s & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n    return n;\n  },\n  g = _ref3 => {\n    let {\n      name: r,\n      prefix: e,\n      bitsPerChar: t,\n      alphabet: i\n    } = _ref3;\n    return X({\n      prefix: e,\n      name: r,\n      encode(s) {\n        return Qi(s, i, t);\n      },\n      decode(s) {\n        return Xi(s, i, t, r);\n      }\n    });\n  },\n  Zi = X({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: r => Yi(r),\n    decode: r => ji(r)\n  });\nvar es = Object.freeze({\n  __proto__: null,\n  identity: Zi\n});\nconst ts = g({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar is = Object.freeze({\n  __proto__: null,\n  base2: ts\n});\nconst ss = g({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar rs = Object.freeze({\n  __proto__: null,\n  base8: ss\n});\nconst ns = B({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar as = Object.freeze({\n  __proto__: null,\n  base10: ns\n});\nconst os = g({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  hs = g({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar cs = Object.freeze({\n  __proto__: null,\n  base16: os,\n  base16upper: hs\n});\nconst us = g({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  ls = g({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  ds = g({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  gs = g({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  ps = g({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  Ds = g({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  ys = g({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  ms = g({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  bs = g({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar fs = Object.freeze({\n  __proto__: null,\n  base32: us,\n  base32upper: ls,\n  base32pad: ds,\n  base32padupper: gs,\n  base32hex: ps,\n  base32hexupper: Ds,\n  base32hexpad: ys,\n  base32hexpadupper: ms,\n  base32z: bs\n});\nconst Es = B({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  ws = B({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar vs = Object.freeze({\n  __proto__: null,\n  base36: Es,\n  base36upper: ws\n});\nconst Is = B({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Cs = B({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar Rs = Object.freeze({\n  __proto__: null,\n  base58btc: Is,\n  base58flickr: Cs\n});\nconst _s = g({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  Ss = g({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  Ts = g({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  Ps = g({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar xs = Object.freeze({\n  __proto__: null,\n  base64: _s,\n  base64pad: Ss,\n  base64url: Ts,\n  base64urlpad: Ps\n});\nconst Ue = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  Os = Ue.reduce((r, e, t) => (r[t] = e, r), []),\n  As = Ue.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction zs(r) {\n  return r.reduce((e, t) => (e += Os[t], e), \"\");\n}\nfunction Ns(r) {\n  const e = [];\n  for (const t of r) {\n    const i = As[t.codePointAt(0)];\n    if (i === void 0) throw new Error(\"Non-base256emoji character: \".concat(t));\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst Us = X({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: zs,\n  decode: Ns\n});\nvar Ls = Object.freeze({\n    __proto__: null,\n    base256emoji: Us\n  }),\n  Fs = Fe,\n  Le = 128,\n  $s = 127,\n  Ms = ~$s,\n  ks = Math.pow(2, 31);\nfunction Fe(r, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; r >= ks;) e[t++] = r & 255 | Le, r /= 128;\n  for (; r & Ms;) e[t++] = r & 255 | Le, r >>>= 7;\n  return e[t] = r | 0, Fe.bytes = t - i + 1, e;\n}\nvar Ks = he,\n  Bs = 128,\n  $e = 127;\nfunction he(r, i) {\n  var t = 0,\n    i = i || 0,\n    s = 0,\n    n = i,\n    a,\n    o = r.length;\n  do {\n    if (n >= o) throw he.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = r[n++], t += s < 28 ? (a & $e) << s : (a & $e) * Math.pow(2, s), s += 7;\n  } while (a >= Bs);\n  return he.bytes = n - i, t;\n}\nvar Vs = Math.pow(2, 7),\n  qs = Math.pow(2, 14),\n  js = Math.pow(2, 21),\n  Ys = Math.pow(2, 28),\n  Gs = Math.pow(2, 35),\n  Hs = Math.pow(2, 42),\n  Js = Math.pow(2, 49),\n  Ws = Math.pow(2, 56),\n  Xs = Math.pow(2, 63),\n  Qs = function Qs(r) {\n    return r < Vs ? 1 : r < qs ? 2 : r < js ? 3 : r < Ys ? 4 : r < Gs ? 5 : r < Hs ? 6 : r < Js ? 7 : r < Ws ? 8 : r < Xs ? 9 : 10;\n  },\n  Zs = {\n    encode: Fs,\n    decode: Ks,\n    encodingLength: Qs\n  },\n  Me = Zs;\nconst ke = function ke(r, e) {\n    let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    return Me.encode(r, e, t), e;\n  },\n  Ke = r => Me.encodingLength(r),\n  ce = (r, e) => {\n    const t = e.byteLength,\n      i = Ke(r),\n      s = i + Ke(t),\n      n = new Uint8Array(s + t);\n    return ke(r, n, 0), ke(t, n, i), n.set(e, s), new er(r, t, e, n);\n  };\nclass er {\n  constructor(e, t, i, s) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = s;\n  }\n}\nconst Be = _ref4 => {\n  let {\n    name: r,\n    code: e,\n    encode: t\n  } = _ref4;\n  return new tr(r, e, t);\n};\nclass tr {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? ce(this.code, t) : t.then(i => ce(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ve = r => /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator(function* (e) {\n      return new Uint8Array(yield crypto.subtle.digest(r, e));\n    });\n    return function (_x) {\n      return _ref5.apply(this, arguments);\n    };\n  }(),\n  ir = Be({\n    name: \"sha2-256\",\n    code: 18,\n    encode: Ve(\"SHA-256\")\n  }),\n  sr = Be({\n    name: \"sha2-512\",\n    code: 19,\n    encode: Ve(\"SHA-512\")\n  });\nvar rr = Object.freeze({\n  __proto__: null,\n  sha256: ir,\n  sha512: sr\n});\nconst qe = 0,\n  nr = \"identity\",\n  je = ze,\n  ar = r => ce(qe, je(r)),\n  or = {\n    code: qe,\n    name: nr,\n    encode: je,\n    digest: ar\n  };\nvar hr = Object.freeze({\n  __proto__: null,\n  identity: or\n});\nnew TextEncoder(), new TextDecoder();\nconst Ye = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, es), is), rs), as), cs), fs), vs), Rs), xs), Ls);\n_objectSpread(_objectSpread({}, rr), hr);\nfunction Ge(r) {\n  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;\n}\nfunction cr() {\n  let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);\n}\nfunction He(r, e, t, i) {\n  return {\n    name: r,\n    prefix: e,\n    encoder: {\n      name: r,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Je = He(\"utf8\", \"u\", r => \"u\" + new TextDecoder(\"utf8\").decode(r), r => new TextEncoder().encode(r.substring(1))),\n  ue = He(\"ascii\", \"a\", r => {\n    let e = \"a\";\n    for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);\n    return e;\n  }, r => {\n    r = r.substring(1);\n    const e = cr(r.length);\n    for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);\n    return e;\n  }),\n  ur = _objectSpread({\n    utf8: Je,\n    \"utf-8\": Je,\n    hex: Ye.base16,\n    latin1: ue,\n    ascii: ue,\n    binary: ue\n  }, Ye);\nfunction lr(r) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n  const t = ur[e];\n  if (!t) throw new Error(\"Unsupported encoding \\\"\".concat(e, \"\\\"\"));\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge(globalThis.Buffer.from(r, \"utf-8\")) : t.decoder.decode(\"\".concat(t.prefix).concat(r));\n}\nconst le = \"wc\",\n  We = 2,\n  Q = \"core\",\n  O = \"\".concat(le, \"@2:\").concat(Q, \":\"),\n  Xe = {\n    name: Q,\n    logger: \"error\"\n  },\n  Qe = {\n    database: \":memory:\"\n  },\n  Ze = \"crypto\",\n  de = \"client_ed25519_seed\",\n  et = U,\n  tt = \"keychain\",\n  it = \"0.3\",\n  st = \"messages\",\n  rt = \"0.3\",\n  nt = zi,\n  at = \"publisher\",\n  ot = \"irn\",\n  ht = \"error\",\n  ge = \"wss://relay.walletconnect.com\",\n  pe = \"wss://relay.walletconnect.org\",\n  ct = \"relayer\",\n  D = {\n    message: \"relayer_message\",\n    message_ack: \"relayer_message_ack\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  ut = \"_subscription\",\n  P = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  lt = Ce,\n  dr = {\n    database: \":memory:\"\n  },\n  dt = \"2.10.4\",\n  gt = 1e4,\n  pt = \"0.3\",\n  Dt = \"WALLETCONNECT_CLIENT_ID\",\n  w = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  gr = W,\n  yt = \"subscription\",\n  mt = \"0.3\",\n  bt = Re * 1e3,\n  ft = \"pairing\",\n  Et = \"0.3\",\n  pr = W,\n  F = {\n    wc_pairingDelete: {\n      req: {\n        ttl: U,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: U,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: _e,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: _e,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: U,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: U,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  V = {\n    create: \"pairing_create\",\n    expire: \"pairing_expire\",\n    delete: \"pairing_delete\",\n    ping: \"pairing_ping\"\n  },\n  R = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  wt = \"history\",\n  vt = \"0.3\",\n  It = \"expirer\",\n  v = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  Ct = \"0.3\",\n  Dr = U,\n  Z = \"verify-api\",\n  $ = \"https://verify.walletconnect.com\",\n  ee = \"https://verify.walletconnect.org\",\n  Rt = [$, ee];\nclass _t {\n  constructor(e, t) {\n    var _this = this;\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = tt, this.version = it, this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      if (!_this.initialized) {\n        const i = yield _this.getKeyChain();\n        typeof i < \"u\" && (_this.keychain = i), _this.initialized = !0;\n      }\n    }), this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator(function* (i, s) {\n        _this.isInitialized(), _this.keychain.set(i, s), yield _this.persist();\n      });\n      return function (_x2, _x3) {\n        return _ref7.apply(this, arguments);\n      };\n    }(), this.get = i => {\n      this.isInitialized();\n      const s = this.keychain.get(i);\n      if (typeof s > \"u\") {\n        const {\n          message: n\n        } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(i));\n        throw new Error(n);\n      }\n      return s;\n    }, this.del = /*#__PURE__*/function () {\n      var _ref8 = _asyncToGenerator(function* (i) {\n        _this.isInitialized(), _this.keychain.delete(i), yield _this.persist();\n      });\n      return function (_x4) {\n        return _ref8.apply(this, arguments);\n      };\n    }(), this.core = e, this.logger = f(t, this.name);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  setKeyChain(e) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.core.storage.setItem(_this2.storageKey, be(e));\n    })();\n  }\n  getKeyChain() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const e = yield _this3.core.storage.getItem(_this3.storageKey);\n      return typeof e < \"u\" ? fe(e) : void 0;\n    })();\n  }\n  persist() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.setKeyChain(_this4.keychain);\n    })();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass St {\n  constructor(e, t, i) {\n    var _this5 = this;\n    this.core = e, this.logger = t, this.name = Ze, this.initialized = !1, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this5.initialized || (yield _this5.keychain.init(), _this5.initialized = !0);\n    }), this.hasKeys = s => (this.isInitialized(), this.keychain.has(s)), this.getClientId = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this5.isInitialized();\n      const s = yield _this5.getClientSeed(),\n        n = G.generateKeyPair(s);\n      return G.encodeIss(n.publicKey);\n    }), this.generateKeyPair = () => {\n      this.isInitialized();\n      const s = ai();\n      return this.setPrivateKey(s.publicKey, s.privateKey);\n    }, this.signJWT = /*#__PURE__*/function () {\n      var _ref11 = _asyncToGenerator(function* (s) {\n        _this5.isInitialized();\n        const n = yield _this5.getClientSeed(),\n          a = G.generateKeyPair(n),\n          o = ie(),\n          h = et;\n        return yield G.signJWT(o, s, h, a);\n      });\n      return function (_x5) {\n        return _ref11.apply(this, arguments);\n      };\n    }(), this.generateSharedKey = (s, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(s),\n        h = oi(o, n);\n      return this.setSymKey(h, a);\n    }, this.setSymKey = /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator(function* (s, n) {\n        _this5.isInitialized();\n        const a = n || hi(s);\n        return yield _this5.keychain.set(a, s), a;\n      });\n      return function (_x6, _x7) {\n        return _ref12.apply(this, arguments);\n      };\n    }(), this.deleteKeyPair = /*#__PURE__*/function () {\n      var _ref13 = _asyncToGenerator(function* (s) {\n        _this5.isInitialized(), yield _this5.keychain.del(s);\n      });\n      return function (_x8) {\n        return _ref13.apply(this, arguments);\n      };\n    }(), this.deleteSymKey = /*#__PURE__*/function () {\n      var _ref14 = _asyncToGenerator(function* (s) {\n        _this5.isInitialized(), yield _this5.keychain.del(s);\n      });\n      return function (_x9) {\n        return _ref14.apply(this, arguments);\n      };\n    }(), this.encode = /*#__PURE__*/function () {\n      var _ref15 = _asyncToGenerator(function* (s, n, a) {\n        _this5.isInitialized();\n        const o = ci(a),\n          h = ri(n);\n        if (Ee(o)) {\n          const y = o.senderPublicKey,\n            M = o.receiverPublicKey;\n          s = yield _this5.generateSharedKey(y, M);\n        }\n        const u = _this5.getSymKey(s),\n          {\n            type: d,\n            senderPublicKey: p\n          } = o;\n        return ui({\n          type: d,\n          symKey: u,\n          message: h,\n          senderPublicKey: p\n        });\n      });\n      return function (_x10, _x11, _x12) {\n        return _ref15.apply(this, arguments);\n      };\n    }(), this.decode = /*#__PURE__*/function () {\n      var _ref16 = _asyncToGenerator(function* (s, n, a) {\n        _this5.isInitialized();\n        const o = li(n, a);\n        if (Ee(o)) {\n          const h = o.receiverPublicKey,\n            u = o.senderPublicKey;\n          s = yield _this5.generateSharedKey(h, u);\n        }\n        try {\n          const h = _this5.getSymKey(s),\n            u = di({\n              symKey: h,\n              encoded: n\n            });\n          return ni(u);\n        } catch (h) {\n          _this5.logger.error(\"Failed to decode message from topic: '\".concat(s, \"', clientId: '\").concat(yield _this5.getClientId(), \"'\")), _this5.logger.error(h);\n        }\n      });\n      return function (_x13, _x14, _x15) {\n        return _ref16.apply(this, arguments);\n      };\n    }(), this.getPayloadType = s => {\n      const n = we(s);\n      return gi(n.type);\n    }, this.getPayloadSenderPublicKey = s => {\n      const n = we(s);\n      return n.senderPublicKey ? Ai(n.senderPublicKey, pi) : void 0;\n    }, this.core = e, this.logger = f(t, this.name), this.keychain = i || new _t(this.core, this.logger);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  setPrivateKey(e, t) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this6.keychain.set(e, t), e;\n    })();\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  getClientSeed() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      let e = \"\";\n      try {\n        e = _this7.keychain.get(de);\n      } catch (_unused) {\n        e = ie(), yield _this7.keychain.set(de, e);\n      }\n      return lr(e, \"base16\");\n    })();\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Tt extends Jt {\n  constructor(e, t) {\n    var _this8;\n    (super(e, t), _this8 = this), this.logger = e, this.core = t, this.messages = new Map(), this.name = st, this.version = rt, this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      if (!_this8.initialized) {\n        _this8.logger.trace(\"Initialized\");\n        try {\n          const i = yield _this8.getRelayerMessages();\n          typeof i < \"u\" && (_this8.messages = i), _this8.logger.debug(\"Successfully Restored records for \".concat(_this8.name)), _this8.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: _this8.messages.size\n          });\n        } catch (i) {\n          _this8.logger.debug(\"Failed to Restore records for \".concat(_this8.name)), _this8.logger.error(i);\n        } finally {\n          _this8.initialized = !0;\n        }\n      }\n    }), this.set = /*#__PURE__*/function () {\n      var _ref18 = _asyncToGenerator(function* (i, s) {\n        _this8.isInitialized();\n        const n = se(s);\n        let a = _this8.messages.get(i);\n        return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = s, _this8.messages.set(i, a), yield _this8.persist()), n;\n      });\n      return function (_x16, _x17) {\n        return _ref18.apply(this, arguments);\n      };\n    }(), this.get = i => {\n      this.isInitialized();\n      let s = this.messages.get(i);\n      return typeof s > \"u\" && (s = {}), s;\n    }, this.has = (i, s) => {\n      this.isInitialized();\n      const n = this.get(i),\n        a = se(s);\n      return typeof n[a] < \"u\";\n    }, this.del = /*#__PURE__*/function () {\n      var _ref19 = _asyncToGenerator(function* (i) {\n        _this8.isInitialized(), _this8.messages.delete(i), yield _this8.persist();\n      });\n      return function (_x18) {\n        return _ref19.apply(this, arguments);\n      };\n    }(), this.logger = f(e, this.name), this.core = t;\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  setRelayerMessages(e) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.core.storage.setItem(_this9.storageKey, be(e));\n    })();\n  }\n  getRelayerMessages() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const e = yield _this10.core.storage.getItem(_this10.storageKey);\n      return typeof e < \"u\" ? fe(e) : void 0;\n    })();\n  }\n  persist() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      yield _this11.setRelayerMessages(_this11.messages);\n    })();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass yr extends Wt {\n  constructor(e, t) {\n    var _this12;\n    (super(e, t), _this12 = this), this.relayer = e, this.logger = t, this.events = new N(), this.name = at, this.queue = new Map(), this.publishTimeout = L(Ni), this.needsTransportRestart = !1, this.publish = /*#__PURE__*/function () {\n      var _ref20 = _asyncToGenerator(function* (i, s, n) {\n        var a;\n        _this12.logger.debug(\"Publishing Payload\"), _this12.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: s,\n            opts: n\n          }\n        });\n        try {\n          const o = (n === null || n === void 0 ? void 0 : n.ttl) || nt,\n            h = re(n),\n            u = (n === null || n === void 0 ? void 0 : n.prompt) || !1,\n            d = (n === null || n === void 0 ? void 0 : n.tag) || 0,\n            p = (n === null || n === void 0 ? void 0 : n.id) || Fi().toString(),\n            y = {\n              topic: i,\n              message: s,\n              opts: {\n                ttl: o,\n                relay: h,\n                prompt: u,\n                tag: d,\n                id: p\n              }\n            },\n            M = setTimeout(() => _this12.queue.set(p, y), _this12.publishTimeout);\n          try {\n            yield yield k(_this12.rpcPublish(i, s, o, h, u, d, p), _this12.publishTimeout, \"Failed to publish payload, please try again.\"), _this12.removeRequestFromQueue(p), _this12.relayer.events.emit(D.publish, y);\n          } catch (c) {\n            if (_this12.logger.debug(\"Publishing Payload stalled\"), _this12.needsTransportRestart = !0, (a = n === null || n === void 0 ? void 0 : n.internal) != null && a.throwOnFailedPublish) throw _this12.removeRequestFromQueue(p), c;\n            return;\n          } finally {\n            clearTimeout(M);\n          }\n          _this12.logger.debug(\"Successfully Published Payload\"), _this12.logger.trace({\n            type: \"method\",\n            method: \"publish\",\n            params: {\n              topic: i,\n              message: s,\n              opts: n\n            }\n          });\n        } catch (o) {\n          throw _this12.logger.debug(\"Failed to Publish Payload\"), _this12.logger.error(o), o;\n        }\n      });\n      return function (_x19, _x20, _x21) {\n        return _ref20.apply(this, arguments);\n      };\n    }(), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.relayer = e, this.logger = f(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return E(this.logger);\n  }\n  rpcPublish(e, t, i, s, n, a, o) {\n    var h, u, d, p;\n    const y = {\n      method: H(s.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      },\n      id: o\n    };\n    return ne((h = y.params) == null ? void 0 : h.prompt) && ((u = y.params) == null || delete u.prompt), ne((d = y.params) == null ? void 0 : d.tag) && ((p = y.params) == null || delete p.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: y\n    }), this.relayer.request(y);\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    var _this13 = this;\n    this.queue.forEach( /*#__PURE__*/function () {\n      var _ref21 = _asyncToGenerator(function* (e) {\n        const {\n          topic: t,\n          message: i,\n          opts: s\n        } = e;\n        yield _this13.publish(t, i, s);\n      });\n      return function (_x22) {\n        return _ref21.apply(this, arguments);\n      };\n    }());\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(Y.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(D.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(D.message_ack, e => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}\nclass mr {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const s = i.filter(n => n !== t);\n      if (!s.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, s);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar br = Object.defineProperty,\n  fr = Object.defineProperties,\n  Er = Object.getOwnPropertyDescriptors,\n  Pt = Object.getOwnPropertySymbols,\n  wr = Object.prototype.hasOwnProperty,\n  vr = Object.prototype.propertyIsEnumerable,\n  xt = (r, e, t) => e in r ? br(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  q = (r, e) => {\n    for (var t in e || (e = {})) wr.call(e, t) && xt(r, t, e[t]);\n    if (Pt) for (var t of Pt(e)) vr.call(e, t) && xt(r, t, e[t]);\n    return r;\n  },\n  De = (r, e) => fr(r, Er(e));\nclass Ot extends Xt {\n  constructor(e, t) {\n    var _this14;\n    (super(e, t), _this14 = this), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new mr(), this.events = new N(), this.name = yt, this.version = mt, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = O, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this14.initialized || (_this14.logger.trace(\"Initialized\"), _this14.registerEventListeners(), _this14.clientId = yield _this14.relayer.core.crypto.getClientId());\n    }), this.subscribe = /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator(function* (i, s) {\n        yield _this14.restartToComplete(), _this14.isInitialized(), _this14.logger.debug(\"Subscribing Topic\"), _this14.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: s\n          }\n        });\n        try {\n          const n = re(s),\n            a = {\n              topic: i,\n              relay: n\n            };\n          _this14.pending.set(i, a);\n          const o = yield _this14.rpcSubscribe(i, n);\n          return _this14.onSubscribe(o, a), _this14.logger.debug(\"Successfully Subscribed Topic\"), _this14.logger.trace({\n            type: \"method\",\n            method: \"subscribe\",\n            params: {\n              topic: i,\n              opts: s\n            }\n          }), o;\n        } catch (n) {\n          throw _this14.logger.debug(\"Failed to Subscribe Topic\"), _this14.logger.error(n), n;\n        }\n      });\n      return function (_x23, _x24) {\n        return _ref23.apply(this, arguments);\n      };\n    }(), this.unsubscribe = /*#__PURE__*/function () {\n      var _ref24 = _asyncToGenerator(function* (i, s) {\n        yield _this14.restartToComplete(), _this14.isInitialized(), typeof (s === null || s === void 0 ? void 0 : s.id) < \"u\" ? yield _this14.unsubscribeById(i, s.id, s) : yield _this14.unsubscribeByTopic(i, s);\n      });\n      return function (_x25, _x26) {\n        return _ref24.apply(this, arguments);\n      };\n    }(), this.isSubscribed = /*#__PURE__*/function () {\n      var _ref25 = _asyncToGenerator(function* (i) {\n        return _this14.topics.includes(i) ? !0 : yield new Promise((s, n) => {\n          const a = new Ui();\n          a.start(_this14.pendingSubscriptionWatchLabel);\n          const o = setInterval(() => {\n            !_this14.pending.has(i) && _this14.topics.includes(i) && (clearInterval(o), a.stop(_this14.pendingSubscriptionWatchLabel), s(!0)), a.elapsed(_this14.pendingSubscriptionWatchLabel) >= bt && (clearInterval(o), a.stop(_this14.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n          }, _this14.pollingInterval);\n        }).catch(() => !1);\n      });\n      return function (_x27) {\n        return _ref25.apply(this, arguments);\n      };\n    }(), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.restart = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this14.restartInProgress = !0, yield _this14.restore(), yield _this14.reset(), _this14.restartInProgress = !1;\n    }), this.relayer = e, this.logger = f(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch (_unused2) {}\n    return i;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  unsubscribeByTopic(e, t) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const i = _this15.topicMap.get(e);\n      yield Promise.all(i.map( /*#__PURE__*/function () {\n        var _ref27 = _asyncToGenerator(function* (s) {\n          return yield _this15.unsubscribeById(e, s, t);\n        });\n        return function (_x28) {\n          return _ref27.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  unsubscribeById(e, t, i) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      _this16.logger.debug(\"Unsubscribing Topic\"), _this16.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n      try {\n        const s = re(i);\n        yield _this16.rpcUnsubscribe(e, t, s);\n        const n = K(\"USER_DISCONNECTED\", \"\".concat(_this16.name, \", \").concat(e));\n        yield _this16.onUnsubscribe(e, t, n), _this16.logger.debug(\"Successfully Unsubscribed Topic\"), _this16.logger.trace({\n          type: \"method\",\n          method: \"unsubscribe\",\n          params: {\n            topic: e,\n            id: t,\n            opts: i\n          }\n        });\n      } catch (s) {\n        throw _this16.logger.debug(\"Failed to Unsubscribe Topic\"), _this16.logger.error(s), s;\n      }\n    })();\n  }\n  rpcSubscribe(e, t) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const i = {\n        method: H(t.protocol).subscribe,\n        params: {\n          topic: e\n        }\n      };\n      _this17.logger.debug(\"Outgoing Relay Payload\"), _this17.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request: i\n      });\n      try {\n        yield yield k(_this17.relayer.request(i), _this17.subscribeTimeout);\n      } catch (_unused3) {\n        _this17.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), _this17.relayer.events.emit(D.connection_stalled);\n      }\n      return se(e + _this17.clientId);\n    })();\n  }\n  rpcBatchSubscribe(e) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (!e.length) return;\n      const t = e[0].relay,\n        i = {\n          method: H(t.protocol).batchSubscribe,\n          params: {\n            topics: e.map(s => s.topic)\n          }\n        };\n      _this18.logger.debug(\"Outgoing Relay Payload\"), _this18.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request: i\n      });\n      try {\n        return yield yield k(_this18.relayer.request(i), _this18.subscribeTimeout);\n      } catch (_unused4) {\n        _this18.logger.debug(\"Outgoing Relay Payload stalled\"), _this18.relayer.events.emit(D.connection_stalled);\n      }\n    })();\n  }\n  rpcUnsubscribe(e, t, i) {\n    const s = {\n      method: H(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    }), this.relayer.request(s);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, De(q({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach(t => {\n      this.setSubscription(t.id, q({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  onUnsubscribe(e, t, i) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      _this19.events.removeAllListeners(t), _this19.hasSubscription(t, e) && _this19.deleteSubscription(t, i), yield _this19.relayer.messages.del(e);\n    })();\n  }\n  setRelayerSubscriptions(e) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      yield _this20.relayer.core.storage.setItem(_this20.storageKey, e);\n    })();\n  }\n  getRelayerSubscriptions() {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this21.relayer.core.storage.getItem(_this21.storageKey);\n    })();\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, q({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(w.deleted, De(q({}, i), {\n      reason: t\n    }));\n  }\n  persist() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      yield _this22.setRelayerSubscriptions(_this22.values), _this22.events.emit(w.sync);\n    })();\n  }\n  reset() {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      if (_this23.cached.length) {\n        const e = Math.ceil(_this23.cached.length / _this23.batchSubscribeTopicsLimit);\n        for (let t = 0; t < e; t++) {\n          const i = _this23.cached.splice(0, _this23.batchSubscribeTopicsLimit);\n          yield _this23.batchSubscribe(i);\n        }\n      }\n      _this23.events.emit(w.resubscribed);\n    })();\n  }\n  restore() {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this24.getRelayerSubscriptions();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this24.subscriptions.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this24.name);\n          throw _this24.logger.error(t), _this24.logger.error(\"\".concat(_this24.name, \": \").concat(JSON.stringify(_this24.values))), new Error(t);\n        }\n        _this24.cached = e, _this24.logger.debug(\"Successfully Restored subscriptions for \".concat(_this24.name)), _this24.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          subscriptions: _this24.values\n        });\n      } catch (e) {\n        _this24.logger.debug(\"Failed to Restore subscriptions for \".concat(_this24.name)), _this24.logger.error(e);\n      }\n    })();\n  }\n  batchSubscribe(e) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      if (!e.length) return;\n      const t = yield _this25.rpcBatchSubscribe(e);\n      Di(t) && _this25.onBatchSubscribe(t.map((i, s) => De(q({}, e[s]), {\n        id: i\n      })));\n    })();\n  }\n  onConnect() {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      _this26.restartInProgress || (yield _this26.restart(), _this26.onEnable());\n    })();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  checkPending() {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this27.initialized || _this27.relayer.transportExplicitlyClosed) return;\n      const e = [];\n      _this27.pending.forEach(t => {\n        e.push(t);\n      }), yield _this27.batchSubscribe(e);\n    })();\n  }\n  registerEventListeners() {\n    var _this28 = this;\n    this.relayer.core.heartbeat.on(Y.pulse, /*#__PURE__*/_asyncToGenerator(function* () {\n      yield _this28.checkPending();\n    })), this.relayer.on(D.connect, /*#__PURE__*/_asyncToGenerator(function* () {\n      yield _this28.onConnect();\n    })), this.relayer.on(D.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(w.created, /*#__PURE__*/function () {\n      var _ref30 = _asyncToGenerator(function* (e) {\n        const t = w.created;\n        _this28.logger.info(\"Emitting \".concat(t)), _this28.logger.debug({\n          type: \"event\",\n          event: t,\n          data: e\n        }), yield _this28.persist();\n      });\n      return function (_x29) {\n        return _ref30.apply(this, arguments);\n      };\n    }()), this.events.on(w.deleted, /*#__PURE__*/function () {\n      var _ref31 = _asyncToGenerator(function* (e) {\n        const t = w.deleted;\n        _this28.logger.info(\"Emitting \".concat(t)), _this28.logger.debug({\n          type: \"event\",\n          event: t,\n          data: e\n        }), yield _this28.persist();\n      });\n      return function (_x30) {\n        return _ref31.apply(this, arguments);\n      };\n    }());\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  restartToComplete() {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      _this29.restartInProgress && (yield new Promise(e => {\n        const t = setInterval(() => {\n          _this29.restartInProgress || (clearInterval(t), e());\n        }, _this29.pollingInterval);\n      }));\n    })();\n  }\n}\nvar Ir = Object.defineProperty,\n  At = Object.getOwnPropertySymbols,\n  Cr = Object.prototype.hasOwnProperty,\n  Rr = Object.prototype.propertyIsEnumerable,\n  zt = (r, e, t) => e in r ? Ir(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  _r = (r, e) => {\n    for (var t in e || (e = {})) Cr.call(e, t) && zt(r, t, e[t]);\n    if (At) for (var t of At(e)) Rr.call(e, t) && zt(r, t, e[t]);\n    return r;\n  };\nclass Nt extends Qt {\n  constructor(e) {\n    var _this30;\n    (super(e), _this30 = this), this.protocol = \"wc\", this.version = 2, this.events = new N(), this.name = ct, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.hasExperiencedNetworkDisruption = !1, this.request = /*#__PURE__*/function () {\n      var _ref32 = _asyncToGenerator(function* (t) {\n        _this30.logger.debug(\"Publishing Request Payload\");\n        try {\n          return yield _this30.toEstablishConnection(), yield _this30.provider.request(t);\n        } catch (i) {\n          throw _this30.logger.debug(\"Failed to Publish Request\"), _this30.logger.error(i), i;\n        }\n      });\n      return function (_x31) {\n        return _ref32.apply(this, arguments);\n      };\n    }(), this.onPayloadHandler = t => {\n      this.onProviderPayload(t);\n    }, this.onConnectHandler = () => {\n      this.events.emit(D.connect);\n    }, this.onDisconnectHandler = () => {\n      this.onProviderDisconnect();\n    }, this.onProviderErrorHandler = t => {\n      this.logger.error(t), this.events.emit(D.error, t), this.logger.info(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }, this.registerProviderListeners = () => {\n      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? f(e.logger, this.name) : ye(me({\n      level: e.logger || ht\n    })), this.messages = new Tt(this.logger, e.core), this.subscriber = new Ot(this, this.logger), this.publisher = new yr(this, this.logger), this.relayUrl = (e === null || e === void 0 ? void 0 : e.relayUrl) || ge, this.projectId = e.projectId, this.provider = {};\n  }\n  init() {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      _this31.logger.trace(\"Initialized\"), _this31.registerEventListeners(), yield _this31.createProvider(), yield Promise.all([_this31.messages.init(), _this31.subscriber.init()]);\n      try {\n        yield _this31.transportOpen();\n      } catch (_unused5) {\n        _this31.logger.warn(\"Connection via \".concat(_this31.relayUrl, \" failed, attempting to connect via failover domain \").concat(pe, \"...\")), yield _this31.restartTransport(pe);\n      }\n      _this31.initialized = !0, setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n        _this31.subscriber.topics.length === 0 && (_this31.logger.info(\"No topics subscribed to after init, closing transport\"), yield _this31.transportClose(), _this31.transportExplicitlyClosed = !1);\n      }), gt);\n    })();\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  publish(e, t, i) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      _this32.isInitialized(), yield _this32.publisher.publish(e, t, i), yield _this32.recordMessageEvent({\n        topic: e,\n        message: t,\n        publishedAt: Date.now()\n      });\n    })();\n  }\n  subscribe(e, t) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      var i;\n      _this33.isInitialized();\n      let s = ((i = _this33.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || \"\";\n      if (s) return s;\n      let n;\n      const a = o => {\n        o.topic === e && (_this33.subscriber.off(w.created, a), n());\n      };\n      return yield Promise.all([new Promise(o => {\n        n = o, _this33.subscriber.on(w.created, a);\n      }), new Promise( /*#__PURE__*/function () {\n        var _ref34 = _asyncToGenerator(function* (o) {\n          s = yield _this33.subscriber.subscribe(e, t), o();\n        });\n        return function (_x32) {\n          return _ref34.apply(this, arguments);\n        };\n      }())]), s;\n    })();\n  }\n  unsubscribe(e, t) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      _this34.isInitialized(), yield _this34.subscriber.unsubscribe(e, t);\n    })();\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  transportClose() {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      _this35.transportExplicitlyClosed = !0, _this35.hasExperiencedNetworkDisruption && _this35.connected ? yield k(_this35.provider.disconnect(), 1e3, \"provider.disconnect()\").catch(() => _this35.onProviderDisconnect()) : _this35.connected && (yield _this35.provider.disconnect());\n    })();\n  }\n  transportOpen(e) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      if (_this36.transportExplicitlyClosed = !1, yield _this36.confirmOnlineStateOrThrow(), !_this36.connectionAttemptInProgress) {\n        e && e !== _this36.relayUrl && (_this36.relayUrl = e, yield _this36.transportClose(), yield _this36.createProvider()), _this36.connectionAttemptInProgress = !0;\n        try {\n          yield Promise.all([new Promise(t => {\n            if (!_this36.initialized) return t();\n            _this36.subscriber.once(w.resubscribed, () => {\n              t();\n            });\n          }), new Promise( /*#__PURE__*/function () {\n            var _ref35 = _asyncToGenerator(function* (t, i) {\n              try {\n                yield k(_this36.provider.connect(), 1e4, \"Socket stalled when trying to connect to \".concat(_this36.relayUrl));\n              } catch (s) {\n                i(s);\n                return;\n              }\n              t();\n            });\n            return function (_x33, _x34) {\n              return _ref35.apply(this, arguments);\n            };\n          }())]);\n        } catch (t) {\n          _this36.logger.error(t);\n          const i = t;\n          if (!_this36.isConnectionStalled(i.message)) throw t;\n          _this36.provider.events.emit(P.disconnect);\n        } finally {\n          _this36.connectionAttemptInProgress = !1, _this36.hasExperiencedNetworkDisruption = !1;\n        }\n      }\n    })();\n  }\n  restartTransport(e) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      yield _this37.confirmOnlineStateOrThrow(), !_this37.connectionAttemptInProgress && (_this37.relayUrl = e || _this37.relayUrl, yield _this37.transportClose(), yield _this37.createProvider(), yield _this37.transportOpen());\n    })();\n  }\n  confirmOnlineStateOrThrow() {\n    return _asyncToGenerator(function* () {\n      if (!(yield ve())) throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n    })();\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some(t => e.includes(t));\n  }\n  createProvider() {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      _this38.provider.connection && _this38.unregisterProviderListeners();\n      const e = yield _this38.core.crypto.signJWT(_this38.relayUrl);\n      _this38.provider = new Li(new ki(yi({\n        sdkVersion: dt,\n        protocol: _this38.protocol,\n        version: _this38.version,\n        relayUrl: _this38.relayUrl,\n        projectId: _this38.projectId,\n        auth: e,\n        useOnCloseEvent: !0\n      }))), _this38.registerProviderListeners();\n    })();\n  }\n  recordMessageEvent(e) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      yield _this39.messages.set(t, i);\n    })();\n  }\n  shouldIgnoreMessageEvent(e) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      if (!i || i.length === 0) return _this40.logger.debug(\"Ignoring invalid/empty message: \".concat(i)), !0;\n      if (!(yield _this40.subscriber.isSubscribed(t))) return _this40.logger.debug(\"Ignoring message for non-subscribed topic \".concat(t)), !0;\n      const s = _this40.messages.has(t, i);\n      return s && _this40.logger.debug(\"Ignoring duplicate message: \".concat(i)), s;\n    })();\n  }\n  onProviderPayload(e) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      if (_this41.logger.debug(\"Incoming Relay Payload\"), _this41.logger.trace({\n        type: \"payload\",\n        direction: \"incoming\",\n        payload: e\n      }), Te(e)) {\n        if (!e.method.endsWith(ut)) return;\n        const t = e.params,\n          {\n            topic: i,\n            message: s,\n            publishedAt: n\n          } = t.data,\n          a = {\n            topic: i,\n            message: s,\n            publishedAt: n\n          };\n        _this41.logger.debug(\"Emitting Relayer Payload\"), _this41.logger.trace(_r({\n          type: \"event\",\n          event: t.id\n        }, a)), _this41.events.emit(t.id, a), yield _this41.acknowledgePayload(e), yield _this41.onMessageEvent(a);\n      } else Pe(e) && _this41.events.emit(D.message_ack, e);\n    })();\n  }\n  onMessageEvent(e) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      (yield _this42.shouldIgnoreMessageEvent(e)) || (_this42.events.emit(D.message, e), yield _this42.recordMessageEvent(e));\n    })();\n  }\n  acknowledgePayload(e) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      const t = xe(e.id, !0);\n      yield _this43.provider.connection.send(t);\n    })();\n  }\n  unregisterProviderListeners() {\n    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);\n  }\n  registerEventListeners() {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      _this44.events.on(D.connection_stalled, () => {\n        _this44.restartTransport().catch(t => _this44.logger.error(t));\n      });\n      let e = yield ve();\n      mi( /*#__PURE__*/function () {\n        var _ref36 = _asyncToGenerator(function* (t) {\n          _this44.initialized && e !== t && (e = t, t ? yield _this44.restartTransport().catch(i => _this44.logger.error(i)) : (_this44.hasExperiencedNetworkDisruption = !0, yield _this44.transportClose().catch(i => _this44.logger.error(i))));\n        });\n        return function (_x35) {\n          return _ref36.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  onProviderDisconnect() {\n    this.events.emit(D.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    var _this45 = this;\n    this.transportExplicitlyClosed || (this.logger.info(\"attemptToReconnect called. Connecting...\"), setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      yield _this45.restartTransport().catch(e => _this45.logger.error(e));\n    }), L(lt)));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  toEstablishConnection() {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      if (yield _this46.confirmOnlineStateOrThrow(), !_this46.connected) {\n        if (_this46.connectionAttemptInProgress) return yield new Promise(e => {\n          const t = setInterval(() => {\n            _this46.connected && (clearInterval(t), e());\n          }, _this46.connectionStatusPollingInterval);\n        });\n        yield _this46.restartTransport();\n      }\n    })();\n  }\n}\nvar Sr = Object.defineProperty,\n  Ut = Object.getOwnPropertySymbols,\n  Tr = Object.prototype.hasOwnProperty,\n  Pr = Object.prototype.propertyIsEnumerable,\n  Lt = (r, e, t) => e in r ? Sr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  Ft = (r, e) => {\n    for (var t in e || (e = {})) Tr.call(e, t) && Lt(r, t, e[t]);\n    if (Ut) for (var t of Ut(e)) Pr.call(e, t) && Lt(r, t, e[t]);\n    return r;\n  };\nclass $t extends Zt {\n  constructor(e, t, i) {\n    var _this47;\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : O;\n    let n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;\n    (super(e, t, i, s), _this47 = this), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = pt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this47.initialized || (_this47.logger.trace(\"Initialized\"), yield _this47.restore(), _this47.cached.forEach(a => {\n        _this47.getKey && a !== null && !ne(a) ? _this47.map.set(_this47.getKey(a), a) : bi(a) ? _this47.map.set(a.id, a) : fi(a) && _this47.map.set(a.topic, a);\n      }), _this47.cached = [], _this47.initialized = !0);\n    }), this.set = /*#__PURE__*/function () {\n      var _ref39 = _asyncToGenerator(function* (a, o) {\n        _this47.isInitialized(), _this47.map.has(a) ? yield _this47.update(a, o) : (_this47.logger.debug(\"Setting value\"), _this47.logger.trace({\n          type: \"method\",\n          method: \"set\",\n          key: a,\n          value: o\n        }), _this47.map.set(a, o), yield _this47.persist());\n      });\n      return function (_x36, _x37) {\n        return _ref39.apply(this, arguments);\n      };\n    }(), this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => (this.isInitialized(), a ? this.values.filter(o => Object.keys(a).every(h => Ki(o[h], a[h]))) : this.values), this.update = /*#__PURE__*/function () {\n      var _ref40 = _asyncToGenerator(function* (a, o) {\n        _this47.isInitialized(), _this47.logger.debug(\"Updating value\"), _this47.logger.trace({\n          type: \"method\",\n          method: \"update\",\n          key: a,\n          update: o\n        });\n        const h = Ft(Ft({}, _this47.getData(a)), o);\n        _this47.map.set(a, h), yield _this47.persist();\n      });\n      return function (_x38, _x39) {\n        return _ref40.apply(this, arguments);\n      };\n    }(), this.delete = /*#__PURE__*/function () {\n      var _ref41 = _asyncToGenerator(function* (a, o) {\n        _this47.isInitialized(), _this47.map.has(a) && (_this47.logger.debug(\"Deleting value\"), _this47.logger.trace({\n          type: \"method\",\n          method: \"delete\",\n          key: a,\n          reason: o\n        }), _this47.map.delete(a), yield _this47.persist());\n      });\n      return function (_x40, _x41) {\n        return _ref41.apply(this, arguments);\n      };\n    }(), this.logger = f(t, this.name), this.storagePrefix = s, this.getKey = n;\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  setDataStore(e) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      yield _this48.core.storage.setItem(_this48.storageKey, e);\n    })();\n  }\n  getDataStore() {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this49.core.storage.getItem(_this49.storageKey);\n    })();\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  persist() {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      yield _this50.setDataStore(_this50.values);\n    })();\n  }\n  restore() {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this51.getDataStore();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this51.map.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this51.name);\n          throw _this51.logger.error(t), new Error(t);\n        }\n        _this51.cached = e, _this51.logger.debug(\"Successfully Restored value for \".concat(_this51.name)), _this51.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          value: _this51.values\n        });\n      } catch (e) {\n        _this51.logger.debug(\"Failed to Restore value for \".concat(_this51.name)), _this51.logger.error(e);\n      }\n    })();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Mt {\n  constructor(e, t) {\n    var _this52 = this;\n    this.core = e, this.logger = t, this.name = ft, this.version = Et, this.events = new Yt(), this.initialized = !1, this.storagePrefix = O, this.ignoredPayloadTypes = [Ei], this.registeredMethods = [], this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this52.initialized || (yield _this52.pairings.init(), yield _this52.cleanup(), _this52.registerRelayerEvents(), _this52.registerExpirerEvents(), _this52.initialized = !0, _this52.logger.trace(\"Initialized\"));\n    }), this.register = _ref43 => {\n      let {\n        methods: i\n      } = _ref43;\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...i])];\n    }, this.create = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this52.isInitialized();\n      const i = ie(),\n        s = yield _this52.core.crypto.setSymKey(i),\n        n = J(Se),\n        a = {\n          protocol: ot\n        },\n        o = {\n          topic: s,\n          expiry: n,\n          relay: a,\n          active: !1\n        },\n        h = wi({\n          protocol: _this52.core.protocol,\n          version: _this52.core.version,\n          topic: s,\n          symKey: i,\n          relay: a\n        });\n      return yield _this52.pairings.set(s, o), yield _this52.core.relayer.subscribe(s), _this52.core.expirer.set(s, n), {\n        topic: s,\n        uri: h\n      };\n    }), this.pair = /*#__PURE__*/function () {\n      var _ref45 = _asyncToGenerator(function* (i) {\n        _this52.isInitialized(), _this52.isValidPair(i);\n        const {\n          topic: s,\n          symKey: n,\n          relay: a\n        } = vi(i.uri);\n        let o;\n        if (_this52.pairings.keys.includes(s) && (o = _this52.pairings.get(s), o.active)) throw new Error(\"Pairing already exists: \".concat(s, \". Please try again with a new connection URI.\"));\n        _this52.core.crypto.keychain.has(s) || (yield _this52.core.crypto.setSymKey(n, s), yield _this52.core.relayer.subscribe(s, {\n          relay: a\n        }));\n        const h = J(Se),\n          u = {\n            topic: s,\n            relay: a,\n            expiry: h,\n            active: !1\n          };\n        return yield _this52.pairings.set(s, u), _this52.core.expirer.set(s, h), i.activatePairing && (yield _this52.activate({\n          topic: s\n        })), _this52.events.emit(V.create, u), u;\n      });\n      return function (_x42) {\n        return _ref45.apply(this, arguments);\n      };\n    }(), this.activate = /*#__PURE__*/function () {\n      var _ref47 = _asyncToGenerator(function* (_ref46) {\n        let {\n          topic: i\n        } = _ref46;\n        _this52.isInitialized();\n        const s = J(W);\n        yield _this52.pairings.update(i, {\n          active: !0,\n          expiry: s\n        }), _this52.core.expirer.set(i, s);\n      });\n      return function (_x43) {\n        return _ref47.apply(this, arguments);\n      };\n    }(), this.ping = /*#__PURE__*/function () {\n      var _ref48 = _asyncToGenerator(function* (i) {\n        _this52.isInitialized(), yield _this52.isValidPing(i);\n        const {\n          topic: s\n        } = i;\n        if (_this52.pairings.keys.includes(s)) {\n          const n = yield _this52.sendRequest(s, \"wc_pairingPing\", {}),\n            {\n              done: a,\n              resolve: o,\n              reject: h\n            } = Ii();\n          _this52.events.once(ae(\"pairing_ping\", n), _ref49 => {\n            let {\n              error: u\n            } = _ref49;\n            u ? h(u) : o();\n          }), yield a();\n        }\n      });\n      return function (_x44) {\n        return _ref48.apply(this, arguments);\n      };\n    }(), this.updateExpiry = /*#__PURE__*/function () {\n      var _ref51 = _asyncToGenerator(function* (_ref50) {\n        let {\n          topic: i,\n          expiry: s\n        } = _ref50;\n        _this52.isInitialized(), yield _this52.pairings.update(i, {\n          expiry: s\n        });\n      });\n      return function (_x45) {\n        return _ref51.apply(this, arguments);\n      };\n    }(), this.updateMetadata = /*#__PURE__*/function () {\n      var _ref53 = _asyncToGenerator(function* (_ref52) {\n        let {\n          topic: i,\n          metadata: s\n        } = _ref52;\n        _this52.isInitialized(), yield _this52.pairings.update(i, {\n          peerMetadata: s\n        });\n      });\n      return function (_x46) {\n        return _ref53.apply(this, arguments);\n      };\n    }(), this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = /*#__PURE__*/function () {\n      var _ref54 = _asyncToGenerator(function* (i) {\n        _this52.isInitialized(), yield _this52.isValidDisconnect(i);\n        const {\n          topic: s\n        } = i;\n        _this52.pairings.keys.includes(s) && (yield _this52.sendRequest(s, \"wc_pairingDelete\", K(\"USER_DISCONNECTED\")), yield _this52.deletePairing(s));\n      });\n      return function (_x47) {\n        return _ref54.apply(this, arguments);\n      };\n    }(), this.sendRequest = /*#__PURE__*/function () {\n      var _ref55 = _asyncToGenerator(function* (i, s, n) {\n        const a = Oe(s, n),\n          o = yield _this52.core.crypto.encode(i, a),\n          h = F[s].req;\n        return _this52.core.history.set(i, a), _this52.core.relayer.publish(i, o, h), a.id;\n      });\n      return function (_x48, _x49, _x50) {\n        return _ref55.apply(this, arguments);\n      };\n    }(), this.sendResult = /*#__PURE__*/function () {\n      var _ref56 = _asyncToGenerator(function* (i, s, n) {\n        const a = xe(i, n),\n          o = yield _this52.core.crypto.encode(s, a),\n          h = yield _this52.core.history.get(s, i),\n          u = F[h.request.method].res;\n        yield _this52.core.relayer.publish(s, o, u), yield _this52.core.history.resolve(a);\n      });\n      return function (_x51, _x52, _x53) {\n        return _ref56.apply(this, arguments);\n      };\n    }(), this.sendError = /*#__PURE__*/function () {\n      var _ref57 = _asyncToGenerator(function* (i, s, n) {\n        const a = $i(i, n),\n          o = yield _this52.core.crypto.encode(s, a),\n          h = yield _this52.core.history.get(s, i),\n          u = F[h.request.method] ? F[h.request.method].res : F.unregistered_method.res;\n        yield _this52.core.relayer.publish(s, o, u), yield _this52.core.history.resolve(a);\n      });\n      return function (_x54, _x55, _x56) {\n        return _ref57.apply(this, arguments);\n      };\n    }(), this.deletePairing = /*#__PURE__*/function () {\n      var _ref58 = _asyncToGenerator(function* (i, s) {\n        yield _this52.core.relayer.unsubscribe(i), yield Promise.all([_this52.pairings.delete(i, K(\"USER_DISCONNECTED\")), _this52.core.crypto.deleteSymKey(i), s ? Promise.resolve() : _this52.core.expirer.del(i)]);\n      });\n      return function (_x57, _x58) {\n        return _ref58.apply(this, arguments);\n      };\n    }(), this.cleanup = /*#__PURE__*/_asyncToGenerator(function* () {\n      const i = _this52.pairings.getAll().filter(s => Ie(s.expiry));\n      yield Promise.all(i.map(s => _this52.deletePairing(s.topic)));\n    }), this.onRelayEventRequest = i => {\n      const {\n        topic: s,\n        payload: n\n      } = i;\n      switch (n.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(s, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(s, n);\n        default:\n          return this.onUnknownRpcMethodRequest(s, n);\n      }\n    }, this.onRelayEventResponse = /*#__PURE__*/function () {\n      var _ref60 = _asyncToGenerator(function* (i) {\n        const {\n            topic: s,\n            payload: n\n          } = i,\n          a = (yield _this52.core.history.get(s, n.id)).request.method;\n        switch (a) {\n          case \"wc_pairingPing\":\n            return _this52.onPairingPingResponse(s, n);\n          default:\n            return _this52.onUnknownRpcMethodResponse(a);\n        }\n      });\n      return function (_x59) {\n        return _ref60.apply(this, arguments);\n      };\n    }(), this.onPairingPingRequest = /*#__PURE__*/function () {\n      var _ref61 = _asyncToGenerator(function* (i, s) {\n        const {\n          id: n\n        } = s;\n        try {\n          _this52.isValidPing({\n            topic: i\n          }), yield _this52.sendResult(n, i, !0), _this52.events.emit(V.ping, {\n            id: n,\n            topic: i\n          });\n        } catch (a) {\n          yield _this52.sendError(n, i, a), _this52.logger.error(a);\n        }\n      });\n      return function (_x60, _x61) {\n        return _ref61.apply(this, arguments);\n      };\n    }(), this.onPairingPingResponse = (i, s) => {\n      const {\n        id: n\n      } = s;\n      setTimeout(() => {\n        Mi(s) ? this.events.emit(ae(\"pairing_ping\", n), {}) : Ae(s) && this.events.emit(ae(\"pairing_ping\", n), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onPairingDeleteRequest = /*#__PURE__*/function () {\n      var _ref62 = _asyncToGenerator(function* (i, s) {\n        const {\n          id: n\n        } = s;\n        try {\n          _this52.isValidDisconnect({\n            topic: i\n          }), yield _this52.deletePairing(i), _this52.events.emit(V.delete, {\n            id: n,\n            topic: i\n          });\n        } catch (a) {\n          yield _this52.sendError(n, i, a), _this52.logger.error(a);\n        }\n      });\n      return function (_x62, _x63) {\n        return _ref62.apply(this, arguments);\n      };\n    }(), this.onUnknownRpcMethodRequest = /*#__PURE__*/function () {\n      var _ref63 = _asyncToGenerator(function* (i, s) {\n        const {\n          id: n,\n          method: a\n        } = s;\n        try {\n          if (_this52.registeredMethods.includes(a)) return;\n          const o = K(\"WC_METHOD_UNSUPPORTED\", a);\n          yield _this52.sendError(n, i, o), _this52.logger.error(o);\n        } catch (o) {\n          yield _this52.sendError(n, i, o), _this52.logger.error(o);\n        }\n      });\n      return function (_x64, _x65) {\n        return _ref63.apply(this, arguments);\n      };\n    }(), this.onUnknownRpcMethodResponse = i => {\n      this.registeredMethods.includes(i) || this.logger.error(K(\"WC_METHOD_UNSUPPORTED\", i));\n    }, this.isValidPair = i => {\n      if (!oe(i)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", \"pair() params: \".concat(i));\n        throw new Error(s);\n      }\n      if (!Ci(i.uri)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", \"pair() uri: \".concat(i.uri));\n        throw new Error(s);\n      }\n    }, this.isValidPing = /*#__PURE__*/function () {\n      var _ref64 = _asyncToGenerator(function* (i) {\n        if (!oe(i)) {\n          const {\n            message: n\n          } = l(\"MISSING_OR_INVALID\", \"ping() params: \".concat(i));\n          throw new Error(n);\n        }\n        const {\n          topic: s\n        } = i;\n        yield _this52.isValidPairingTopic(s);\n      });\n      return function (_x66) {\n        return _ref64.apply(this, arguments);\n      };\n    }(), this.isValidDisconnect = /*#__PURE__*/function () {\n      var _ref65 = _asyncToGenerator(function* (i) {\n        if (!oe(i)) {\n          const {\n            message: n\n          } = l(\"MISSING_OR_INVALID\", \"disconnect() params: \".concat(i));\n          throw new Error(n);\n        }\n        const {\n          topic: s\n        } = i;\n        yield _this52.isValidPairingTopic(s);\n      });\n      return function (_x67) {\n        return _ref65.apply(this, arguments);\n      };\n    }(), this.isValidPairingTopic = /*#__PURE__*/function () {\n      var _ref66 = _asyncToGenerator(function* (i) {\n        if (!Ri(i, !1)) {\n          const {\n            message: s\n          } = l(\"MISSING_OR_INVALID\", \"pairing topic should be a string: \".concat(i));\n          throw new Error(s);\n        }\n        if (!_this52.pairings.keys.includes(i)) {\n          const {\n            message: s\n          } = l(\"NO_MATCHING_KEY\", \"pairing topic doesn't exist: \".concat(i));\n          throw new Error(s);\n        }\n        if (Ie(_this52.pairings.get(i).expiry)) {\n          yield _this52.deletePairing(i);\n          const {\n            message: s\n          } = l(\"EXPIRED\", \"pairing topic: \".concat(i));\n          throw new Error(s);\n        }\n      });\n      return function (_x68) {\n        return _ref66.apply(this, arguments);\n      };\n    }(), this.core = e, this.logger = f(t, this.name), this.pairings = new $t(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    var _this53 = this;\n    this.core.relayer.on(D.message, /*#__PURE__*/function () {\n      var _ref67 = _asyncToGenerator(function* (e) {\n        const {\n          topic: t,\n          message: i\n        } = e;\n        if (!_this53.pairings.keys.includes(t) || _this53.ignoredPayloadTypes.includes(_this53.core.crypto.getPayloadType(i))) return;\n        const s = yield _this53.core.crypto.decode(t, i);\n        try {\n          Te(s) ? (_this53.core.history.set(t, s), _this53.onRelayEventRequest({\n            topic: t,\n            payload: s\n          })) : Pe(s) && (yield _this53.core.history.resolve(s), yield _this53.onRelayEventResponse({\n            topic: t,\n            payload: s\n          }), _this53.core.history.delete(t, s.id));\n        } catch (n) {\n          _this53.logger.error(n);\n        }\n      });\n      return function (_x69) {\n        return _ref67.apply(this, arguments);\n      };\n    }());\n  }\n  registerExpirerEvents() {\n    var _this54 = this;\n    this.core.expirer.on(v.expired, /*#__PURE__*/function () {\n      var _ref68 = _asyncToGenerator(function* (e) {\n        const {\n          topic: t\n        } = _i(e.target);\n        t && _this54.pairings.keys.includes(t) && (yield _this54.deletePairing(t, !0), _this54.events.emit(V.expire, {\n          topic: t\n        }));\n      });\n      return function (_x70) {\n        return _ref68.apply(this, arguments);\n      };\n    }());\n  }\n}\nclass kt extends ei {\n  constructor(e, t) {\n    var _this55;\n    (super(e, t), _this55 = this), this.core = e, this.logger = t, this.records = new Map(), this.events = new N(), this.name = wt, this.version = vt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this55.initialized || (_this55.logger.trace(\"Initialized\"), yield _this55.restore(), _this55.cached.forEach(i => _this55.records.set(i.id, i)), _this55.cached = [], _this55.registerEventListeners(), _this55.initialized = !0);\n    }), this.set = (i, s, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: i,\n        request: s,\n        chainId: n\n      }), this.records.has(s.id)) return;\n      const a = {\n        id: s.id,\n        topic: i,\n        request: {\n          method: s.method,\n          params: s.params || null\n        },\n        chainId: n,\n        expiry: J(W)\n      };\n      this.records.set(a.id, a), this.events.emit(R.created, a);\n    }, this.resolve = /*#__PURE__*/function () {\n      var _ref70 = _asyncToGenerator(function* (i) {\n        if (_this55.isInitialized(), _this55.logger.debug(\"Updating JSON-RPC response history record\"), _this55.logger.trace({\n          type: \"method\",\n          method: \"update\",\n          response: i\n        }), !_this55.records.has(i.id)) return;\n        const s = yield _this55.getRecord(i.id);\n        typeof s.response > \"u\" && (s.response = Ae(i) ? {\n          error: i.error\n        } : {\n          result: i.result\n        }, _this55.records.set(s.id, s), _this55.events.emit(R.updated, s));\n      });\n      return function (_x71) {\n        return _ref70.apply(this, arguments);\n      };\n    }(), this.get = /*#__PURE__*/function () {\n      var _ref71 = _asyncToGenerator(function* (i, s) {\n        return _this55.isInitialized(), _this55.logger.debug(\"Getting record\"), _this55.logger.trace({\n          type: \"method\",\n          method: \"get\",\n          topic: i,\n          id: s\n        }), yield _this55.getRecord(s);\n      });\n      return function (_x72, _x73) {\n        return _ref71.apply(this, arguments);\n      };\n    }(), this.delete = (i, s) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: s\n      }), this.values.forEach(n => {\n        if (n.topic === i) {\n          if (typeof s < \"u\" && n.id !== s) return;\n          this.records.delete(n.id), this.events.emit(R.deleted, n);\n        }\n      });\n    }, this.exists = /*#__PURE__*/function () {\n      var _ref72 = _asyncToGenerator(function* (i, s) {\n        return _this55.isInitialized(), _this55.records.has(s) ? (yield _this55.getRecord(s)).topic === i : !1;\n      });\n      return function (_x74, _x75) {\n        return _ref72.apply(this, arguments);\n      };\n    }(), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = f(t, this.name);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const i = {\n        topic: t.topic,\n        request: Oe(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(i);\n    }), e;\n  }\n  setJsonRpcRecords(e) {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      yield _this56.core.storage.setItem(_this56.storageKey, e);\n    })();\n  }\n  getJsonRpcRecords() {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this57.core.storage.getItem(_this57.storageKey);\n    })();\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw new Error(i);\n    }\n    return t;\n  }\n  persist() {\n    var _this58 = this;\n    return _asyncToGenerator(function* () {\n      yield _this58.setJsonRpcRecords(_this58.values), _this58.events.emit(R.sync);\n    })();\n  }\n  restore() {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this59.getJsonRpcRecords();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this59.records.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this59.name);\n          throw _this59.logger.error(t), new Error(t);\n        }\n        _this59.cached = e, _this59.logger.debug(\"Successfully Restored records for \".concat(_this59.name)), _this59.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          records: _this59.values\n        });\n      } catch (e) {\n        _this59.logger.debug(\"Failed to Restore records for \".concat(_this59.name)), _this59.logger.error(e);\n      }\n    })();\n  }\n  registerEventListeners() {\n    this.events.on(R.created, e => {\n      const t = R.created;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(R.updated, e => {\n      const t = R.updated;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(R.deleted, e => {\n      const t = R.deleted;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.core.heartbeat.on(Y.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.records.forEach(e => {\n        L(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(\"Deleting expired history log: \".concat(e.id)), this.delete(e.topic, e.id));\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Kt extends ti {\n  constructor(e, t) {\n    var _this60;\n    (super(e, t), _this60 = this), this.core = e, this.logger = t, this.expirations = new Map(), this.events = new N(), this.name = It, this.version = Ct, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this60.initialized || (_this60.logger.trace(\"Initialized\"), yield _this60.restore(), _this60.cached.forEach(i => _this60.expirations.set(i.target, i)), _this60.cached = [], _this60.registerEventListeners(), _this60.initialized = !0);\n    }), this.has = i => {\n      try {\n        const s = this.formatTarget(i);\n        return typeof this.getExpiration(s) < \"u\";\n      } catch (_unused6) {\n        return !1;\n      }\n    }, this.set = (i, s) => {\n      this.isInitialized();\n      const n = this.formatTarget(i),\n        a = {\n          target: n,\n          expiry: s\n        };\n      this.expirations.set(n, a), this.checkExpiry(n, a), this.events.emit(v.created, {\n        target: n,\n        expiration: a\n      });\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.formatTarget(i);\n      return this.getExpiration(s);\n    }, this.del = i => {\n      if (this.isInitialized(), this.has(i)) {\n        const s = this.formatTarget(i),\n          n = this.getExpiration(s);\n        this.expirations.delete(s), this.events.emit(v.deleted, {\n          target: s,\n          expiration: n\n        });\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = f(t, this.name);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return Si(e);\n    if (typeof e == \"number\") return Ti(e);\n    const {\n      message: t\n    } = l(\"UNKNOWN_TYPE\", \"Target type: \".concat(typeof e));\n    throw new Error(t);\n  }\n  setExpirations(e) {\n    var _this61 = this;\n    return _asyncToGenerator(function* () {\n      yield _this61.core.storage.setItem(_this61.storageKey, e);\n    })();\n  }\n  getExpirations() {\n    var _this62 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this62.core.storage.getItem(_this62.storageKey);\n    })();\n  }\n  persist() {\n    var _this63 = this;\n    return _asyncToGenerator(function* () {\n      yield _this63.setExpirations(_this63.values), _this63.events.emit(v.sync);\n    })();\n  }\n  restore() {\n    var _this64 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this64.getExpirations();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this64.expirations.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this64.name);\n          throw _this64.logger.error(t), new Error(t);\n        }\n        _this64.cached = e, _this64.logger.debug(\"Successfully Restored expirations for \".concat(_this64.name)), _this64.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          expirations: _this64.values\n        });\n      } catch (e) {\n        _this64.logger.debug(\"Failed to Restore expirations for \".concat(_this64.name)), _this64.logger.error(e);\n      }\n    })();\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: i\n    } = t;\n    L(i) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(v.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(Y.pulse, () => this.checkExpirations()), this.events.on(v.created, e => {\n      const t = v.created;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(v.expired, e => {\n      const t = v.expired;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(v.deleted, e => {\n      const t = v.deleted;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Bt extends ii {\n  constructor(e, t) {\n    var _this65;\n    (super(e, t), _this65 = this), this.projectId = e, this.logger = t, this.name = Z, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = /*#__PURE__*/function () {\n      var _ref74 = _asyncToGenerator(function* (i) {\n        if (_this65.verifyDisabled || Pi() || !xi()) return;\n        const s = _this65.getVerifyUrl(i === null || i === void 0 ? void 0 : i.verifyUrl);\n        _this65.verifyUrl !== s && _this65.removeIframe(), _this65.verifyUrl = s;\n        try {\n          yield _this65.createIframe();\n        } catch (n) {\n          _this65.logger.info(\"Verify iframe failed to load: \".concat(_this65.verifyUrl)), _this65.logger.info(n);\n        }\n        if (!_this65.initialized) {\n          _this65.removeIframe(), _this65.verifyUrl = ee;\n          try {\n            yield _this65.createIframe();\n          } catch (n) {\n            _this65.logger.info(\"Verify iframe failed to load: \".concat(_this65.verifyUrl)), _this65.logger.info(n), _this65.verifyDisabled = !0;\n          }\n        }\n      });\n      return function (_x76) {\n        return _ref74.apply(this, arguments);\n      };\n    }(), this.register = /*#__PURE__*/function () {\n      var _ref75 = _asyncToGenerator(function* (i) {\n        _this65.initialized ? _this65.sendPost(i.attestationId) : (_this65.addToQueue(i.attestationId), yield _this65.init());\n      });\n      return function (_x77) {\n        return _ref75.apply(this, arguments);\n      };\n    }(), this.resolve = /*#__PURE__*/function () {\n      var _ref76 = _asyncToGenerator(function* (i) {\n        if (_this65.isDevEnv) return \"\";\n        const s = _this65.getVerifyUrl(i === null || i === void 0 ? void 0 : i.verifyUrl);\n        let n;\n        try {\n          n = yield _this65.fetchAttestation(i.attestationId, s);\n        } catch (a) {\n          _this65.logger.info(\"failed to resolve attestation: \".concat(i.attestationId, \" from url: \").concat(s)), _this65.logger.info(a), n = yield _this65.fetchAttestation(i.attestationId, ee);\n        }\n        return n;\n      });\n      return function (_x78) {\n        return _ref76.apply(this, arguments);\n      };\n    }(), this.fetchAttestation = /*#__PURE__*/function () {\n      var _ref77 = _asyncToGenerator(function* (i, s) {\n        _this65.logger.info(\"resolving attestation: \".concat(i, \" from url: \").concat(s));\n        const n = _this65.startAbortTimer(Ce * 2),\n          a = yield fetch(\"\".concat(s, \"/attestation/\").concat(i), {\n            signal: _this65.abortController.signal\n          });\n        return clearTimeout(n), a.status === 200 ? yield a.json() : void 0;\n      });\n      return function (_x79, _x80) {\n        return _ref77.apply(this, arguments);\n      };\n    }(), this.addToQueue = i => {\n      this.queue.push(i);\n    }, this.processQueue = () => {\n      this.queue.length !== 0 && (this.queue.forEach(i => this.sendPost(i)), this.queue = []);\n    }, this.sendPost = i => {\n      var s;\n      try {\n        if (!this.iframe) return;\n        (s = this.iframe.contentWindow) == null || s.postMessage(i, \"*\"), this.logger.info(\"postMessage sent: \".concat(i, \" \").concat(this.verifyUrl));\n      } catch (_unused7) {}\n    }, this.createIframe = /*#__PURE__*/_asyncToGenerator(function* () {\n      let i;\n      const s = n => {\n        n.data === \"verify_ready\" && (_this65.initialized = !0, _this65.processQueue(), window.removeEventListener(\"message\", s), i());\n      };\n      yield Promise.race([new Promise(n => {\n        if (document.getElementById(Z)) return n();\n        window.addEventListener(\"message\", s);\n        const a = document.createElement(\"iframe\");\n        a.id = Z, a.src = \"\".concat(_this65.verifyUrl, \"/\").concat(_this65.projectId), a.style.display = \"none\", document.body.append(a), _this65.iframe = a, i = n;\n      }), new Promise((n, a) => setTimeout(() => {\n        window.removeEventListener(\"message\", s), a(\"verify iframe load timeout\");\n      }, L(Re)))]);\n    }), this.removeIframe = () => {\n      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);\n    }, this.getVerifyUrl = i => {\n      let s = i || $;\n      return Rt.includes(s) || (this.logger.info(\"verify url: \".concat(s, \", not included in trusted list, assigning default: \").concat($)), s = $), s;\n    }, this.logger = f(t, this.name), this.verifyUrl = $, this.abortController = new AbortController(), this.isDevEnv = Oi() && process.env.IS_VITEST;\n  }\n  get context() {\n    return E(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), L(e));\n  }\n}\nvar xr = Object.defineProperty,\n  Vt = Object.getOwnPropertySymbols,\n  Or = Object.prototype.hasOwnProperty,\n  Ar = Object.prototype.propertyIsEnumerable,\n  qt = (r, e, t) => e in r ? xr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  jt = (r, e) => {\n    for (var t in e || (e = {})) Or.call(e, t) && qt(r, t, e[t]);\n    if (Vt) for (var t of Vt(e)) Ar.call(e, t) && qt(r, t, e[t]);\n    return r;\n  };\nclass te extends si {\n  constructor(e) {\n    super(e), this.protocol = le, this.version = We, this.name = Q, this.events = new N(), this.initialized = !1, this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.projectId = e === null || e === void 0 ? void 0 : e.projectId, this.relayUrl = (e === null || e === void 0 ? void 0 : e.relayUrl) || ge, this.customStoragePrefix = e != null && e.customStoragePrefix ? \":\".concat(e.customStoragePrefix) : \"\";\n    const t = typeof (e === null || e === void 0 ? void 0 : e.logger) < \"u\" && typeof (e === null || e === void 0 ? void 0 : e.logger) != \"string\" ? e.logger : ye(me({\n      level: (e === null || e === void 0 ? void 0 : e.logger) || Xe.logger\n    }));\n    this.logger = f(t, this.name), this.heartbeat = new Ht(), this.crypto = new St(this, this.logger, e === null || e === void 0 ? void 0 : e.keychain), this.history = new kt(this, this.logger), this.expirer = new Kt(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Gt(jt(jt({}, Qe), e === null || e === void 0 ? void 0 : e.storageOptions)), this.relayer = new Nt({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new Mt(this, this.logger), this.verify = new Bt(this.projectId || \"\", this.logger);\n  }\n  static init(e) {\n    return _asyncToGenerator(function* () {\n      const t = new te(e);\n      yield t.initialize();\n      const i = yield t.crypto.getClientId();\n      return yield t.storage.setItem(Dt, i), t;\n    })();\n  }\n  get context() {\n    return E(this.logger);\n  }\n  start() {\n    var _this66 = this;\n    return _asyncToGenerator(function* () {\n      _this66.initialized || (yield _this66.initialize());\n    })();\n  }\n  initialize() {\n    var _this67 = this;\n    return _asyncToGenerator(function* () {\n      _this67.logger.trace(\"Initialized\");\n      try {\n        yield _this67.crypto.init(), yield _this67.history.init(), yield _this67.expirer.init(), yield _this67.relayer.init(), yield _this67.heartbeat.init(), yield _this67.pairing.init(), _this67.initialized = !0, _this67.logger.info(\"Core Initialization Success\");\n      } catch (e) {\n        throw _this67.logger.warn(\"Core Initialization Failure at epoch \".concat(Date.now()), e), _this67.logger.error(e.message), e;\n      }\n    })();\n  }\n}\nconst zr = te;\nexport { Q as CORE_CONTEXT, Xe as CORE_DEFAULT, le as CORE_PROTOCOL, Qe as CORE_STORAGE_OPTIONS, O as CORE_STORAGE_PREFIX, We as CORE_VERSION, de as CRYPTO_CLIENT_SEED, Ze as CRYPTO_CONTEXT, et as CRYPTO_JWT_TTL, zr as Core, St as Crypto, It as EXPIRER_CONTEXT, Dr as EXPIRER_DEFAULT_TTL, v as EXPIRER_EVENTS, Ct as EXPIRER_STORAGE_VERSION, Kt as Expirer, wt as HISTORY_CONTEXT, R as HISTORY_EVENTS, vt as HISTORY_STORAGE_VERSION, kt as JsonRpcHistory, tt as KEYCHAIN_CONTEXT, it as KEYCHAIN_STORAGE_VERSION, _t as KeyChain, st as MESSAGES_CONTEXT, rt as MESSAGES_STORAGE_VERSION, Tt as MessageTracker, ft as PAIRING_CONTEXT, pr as PAIRING_DEFAULT_TTL, V as PAIRING_EVENTS, F as PAIRING_RPC_OPTS, Et as PAIRING_STORAGE_VERSION, bt as PENDING_SUB_RESOLUTION_TIMEOUT, at as PUBLISHER_CONTEXT, nt as PUBLISHER_DEFAULT_TTL, Mt as Pairing, ct as RELAYER_CONTEXT, ht as RELAYER_DEFAULT_LOGGER, ot as RELAYER_DEFAULT_PROTOCOL, ge as RELAYER_DEFAULT_RELAY_URL, D as RELAYER_EVENTS, pe as RELAYER_FAILOVER_RELAY_URL, P as RELAYER_PROVIDER_EVENTS, lt as RELAYER_RECONNECT_TIMEOUT, dt as RELAYER_SDK_VERSION, dr as RELAYER_STORAGE_OPTIONS, ut as RELAYER_SUBSCRIBER_SUFFIX, gt as RELAYER_TRANSPORT_CUTOFF, Nt as Relayer, pt as STORE_STORAGE_VERSION, yt as SUBSCRIBER_CONTEXT, gr as SUBSCRIBER_DEFAULT_TTL, w as SUBSCRIBER_EVENTS, mt as SUBSCRIBER_STORAGE_VERSION, $t as Store, Ot as Subscriber, Rt as TRUSTED_VERIFY_URLS, Z as VERIFY_CONTEXT, ee as VERIFY_FALLBACK_SERVER, $ as VERIFY_SERVER, Bt as Verify, Dt as WALLETCONNECT_CLIENT_ID, te as default };","map":null,"metadata":{},"sourceType":"module"}