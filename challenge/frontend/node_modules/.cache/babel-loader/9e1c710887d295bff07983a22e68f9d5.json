{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWalletChainId = exports.networkHasUpdated = exports.switchToNetwork = exports.addNetworksToMetamask = exports.addNetworkToMetamask = exports.addTokensToMetamask = exports.makeAddCeloTokensParams = exports.tokenToParam = exports.makeNetworkParams = exports.MetamaskRPCErrorCode = void 0;\nconst mini_kit_1 = require(\"@celo/contractkit/lib/mini-kit\");\nconst constants_1 = require(\"../constants\");\nconst types_1 = require(\"../types\");\nconst CELO_PARAMS = Object.freeze({\n  chainName: 'Celo',\n  testnet: false,\n  nativeCurrency: {\n    name: 'CELO'\n  }\n});\nconst ALFAJORES_PARAMS = Object.freeze({\n  chainName: 'Alfajores Testnet',\n  testnet: true,\n  nativeCurrency: {\n    name: 'A-CELO'\n  }\n});\nconst BAKLAVA_PARAMS = Object.freeze({\n  chainName: 'Baklava Testnet',\n  testnet: true,\n  nativeCurrency: {\n    name: 'B-CELO'\n  }\n});\nconst CANNOLI_PARAMS = Object.freeze({\n  chainName: 'Cannoli Testnet',\n  testnet: true,\n  nativeCurrency: {\n    name: 'C-CELO'\n  }\n});\nconst PARAMS = {\n  [types_1.ChainId.Mainnet]: CELO_PARAMS,\n  [types_1.ChainId.Alfajores]: ALFAJORES_PARAMS,\n  [types_1.ChainId.Baklava]: BAKLAVA_PARAMS,\n  [types_1.ChainId.Cannoli]: CANNOLI_PARAMS\n};\n// First Class Supported Networks\nconst NETWORKS = {\n  [types_1.ChainId.Mainnet]: constants_1.Mainnet,\n  [types_1.ChainId.Alfajores]: constants_1.Alfajores,\n  [types_1.ChainId.Baklava]: constants_1.Baklava,\n  [types_1.ChainId.Cannoli]: constants_1.Cannoli\n};\nvar MetamaskRPCErrorCode;\n(function (MetamaskRPCErrorCode) {\n  MetamaskRPCErrorCode[MetamaskRPCErrorCode[\"AwaitingUserConfirmation\"] = -32002] = \"AwaitingUserConfirmation\";\n  MetamaskRPCErrorCode[MetamaskRPCErrorCode[\"UnrecognizedChainID\"] = -32603] = \"UnrecognizedChainID\";\n  MetamaskRPCErrorCode[MetamaskRPCErrorCode[\"UnknownNetwork\"] = 4902] = \"UnknownNetwork\";\n})(MetamaskRPCErrorCode = exports.MetamaskRPCErrorCode || (exports.MetamaskRPCErrorCode = {}));\nconst makeNetworkParams = (info, CELO) => __awaiter(void 0, void 0, void 0, function* () {\n  var _a;\n  const [symbol, decimals] = yield Promise.all([CELO.symbol(), CELO.decimals()]);\n  return {\n    chainId: \"0x\".concat(info.chainId.toString(16)),\n    chainName: (_a = PARAMS[info.chainId].chainName) !== null && _a !== void 0 ? _a : info.name,\n    nativeCurrency: {\n      name: PARAMS[info.chainId].nativeCurrency.name,\n      symbol,\n      decimals\n    },\n    rpcUrls: [info.rpcUrl],\n    blockExplorerUrls: [info.explorer],\n    iconUrls: [\"https://celoreserve.org/assets/tokens/\".concat(symbol, \".svg\")] // unfortunately unused\n  };\n});\n\nexports.makeNetworkParams = makeNetworkParams;\nconst tokenToParam = token => __awaiter(void 0, void 0, void 0, function* () {\n  const [symbol, decimals, name] = yield Promise.all([token.symbol(), token.decimals(), token.name()]);\n  return {\n    type: 'ERC20',\n    options: {\n      address: token.address,\n      name,\n      symbol,\n      decimals,\n      image: \"https://reserve.mento.org/assets/tokens/\".concat(symbol, \".svg\")\n    }\n  };\n});\nexports.tokenToParam = tokenToParam;\nconst makeAddCeloTokensParams = tokens => __awaiter(void 0, void 0, void 0, function* () {\n  return Promise.all(Object.values(tokens).map(exports.tokenToParam));\n});\nexports.makeAddCeloTokensParams = makeAddCeloTokensParams;\nconst addTokensToMetamask = (ethereum, tokens) => __awaiter(void 0, void 0, void 0, function* () {\n  const tokenParams = yield (0, exports.makeAddCeloTokensParams)(tokens);\n  const added = (yield Promise.all(tokenParams.map(params => ethereum === null || ethereum === void 0 ? void 0 : ethereum.request({\n    method: 'wallet_watchAsset',\n    params\n  })))).every(Boolean);\n  return added;\n});\nexports.addTokensToMetamask = addTokensToMetamask;\nconst addNetworkToMetamask = (ethereum, networkConfig) => __awaiter(void 0, void 0, void 0, function* () {\n  try {\n    // For Celo Chains\n    if (Object.keys(NETWORKS).includes(networkConfig.chainId.toString())) {\n      const _b = yield (0, mini_kit_1.newKit)(networkConfig.rpcUrl).celoTokens.getWrappers(),\n        {\n          CELO\n        } = _b,\n        tokens = __rest(_b, [\"CELO\"]);\n      yield ethereum === null || ethereum === void 0 ? void 0 : ethereum.request({\n        method: 'wallet_addEthereumChain',\n        params: [yield (0, exports.makeNetworkParams)(networkConfig, CELO)]\n      });\n      yield (0, exports.addTokensToMetamask)(ethereum, tokens);\n      // For other chains\n    } else {\n      yield ethereum === null || ethereum === void 0 ? void 0 : ethereum.request({\n        method: 'wallet_addEthereumChain',\n        params: [{\n          chainId: networkConfig.chainId,\n          chainName: networkConfig.name,\n          rpcUrls: [networkConfig.rpcUrl],\n          blockExplorerUrls: [networkConfig.explorer],\n          nativeCurrency: networkConfig.nativeCurrency\n        }]\n      });\n    }\n  } catch (err) {\n    const {\n      code\n    } = err;\n    if (code === MetamaskRPCErrorCode.AwaitingUserConfirmation) {\n      // user has already been requested to add the network\n      // maybe add a user CTA\n      throw new Error(\"Please check your Metamask window to add \".concat(networkConfig.name, \" to Metamask\"));\n    } else {\n      throw err;\n    }\n  }\n});\nexports.addNetworkToMetamask = addNetworkToMetamask;\nfunction addNetworksToMetamask(ethereum) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield Promise.all(Object.values(NETWORKS).map(network => (0, exports.addNetworkToMetamask)(ethereum, network)));\n  });\n}\nexports.addNetworksToMetamask = addNetworksToMetamask;\nfunction switchToNetwork(network, ethereum, getChainId) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [chainId, walletChainId] = yield Promise.all([getChainId(), getWalletChainId(ethereum)]);\n    if (network.chainId !== chainId || network.chainId !== walletChainId) {\n      try {\n        yield ethereum.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{\n            chainId: \"0x\".concat(network.chainId.toString(16))\n          }]\n        });\n        yield (0, exports.networkHasUpdated)(getChainId, network.chainId);\n      } catch (err) {\n        const {\n          code\n        } = err;\n        if (code === MetamaskRPCErrorCode.UnknownNetwork || code === MetamaskRPCErrorCode.UnrecognizedChainID) {\n          // ChainId not yet added to metamask\n          yield (0, exports.addNetworkToMetamask)(ethereum, network);\n          return switchToNetwork(network, ethereum, getChainId);\n        } else if (code === MetamaskRPCErrorCode.AwaitingUserConfirmation) {\n          // user has already been requested to switch the network\n          return;\n        } else {\n          throw err;\n        }\n      }\n    }\n  });\n}\nexports.switchToNetwork = switchToNetwork;\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst SLEEP = 500;\nconst MAX_WAIT_MINUTES = 3;\nconst MAX_RETRY = Math.round(MAX_WAIT_MINUTES * 1000 / SLEEP);\n// Hacky workaround to wait for the network to change.\\\nconst networkHasUpdated = (getChainId, expectedChainId) => __awaiter(void 0, void 0, void 0, function* () {\n  let attempts = 0;\n  let isNetworkUpdated = false;\n  while (!isNetworkUpdated) {\n    attempts++;\n    if (attempts >= MAX_RETRY) {\n      throw new Error('Network did not change');\n    }\n    const chainId = yield getChainId();\n    if (chainId === expectedChainId) {\n      isNetworkUpdated = true;\n      return true;\n    }\n    yield sleep(SLEEP);\n  }\n});\nexports.networkHasUpdated = networkHasUpdated;\nfunction getWalletChainId(ethereum) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const walletChainId = ethereum.chainId ? ethereum.chainId : yield ethereum.request({\n      method: 'eth_chainId'\n    });\n    return parseInt(walletChainId, 16);\n  });\n}\nexports.getWalletChainId = getWalletChainId;","map":null,"metadata":{},"sourceType":"script"}