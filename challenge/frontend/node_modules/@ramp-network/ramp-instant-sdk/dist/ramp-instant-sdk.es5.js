/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Older browsers don't support event options, feature detect it.

// Adopted and modified solution from Bohdan Didukh (2017)
// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi

var hasPassiveEvents = false;
if (typeof window !== 'undefined') {
  var passiveTestOptions = {
    get passive() {
      hasPassiveEvents = true;
      return undefined;
    }
  };
  window.addEventListener('testPassive', null, passiveTestOptions);
  window.removeEventListener('testPassive', null, passiveTestOptions);
}

var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);


var locks = [];
var documentListenerAdded = false;
var initialClientY = -1;
var previousBodyOverflowSetting = void 0;
var previousBodyPaddingRight = void 0;

// returns true if `el` should be allowed to receive touchmove events.
var allowTouchMove = function allowTouchMove(el) {
  return locks.some(function (lock) {
    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
      return true;
    }

    return false;
  });
};

var preventDefault = function preventDefault(rawEvent) {
  var e = rawEvent || window.event;

  // For the case whereby consumers adds a touchmove event listener to document.
  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
  // the touchmove event on document will break.
  if (allowTouchMove(e.target)) {
    return true;
  }

  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).
  if (e.touches.length > 1) return true;

  if (e.preventDefault) e.preventDefault();

  return false;
};

var setOverflowHidden = function setOverflowHidden(options) {
  // If previousBodyPaddingRight is already set, don't set it again.
  if (previousBodyPaddingRight === undefined) {
    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

    if (_reserveScrollBarGap && scrollBarGap > 0) {
      previousBodyPaddingRight = document.body.style.paddingRight;
      document.body.style.paddingRight = scrollBarGap + 'px';
    }
  }

  // If previousBodyOverflowSetting is already set, don't set it again.
  if (previousBodyOverflowSetting === undefined) {
    previousBodyOverflowSetting = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
  }
};

var restoreOverflowSetting = function restoreOverflowSetting() {
  if (previousBodyPaddingRight !== undefined) {
    document.body.style.paddingRight = previousBodyPaddingRight;

    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
    // can be set again.
    previousBodyPaddingRight = undefined;
  }

  if (previousBodyOverflowSetting !== undefined) {
    document.body.style.overflow = previousBodyOverflowSetting;

    // Restore previousBodyOverflowSetting to undefined
    // so setOverflowHidden knows it can be set again.
    previousBodyOverflowSetting = undefined;
  }
};

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions
var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
};

var handleScroll = function handleScroll(event, targetElement) {
  var clientY = event.targetTouches[0].clientY - initialClientY;

  if (allowTouchMove(event.target)) {
    return false;
  }

  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
    // element is at the top of its scroll.
    return preventDefault(event);
  }

  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
    // element is at the bottom of its scroll.
    return preventDefault(event);
  }

  event.stopPropagation();
  return true;
};

var disableBodyScroll = function disableBodyScroll(targetElement, options) {
  // targetElement must be provided
  if (!targetElement) {
    // eslint-disable-next-line no-console
    console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
    return;
  }

  // disableBodyScroll must not have been called on this targetElement before
  if (locks.some(function (lock) {
    return lock.targetElement === targetElement;
  })) {
    return;
  }

  var lock = {
    targetElement: targetElement,
    options: options || {}
  };

  locks = [].concat(_toConsumableArray(locks), [lock]);

  if (isIosDevice) {
    targetElement.ontouchstart = function (event) {
      if (event.targetTouches.length === 1) {
        // detect single touch.
        initialClientY = event.targetTouches[0].clientY;
      }
    };
    targetElement.ontouchmove = function (event) {
      if (event.targetTouches.length === 1) {
        // detect single touch.
        handleScroll(event, targetElement);
      }
    };

    if (!documentListenerAdded) {
      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
      documentListenerAdded = true;
    }
  } else {
    setOverflowHidden(options);
  }
};

var clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {
  if (isIosDevice) {
    // Clear all locks ontouchstart/ontouchmove handlers, and the references.
    locks.forEach(function (lock) {
      lock.targetElement.ontouchstart = null;
      lock.targetElement.ontouchmove = null;
    });

    if (documentListenerAdded) {
      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
      documentListenerAdded = false;
    }

    // Reset initial clientY.
    initialClientY = -1;
  } else {
    restoreOverflowSetting();
  }

  locks = [];
};

var baseWidgetUrl = 'https://buy.ramp.network/';

var PaymentMethodName;
(function (PaymentMethodName) {
    PaymentMethodName["MANUAL_BANK_TRANSFER"] = "MANUAL_BANK_TRANSFER";
    PaymentMethodName["AUTO_BANK_TRANSFER"] = "AUTO_BANK_TRANSFER";
    PaymentMethodName["CARD_PAYMENT"] = "CARD_PAYMENT";
    PaymentMethodName["APPLE_PAY"] = "APPLE_PAY";
})(PaymentMethodName || (PaymentMethodName = {}));
var PurchaseStatus;
(function (PurchaseStatus) {
    PurchaseStatus["INITIALIZED"] = "INITIALIZED";
    PurchaseStatus["PAYMENT_STARTED"] = "PAYMENT_STARTED";
    PurchaseStatus["PAYMENT_IN_PROGRESS"] = "PAYMENT_IN_PROGRESS";
    PurchaseStatus["PAYMENT_FAILED"] = "PAYMENT_FAILED";
    PurchaseStatus["PAYMENT_EXECUTED"] = "PAYMENT_EXECUTED";
    PurchaseStatus["FIAT_RECEIVED"] = "FIAT_RECEIVED";
    PurchaseStatus["FIAT_SENT"] = "FIAT_SENT";
    PurchaseStatus["EXPIRED"] = "EXPIRED";
    PurchaseStatus["CANCELLED"] = "CANCELLED";
    PurchaseStatus["RELEASING"] = "RELEASING";
    PurchaseStatus["RELEASED"] = "RELEASED";
})(PurchaseStatus || (PurchaseStatus = {}));
var EventSeverity;
(function (EventSeverity) {
    EventSeverity["VERBOSE"] = "VERBOSE";
    EventSeverity["DEBUG"] = "DEBUG";
    EventSeverity["INFO"] = "INFO";
    EventSeverity["WARNING"] = "WARNING";
    EventSeverity["ERROR"] = "ERROR";
    EventSeverity["CRITICAL"] = "CRITICAL";
})(EventSeverity || (EventSeverity = {}));
var WidgetEventTypes;
(function (WidgetEventTypes) {
    WidgetEventTypes["WIDGET_CLOSE"] = "WIDGET_CLOSE";
    WidgetEventTypes["WIDGET_CONFIG_DONE"] = "WIDGET_CONFIG_DONE";
    WidgetEventTypes["WIDGET_CONFIG_FAILED"] = "WIDGET_CONFIG_FAILED";
    WidgetEventTypes["PURCHASE_CREATED"] = "PURCHASE_CREATED";
})(WidgetEventTypes || (WidgetEventTypes = {}));
var InternalEventTypes;
(function (InternalEventTypes) {
    InternalEventTypes["WIDGET_CLOSE_REQUEST"] = "WIDGET_CLOSE_REQUEST";
    InternalEventTypes["WIDGET_CLOSE_REQUEST_CANCELLED"] = "WIDGET_CLOSE_REQUEST_CANCELLED";
    InternalEventTypes["WIDGET_CLOSE_REQUEST_CONFIRMED"] = "WIDGET_CLOSE_REQUEST_CONFIRMED";
    InternalEventTypes["REQUEST_CRYPTO_ACCOUNT"] = "REQUEST_CRYPTO_ACCOUNT";
})(InternalEventTypes || (InternalEventTypes = {}));
var InternalSdkEventTypes;
(function (InternalSdkEventTypes) {
    InternalSdkEventTypes["REQUEST_CRYPTO_ACCOUNT_RESULT"] = "REQUEST_CRYPTO_ACCOUNT_RESULT";
})(InternalSdkEventTypes || (InternalSdkEventTypes = {}));

function getRandomIntString() {
    try {
        return String(crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    catch (_a) {
        // if `crypto` is not supported, fall back to Math.random
        // tslint:disable-next-line:no-magic-numbers
        return String(Math.floor(Math.random() * 10000000));
    }
}
var widgetDesktopWidth = 895;
var widgetDesktopHeight = 590;
var minWidgetMobileWidth = 320;
var minWidgetMobileHeight = 667;
function normalizeConfigAndLogErrorsOnInvalidFields(config) {
    var errors = [];
    var configCopy = __assign({}, config);
    if (![
        'desktop',
        'mobile',
        'hosted-desktop',
        'hosted-mobile',
        'hosted-auto',
        'auto',
        'embedded-desktop',
        'embedded-mobile',
    ].includes(config.variant)) {
        configCopy.variant = 'desktop';
        errors.push({
            fieldName: 'variant',
            description: 'Invalid value for `variant` config field ',
            exampleValue: "'desktop'",
            severity: EventSeverity.WARNING,
        });
    }
    if (config.variant === 'embedded-desktop' || config.variant === 'embedded-mobile') {
        validateContainerNode(config.containerNode, config.variant);
    }
    if (!['embedded-desktop', 'embedded-mobile'].includes(configCopy.variant)) {
        delete configCopy.containerNode;
    }
    logErrors(errors);
    return configCopy;
}
function logErrors(errors) {
    if (!errors.length) {
        return;
    }
    // tslint:disable:no-console
    console.group('Config errors');
    errors.forEach(function (error) {
        console.group(error.fieldName);
        console.log(error.description);
        console.log("Example expected value: ".concat(error.exampleValue));
        console.log("Severity: ".concat(error.severity));
        console.groupEnd();
    });
    console.groupEnd();
    // tslint:enable:no-console
}
function initEventListenersDict() {
    var widgetEventTypes = Array.from(Object.values(WidgetEventTypes));
    var internalEventTypes = Array.from(Object.values(InternalEventTypes));
    return __spreadArray(__spreadArray([], widgetEventTypes, true), internalEventTypes, true).reduce(function (listenersDict, eventType) {
        listenersDict[eventType] = [];
        return listenersDict;
    }, {});
}
function determineWidgetVariant(config) {
    var _a;
    var mediaQuery = '(min-width: 920px) and (min-height: 630px)';
    var variant = (_a = config.variant) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
    if (variant === 'mobile' ||
        variant === 'desktop' ||
        variant === 'hosted-mobile' ||
        variant === 'hosted-desktop' ||
        variant === 'embedded-desktop' ||
        variant === 'embedded-mobile') {
        return variant;
    }
    var isDesktop = window.matchMedia(mediaQuery).matches;
    if (variant === 'hosted-auto') {
        return isDesktop ? 'hosted-desktop' : 'hosted-mobile';
    }
    return isDesktop ? 'desktop' : 'mobile';
}
function isHtmlElement(element) {
    return typeof element.blur === 'function';
}
function validateContainerNode(containerNode, variant) {
    if (!document.body) {
        throw new Error("Couldn't find <body> element.");
    }
    if (!(containerNode instanceof HTMLElement)) {
        throw new Error('Container node has to be a proper HTML element.');
    }
    if (!document.body.contains(containerNode)) {
        throw new Error('Container node must be attached to the document.');
    }
    var _a = containerNode.getBoundingClientRect(), width = _a.width, height = _a.height;
    if (variant === 'embedded-desktop') {
        if (width + 1 < widgetDesktopWidth) {
            throw new Error("Container node must be at least ".concat(widgetDesktopWidth, "px wide."));
        }
        if (height + 1 < widgetDesktopHeight) {
            throw new Error("Container node must be at least ".concat(widgetDesktopHeight, "px tall."));
        }
    }
    else if (variant === 'embedded-mobile') {
        if (width + 1 < minWidgetMobileWidth) {
            throw new Error("Container node must be at least ".concat(minWidgetMobileWidth, "px wide."));
        }
        if (height + 1 < minWidgetMobileHeight) {
            throw new Error("Container node must be at least ".concat(minWidgetMobileHeight, "px tall."));
        }
    }
}

function getBaseUrl(config) {
    return new URL(config.url || baseWidgetUrl);
}
function initWidgetIframeUrl(config) {
    var baseUrl = getBaseUrl(config);
    var hostUrl = window.location.origin;
    config.containerNode; config.url; var configWithoutIframeUrl = __rest(config, ["containerNode", "url"]);
    var preparedConfig = __assign(__assign({}, configWithoutIframeUrl), { hostUrl: hostUrl });
    Object.entries(preparedConfig).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        if (value) {
            baseUrl.searchParams.append(key, value);
        }
    });
    return baseUrl.toString();
}
function hideWebsiteBelow(parent, containerWidth) {
    var backgroundWebsiteHider = document.createElement('div');
    backgroundWebsiteHider.classList.add('background-hider');
    if (containerWidth) {
        backgroundWebsiteHider.style.maxWidth = "".concat(containerWidth, "px");
    }
    parent.appendChild(backgroundWebsiteHider);
}
function initDOMNodeWithOverlay(url, dispatch, config) {
    var body = document.querySelector('body');
    var shadowHost = document.createElement('div');
    shadowHost.style.width = '100%';
    shadowHost.style.height = '100%';
    var shadow = shadowHost.attachShadow({ mode: 'open' });
    shadow.appendChild(getStylesForShadowDom(config.variant));
    var iframe = prepareIframeNode(url, config.variant);
    var overlay = prepareOverlayNode(iframe, dispatch);
    overlay.appendChild(iframe);
    shadow.appendChild(overlay);
    return {
        body: body,
        iframe: iframe,
        overlay: overlay,
        shadow: shadow,
        shadowHost: shadowHost,
    };
}
function initDOMNodeWithoutOverlay(url, _dispatch, config) {
    var body = document.querySelector('body');
    var shadowHost = document.createElement('div');
    shadowHost.style.width = '100%';
    shadowHost.style.height = '100%';
    var shadow = shadowHost.attachShadow({ mode: 'open' });
    var container = document.createElement('div');
    container.classList.add('embedded-container');
    shadow.appendChild(container);
    var loader = document.createElement('div');
    loader.classList.add('loader-container');
    // tslint:disable:max-line-length
    loader.innerHTML = "\n    <svg width=\"92\" height=\"60\" viewBox=\"0 0 51 32\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"loader\">\n      <path d=\"M16.2232 18.8309L22.282 24.912C22.7953 25.4272 22.7948 26.2647 22.281 26.7792L17.651 31.4158C16.8619 32.1947 15.5719 32.1947 14.7828 31.4158L0.591812 17.4093C-0.197271 16.6305 -0.197271 15.3571 0.591812 14.5783L14.7828 0.584122C15.5719 -0.194707 16.8619 -0.194707 17.651 0.584122L22.281 5.22078C22.7948 5.73535 22.7953 6.57281 22.282 7.08795L16.2232 13.1691C14.645 14.7267 14.645 17.2733 16.2232 18.8309Z\" fill=\"#21BF73\"></path>\n      <path d=\"M34.4433 18.8309L28.3845 24.912C27.8712 25.4272 27.8717 26.2647 28.3855 26.7792L33.0155 31.4158C33.8046 32.1947 35.0946 32.1947 35.8837 31.4158L50.0747 17.4093C50.8638 16.6305 50.8638 15.3571 50.0747 14.5783L35.8837 0.584122C35.0946 -0.194707 33.8046 -0.194707 33.0155 0.584122L28.3855 5.22078C27.8717 5.73535 27.8712 6.57281 28.3845 7.08795L34.4433 13.1691C36.0215 14.7267 36.0215 17.2733 34.4433 18.8309Z\" fill=\"#0A6E5C\"></path>\n      <path d=\"M17.8128 17.157C17.1737 16.518 17.1737 15.482 17.8128 14.843L24.1765 8.47926C24.8155 7.84025 25.8515 7.84025 26.4905 8.47926L32.8542 14.843C33.4932 15.482 33.4932 16.518 32.8542 17.157L26.4905 23.5207C25.8515 24.1598 24.8155 24.1598 24.1765 23.5207L17.8128 17.157Z\" fill=\"#21BF73\"></path>\n    </svg>";
    // tslint:enable:max-line-length
    container.appendChild(loader);
    shadow.appendChild(getStylesForShadowDom(config.variant));
    var iframe = prepareIframeNode(url, config.variant, config.containerNode);
    container.appendChild(iframe);
    return {
        body: body,
        iframe: iframe,
        overlay: null,
        shadow: shadow,
        shadowHost: shadowHost,
    };
}
function importFonts() {
    if (document.querySelector('[data-ramp-font]')) {
        return;
    }
    var font = document.createElement('link');
    font.setAttribute('href', 'https://fonts.googleapis.com/css?family=Poppins:200,400,500,600,700&display=swap&subset=latin-ext');
    font.setAttribute('rel', 'stylesheet');
    font.setAttribute('data-ramp-font', '');
    document.head.appendChild(font);
}
function prepareIframeNode(url, variant, containerNode) {
    var iframe = document.createElement('iframe');
    iframe.setAttribute('src', url);
    if (containerNode) {
        iframe.setAttribute('width', variant === 'desktop' || variant === 'embedded-desktop'
            ? widgetDesktopWidth.toString()
            : containerNode.getBoundingClientRect().width.toString());
        iframe.setAttribute('height', variant === 'desktop' || variant === 'embedded-desktop'
            ? widgetDesktopHeight.toString()
            : containerNode.getBoundingClientRect().height.toString());
    }
    else {
        iframe.setAttribute('width', variant === 'desktop' || variant === 'embedded-desktop'
            ? widgetDesktopWidth.toString()
            : window.innerWidth.toString());
        iframe.setAttribute('height', variant === 'desktop' || variant === 'embedded-desktop'
            ? widgetDesktopHeight.toString()
            : window.innerHeight.toString());
    }
    iframe.setAttribute('allow', 'microphone; camera; clipboard-read; clipboard-write');
    iframe.classList.add('iframe');
    return iframe;
}
function prepareOverlayNode(iframe, dispatch) {
    var overlay = document.createElement('div');
    overlay.classList.add('overlay');
    var loader = document.createElement('div');
    loader.classList.add('loader-container');
    // tslint:disable:max-line-length
    loader.innerHTML = "\n    <svg width=\"92\" height=\"60\" viewBox=\"0 0 51 32\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"loader\">\n      <path d=\"M16.2232 18.8309L22.282 24.912C22.7953 25.4272 22.7948 26.2647 22.281 26.7792L17.651 31.4158C16.8619 32.1947 15.5719 32.1947 14.7828 31.4158L0.591812 17.4093C-0.197271 16.6305 -0.197271 15.3571 0.591812 14.5783L14.7828 0.584122C15.5719 -0.194707 16.8619 -0.194707 17.651 0.584122L22.281 5.22078C22.7948 5.73535 22.7953 6.57281 22.282 7.08795L16.2232 13.1691C14.645 14.7267 14.645 17.2733 16.2232 18.8309Z\" fill=\"#21BF73\"></path>\n      <path d=\"M34.4433 18.8309L28.3845 24.912C27.8712 25.4272 27.8717 26.2647 28.3855 26.7792L33.0155 31.4158C33.8046 32.1947 35.0946 32.1947 35.8837 31.4158L50.0747 17.4093C50.8638 16.6305 50.8638 15.3571 50.0747 14.5783L35.8837 0.584122C35.0946 -0.194707 33.8046 -0.194707 33.0155 0.584122L28.3855 5.22078C27.8717 5.73535 27.8712 6.57281 28.3845 7.08795L34.4433 13.1691C36.0215 14.7267 36.0215 17.2733 34.4433 18.8309Z\" fill=\"#0A6E5C\"></path>\n      <path d=\"M17.8128 17.157C17.1737 16.518 17.1737 15.482 17.8128 14.843L24.1765 8.47926C24.8155 7.84025 25.8515 7.84025 26.4905 8.47926L32.8542 14.843C33.4932 15.482 33.4932 16.518 32.8542 17.157L26.4905 23.5207C25.8515 24.1598 24.8155 24.1598 24.1765 23.5207L17.8128 17.157Z\" fill=\"#21BF73\"></path>\n    </svg>";
    // tslint:enable:max-line-length
    overlay.appendChild(loader);
    overlay.addEventListener('click', function (event) {
        if (event.target !== iframe && !overlay.querySelectorAll('.close-modal').length) {
            dispatch({
                type: InternalEventTypes.WIDGET_CLOSE_REQUEST,
                payload: null,
                internal: true,
            });
        }
    });
    return overlay;
}
function areUrlsEqual(url0, url1) {
    return new URL(url0).toString() === new URL(url1).toString();
}
function isCloseModalAlreadyOpen(containerNode) {
    return containerNode.querySelectorAll('.close-modal').length !== 0;
}
function prepareCloseModalNode(dispatch) {
    var container = document.createElement('div');
    container.classList.add('close-modal');
    var textEl = document.createElement('div');
    textEl.classList.add('close-modal__text');
    textEl.textContent = 'Are you sure you want to exit Ramp and abandon the transaction?';
    var buttonContainer = document.createElement('div');
    buttonContainer.classList.add('close-modal__button-container');
    var cancelButton = document.createElement('button');
    cancelButton.setAttribute('type', 'button');
    cancelButton.classList.add('close-modal__button');
    cancelButton.classList.add('close-modal__button--cancel');
    cancelButton.textContent = 'Cancel';
    cancelButton.addEventListener('click', function (event) {
        event.stopPropagation();
        dispatch({
            type: InternalEventTypes.WIDGET_CLOSE_REQUEST_CANCELLED,
            payload: null,
            internal: true,
        });
    });
    var exitButton = document.createElement('button');
    exitButton.setAttribute('type', 'button');
    exitButton.classList.add('close-modal__button');
    exitButton.classList.add('close-modal__button--exit');
    exitButton.textContent = 'Exit';
    exitButton.addEventListener('click', function (event) {
        event.stopPropagation();
        dispatch({
            type: InternalEventTypes.WIDGET_CLOSE_REQUEST_CONFIRMED,
            payload: null,
            internal: true,
        });
    });
    buttonContainer.appendChild(cancelButton);
    buttonContainer.appendChild(exitButton);
    container.appendChild(textEl);
    container.appendChild(buttonContainer);
    return container;
}
function getStylesForShadowDom(variant) {
    var styles = document.createElement('style');
    var isMobile = variant === 'mobile' || variant === 'hosted-mobile' || variant === 'embedded-mobile';
    var isEmbedded = variant === 'embedded-mobile' || variant === 'embedded-desktop';
    styles.textContent = "\n\n    .background-hider {\n      content: '';\n      height: 30vh;\n      width: 100vw;\n      position: fixed;\n      bottom: 0;\n      transform: translateY(50%);\n      background-color: #f5f8fb;\n      z-index: 999;\n    }\n\n    .overlay {\n      position: fixed;\n      z-index: 1000;\n      width: 100vw;\n      height: ".concat(isMobile ? '100%;' : '100vh;', "\n      top: 0;\n      left: 0;\n      overflow: hidden;\n      background-color: rgba(166, 174, 185, 0.7);\n      display: flex;\n      flex-flow: row nowrap;\n      justify-content: center;\n      ").concat(isMobile ? 'align-items: flex-start;' : 'align-items: center;', "\n    }\n\n    .embedded-container {\n      z-index: 1000;\n      position: relative;\n      width: 100%;\n      height: 100%;\n      display: flex;\n      flex-flow: row nowrap;\n      justify-content: center;\n      ").concat(isMobile ? 'align-items: flex-start;' : 'align-items: center;', "\n      min-width: ").concat(isMobile ? minWidgetMobileWidth : widgetDesktopWidth, "px;\n      min-height: ").concat(isMobile ? minWidgetMobileHeight : widgetDesktopHeight, "px;\n    }\n\n    .loader-container {\n      align-self: center;\n    }\n\n    .loader {\n      transform-origin: center;\n      animation: logoAnimation 4s linear infinite;\n      width: 100px;\n      height: auto;\n      align-self: center;\n    }\n\n    .loader path:nth-child(3) {\n      transform-origin: center;\n      position: relative;\n    }\n\n    .loader path:nth-child(1) {\n      transform-origin: center;\n      position: relative;\n      animation: box1Animation 4s linear infinite;\n      transform: scale(0.4) translateX(6px);\n    }\n\n    .loader path:nth-child(2) {\n      transform-origin: center;\n      position: relative;\n      animation: box4Animation 4s linear infinite;\n      transform: scale(0.4) translateX(-6px);\n    }\n\n    @keyframes logoAnimation {\n      10% {\n        transform: rotate(180deg);\n      }\n      30%{\n        transform: rotate(360deg);\n      }\n      70% {\n        transform: rotate(360deg);\n      }\n      90% {\n        transform: rotate(520deg);\n      }\n      100% {\n        transform: rotate(720deg);\n      }\n    }\n\n    @keyframes box1Animation {\n      0%, 10% {\n        transform: scale(0.4) translateX(6px);\n      }\n      30%, 70% {\n        transform: scale(1) translateX(0);\n      }\n      90% {\n        transform: scale(0.4) translateX(6px);\n      }\n    }\n\n\n    @keyframes box4Animation {\n      0%, 10% {\n        transform: scale(0.4) translateX(-6px);\n      }\n      30%, 70% {\n        transform: scale(1) translateX(0);\n      }\n      90% {\n        transform: scale(0.4) translateX(-6px);\n      }\n    }\n\n    .iframe {\n      border: none;\n      user-select: none;\n      visibility: hidden;\n      position: absolute;\n    }\n\n    .iframe.visible {\n      visibility: visible;\n      ").concat(!isEmbedded && isMobile
        ? "\n        width: 100vw;\n        height: 100%;\n      "
        : '', "\n    }\n\n    .close-modal {\n      font-family: 'Poppins', sans-serif;\n      width: 678px;\n      height: 276px;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      z-index: 9999;\n      box-shadow: 0px 54px 200px rgba(36, 37, 57, 0.2);\n      display: flex;\n      flex-flow: column nowrap;\n      justify-content: flex-start;\n      align-items: center;\n      padding: 35px;\n      border-radius: 8px;\n      background: #fff;\n\n      box-sizing: border-box;\n    }\n\n    .close-modal * {\n      box-sizing: border-box;\n    }\n\n    .close-modal__text {\n      margin: 40px auto 30px;\n      font-weight: 600;\n      font-size: 24px;\n      line-height: 36px;\n      text-align: center;\n\n      color: #242539;\n    }\n\n    .close-modal__button-container {\n      width: 318px;\n      display: flex;\n      flex-flow: row nowrap;\n      justify-content: space-between;\n      align-items: center;\n    }\n\n    .close-modal__button {\n      background: #fff;\n      border: 2px solid #EDEEF3;\n      border-radius: 74px;\n      width: 152px;\n      height: 56px;\n      cursor: pointer;\n      font-weight: 600;\n      font-size: 14px;\n      line-height: 21px;\n      color: #2B2D56;\n      text-transform: uppercase;\n    }\n\n    .close-modal__button--exit {\n      background: #DD3E56;\n      box-shadow: 0px 8px 34px rgba(221, 62, 86, 0.4);\n      color: #fff;\n      border-color: transparent;\n    }\n  ");
    return styles;
}

var RampInstantSDK = /** @class */ (function () {
    function RampInstantSDK(config) {
        this._listeners = initEventListenersDict();
        this._isVisible = false;
        importFonts();
        this.unsubscribe = this.unsubscribe.bind(this);
        this.on = this.on.bind(this);
        this.show = this.show.bind(this);
        this._handleEscapeClick = this._handleEscapeClick.bind(this);
        this._dispatchEvent = this._dispatchEvent.bind(this);
        this._subscribeToWidgetEvents = this._subscribeToWidgetEvents.bind(this);
        this._on = this._on.bind(this);
        this._registerSdkEventHandlers = this._registerSdkEventHandlers.bind(this);
        this._subscribeToWidgetEvents = this._subscribeToWidgetEvents.bind(this);
        this._rawNormalizedConfig = normalizeConfigAndLogErrorsOnInvalidFields(__assign({ variant: 'desktop' }, config));
        var widgetVariant = determineWidgetVariant(this._rawNormalizedConfig);
        this._config = __assign(__assign({}, this._rawNormalizedConfig), { variant: widgetVariant, widgetInstanceId: getRandomIntString() });
    }
    RampInstantSDK.prototype.show = function () {
        if (this._isVisible) {
            throw new Error('Widget is already visible - you can only call this once per instance');
        }
        if (document.activeElement && isHtmlElement(document.activeElement)) {
            document.activeElement.blur();
        }
        this._registerSdkEventHandlers();
        window.addEventListener('message', this._subscribeToWidgetEvents);
        if (this._isConfiguredAsHosted()) {
            this._showUsingHostedMode();
        }
        else if (this._isConfiguredAsEmbedded()) {
            this._showUsingEmbeddedMode();
        }
        else if (this._isConfiguredWithOverlay()) {
            this._showUsingOverlayMode();
        }
        window.addEventListener('keydown', this._handleEscapeClick, true);
        return this;
    };
    RampInstantSDK.prototype.on = function (type, callback) {
        this._on(type, callback, false);
        return this;
    };
    RampInstantSDK.prototype.unsubscribe = function (type, callback) {
        var _this = this;
        if (type === '*') {
            var allTypes = Object.entries(this._listeners);
            allTypes.forEach(function (_a) {
                var key = _a[0], eventHandlers = _a[1];
                var filteredHandlers = eventHandlers.filter(function (l) { return l.callback !== callback; });
                _this._listeners[key] = filteredHandlers;
            });
        }
        else {
            this._listeners[type] = this._listeners[type].filter(function (l) { return l.callback !== callback; });
        }
        return this;
    };
    RampInstantSDK.prototype._on = function (type, callback, internal) {
        if (type !== '*' && !this._listeners[type]) {
            // tslint:disable-next-line:no-console
            console.warn("Unknown / unsupported event name - '".concat(type, "'. This listener will have no effect."));
        }
        if (type === '*') {
            var allTypes = Object.values(this._listeners);
            allTypes.forEach(function (eventHandlers) { return eventHandlers.push({ callback: callback, internal: internal }); });
        }
        else {
            this._listeners[type].push({ callback: callback, internal: internal });
        }
    };
    RampInstantSDK.prototype.close = function () {
        this._dispatchEvent({
            type: WidgetEventTypes.WIDGET_CLOSE,
            payload: null,
            widgetInstanceId: this._config.widgetInstanceId,
        });
        return this;
    };
    RampInstantSDK.prototype.onRequestCryptoAccount = function (callback) {
        var _this = this;
        var onRequestCryptoAccount = function (event) { return __awaiter(_this, void 0, void 0, function () {
            var result, e_1, errorMessage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, callback(event.payload.type, event.payload.assetSymbol)];
                    case 1:
                        result = _a.sent();
                        if (!result.address) {
                            throw new Error('Missing address in the callback result');
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        errorMessage = void 0;
                        if (typeof e_1 === 'string') {
                            errorMessage = e_1;
                        }
                        else if (e_1 instanceof Error) {
                            errorMessage = e_1.message;
                        }
                        this._sendEventToWidget({
                            type: InternalSdkEventTypes.REQUEST_CRYPTO_ACCOUNT_RESULT,
                            payload: {
                                error: errorMessage,
                            },
                        });
                        return [2 /*return*/];
                    case 3:
                        this._sendEventToWidget({
                            type: InternalSdkEventTypes.REQUEST_CRYPTO_ACCOUNT_RESULT,
                            payload: {
                                address: result.address,
                                type: result.type,
                                name: result.name,
                                assetSymbol: result.assetSymbol,
                            },
                        });
                        return [2 /*return*/];
                }
            });
        }); };
        this._on(InternalEventTypes.REQUEST_CRYPTO_ACCOUNT, onRequestCryptoAccount, true);
        return this;
    };
    RampInstantSDK.prototype._subscribeToWidgetEvents = function (event) {
        if (!event.data) {
            return;
        }
        if (!areUrlsEqual(event.origin, getBaseUrl(this._config).origin)) {
            return;
        }
        var eventData = event.data;
        if (!eventData.widgetInstanceId ||
            eventData.widgetInstanceId !== this._config.widgetInstanceId) {
            return;
        }
        this._dispatchEvent(eventData);
    };
    RampInstantSDK.prototype._registerSdkEventHandlers = function () {
        var _this = this;
        this._on(WidgetEventTypes.WIDGET_CLOSE, function (_event) {
            var _a, _b;
            if (_this._isConfiguredAsHosted()) {
                try {
                    (_a = _this.widgetWindow) === null || _a === void 0 ? void 0 : _a.close();
                }
                catch (e) {
                    throw new Error('Could not close the widget window');
                }
            }
            else {
                (_b = _this.domNodes) === null || _b === void 0 ? void 0 : _b.shadowHost.remove();
                clearAllBodyScrollLocks();
            }
            _this._teardownEventSubscriptions();
        }, true);
        var onConfigEvent = function () {
            var _a, _b;
            if (_this._isConfiguredAsHosted()) {
                return;
            }
            (_a = _this.domNodes) === null || _a === void 0 ? void 0 : _a.iframe.classList.add('visible');
            var loader = (_b = _this.domNodes) === null || _b === void 0 ? void 0 : _b.shadow.querySelector('.loader-container');
            if (loader) {
                loader.remove();
            }
        };
        this._on(WidgetEventTypes.WIDGET_CONFIG_DONE, onConfigEvent, true);
        this._on(WidgetEventTypes.WIDGET_CONFIG_FAILED, onConfigEvent, true);
        this._on(InternalEventTypes.WIDGET_CLOSE_REQUEST, function (_event) {
            if (_this._isConfiguredAsHosted() || _this._isConfiguredAsEmbedded()) {
                return;
            }
            if (_this._config.variant === 'mobile' || isCloseModalAlreadyOpen(_this.domNodes.overlay)) {
                return;
            }
            _this.domNodes.overlay.appendChild(prepareCloseModalNode(_this._dispatchEvent));
        }, true);
        this._on(InternalEventTypes.WIDGET_CLOSE_REQUEST_CONFIRMED, function (_event) {
            _this._dispatchEvent({
                type: WidgetEventTypes.WIDGET_CLOSE,
                payload: null,
                widgetInstanceId: _this._config.widgetInstanceId,
            });
        }, true);
        this._on(InternalEventTypes.WIDGET_CLOSE_REQUEST_CANCELLED, function (_event) {
            if (_this._isConfiguredAsHosted() || _this._isConfiguredAsEmbedded()) {
                return;
            }
            var modal = _this.domNodes.overlay.querySelector('.close-modal');
            if (modal) {
                modal.remove();
            }
        }, true);
    };
    RampInstantSDK.prototype._sendEventToWidget = function (event) {
        var _a, _b, _c;
        if (!this._isVisible) {
            throw new Error("Widget is not visible couldn't send the event");
        }
        try {
            (_c = ((_a = this.widgetWindow) !== null && _a !== void 0 ? _a : (_b = this.domNodes) === null || _b === void 0 ? void 0 : _b.iframe.contentWindow)) === null || _c === void 0 ? void 0 : _c.postMessage(event, getBaseUrl(this._config).origin);
            // tslint:disable-next-line:no-empty
        }
        catch (_d) { }
    };
    RampInstantSDK.prototype._dispatchEvent = function (event) {
        var type = event.type;
        this._listeners[type].forEach(function (handler) { return handler.callback(event); });
    };
    RampInstantSDK.prototype._handleEscapeClick = function (event) {
        var escKeyCode = 27;
        if (event.key === 'Escape' || event.key === 'Esc' || event.keyCode === escKeyCode) {
            this._dispatchEvent({
                type: InternalEventTypes.WIDGET_CLOSE_REQUEST,
                payload: null,
                internal: true,
            });
        }
    };
    // Event subscriptions aren't cleared so that host can receive a PAYMENT_SUCCESSFUL event
    // even after the widget has been closed
    RampInstantSDK.prototype._teardownEventSubscriptions = function () {
        window.removeEventListener('keydown', this._handleEscapeClick, true);
        window.removeEventListener('message', this._subscribeToWidgetEvents);
    };
    RampInstantSDK.prototype._showUsingEmbeddedMode = function () {
        var _a, _b;
        var widgetUrl = initWidgetIframeUrl(this._config);
        this.domNodes = initDOMNodeWithoutOverlay(widgetUrl, this._dispatchEvent, this._config);
        if (!((_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.body)) {
            throw new Error("Couldn't find <body> element.");
        }
        (_b = this._config.containerNode) === null || _b === void 0 ? void 0 : _b.appendChild(this.domNodes.shadowHost);
        this._isVisible = true;
    };
    RampInstantSDK.prototype._showUsingOverlayMode = function () {
        var _a;
        var widgetUrl = initWidgetIframeUrl(this._config);
        this.domNodes = initDOMNodeWithOverlay(widgetUrl, this._dispatchEvent, this._config);
        if (!((_a = this.domNodes) === null || _a === void 0 ? void 0 : _a.body)) {
            throw new Error("Couldn't find <body> element.");
        }
        this.domNodes.body.appendChild(this.domNodes.shadowHost);
        this._isVisible = true;
        disableBodyScroll(this.domNodes.iframe);
        var widgetMode = determineWidgetVariant(this._config);
        if (widgetMode !== 'desktop' && widgetMode !== 'embedded-desktop') {
            hideWebsiteBelow(this.domNodes.shadow);
        }
    };
    RampInstantSDK.prototype._showUsingHostedMode = function () {
        var _a;
        var widgetUrl = initWidgetIframeUrl(this._config);
        this.widgetWindow = (_a = window.open(widgetUrl)) !== null && _a !== void 0 ? _a : undefined;
    };
    RampInstantSDK.prototype._isConfiguredWithOverlay = function () {
        return ['desktop', 'mobile'].includes(this._config.variant);
    };
    RampInstantSDK.prototype._isConfiguredAsHosted = function () {
        return ['hosted-desktop', 'hosted-mobile'].includes(this._config.variant);
    };
    RampInstantSDK.prototype._isConfiguredAsEmbedded = function () {
        return ['embedded-desktop', 'embedded-mobile'].includes(this._rawNormalizedConfig.variant);
    };
    return RampInstantSDK;
}());

export { WidgetEventTypes as RampInstantEventTypes, RampInstantSDK };
//# sourceMappingURL=ramp-instant-sdk.es5.js.map
