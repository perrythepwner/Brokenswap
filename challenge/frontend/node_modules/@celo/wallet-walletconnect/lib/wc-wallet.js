"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectWallet = void 0;
const base_1 = require("@celo/base");
const wallet_remote_1 = require("@celo/wallet-remote");
const sign_client_1 = __importDefault(require("@walletconnect/sign-client"));
const utils_1 = require("@walletconnect/utils");
const debug_1 = __importDefault(require("debug"));
const events_1 = __importDefault(require("events"));
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_2 = require("./utils");
const canceler_1 = __importDefault(require("./utils/canceler"));
const wc_signer_1 = require("./wc-signer");
const debug = (0, debug_1.default)('kit:wallet:wallet-connect-wallet');
/**
 * Session establishment happens out of band so after somehow
 * communicating the connection URI (often via QR code) we can
 * continue with the setup process
 */
function waitForTruthy(getValue, signal, waitDuration = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        if (signal.canceled || getValue()) {
            return;
        }
        yield (0, base_1.sleep)(waitDuration);
        return waitForTruthy(getValue, signal, waitDuration);
    });
}
const defaultInitOptions = {
    logger: process.env.NODE_ENV === 'production' ? 'error' : 'debug',
    metadata: {
        name: 'react-celo',
        description: "Celo's react-celo is a library to help developers and validators to interact with the celo-blockchain.",
        url: 'https://github.com/celo-org/celo-monorepo/tree/master/packages/sdk/contractkit',
        icons: ['https://avatars.githubusercontent.com/u/37552875?s=200&v=4'],
    },
};
const requiredNamespaces = {
    eip155: {
        chains: [],
        methods: [types_1.SupportedMethods.signTransaction],
        events: ['accountsChanged'],
    },
};
const optionalNamespaces = {
    eip155: {
        chains: [
            'eip155:44787',
            'eip155:42220',
            'eip155:17323',
            'eip155:62320', // baklava
        ],
        methods: Object.values(types_1.SupportedMethods),
        events: ['chainChanged', 'accountsChanged'],
    },
};
class WalletConnectWallet extends wallet_remote_1.RemoteWallet {
    constructor({ init, projectId, chainId }) {
        super();
        this.emitter = new events_1.default();
        this.signers = new Map();
        this.on = (event, fn) => {
            this.emitter.on(event, fn);
        };
        this.emit = (event, error, data) => {
            console.info('emit', event, error, data);
            this.emitter.emit(event, error, data);
        };
        this.onSessionProposal = (session) => {
            this.emit('session_proposal', null, session);
        };
        this.onSessionUpdated = (session) => {
            var _a;
            const { topic, params: { namespaces }, } = session;
            const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);
            this.session = Object.assign(Object.assign({}, _session), { namespaces });
            this.emit('session_update', null, session);
        };
        this.onSessionExtended = (session) => {
            var _a;
            const { topic } = session;
            const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);
            this.session = Object.assign({}, _session);
            this.emit('session_extend', null, session);
        };
        this.onSessionExpire = ({ topic }) => {
            var _a, _b, _c;
            // can you be connected to a topic that isnt the main topic? how to just disconnect that topic?
            if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {
                void this.close();
            }
            else if ((_b = this.client) === null || _b === void 0 ? void 0 : _b.pairing.values) {
                const sessionForTopic = this.client.pairing.values.find((connection) => connection.topic === topic);
                console.warn('received session expired for topic', topic, 'which is not the topic of session', (_c = this.session) === null || _c === void 0 ? void 0 : _c.topic, 'session with such topic in storage', sessionForTopic || 'false');
            }
        };
        this.onSessionDeleted = (session) => {
            this.emit('session_delete', null, session);
            void this.close().catch((e) => {
                console.error('error closing session', e);
            });
        };
        this.onSessionEvent = (event) => {
            this.emit('session_event', null, event);
        };
        this.onSessionPing = (ping) => {
            this.emit('session_ping', null, ping);
        };
        this.onSessionRequest = (request) => {
            this.emit('session_request', null, request);
        };
        this.close = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (!this.client) {
                throw new Error('Wallet must be initialized before calling close()');
            }
            this.canceler.cancel();
            const reason = (0, utils_1.getSdkError)('USER_DISCONNECTED');
            const connections = this.client.pairing.values;
            this.session && this.client.session.delete((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic, reason);
            yield Promise.all(connections.map((connection) => {
                try {
                    console.info('closing wc connection', connection, reason);
                    return this.client.disconnect({
                        topic: connection.topic,
                        reason,
                    });
                }
                catch (e) {
                    console.error('Error closing wc connection', connection, reason, e);
                }
            }));
            // ensures pairing is deleted so wallet doesnt have a lingering one.
            if (((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) && this.client.pairing) {
                yield ((_c = this.client.pairing) === null || _c === void 0 ? void 0 : _c.delete(this.session.topic, reason));
            }
            this.client = undefined;
            this.session = undefined;
        });
        this.canceler = new canceler_1.default();
        this.initOptions = Object.assign(Object.assign(Object.assign({}, defaultInitOptions), init), { projectId });
        this.chainId = chainId;
        void this.getWalletConnectClient()
            .then((client) => __awaiter(this, void 0, void 0, function* () {
            this.client = client;
            this.setupListeners();
            // when we're in certain environments (like the browser) the
            // WalletConnect client will handle retrieving old sessions.
            if (client.session) {
                const session = client.session
                    .getAll()
                    .sort((a, b) => b.expiry - a.expiry)
                    .find((x) => x.acknowledged && x.expiry * 1000 > Date.now());
                if (session) {
                    try {
                        yield client.extend({
                            topic: session.topic,
                        });
                    }
                    catch (e) {
                        debug('session resurrection, extend failed, wallet most likely refuses session extensions', e);
                    }
                    this.session = session;
                    // It might be better not to emit an event here. after all this is a fake event anyway.
                    this.emit('session_update', null, {
                        id: 0,
                        topic: session.topic,
                        params: { namespaces: session.namespaces },
                    });
                }
            }
        }))
            .catch((e) => {
            debug('session resurrection failed', e);
            this.emit('session_update', e);
        });
    }
    hasSession() {
        return __awaiter(this, void 0, void 0, function* () {
            yield waitForTruthy(() => !!this.session, this.canceler.status);
        });
    }
    setupListeners() {
        if (!this.client)
            return;
        this.client.on('session_proposal', this.onSessionProposal);
        this.client.on('session_update', this.onSessionUpdated);
        this.client.on('session_delete', this.onSessionDeleted);
        // currently when disconnecting the pairing from the offical wc w implementation
        // https://react-wallet.walletconnect.com/pairings our dapp does not disconnect.
        this.client.pairing.core.events.on('wc_pairingDeleted', this.onSessionDeleted);
        this.client.core.on('subscription_deleted', this.onSessionDeleted);
        this.client.pairing.core.on('wc_pairingDeleted', this.onSessionDeleted);
        this.client.on('session_extend', this.onSessionExtended);
        this.client.on('session_event', this.onSessionEvent);
        this.client.on('session_expire', this.onSessionExpire);
        this.client.on('session_ping', this.onSessionPing);
        this.client.on('session_request', this.onSessionRequest);
    }
    /**
     * Pulled out to allow mocking
     */
    getWalletConnectClient() {
        return sign_client_1.default.init(this.initOptions);
    }
    switchToChain(params) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                return true;
            }
            // check if session already has the desired chain in it by checking accounts and chains
            const accountSessions = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces) === null || _b === void 0 ? void 0 : _b.eip155) === null || _c === void 0 ? void 0 : _c.accounts) === null || _d === void 0 ? void 0 : _d.filter((eip155ChainAccount) => this.chainId.toString() === (0, utils_2.parseAddress)(eip155ChainAccount).networkId);
            const chainSessions = (_f = (_e = this.session) === null || _e === void 0 ? void 0 : _e.namespaces.eip155.chains) === null || _f === void 0 ? void 0 : _f.filter((prefixedChain) => prefixedChain === `eip155:${params.chainId}`);
            if (!(accountSessions === null || accountSessions === void 0 ? void 0 : accountSessions.length) && !(chainSessions === null || chainSessions === void 0 ? void 0 : chainSessions.length)) {
                const accounts = this.session.namespaces.eip155.accounts;
                // update the chain data in the session.
                // this is necessary since we only require the current chain when connecting and some wallets
                //  might not notice the optional namespace chains and thus not include them on the namespaces when connecting even if they do in fact support them
                try {
                    const updatingSession = {
                        topic: this.session.topic,
                        namespaces: {
                            eip155: {
                                accounts: accounts.concat(accounts.map((account) => {
                                    return `eip155:${params.chainId}:${(0, utils_2.parseAddress)(account).address}`;
                                })),
                                chains: (((_g = this.session) === null || _g === void 0 ? void 0 : _g.namespaces.eip155.chains) || []).concat([
                                    `eip155:${params.chainId}`,
                                ]),
                                methods: this.session.namespaces.eip155.methods,
                                events: this.session.namespaces.eip155.events,
                            },
                        },
                    };
                    const resp = yield ((_h = this.client) === null || _h === void 0 ? void 0 : _h.update(updatingSession));
                    yield (resp === null || resp === void 0 ? void 0 : resp.acknowledged());
                    // ensure we have the new data on the local session.
                    this.onSessionUpdated({
                        id: 0,
                        topic: updatingSession.topic,
                        params: { namespaces: updatingSession.namespaces },
                    });
                    return true;
                }
                catch (e) {
                    console.error(`switchToChain failed, wallet likely does not support ${params.chainId}`, e);
                    return false;
                }
            }
            this.chainId = params.chainId;
            yield this.loadAccountSigners();
            return true;
        });
    }
    /**
     * Get the URI needed for out of band session establishment
     */
    getUri() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.client = this.client || (yield this.getWalletConnectClient());
            if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.acknowledged) &&
                ((_b = this.session) === null || _b === void 0 ? void 0 : _b.expiry) &&
                ((_c = this.session) === null || _c === void 0 ? void 0 : _c.expiry) * 1000 > Date.now()) {
                return;
            }
            this.setupListeners();
            // wallets will literally fail if they don't support a chainId in the required namespaces
            // likewise wallets return an error if they dont support a method in the required namespaces
            // therefore required really is required and we add new chain to namespaces when switching chains. see switchToChain
            const { uri, approval } = yield this.client.connect({
                requiredNamespaces: {
                    eip155: Object.assign(Object.assign({}, requiredNamespaces.eip155), { chains: [`eip155:${this.chainId}`] }),
                },
                optionalNamespaces,
            });
            void approval()
                .then((session) => {
                console.info('approved session', session);
                this.session = session;
                this.emit('session_update', null, {
                    id: 1,
                    topic: session.topic,
                    params: { namespaces: session.namespaces },
                });
            })
                .catch((err) => {
                this.emit('session_update', err);
            });
            return uri;
        });
    }
    loadAccountSigners() {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * Session establishment happens out of band so after somehow
             * communicating the connection URI (often via QR code) we can
             * continue with the setup process
             */
            yield waitForTruthy(() => !!this.session, this.canceler.status);
            if (this.canceler.status.canceled) {
                // This will be true if this.canceler.cancel() was called earlier
                throw constants_1.CANCELED;
            }
            const addressToSigner = new Map();
            const allNamespaceAccounts = Object.values(this.session.namespaces)
                .map((namespace) => namespace.accounts)
                .flat();
            // namespace.accounts is an array of chain prefixed addresses,
            // we should not be assuming that every address can work for every chain. but instead filtering based on chain prefix.
            allNamespaceAccounts
                .filter((addressLike) => {
                const { networkId } = (0, utils_2.parseAddress)(addressLike);
                return networkId === String(this.chainId); // chain id matches this.chainId
            })
                .forEach((addressLike) => {
                const { address } = (0, utils_2.parseAddress)(addressLike);
                const signer = new wc_signer_1.WalletConnectSigner(this.client, this.session, address, String(this.chainId));
                addressToSigner.set(address, signer);
                this.addSigner(address, signer);
            });
            // note the parent of this class has  a private signers map at addressSigners. which is what addSigner and GetSigner access
            this.signers = addressToSigner;
            return addressToSigner;
        });
    }
    /**
     * Gets the signer based on the 'from' field in the tx body
     * @param txParams Transaction to sign
     * @dev overrides WalletBase.signTransaction
     */
    signTransaction(txParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromAddress = txParams.from.toString();
            const signer = this.getSigner(fromAddress);
            return signer.signRawTransaction(txParams);
        });
    }
}
exports.WalletConnectWallet = WalletConnectWallet;
//# sourceMappingURL=wc-wallet.js.map