"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAddress = void 0;
const address_1 = require("@celo/utils/lib/address");
function invalidChain(chain) {
    return chain !== 'celo' && chain !== 'eip155';
}
// celo:0x123
function parseShortNameAddress(addressLike) {
    const [celo, address] = addressLike.split(':');
    if (invalidChain(celo) || !(0, address_1.isValidAddress)(address)) {
        throw new Error('Invalid short name address');
    }
    // default to mainnet
    return { address, networkId: '42220' };
}
// <address>@<chain>:<network_id>
// 0x123@celo:1234
// 0x123@eip155:1234
function parseCaip50Address(addressLike) {
    const [address, chain, networkId] = addressLike.split(/[@:]/);
    if (!(0, address_1.isValidAddress)(address) || invalidChain(chain)) {
        throw new Error(`Invalid CAIP50 address ${address}`);
    }
    return { address, networkId };
}
// <chain>:<network_id>:<address>
// celo:1234:0x123
// eip155:1234:0x123
function parseCaip10Address(addressLike) {
    const [chain, networkId, address] = addressLike.split(':');
    if (!(0, address_1.isValidAddress)(address) || invalidChain(chain)) {
        throw new Error(`Invalid CAIP10 address ${address}`);
    }
    return { address, networkId };
}
function parseAddress(addressLike) {
    let lastError;
    for (const parse of [
        parseCaip10Address,
        parseCaip50Address,
        parseShortNameAddress,
    ]) {
        try {
            return parse(addressLike);
        }
        catch (e) {
            lastError = e;
        }
    }
    throw lastError;
}
exports.parseAddress = parseAddress;
//# sourceMappingURL=parse-addresses.js.map