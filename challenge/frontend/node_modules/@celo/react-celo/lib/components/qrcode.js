"use strict";
/**
  This QRCode generator is inspired from
  https://github.com/rainbow-me/rainbow-button/blob/master/src/components/qrcode/QRCode.tsx
  which is registered under the MIT license
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const qrcode_1 = require("qrcode");
const react_1 = __importStar(require("react"));
const use_theme_1 = __importDefault(require("../hooks/use-theme"));
const logger_1 = require("../utils/logger");
const tailwind_1 = __importDefault(require("../utils/tailwind"));
// From https://github.com/soldair/node-qrcode#qr-code-capacity
const qrCodeCapacity = [
    // ['H', 1273],
    // ['Q', 1663],
    ['M', 2331],
    ['L', 2953],
];
const generateMatrix = (value) => {
    const bytes = Buffer.from(value).byteLength;
    let i = 0;
    while (qrCodeCapacity[i][1] <= bytes) {
        i++;
    }
    const qrcode = (0, qrcode_1.create)(value, {
        errorCorrectionLevel: qrCodeCapacity[i][0],
    });
    const arr = Array.from(qrcode.modules.data);
    const sqrt = Math.sqrt(arr.length);
    return arr.reduce((rows, key, index) => {
        if (index % sqrt === 0) {
            rows.push([key]);
        }
        else {
            rows[rows.length - 1].push(key);
        }
        return rows;
    }, []);
};
const BORDER_RADIUS = 2;
const CORNER_SQUARES = 3;
const MASK_SIZE = 7;
function matrixToCorners(matrix, size) {
    const rects = [];
    const cellSize = size / matrix.length;
    const corners = [
        [0, 0],
        [1, 0],
        [0, 1],
    ];
    for (let index = 0; index < corners.length; index++) {
        const [x, y] = corners[index];
        const x1 = (matrix.length - MASK_SIZE) * cellSize * x;
        const y1 = (matrix.length - MASK_SIZE) * cellSize * y;
        for (let i = 0; i < CORNER_SQUARES; i++) {
            rects.push(react_1.default.createElement("rect", { className: i % 2 !== 0 ? 'tw-fill-white' : 'tw-fill-black', height: cellSize * (MASK_SIZE - i * 2), key: `corner-${x}-${y}-${i}`, rx: (i - BORDER_RADIUS - 1) * -BORDER_RADIUS + (i === 0 ? 2 : 0), ry: (i - BORDER_RADIUS - 1) * -BORDER_RADIUS + (i === 0 ? 2 : 0), width: cellSize * (MASK_SIZE - i * 2), x: x1 + cellSize * i, y: y1 + cellSize * i }));
        }
    }
    return rects;
}
function matrixToDots(matrix, size) {
    const dots = [];
    const cellSize = size / matrix.length;
    const matrixMiddleStart = matrix.length / 2;
    const matrixMiddleEnd = matrix.length / 2 - 1;
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            const data = matrix[i][j];
            if (!data)
                continue;
            if (!((i < MASK_SIZE && j < MASK_SIZE) ||
                (i > matrix.length - (MASK_SIZE + 1) && j < MASK_SIZE) ||
                (i < MASK_SIZE && j > matrix.length - (MASK_SIZE + 1)))) {
                if (!(i > matrixMiddleStart &&
                    i < matrixMiddleEnd &&
                    j > matrixMiddleStart &&
                    j < matrixMiddleEnd &&
                    i < j &&
                    j < i + 1)) {
                    dots.push(react_1.default.createElement("circle", { cx: i * cellSize + cellSize / 3, cy: j * cellSize + cellSize / 3, className: "tw-fill-black", key: `circle-${i}-${j}`, r: cellSize / 3 }));
                }
            }
        }
    }
    return dots;
}
const styles = (0, tailwind_1.default)({
    container: `
    tw-border
    tw-relative
    tw-select-none
    tw-p-5
    tw-rounded-lg
    tw-bg-white`,
});
const PrettyQrCode = ({ size = 200, value }) => {
    const theme = (0, use_theme_1.default)();
    const matrix = (0, react_1.useMemo)(() => {
        const _matrix = generateMatrix(value);
        (0, logger_1.getApplicationLogger)().debug('[PrettyQrCode]', 'Generated matrix');
        return _matrix;
    }, [value]);
    const corners = (0, react_1.useMemo)(() => matrixToCorners(matrix, size), [size, matrix]);
    const dots = (0, react_1.useMemo)(() => matrixToDots(matrix, size), [size, matrix]);
    return (react_1.default.createElement("div", { className: styles.container, style: { borderColor: theme.muted } },
        react_1.default.createElement("svg", { height: size, style: { all: 'revert' }, width: size },
            react_1.default.createElement("rect", { fill: "transparent", height: size, width: size }),
            corners,
            dots)));
};
exports.default = PrettyQrCode;
//# sourceMappingURL=qrcode.js.map