"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resurrector = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
const base_1 = require("@celo/contractkit/lib/base");
const connectors_1 = require("../connectors");
const constants_1 = require("../constants");
const local_storage_1 = require("./local-storage");
const logger_1 = require("./logger");
function resurrector(networks, dapp, manualNetworkingMode) {
    const walletType = (0, local_storage_1.getTypedStorageKey)(constants_1.localStorageKeys.lastUsedWalletType);
    const network = getNetwork(networks);
    if (!walletType || !network)
        return null;
    (0, logger_1.getApplicationLogger)().log('[resurrector] will create', walletType, 'with', network, dapp);
    try {
        switch (walletType) {
            case constants_1.WalletTypes.Ledger: {
                const index = (0, local_storage_1.getTypedStorageKey)(constants_1.localStorageKeys.lastUsedIndex);
                if (index === null)
                    return null;
                return new connectors_1.LedgerConnector(network, index, base_1.CeloContract.GoldToken);
            }
            case constants_1.WalletTypes.CeloExtensionWallet:
                return new connectors_1.CeloExtensionWalletConnector(network, base_1.CeloContract.GoldToken);
            case constants_1.WalletTypes.MetaMask:
                return new connectors_1.MetaMaskConnector(network, manualNetworkingMode, base_1.CeloContract.GoldToken);
            case constants_1.WalletTypes.Injected:
                return new connectors_1.InjectedConnector(network, manualNetworkingMode, base_1.CeloContract.GoldToken, undefined);
            case constants_1.WalletTypes.PrivateKey: {
                const privateKey = (0, local_storage_1.getTypedStorageKey)(constants_1.localStorageKeys.lastUsedPrivateKey);
                return new connectors_1.PrivateKeyConnector(network, privateKey, base_1.CeloContract.GoldToken);
            }
            case constants_1.WalletTypes.CoinbaseWallet:
                return new connectors_1.CoinbaseWalletConnector(network, manualNetworkingMode, dapp);
            case constants_1.WalletTypes.CeloDance:
            case constants_1.WalletTypes.CeloTerminal:
            case constants_1.WalletTypes.CeloWallet:
            case constants_1.WalletTypes.Valora:
            case constants_1.WalletTypes.WalletConnect: {
                return new connectors_1.WalletConnectConnector(network, manualNetworkingMode, base_1.CeloContract.GoldToken, {
                    projectId: dapp.walletConnectProjectId,
                    chainId: network.chainId,
                    init: {
                        metadata: Object.assign(Object.assign({}, dapp), { icons: [dapp.icon] }),
                    },
                });
            }
            case constants_1.WalletTypes.Unauthenticated:
                return null;
        }
    }
    catch (e) {
        (0, logger_1.getApplicationLogger)().error('Unknown error resurrecting', walletType, e);
        return null;
    }
}
exports.resurrector = resurrector;
function getNetwork(networks) {
    const networkName = (0, local_storage_1.getTypedStorageKey)(constants_1.localStorageKeys.lastUsedNetwork);
    if (!networkName)
        return;
    const network = networks.find((net) => net.name === networkName);
    return network;
}
//# sourceMappingURL=resurrector.js.map