"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWalletChainId = exports.networkHasUpdated = exports.switchToNetwork = exports.addNetworksToMetamask = exports.addNetworkToMetamask = exports.addTokensToMetamask = exports.makeAddCeloTokensParams = exports.tokenToParam = exports.makeNetworkParams = exports.MetamaskRPCErrorCode = void 0;
const mini_kit_1 = require("@celo/contractkit/lib/mini-kit");
const constants_1 = require("../constants");
const types_1 = require("../types");
const CELO_PARAMS = Object.freeze({
    chainName: 'Celo',
    testnet: false,
    nativeCurrency: {
        name: 'CELO',
    },
});
const ALFAJORES_PARAMS = Object.freeze({
    chainName: 'Alfajores Testnet',
    testnet: true,
    nativeCurrency: {
        name: 'A-CELO',
    },
});
const BAKLAVA_PARAMS = Object.freeze({
    chainName: 'Baklava Testnet',
    testnet: true,
    nativeCurrency: {
        name: 'B-CELO',
    },
});
const CANNOLI_PARAMS = Object.freeze({
    chainName: 'Cannoli Testnet',
    testnet: true,
    nativeCurrency: {
        name: 'C-CELO',
    },
});
const PARAMS = {
    [types_1.ChainId.Mainnet]: CELO_PARAMS,
    [types_1.ChainId.Alfajores]: ALFAJORES_PARAMS,
    [types_1.ChainId.Baklava]: BAKLAVA_PARAMS,
    [types_1.ChainId.Cannoli]: CANNOLI_PARAMS,
};
// First Class Supported Networks
const NETWORKS = {
    [types_1.ChainId.Mainnet]: constants_1.Mainnet,
    [types_1.ChainId.Alfajores]: constants_1.Alfajores,
    [types_1.ChainId.Baklava]: constants_1.Baklava,
    [types_1.ChainId.Cannoli]: constants_1.Cannoli,
};
var MetamaskRPCErrorCode;
(function (MetamaskRPCErrorCode) {
    MetamaskRPCErrorCode[MetamaskRPCErrorCode["AwaitingUserConfirmation"] = -32002] = "AwaitingUserConfirmation";
    MetamaskRPCErrorCode[MetamaskRPCErrorCode["UnrecognizedChainID"] = -32603] = "UnrecognizedChainID";
    MetamaskRPCErrorCode[MetamaskRPCErrorCode["UnknownNetwork"] = 4902] = "UnknownNetwork";
})(MetamaskRPCErrorCode = exports.MetamaskRPCErrorCode || (exports.MetamaskRPCErrorCode = {}));
const makeNetworkParams = (info, CELO) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const [symbol, decimals] = yield Promise.all([
        CELO.symbol(),
        CELO.decimals(),
    ]);
    return {
        chainId: `0x${info.chainId.toString(16)}`,
        chainName: (_a = PARAMS[info.chainId].chainName) !== null && _a !== void 0 ? _a : info.name,
        nativeCurrency: {
            name: PARAMS[info.chainId].nativeCurrency.name,
            symbol,
            decimals,
        },
        rpcUrls: [info.rpcUrl],
        blockExplorerUrls: [info.explorer],
        iconUrls: [`https://celoreserve.org/assets/tokens/${symbol}.svg`], // unfortunately unused
    };
});
exports.makeNetworkParams = makeNetworkParams;
const tokenToParam = (token) => __awaiter(void 0, void 0, void 0, function* () {
    const [symbol, decimals, name] = yield Promise.all([
        token.symbol(),
        token.decimals(),
        token.name(),
    ]);
    return {
        type: 'ERC20',
        options: {
            address: token.address,
            name,
            symbol,
            decimals,
            image: `https://reserve.mento.org/assets/tokens/${symbol}.svg`,
        },
    };
});
exports.tokenToParam = tokenToParam;
const makeAddCeloTokensParams = (tokens) => __awaiter(void 0, void 0, void 0, function* () { return Promise.all(Object.values(tokens).map(exports.tokenToParam)); });
exports.makeAddCeloTokensParams = makeAddCeloTokensParams;
const addTokensToMetamask = (ethereum, tokens) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenParams = yield (0, exports.makeAddCeloTokensParams)(tokens);
    const added = (yield Promise.all(tokenParams.map((params) => ethereum === null || ethereum === void 0 ? void 0 : ethereum.request({
        method: 'wallet_watchAsset',
        params,
    })))).every(Boolean);
    return added;
});
exports.addTokensToMetamask = addTokensToMetamask;
const addNetworkToMetamask = (ethereum, networkConfig) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // For Celo Chains
        if (Object.keys(NETWORKS).includes(networkConfig.chainId.toString())) {
            const _b = (yield (0, mini_kit_1.newKit)(networkConfig.rpcUrl).celoTokens.getWrappers()), { CELO } = _b, tokens = __rest(_b, ["CELO"]);
            yield (ethereum === null || ethereum === void 0 ? void 0 : ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [yield (0, exports.makeNetworkParams)(networkConfig, CELO)],
            }));
            yield (0, exports.addTokensToMetamask)(ethereum, tokens);
            // For other chains
        }
        else {
            yield (ethereum === null || ethereum === void 0 ? void 0 : ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [
                    {
                        chainId: networkConfig.chainId,
                        chainName: networkConfig.name,
                        rpcUrls: [networkConfig.rpcUrl],
                        blockExplorerUrls: [networkConfig.explorer],
                        nativeCurrency: networkConfig.nativeCurrency,
                    },
                ],
            }));
        }
    }
    catch (err) {
        const { code } = err;
        if (code === MetamaskRPCErrorCode.AwaitingUserConfirmation) {
            // user has already been requested to add the network
            // maybe add a user CTA
            throw new Error(`Please check your Metamask window to add ${networkConfig.name} to Metamask`);
        }
        else {
            throw err;
        }
    }
});
exports.addNetworkToMetamask = addNetworkToMetamask;
function addNetworksToMetamask(ethereum) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(Object.values(NETWORKS).map((network) => (0, exports.addNetworkToMetamask)(ethereum, network)));
    });
}
exports.addNetworksToMetamask = addNetworksToMetamask;
function switchToNetwork(network, ethereum, getChainId) {
    return __awaiter(this, void 0, void 0, function* () {
        const [chainId, walletChainId] = yield Promise.all([
            getChainId(),
            getWalletChainId(ethereum),
        ]);
        if (network.chainId !== chainId || network.chainId !== walletChainId) {
            try {
                yield ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [
                        {
                            chainId: `0x${network.chainId.toString(16)}`,
                        },
                    ],
                });
                yield (0, exports.networkHasUpdated)(getChainId, network.chainId);
            }
            catch (err) {
                const { code } = err;
                if (code === MetamaskRPCErrorCode.UnknownNetwork ||
                    code === MetamaskRPCErrorCode.UnrecognizedChainID) {
                    // ChainId not yet added to metamask
                    yield (0, exports.addNetworkToMetamask)(ethereum, network);
                    return switchToNetwork(network, ethereum, getChainId);
                }
                else if (code === MetamaskRPCErrorCode.AwaitingUserConfirmation) {
                    // user has already been requested to switch the network
                    return;
                }
                else {
                    throw err;
                }
            }
        }
    });
}
exports.switchToNetwork = switchToNetwork;
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const SLEEP = 500;
const MAX_WAIT_MINUTES = 3;
const MAX_RETRY = Math.round((MAX_WAIT_MINUTES * 1000) / SLEEP);
// Hacky workaround to wait for the network to change.\
const networkHasUpdated = (getChainId, expectedChainId) => __awaiter(void 0, void 0, void 0, function* () {
    let attempts = 0;
    let isNetworkUpdated = false;
    while (!isNetworkUpdated) {
        attempts++;
        if (attempts >= MAX_RETRY) {
            throw new Error('Network did not change');
        }
        const chainId = yield getChainId();
        if (chainId === expectedChainId) {
            isNetworkUpdated = true;
            return true;
        }
        yield sleep(SLEEP);
    }
});
exports.networkHasUpdated = networkHasUpdated;
function getWalletChainId(ethereum) {
    return __awaiter(this, void 0, void 0, function* () {
        const walletChainId = ethereum.chainId
            ? ethereum.chainId
            : yield ethereum.request({ method: 'eth_chainId' });
        return parseInt(walletChainId, 16);
    });
}
exports.getWalletChainId = getWalletChainId;
//# sourceMappingURL=metamask.js.map