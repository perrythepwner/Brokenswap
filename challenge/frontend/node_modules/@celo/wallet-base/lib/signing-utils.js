"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeSig = exports.verifySignatureWithoutPrefix = exports.verifyEIP712TypedDataSigner = exports.recoverMessageSigner = exports.getSignerFromTxEIP2718TX = exports.recoverTransaction = exports.extractSignature = exports.encodeTransaction = exports.isPriceToLow = exports.rlpEncodedTx = exports.stringNumberOrBNToHex = exports.getHashFromEncoded = exports.chainIdTransformationForSigning = exports.thirtyTwo = exports.sixtyFour = exports.publicKeyPrefix = void 0;
var address_1 = require("@celo/base/lib/address");
var connect_1 = require("@celo/connect");
var formatter_1 = require("@celo/connect/lib/utils/formatter");
var sign_typed_data_utils_1 = require("@celo/utils/lib/sign-typed-data-utils");
var signatureUtils_1 = require("@celo/utils/lib/signatureUtils");
var util_1 = require("@ethereumjs/util");
var debug_1 = __importDefault(require("debug"));
// @ts-ignore-next-line eth-lib types not found
var eth_lib_1 = require("eth-lib");
var keccak_1 = require("ethereum-cryptography/keccak");
var utils_js_1 = require("ethereum-cryptography/utils.js");
var web3_1 = __importDefault(require("web3")); // TODO try to do this without web3 direct
var web3_eth_accounts_1 = __importDefault(require("web3-eth-accounts"));
var debug = (0, debug_1.default)('wallet-base:tx:sign');
// Original code taken from
// https://github.com/ethereum/web3.js/blob/1.x/packages/web3-eth-accounts/src/index.js
// 0x04 prefix indicates that the key is not compressed
// https://tools.ietf.org/html/rfc5480#section-2.2
exports.publicKeyPrefix = 0x04;
exports.sixtyFour = 64;
exports.thirtyTwo = 32;
var Y_PARITY_EIP_2098 = 27;
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
// Simple replay attack protection
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
function chainIdTransformationForSigning(chainId) {
    return chainId * 2 + 35;
}
exports.chainIdTransformationForSigning = chainIdTransformationForSigning;
function getHashFromEncoded(rlpEncode) {
    return eth_lib_1.hash.keccak256(rlpEncode);
}
exports.getHashFromEncoded = getHashFromEncoded;
function trimLeadingZero(hex) {
    while (hex && hex.startsWith('0x0')) {
        hex = (0, address_1.ensureLeading0x)(hex.slice(3));
    }
    return hex;
}
function makeEven(hex) {
    if (hex.length % 2 === 1) {
        hex = hex.replace('0x', '0x0');
    }
    return hex;
}
function signatureFormatter(signature, type) {
    var v = signature.v;
    if (type !== 'celo-legacy') {
        v = signature.v === Y_PARITY_EIP_2098 ? 0 : 1;
    }
    return {
        v: stringNumberToHex(v),
        r: makeEven(trimLeadingZero((0, address_1.ensureLeading0x)(signature.r.toString('hex')))),
        s: makeEven(trimLeadingZero((0, address_1.ensureLeading0x)(signature.s.toString('hex')))),
    };
}
function stringNumberOrBNToHex(num) {
    if (typeof num === 'string' || typeof num === 'number' || num === undefined) {
        return stringNumberToHex(num);
    }
    else {
        return makeEven("0x" + num.toString(16));
    }
}
exports.stringNumberOrBNToHex = stringNumberOrBNToHex;
function stringNumberToHex(num) {
    var auxNumber = Number(num);
    if (num === '0x' || num === undefined || auxNumber === 0) {
        return '0x';
    }
    return makeEven(web3_1.default.utils.numberToHex(num));
}
function rlpEncodedTx(tx) {
    assertSerializableTX(tx);
    var transaction = (0, formatter_1.inputCeloTxFormatter)(tx);
    transaction.to = eth_lib_1.bytes.fromNat(tx.to || '0x').toLowerCase();
    transaction.nonce = Number((tx.nonce !== '0x' ? tx.nonce : 0) || 0);
    transaction.data = eth_lib_1.bytes.fromNat(tx.data || '0x').toLowerCase();
    transaction.value = stringNumberOrBNToHex(tx.value);
    transaction.gas = stringNumberOrBNToHex(tx.gas);
    transaction.chainId = tx.chainId || 1;
    // Celo Specific
    transaction.feeCurrency = eth_lib_1.bytes.fromNat(tx.feeCurrency || '0x').toLowerCase();
    transaction.gatewayFeeRecipient = eth_lib_1.bytes.fromNat(tx.gatewayFeeRecipient || '0x').toLowerCase();
    transaction.gatewayFee = stringNumberOrBNToHex(tx.gatewayFee);
    // Legacy
    transaction.gasPrice = stringNumberOrBNToHex(tx.gasPrice);
    // EIP1559 / CIP42
    transaction.maxFeePerGas = stringNumberOrBNToHex(tx.maxFeePerGas);
    transaction.maxPriorityFeePerGas = stringNumberOrBNToHex(tx.maxPriorityFeePerGas);
    var rlpEncode;
    if (isCIP64(tx)) {
        // https://github.com/celo-org/celo-proposals/blob/master/CIPs/cip-0064.md
        // 0x7b || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, feeCurrency, signatureYParity, signatureR, signatureS]).
        rlpEncode = eth_lib_1.RLP.encode([
            stringNumberToHex(transaction.chainId),
            stringNumberToHex(transaction.nonce),
            transaction.maxPriorityFeePerGas || '0x',
            transaction.maxFeePerGas || '0x',
            transaction.gas || '0x',
            transaction.to || '0x',
            transaction.value || '0x',
            transaction.data || '0x',
            transaction.accessList || [],
            transaction.feeCurrency || '0x',
        ]);
        delete transaction.gatewayFee;
        delete transaction.gatewayFeeRecipient;
        delete transaction.gasPrice;
        return { transaction: transaction, rlpEncode: concatHex([TxTypeToPrefix.cip64, rlpEncode]), type: 'cip64' };
    }
    else if (isCIP42(tx)) {
        // There shall be a typed transaction with the code 0x7c that has the following format:
        // 0x7c || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, feecurrency, gatewayFeeRecipient, gatewayfee, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).
        // This will be in addition to the type 0x02 transaction as specified in EIP-1559.
        rlpEncode = eth_lib_1.RLP.encode([
            stringNumberToHex(transaction.chainId),
            stringNumberToHex(transaction.nonce),
            transaction.maxPriorityFeePerGas || '0x',
            transaction.maxFeePerGas || '0x',
            transaction.gas || '0x',
            transaction.feeCurrency || '0x',
            transaction.gatewayFeeRecipient || '0x',
            transaction.gatewayFee || '0x',
            transaction.to || '0x',
            transaction.value || '0x',
            transaction.data || '0x',
            transaction.accessList || [],
        ]);
        delete transaction.gasPrice;
        return { transaction: transaction, rlpEncode: concatHex([TxTypeToPrefix.cip42, rlpEncode]), type: 'cip42' };
    }
    else if (isEIP1559(tx)) {
        // https://eips.ethereum.org/EIPS/eip-1559
        // 0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).
        rlpEncode = eth_lib_1.RLP.encode([
            stringNumberToHex(transaction.chainId),
            stringNumberToHex(transaction.nonce),
            transaction.maxPriorityFeePerGas || '0x',
            transaction.maxFeePerGas || '0x',
            transaction.gas || '0x',
            transaction.to || '0x',
            transaction.value || '0x',
            transaction.data || '0x',
            transaction.accessList || [],
        ]);
        delete transaction.feeCurrency;
        delete transaction.gatewayFee;
        delete transaction.gatewayFeeRecipient;
        delete transaction.gasPrice;
        return {
            transaction: transaction,
            rlpEncode: concatHex([TxTypeToPrefix.eip1559, rlpEncode]),
            type: 'eip1559',
        };
    }
    else {
        // This order should match the order in Geth.
        // https://github.com/celo-org/celo-blockchain/blob/027dba2e4584936cc5a8e8993e4e27d28d5247b8/core/types/transaction.go#L65
        rlpEncode = eth_lib_1.RLP.encode([
            stringNumberToHex(transaction.nonce),
            transaction.gasPrice,
            transaction.gas,
            transaction.feeCurrency,
            transaction.gatewayFeeRecipient,
            transaction.gatewayFee,
            transaction.to,
            transaction.value,
            transaction.data,
            stringNumberToHex(transaction.chainId),
            '0x',
            '0x',
        ]);
        return { transaction: transaction, rlpEncode: rlpEncode, type: 'celo-legacy' };
    }
}
exports.rlpEncodedTx = rlpEncodedTx;
var TxTypeToPrefix;
(function (TxTypeToPrefix) {
    TxTypeToPrefix["celo-legacy"] = "";
    TxTypeToPrefix["cip42"] = "0x7c";
    TxTypeToPrefix["cip64"] = "0x7b";
    TxTypeToPrefix["eip1559"] = "0x02";
})(TxTypeToPrefix || (TxTypeToPrefix = {}));
function concatTypePrefixHex(rawTransaction, txType) {
    var prefix = TxTypeToPrefix[txType];
    if (prefix) {
        return concatHex([prefix, rawTransaction]);
    }
    return rawTransaction;
}
function assertSerializableTX(tx) {
    if (!tx.gas) {
        throw new Error('"gas" is missing');
    }
    // ensure at least gasPrice or maxFeePerGas and maxPriorityFeePerGas are set
    if (!(0, connect_1.isPresent)(tx.gasPrice) &&
        (!(0, connect_1.isPresent)(tx.maxFeePerGas) || !(0, connect_1.isPresent)(tx.maxPriorityFeePerGas))) {
        throw new Error('"gasPrice" or "maxFeePerGas" and "maxPriorityFeePerGas" are missing');
    }
    // ensure that gasPrice and maxFeePerGas are not set at the same time
    if ((0, connect_1.isPresent)(tx.gasPrice) &&
        ((0, connect_1.isPresent)(tx.maxFeePerGas) || (0, connect_1.isPresent)(tx.maxPriorityFeePerGas))) {
        throw new Error('when "maxFeePerGas" or "maxPriorityFeePerGas" are set, "gasPrice" must not be set');
    }
    if (isNullOrUndefined(tx.nonce) || isNullOrUndefined(tx.chainId)) {
        throw new Error('One of the values "chainId" or "nonce" couldn\'t be fetched: ' +
            JSON.stringify({ chainId: tx.chainId, nonce: tx.nonce }));
    }
    if (isLessThanZero(tx.nonce) || isLessThanZero(tx.gas) || isLessThanZero(tx.chainId)) {
        throw new Error('Gas, nonce or chainId is less than than 0');
    }
    isPriceToLow(tx);
}
function isPriceToLow(tx) {
    var prices = [tx.gasPrice, tx.maxFeePerGas, tx.maxPriorityFeePerGas].filter(function (price) { return price !== undefined; });
    var isLow = false;
    for (var _i = 0, prices_1 = prices; _i < prices_1.length; _i++) {
        var price = prices_1[_i];
        if (isLessThanZero(price)) {
            throw new Error('GasPrice or maxFeePerGas or maxPriorityFeePerGas is less than than 0');
        }
    }
    return isLow;
}
exports.isPriceToLow = isPriceToLow;
function isEIP1559(tx) {
    return (0, connect_1.isPresent)(tx.maxFeePerGas) && (0, connect_1.isPresent)(tx.maxPriorityFeePerGas);
}
function isCIP64(tx) {
    return (isEIP1559(tx) &&
        (0, connect_1.isPresent)(tx.feeCurrency) &&
        !(0, connect_1.isPresent)(tx.gatewayFeeRecipient) &&
        !(0, connect_1.isPresent)(tx.gatewayFeeRecipient));
}
function isCIP42(tx) {
    return (isEIP1559(tx) &&
        ((0, connect_1.isPresent)(tx.feeCurrency) || (0, connect_1.isPresent)(tx.gatewayFeeRecipient) || (0, connect_1.isPresent)(tx.gatewayFee)));
}
function concatHex(values) {
    return "0x".concat(values.reduce(function (acc, x) { return acc + x.replace('0x', ''); }, ''));
}
function isLessThanZero(value) {
    if (isNullOrUndefined(value)) {
        return true;
    }
    switch (typeof value) {
        case 'string':
        case 'number':
            return Number(value) < 0;
        default:
            return (value === null || value === void 0 ? void 0 : value.lt(web3_1.default.utils.toBN(0))) || false;
    }
}
function encodeTransaction(rlpEncoded, signature) {
    return __awaiter(this, void 0, void 0, function () {
        var sanitizedSignature, v, r, s, decodedTX, rawTx, rawTransaction, hash, baseTX, tx, result;
        return __generator(this, function (_a) {
            sanitizedSignature = signatureFormatter(signature, rlpEncoded.type);
            v = sanitizedSignature.v;
            r = sanitizedSignature.r;
            s = sanitizedSignature.s;
            decodedTX = prefixAwareRLPDecode(rlpEncoded.rlpEncode, rlpEncoded.type);
            rawTx = (rlpEncoded.type === 'celo-legacy' ? decodedTX.slice(0, 9) : decodedTX).concat([
                v,
                r,
                s,
            ]);
            rawTransaction = concatTypePrefixHex(eth_lib_1.RLP.encode(rawTx), rlpEncoded.type);
            hash = getHashFromEncoded(rawTransaction);
            baseTX = {
                nonce: rlpEncoded.transaction.nonce.toString(),
                gas: rlpEncoded.transaction.gas.toString(),
                to: rlpEncoded.transaction.to.toString(),
                value: rlpEncoded.transaction.value.toString(),
                input: rlpEncoded.transaction.data,
                v: v,
                r: r,
                s: s,
                hash: hash,
            };
            tx = baseTX;
            if (rlpEncoded.type === 'eip1559' || rlpEncoded.type === 'cip42') {
                tx = __assign(__assign({}, tx), { 
                    // @ts-expect-error -- just a matter of how  this tx is built
                    maxFeePerGas: rlpEncoded.transaction.maxFeePerGas.toString(), maxPriorityFeePerGas: rlpEncoded.transaction.maxPriorityFeePerGas.toString(), accessList: (0, formatter_1.parseAccessList)(rlpEncoded.transaction.accessList || []) });
            }
            if (rlpEncoded.type === 'cip42' || rlpEncoded.type === 'celo-legacy') {
                tx = __assign(__assign({}, tx), { 
                    // @ts-expect-error -- just a matter of how  this tx is built
                    feeCurrency: rlpEncoded.transaction.feeCurrency.toString(), gatewayFeeRecipient: rlpEncoded.transaction.gatewayFeeRecipient.toString(), gatewayFee: rlpEncoded.transaction.gatewayFee.toString() });
            }
            if (rlpEncoded.type === 'celo-legacy') {
                tx = __assign(__assign({}, tx), { 
                    // @ts-expect-error -- just a matter of how  this tx is built
                    gasPrice: rlpEncoded.transaction.gasPrice.toString() });
            }
            result = {
                tx: tx,
                raw: rawTransaction,
                type: rlpEncoded.type,
            };
            return [2 /*return*/, result];
        });
    });
}
exports.encodeTransaction = encodeTransaction;
// new types have prefix but legacy does not
function prefixAwareRLPDecode(rlpEncode, type) {
    return type === 'celo-legacy' ? eth_lib_1.RLP.decode(rlpEncode) : eth_lib_1.RLP.decode("0x".concat(rlpEncode.slice(4)));
}
function correctLengthOf(type, includeSig) {
    if (includeSig === void 0) { includeSig = true; }
    switch (type) {
        case 'cip64': {
            return includeSig ? 13 : 10;
        }
        case 'cip42':
            return includeSig ? 15 : 12;
        case 'celo-legacy':
        case 'eip1559':
            return 12;
    }
}
// Based on the return type of ensureLeading0x this was not a Buffer
function extractSignature(rawTx) {
    var type = determineTXType(rawTx);
    var rawValues = prefixAwareRLPDecode(rawTx, type);
    var length = rawValues.length;
    if (correctLengthOf(type) !== length) {
        throw new Error("@extractSignature: provided transaction has ".concat(length, " elements but ").concat(type, " txs with a signature have ").concat(correctLengthOf(type), " ").concat(JSON.stringify(rawValues)));
    }
    return extractSignatureFromDecoded(rawValues);
}
exports.extractSignature = extractSignature;
function extractSignatureFromDecoded(rawValues) {
    // signature is always (for the tx we support so far) the last three elements of the array in order v, r, s,
    var v = rawValues.at(-3);
    var r = rawValues.at(-2);
    var s = rawValues.at(-1);
    // https://github.com/wagmi-dev/viem/blob/993321689b3e2220976504e7e170fe47731297ce/src/utils/transaction/parseTransaction.ts#L281
    // Account.recover cannot handle canonicalized signatures
    // A canonicalized signature may have the first byte removed if its value is 0
    r = (0, address_1.ensureLeading0x)((0, address_1.trimLeading0x)(r).padStart(64, '0'));
    s = (0, address_1.ensureLeading0x)((0, address_1.trimLeading0x)(s).padStart(64, '0'));
    return {
        v: v,
        r: r,
        s: s,
    };
}
// Recover transaction and sender address from a raw transaction.
// This is used for testing.
function recoverTransaction(rawTx) {
    if (!rawTx.startsWith('0x')) {
        throw new Error('rawTx must start with 0x');
    }
    switch (determineTXType(rawTx)) {
        case 'cip64':
            return recoverTransactionCIP64(rawTx);
        case 'cip42':
            return recoverTransactionCIP42(rawTx);
        case 'eip1559':
            return recoverTransactionEIP1559(rawTx);
        default:
            var rawValues = eth_lib_1.RLP.decode(rawTx);
            debug('signing-utils@recoverTransaction: values are %s', rawValues);
            var recovery = eth_lib_1.bytes.toNumber(rawValues[9]);
            // tslint:disable-next-line:no-bitwise
            var chainId = eth_lib_1.bytes.fromNumber((recovery - 35) >> 1);
            var celoTx = {
                type: 'celo-legacy',
                nonce: rawValues[0].toLowerCase() === '0x' ? 0 : parseInt(rawValues[0], 16),
                gasPrice: rawValues[1].toLowerCase() === '0x' ? 0 : parseInt(rawValues[1], 16),
                gas: rawValues[2].toLowerCase() === '0x' ? 0 : parseInt(rawValues[2], 16),
                feeCurrency: rawValues[3],
                gatewayFeeRecipient: rawValues[4],
                gatewayFee: rawValues[5],
                to: rawValues[6],
                value: rawValues[7],
                data: rawValues[8],
                chainId: chainId,
            };
            var _a = extractSignatureFromDecoded(rawValues), r = _a.r, v = _a.v, s = _a.s;
            var signature = eth_lib_1.account.encodeSignature([v, r, s]);
            var extraData = recovery < 35 ? [] : [chainId, '0x', '0x'];
            var signingData = rawValues.slice(0, 9).concat(extraData);
            var signingDataHex = eth_lib_1.RLP.encode(signingData);
            var signer = eth_lib_1.account.recover(getHashFromEncoded(signingDataHex), signature);
            return [celoTx, signer];
    }
}
exports.recoverTransaction = recoverTransaction;
// inspired by @ethereumjs/tx
function getPublicKeyofSignerFromTx(transactionArray, type) {
    // this needs to be 10 for cip64, 12 for cip42 and eip1559
    var base = transactionArray.slice(0, correctLengthOf(type, false));
    var message = concatHex([TxTypeToPrefix[type], eth_lib_1.RLP.encode(base).slice(2)]);
    var msgHash = (0, keccak_1.keccak256)((0, utils_js_1.hexToBytes)(message));
    var _a = extractSignatureFromDecoded(transactionArray), v = _a.v, r = _a.r, s = _a.s;
    try {
        return (0, util_1.ecrecover)((0, util_1.toBuffer)(msgHash), v === '0x' || v === undefined ? BigInt(0) : BigInt(1), (0, util_1.toBuffer)(r), (0, util_1.toBuffer)(s));
    }
    catch (e) {
        throw new Error(e);
    }
}
function getSignerFromTxEIP2718TX(serializedTransaction) {
    var transactionArray = eth_lib_1.RLP.decode("0x".concat(serializedTransaction.slice(4)));
    var signer = getPublicKeyofSignerFromTx(transactionArray, determineTXType(serializedTransaction));
    return (0, util_1.toChecksumAddress)(util_1.Address.fromPublicKey(signer).toString());
}
exports.getSignerFromTxEIP2718TX = getSignerFromTxEIP2718TX;
function determineTXType(serializedTransaction) {
    var prefix = serializedTransaction.slice(0, 4);
    if (prefix === TxTypeToPrefix.eip1559) {
        return 'eip1559';
    }
    else if (prefix === TxTypeToPrefix.cip42) {
        return 'cip42';
    }
    else if (prefix === TxTypeToPrefix.cip64) {
        return 'cip64';
    }
    return 'celo-legacy';
}
function vrsForRecovery(vRaw, r, s) {
    var v = vRaw === '0x' || (0, formatter_1.hexToNumber)(vRaw) === 0 ? Y_PARITY_EIP_2098 : Y_PARITY_EIP_2098 + 1;
    return {
        v: v,
        r: r,
        s: s,
        yParity: v === Y_PARITY_EIP_2098 ? 0 : 1,
    };
}
function recoverTransactionCIP42(serializedTransaction) {
    var transactionArray = prefixAwareRLPDecode(serializedTransaction, 'cip42');
    debug('signing-utils@recoverTransactionCIP42: values are %s', transactionArray);
    if (transactionArray.length !== 15 && transactionArray.length !== 12) {
        throw new Error("Invalid transaction length for type CIP42: ".concat(transactionArray.length, " instead of 15 or 12. array: ").concat(transactionArray));
    }
    var chainId = transactionArray[0], nonce = transactionArray[1], maxPriorityFeePerGas = transactionArray[2], maxFeePerGas = transactionArray[3], gas = transactionArray[4], feeCurrency = transactionArray[5], gatewayFeeRecipient = transactionArray[6], gatewayFee = transactionArray[7], to = transactionArray[8], value = transactionArray[9], data = transactionArray[10], accessList = transactionArray[11], vRaw = transactionArray[12], r = transactionArray[13], s = transactionArray[14];
    var celoTX = __assign({ type: 'cip42', nonce: nonce.toLowerCase() === '0x' ? 0 : parseInt(nonce, 16), maxPriorityFeePerGas: maxPriorityFeePerGas.toLowerCase() === '0x' ? 0 : parseInt(maxPriorityFeePerGas, 16), maxFeePerGas: maxFeePerGas.toLowerCase() === '0x' ? 0 : parseInt(maxFeePerGas, 16), gas: gas.toLowerCase() === '0x' ? 0 : parseInt(gas, 16), feeCurrency: feeCurrency, gatewayFeeRecipient: gatewayFeeRecipient, gatewayFee: gatewayFee, to: to, value: value.toLowerCase() === '0x' ? 0 : parseInt(value, 16), data: data, chainId: chainId.toLowerCase() === '0x' ? 0 : parseInt(chainId, 16), accessList: (0, formatter_1.parseAccessList)(accessList) }, vrsForRecovery(vRaw, r, s));
    var signer = transactionArray.length === 15 ? getSignerFromTxEIP2718TX(serializedTransaction) : 'unsigned';
    return [celoTX, signer];
}
function recoverTransactionCIP64(serializedTransaction) {
    var transactionArray = prefixAwareRLPDecode(serializedTransaction, 'cip64');
    debug('signing-utils@recoverTransactionCIP64: values are %s', transactionArray);
    if (transactionArray.length !== 13 && transactionArray.length !== 10) {
        throw new Error("Invalid transaction length for type CIP64: ".concat(transactionArray.length, " instead of 13 or 10. array: ").concat(transactionArray));
    }
    var chainId = transactionArray[0], nonce = transactionArray[1], maxPriorityFeePerGas = transactionArray[2], maxFeePerGas = transactionArray[3], gas = transactionArray[4], to = transactionArray[5], value = transactionArray[6], data = transactionArray[7], accessList = transactionArray[8], feeCurrency = transactionArray[9], vRaw = transactionArray[10], r = transactionArray[11], s = transactionArray[12];
    var celoTX = __assign({ type: 'cip64', nonce: nonce.toLowerCase() === '0x' ? 0 : parseInt(nonce, 16), maxPriorityFeePerGas: maxPriorityFeePerGas.toLowerCase() === '0x' ? 0 : parseInt(maxPriorityFeePerGas, 16), maxFeePerGas: maxFeePerGas.toLowerCase() === '0x' ? 0 : parseInt(maxFeePerGas, 16), gas: gas.toLowerCase() === '0x' ? 0 : parseInt(gas, 16), feeCurrency: feeCurrency, to: to, value: value.toLowerCase() === '0x' ? 0 : parseInt(value, 16), data: data, chainId: chainId.toLowerCase() === '0x' ? 0 : parseInt(chainId, 16), accessList: (0, formatter_1.parseAccessList)(accessList) }, vrsForRecovery(vRaw, r, s));
    var signer = transactionArray.length === 13 ? getSignerFromTxEIP2718TX(serializedTransaction) : 'unsigned';
    return [celoTX, signer];
}
function recoverTransactionEIP1559(serializedTransaction) {
    var transactionArray = prefixAwareRLPDecode(serializedTransaction, 'eip1559');
    debug('signing-utils@recoverTransactionEIP1559: values are %s', transactionArray);
    var chainId = transactionArray[0], nonce = transactionArray[1], maxPriorityFeePerGas = transactionArray[2], maxFeePerGas = transactionArray[3], gas = transactionArray[4], to = transactionArray[5], value = transactionArray[6], data = transactionArray[7], accessList = transactionArray[8], vRaw = transactionArray[9], r = transactionArray[10], s = transactionArray[11];
    var celoTx = __assign({ type: 'eip1559', nonce: nonce.toLowerCase() === '0x' ? 0 : parseInt(nonce, 16), gas: gas.toLowerCase() === '0x' ? 0 : parseInt(gas, 16), maxPriorityFeePerGas: maxPriorityFeePerGas.toLowerCase() === '0x' ? 0 : parseInt(maxPriorityFeePerGas, 16), maxFeePerGas: maxFeePerGas.toLowerCase() === '0x' ? 0 : parseInt(maxFeePerGas, 16), to: to, value: value.toLowerCase() === '0x' ? 0 : parseInt(value, 16), data: data, chainId: chainId.toLowerCase() === '0x' ? 0 : parseInt(chainId, 16), accessList: (0, formatter_1.parseAccessList)(accessList) }, vrsForRecovery(vRaw, r, s));
    var web3Account = new web3_eth_accounts_1.default();
    var signer = web3Account.recoverTransaction(serializedTransaction);
    return [celoTx, signer];
}
function recoverMessageSigner(signingDataHex, signedData) {
    var dataBuff = (0, util_1.toBuffer)(signingDataHex);
    var msgHashBuff = (0, util_1.hashPersonalMessage)(dataBuff);
    var signature = (0, util_1.fromRpcSig)(signedData);
    var publicKey = (0, util_1.ecrecover)(msgHashBuff, signature.v, signature.r, signature.s);
    var address = (0, util_1.pubToAddress)(publicKey, true);
    return (0, address_1.ensureLeading0x)(address.toString('hex'));
}
exports.recoverMessageSigner = recoverMessageSigner;
function verifyEIP712TypedDataSigner(typedData, signedData, expectedAddress) {
    var dataHex = (0, util_1.bufferToHex)((0, sign_typed_data_utils_1.generateTypedDataHash)(typedData));
    return verifySignatureWithoutPrefix(dataHex, signedData, expectedAddress);
}
exports.verifyEIP712TypedDataSigner = verifyEIP712TypedDataSigner;
function verifySignatureWithoutPrefix(messageHash, signature, signer) {
    try {
        (0, signatureUtils_1.parseSignatureWithoutPrefix)(messageHash, signature, signer);
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.verifySignatureWithoutPrefix = verifySignatureWithoutPrefix;
function decodeSig(sig) {
    var _a = eth_lib_1.account.decodeSignature(sig), v = _a[0], r = _a[1], s = _a[2];
    return {
        v: parseInt(v, 16),
        r: (0, util_1.toBuffer)(r),
        s: (0, util_1.toBuffer)(s),
    };
}
exports.decodeSig = decodeSig;
//# sourceMappingURL=signing-utils.js.map