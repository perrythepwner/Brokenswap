/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface LimitOrderProtocolInterface extends ethers.utils.Interface {
  functions: {
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "LIMIT_ORDER_RFQ_TYPEHASH()": FunctionFragment;
    "LIMIT_ORDER_TYPEHASH()": FunctionFragment;
    "advanceNonce(uint8)": FunctionFragment;
    "and(address[],bytes[])": FunctionFragment;
    "arbitraryStaticCall(address,bytes)": FunctionFragment;
    "cancelOrder((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes))": FunctionFragment;
    "cancelOrderRFQ(uint256)": FunctionFragment;
    "checkPredicate((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes))": FunctionFragment;
    "doublePrice(address,address,uint256,int256,uint256)": FunctionFragment;
    "eq(uint256,address,bytes)": FunctionFragment;
    "fillOrder((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,(uint256,uint256,uint256))": FunctionFragment;
    "fillOrderRFQ((uint256,address,address,address,address,uint256,uint256),bytes,uint256,uint256)": FunctionFragment;
    "fillOrderRFQTo((uint256,address,address,address,address,uint256,uint256),bytes,uint256,uint256,address)": FunctionFragment;
    "fillOrderRFQToWithPermit((uint256,address,address,address,address,uint256,uint256),bytes,uint256,uint256,address,bytes)": FunctionFragment;
    "fillOrderTo((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,(uint256,uint256,uint256),address)": FunctionFragment;
    "fillOrderToWithExtraInteraction((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,(uint256,uint256,uint256),address,bytes)": FunctionFragment;
    "fillOrderToWithPermit((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,(uint256,uint256,uint256),address,bytes)": FunctionFragment;
    "getMakerAmount(uint256,uint256,uint256)": FunctionFragment;
    "getTakerAmount(uint256,uint256,uint256)": FunctionFragment;
    "gt(uint256,address,bytes)": FunctionFragment;
    "hashOrder((uint256,address,address,address,address,address,uint256,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes))": FunctionFragment;
    "hashOrderRFQ((uint256,address,address,address,address,uint256,uint256))": FunctionFragment;
    "increaseNonce()": FunctionFragment;
    "invalidatorForOrderRFQ(address,uint256)": FunctionFragment;
    "lt(uint256,address,bytes)": FunctionFragment;
    "nonce(address)": FunctionFragment;
    "nonceEquals(address,uint256)": FunctionFragment;
    "or(address[],bytes[])": FunctionFragment;
    "remaining(bytes32)": FunctionFragment;
    "remainingRaw(bytes32)": FunctionFragment;
    "remainingsRaw(bytes32[])": FunctionFragment;
    "simulateCalls(address[],bytes[])": FunctionFragment;
    "singlePrice(address,uint256,uint256)": FunctionFragment;
    "timestampBelow(uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LIMIT_ORDER_RFQ_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LIMIT_ORDER_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "advanceNonce",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "and",
    values: [string[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "arbitraryStaticCall",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrderRFQ",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "checkPredicate",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "doublePrice",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "eq",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrder",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      BytesLike,
      {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderRFQ",
    values: [
      {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      BytesLike,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderRFQTo",
    values: [
      {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      BytesLike,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderRFQToWithPermit",
    values: [
      {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      BytesLike,
      BigNumberish,
      BigNumberish,
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderTo",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      BytesLike,
      {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderToWithExtraInteraction",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      BytesLike,
      {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderToWithPermit",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      BytesLike,
      {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMakerAmount",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTakerAmount",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "gt",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hashOrder",
    values: [
      {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "hashOrderRFQ",
    values: [
      {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "invalidatorForOrderRFQ",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "lt",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "nonce", values: [string]): string;
  encodeFunctionData(
    functionFragment: "nonceEquals",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "or",
    values: [string[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "remaining",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "remainingRaw",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "remainingsRaw",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateCalls",
    values: [string[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "singlePrice",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "timestampBelow",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LIMIT_ORDER_RFQ_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LIMIT_ORDER_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "advanceNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "and", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "arbitraryStaticCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrderRFQ",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkPredicate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "doublePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "eq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fillOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderRFQ",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderRFQTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderRFQToWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderToWithExtraInteraction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderToWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMakerAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTakerAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hashOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hashOrderRFQ",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "invalidatorForOrderRFQ",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "nonceEquals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "or", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "remaining", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "remainingRaw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "remainingsRaw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simulateCalls",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "singlePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "timestampBelow",
    data: BytesLike
  ): Result;

  events: {
    "NonceIncreased(address,uint256)": EventFragment;
    "OrderCanceled(address,bytes32,uint256)": EventFragment;
    "OrderFilled(address,bytes32,uint256)": EventFragment;
    "OrderFilledRFQ(bytes32,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "NonceIncreased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderFilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderFilledRFQ"): EventFragment;
}

export type NonceIncreasedEvent = TypedEvent<
  [string, BigNumber] & { maker: string; newNonce: BigNumber }
>;

export type OrderCanceledEvent = TypedEvent<
  [string, string, BigNumber] & {
    maker: string;
    orderHash: string;
    remainingRaw: BigNumber;
  }
>;

export type OrderFilledEvent = TypedEvent<
  [string, string, BigNumber] & {
    maker: string;
    orderHash: string;
    remaining: BigNumber;
  }
>;

export type OrderFilledRFQEvent = TypedEvent<
  [string, BigNumber] & { orderHash: string; makingAmount: BigNumber }
>;

export class LimitOrderProtocol extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: LimitOrderProtocolInterface;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    cancelOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelOrderRFQ(
      orderInfo: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    checkPredicate(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    fillOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderRFQTo(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderRFQToWithPermit(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderTo(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderToWithExtraInteraction(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      extraInteraction: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderToWithPermit(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    hashOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<[string]>;

    hashOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string]>;

    increaseNonce(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    invalidatorForOrderRFQ(
      maker: string,
      slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    nonce(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    remainingsRaw(
      orderHashes: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  advanceNonce(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  and(
    targets: string[],
    data: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  arbitraryStaticCall(
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  cancelOrder(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelOrderRFQ(
    orderInfo: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  checkPredicate(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<boolean>;

  doublePrice(
    oracle1: string,
    oracle2: string,
    spread: BigNumberish,
    decimalsScale: BigNumberish,
    amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  eq(
    value: BigNumberish,
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  fillOrder(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    signature: BytesLike,
    orderAmounts: {
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      thresholdAmount: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderRFQ(
    order: {
      info: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
    },
    signature: BytesLike,
    makingAmount: BigNumberish,
    takingAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderRFQTo(
    order: {
      info: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
    },
    signature: BytesLike,
    makingAmount: BigNumberish,
    takingAmount: BigNumberish,
    target: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderRFQToWithPermit(
    order: {
      info: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
    },
    signature: BytesLike,
    makingAmount: BigNumberish,
    takingAmount: BigNumberish,
    target: string,
    permit: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderTo(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    signature: BytesLike,
    orderAmounts: {
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      thresholdAmount: BigNumberish;
    },
    target: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderToWithExtraInteraction(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    signature: BytesLike,
    orderAmounts: {
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      thresholdAmount: BigNumberish;
    },
    target: string,
    extraInteraction: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderToWithPermit(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    signature: BytesLike,
    orderAmounts: {
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      thresholdAmount: BigNumberish;
    },
    target: string,
    permit: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getMakerAmount(
    orderMakerAmount: BigNumberish,
    orderTakerAmount: BigNumberish,
    swapTakerAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTakerAmount(
    orderMakerAmount: BigNumberish,
    orderTakerAmount: BigNumberish,
    swapMakerAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  gt(
    value: BigNumberish,
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  hashOrder(
    order: {
      salt: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      receiver: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
      makerAssetData: BytesLike;
      takerAssetData: BytesLike;
      getMakerAmount: BytesLike;
      getTakerAmount: BytesLike;
      predicate: BytesLike;
      permit: BytesLike;
      interaction: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  hashOrderRFQ(
    order: {
      info: BigNumberish;
      makerAsset: string;
      takerAsset: string;
      maker: string;
      allowedSender: string;
      makingAmount: BigNumberish;
      takingAmount: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  increaseNonce(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  invalidatorForOrderRFQ(
    maker: string,
    slot: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  lt(
    value: BigNumberish,
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  nonce(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  nonceEquals(
    makerAddress: string,
    makerNonce: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  or(
    targets: string[],
    data: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  remaining(
    orderHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  remainingRaw(
    orderHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  remainingsRaw(
    orderHashes: BytesLike[],
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  simulateCalls(
    targets: string[],
    data: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  singlePrice(
    oracle: string,
    inverseAndSpread: BigNumberish,
    amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  timestampBelow(
    time: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOrderRFQ(
      orderInfo: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    checkPredicate(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    fillOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderRFQTo(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderRFQToWithPermit(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      permit: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderTo(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderToWithExtraInteraction(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      extraInteraction: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderToWithPermit(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      permit: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    hashOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    hashOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    increaseNonce(overrides?: CallOverrides): Promise<void>;

    invalidatorForOrderRFQ(
      maker: string,
      slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    nonce(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remainingsRaw(
      orderHashes: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "NonceIncreased(address,uint256)"(
      maker?: string | null,
      newNonce?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { maker: string; newNonce: BigNumber }
    >;

    NonceIncreased(
      maker?: string | null,
      newNonce?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { maker: string; newNonce: BigNumber }
    >;

    "OrderCanceled(address,bytes32,uint256)"(
      maker?: string | null,
      orderHash?: null,
      remainingRaw?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { maker: string; orderHash: string; remainingRaw: BigNumber }
    >;

    OrderCanceled(
      maker?: string | null,
      orderHash?: null,
      remainingRaw?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { maker: string; orderHash: string; remainingRaw: BigNumber }
    >;

    "OrderFilled(address,bytes32,uint256)"(
      maker?: string | null,
      orderHash?: null,
      remaining?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { maker: string; orderHash: string; remaining: BigNumber }
    >;

    OrderFilled(
      maker?: string | null,
      orderHash?: null,
      remaining?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { maker: string; orderHash: string; remaining: BigNumber }
    >;

    "OrderFilledRFQ(bytes32,uint256)"(
      orderHash?: null,
      makingAmount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { orderHash: string; makingAmount: BigNumber }
    >;

    OrderFilledRFQ(
      orderHash?: null,
      makingAmount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { orderHash: string; makingAmount: BigNumber }
    >;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelOrderRFQ(
      orderInfo: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    checkPredicate(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fillOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderRFQTo(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderRFQToWithPermit(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderTo(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderToWithExtraInteraction(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      extraInteraction: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderToWithPermit(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    increaseNonce(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    invalidatorForOrderRFQ(
      maker: string,
      slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonce(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remainingsRaw(
      orderHashes: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    LIMIT_ORDER_RFQ_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    LIMIT_ORDER_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelOrderRFQ(
      orderInfo: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    checkPredicate(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fillOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderRFQTo(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderRFQToWithPermit(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      signature: BytesLike,
      makingAmount: BigNumberish,
      takingAmount: BigNumberish,
      target: string,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderTo(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderToWithExtraInteraction(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      extraInteraction: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderToWithPermit(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      signature: BytesLike,
      orderAmounts: {
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        thresholdAmount: BigNumberish;
      },
      target: string,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashOrder(
      order: {
        salt: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        receiver: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
        makerAssetData: BytesLike;
        takerAssetData: BytesLike;
        getMakerAmount: BytesLike;
        getTakerAmount: BytesLike;
        predicate: BytesLike;
        permit: BytesLike;
        interaction: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashOrderRFQ(
      order: {
        info: BigNumberish;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumberish;
        takingAmount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    increaseNonce(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    invalidatorForOrderRFQ(
      maker: string,
      slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonce(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    remainingsRaw(
      orderHashes: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
