{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitList: ordered variable-length collection of boolean values, limited to N bits\n * - Notation `Bitlist[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitListType extends bitArray_2.BitArrayType {\n  constructor(limitBits, opts) {\n    var _opts$typeName;\n    super();\n    this.limitBits = limitBits;\n    this.fixedSize = null;\n    this.minSize = 1; // +1 for the extra padding bit\n    this.isList = true;\n    if (limitBits === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"BitList[\".concat(limitBits, \"]\");\n    // TODO Check that itemsPerChunk is an integer\n    this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Depth includes the extra level for the length node\n    this.depth = 1 + this.chunkDepth;\n    this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);\n  }\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(0);\n  }\n  // Views: inherited from BitArrayType\n  // Serialization + deserialization\n  value_serializedSize(value) {\n    return bitLenToSerializedLength(value.bitLen);\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return applyPaddingBit(output.uint8Array, offset, value.bitLen);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    return new bitArray_1.BitArray(uint8Array, bitLen);\n  }\n  tree_serializedSize(node) {\n    return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n    const bitLen = arrayBasic_1.getLengthFromRootNode(node);\n    const byteLen = Math.ceil(bitLen / 8);\n    const chunkLen = Math.ceil(byteLen / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n    return applyPaddingBit(output.uint8Array, offset, bitLen);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);\n    return arrayBasic_1.addLengthNode(chunksNode, bitLen);\n  }\n  tree_getByteLen(node) {\n    if (!node) throw new Error(\"BitListType requires a node to get leaves\");\n    return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);\n  }\n  // Merkleization: inherited from BitArrayType\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);\n  }\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n  deserializeUint8ArrayBitListFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = deserializeUint8ArrayBitListFromBytes(data, start, end);\n    if (bitLen > this.limitBits) {\n      throw Error(\"bitLen over limit \".concat(bitLen, \" > \").concat(this.limitBits));\n    }\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n}\nexports.BitListType = BitListType;\nfunction deserializeUint8ArrayBitListFromBytes(data, start, end) {\n  if (end > data.length) {\n    throw Error(\"BitList attempting to read byte \".concat(end, \" of data length \").concat(data.length));\n  }\n  const lastByte = data[end - 1];\n  const size = end - start;\n  if (lastByte === 0) {\n    throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n  }\n  if (lastByte === 1) {\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);\n    const bitLen = (size - 1) * 8;\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n  // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n  // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n  const uint8Array = Uint8Array.prototype.slice.call(data, start, end);\n  // mask lastChunkByte\n  const lastByteBitLength = lastByte.toString(2).length - 1;\n  const bitLen = (size - 1) * 8 + lastByteBitLength;\n  const mask = 0xff >> 8 - lastByteBitLength;\n  uint8Array[size - 1] &= mask;\n  return {\n    uint8Array,\n    bitLen\n  };\n}\nfunction bitLenToSerializedLength(bitLen) {\n  const bytes = Math.ceil(bitLen / 8);\n  // +1 for the extra padding bit\n  return bitLen % 8 === 0 ? bytes + 1 : bytes;\n}\n/**\n * Apply padding bit to a serialized BitList already written to `output` at `offset`\n * @returns New offset after (maybe) writting a padding bit.\n */\nfunction applyPaddingBit(output, offset, bitLen) {\n  const byteLen = Math.ceil(bitLen / 8);\n  const newOffset = offset + byteLen;\n  if (bitLen % 8 === 0) {\n    output[newOffset] = 1;\n    return newOffset + 1;\n  } else {\n    output[newOffset - 1] |= 1 << bitLen % 8;\n    return newOffset;\n  }\n}","map":{"version":3,"sources":["../../src/type/bitList.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitList: ordered variable-length collection of boolean values, limited to N bits\n * - Notation `Bitlist[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitListType extends bitArray_2.BitArrayType {\n    constructor(limitBits, opts) {\n        super();\n        this.limitBits = limitBits;\n        this.fixedSize = null;\n        this.minSize = 1; // +1 for the extra padding bit\n        this.isList = true;\n        if (limitBits === 0)\n            throw Error(\"List limit must be > 0\");\n        this.typeName = opts?.typeName ?? `BitList[${limitBits}]`;\n        // TODO Check that itemsPerChunk is an integer\n        this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        // Depth includes the extra level for the length node\n        this.depth = 1 + this.chunkDepth;\n        this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);\n    }\n    defaultValue() {\n        return bitArray_1.BitArray.fromBitLen(0);\n    }\n    // Views: inherited from BitArrayType\n    // Serialization + deserialization\n    value_serializedSize(value) {\n        return bitLenToSerializedLength(value.bitLen);\n    }\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array.set(value.uint8Array, offset);\n        return applyPaddingBit(output.uint8Array, offset, value.bitLen);\n    }\n    value_deserializeFromBytes(data, start, end) {\n        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n        return new bitArray_1.BitArray(uint8Array, bitLen);\n    }\n    tree_serializedSize(node) {\n        return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n        const bitLen = arrayBasic_1.getLengthFromRootNode(node);\n        const byteLen = Math.ceil(bitLen / 8);\n        const chunkLen = Math.ceil(byteLen / 32);\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n        return applyPaddingBit(output.uint8Array, offset, bitLen);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const { uint8Array, bitLen } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);\n        return arrayBasic_1.addLengthNode(chunksNode, bitLen);\n    }\n    tree_getByteLen(node) {\n        if (!node)\n            throw new Error(\"BitListType requires a node to get leaves\");\n        return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);\n    }\n    // Merkleization: inherited from BitArrayType\n    hashTreeRoot(value) {\n        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);\n    }\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from BitArrayType\n    // Deserializer helpers\n    deserializeUint8ArrayBitListFromBytes(data, start, end) {\n        const { uint8Array, bitLen } = deserializeUint8ArrayBitListFromBytes(data, start, end);\n        if (bitLen > this.limitBits) {\n            throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);\n        }\n        return { uint8Array, bitLen };\n    }\n}\nexports.BitListType = BitListType;\nfunction deserializeUint8ArrayBitListFromBytes(data, start, end) {\n    if (end > data.length) {\n        throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);\n    }\n    const lastByte = data[end - 1];\n    const size = end - start;\n    if (lastByte === 0) {\n        throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n    }\n    if (lastByte === 1) {\n        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n        const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);\n        const bitLen = (size - 1) * 8;\n        return { uint8Array, bitLen };\n    }\n    // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    const uint8Array = Uint8Array.prototype.slice.call(data, start, end);\n    // mask lastChunkByte\n    const lastByteBitLength = lastByte.toString(2).length - 1;\n    const bitLen = (size - 1) * 8 + lastByteBitLength;\n    const mask = 0xff >> (8 - lastByteBitLength);\n    uint8Array[size - 1] &= mask;\n    return { uint8Array, bitLen };\n}\nfunction bitLenToSerializedLength(bitLen) {\n    const bytes = Math.ceil(bitLen / 8);\n    // +1 for the extra padding bit\n    return bitLen % 8 === 0 ? bytes + 1 : bytes;\n}\n/**\n * Apply padding bit to a serialized BitList already written to `output` at `offset`\n * @returns New offset after (maybe) writting a padding bit.\n */\nfunction applyPaddingBit(output, offset, bitLen) {\n    const byteLen = Math.ceil(bitLen / 8);\n    const newOffset = offset + byteLen;\n    if (bitLen % 8 === 0) {\n        output[newOffset] = 1;\n        return newOffset + 1;\n    }\n    else {\n        output[newOffset - 1] |= 1 << bitLen % 8;\n        return newOffset;\n    }\n}\n//# sourceMappingURL=bitList.js.map"]},"metadata":{},"sourceType":"script"}