{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap {\n  constructor(entries) {\n    _FrozenMap_map.set(this, void 0);\n    __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n    Object.freeze(this);\n  }\n  get size() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n  }\n  [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n  }\n  entries() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n  }\n  forEach(callbackfn, thisArg) {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner map.\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));\n  }\n  get(key) {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n  }\n  has(key) {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n  }\n  keys() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n  }\n  values() {\n    return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n  }\n  toString() {\n    return \"FrozenMap(\".concat(this.size, \") {\").concat(this.size > 0 ? \" \".concat([...this.entries()].map(_ref => {\n      let [key, value] = _ref;\n      return \"\".concat(String(key), \" => \").concat(String(value));\n    }).join(', '), \" \") : '', \"}\");\n  }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet {\n  constructor(values) {\n    _FrozenSet_set.set(this, void 0);\n    __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n    Object.freeze(this);\n  }\n  get size() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n  }\n  [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n  }\n  entries() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n  }\n  forEach(callbackfn, thisArg) {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner set.\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));\n  }\n  has(value) {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n  }\n  keys() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n  }\n  values() {\n    return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n  }\n  toString() {\n    return \"FrozenSet(\".concat(this.size, \") {\").concat(this.size > 0 ? \" \".concat([...this.values()].map(member => String(member)).join(', '), \" \") : '', \"}\");\n  }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);","map":{"version":3,"sources":["../src/collections.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap<Key, Value> implements ReadonlyMap<Key, Value> {\n  readonly #map: Map<Key, Value>;\n\n  public get size() {\n    return this.#map.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#map[Symbol.iterator]();\n  }\n\n  constructor(entries?: readonly (readonly [Key, Value])[] | null) {\n    this.#map = new Map<Key, Value>(entries);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#map.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, key: Key, map: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner map.\n    return this.#map.forEach((value: Value, key: Key, _map: unknown) =>\n      callbackfn.call(thisArg, value, key, this),\n    );\n  }\n\n  public get(key: Key) {\n    return this.#map.get(key);\n  }\n\n  public has(key: Key) {\n    return this.#map.has(key);\n  }\n\n  public keys() {\n    return this.#map.keys();\n  }\n\n  public values() {\n    return this.#map.values();\n  }\n\n  public toString(): string {\n    return `FrozenMap(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.entries()]\n            .map(([key, value]) => `${String(key)} => ${String(value)}`)\n            .join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet<Value> implements ReadonlySet<Value> {\n  readonly #set: Set<Value>;\n\n  public get size() {\n    return this.#set.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#set[Symbol.iterator]();\n  }\n\n  constructor(values?: readonly Value[] | null) {\n    this.#set = new Set<Value>(values);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#set.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, value2: Value, set: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner set.\n    return this.#set.forEach((value: Value, value2: Value, _set: unknown) =>\n      callbackfn.call(thisArg, value, value2, this),\n    );\n  }\n\n  public has(value: Value) {\n    return this.#set.has(value);\n  }\n\n  public keys() {\n    return this.#set.keys();\n  }\n\n  public values() {\n    return this.#set.values();\n  }\n\n  public toString(): string {\n    return `FrozenSet(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\n\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n\nexport { FrozenMap, FrozenSet };\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}