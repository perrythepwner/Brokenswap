{"ast":null,"code":"const Account = require(\"./account\");\nconst Nat = require(\"./nat\");\nconst Bytes = require(\"./bytes\");\nconst RLP = require(\"./rlp\");\nconst keccak256 = require(\"./hash\").keccak256;\n\n// EthereumRPC, IncompleteTransaction -> Promise Transaction\nconst addDefaults = (rpc, tx) => {\n  var baseDefaults = [tx.chainId || rpc(\"net_version\", []), tx.gasPrice || rpc(\"eth_gasPrice\", []), tx.nonce || rpc(\"eth_getTransactionCount\", [tx.from, \"latest\"]), tx.value || \"0x0\", tx.data || \"0x\"];\n  const noAddress = address => !address || address === \"\" || address === \"0x\";\n  return Promise.all(baseDefaults).then(_ref => {\n    let [chainIdNum, gasPrice, nonce, value, data] = _ref;\n    var chainId = Nat.fromNumber(chainIdNum);\n    var gasEstimator = tx.gas ? Promise.resolve(null) : rpc(\"eth_estimateGas\", [{\n      from: noAddress(tx.from) ? null : tx.from,\n      to: noAddress(tx.to) ? null : tx.to,\n      value: tx.value,\n      nonce: tx.nonce,\n      data: tx.data\n    }]);\n    return gasEstimator.then(gasEstimate => {\n      if (gasEstimate.error) {\n        throw gasEstimate.error;\n      }\n      return {\n        chainId: chainId,\n        from: noAddress(tx.from) ? \"0x\" : tx.from.toLowerCase(),\n        to: noAddress(tx.to) ? \"0x\" : tx.to.toLowerCase(),\n        gasPrice: gasPrice,\n        gas: tx.gas ? tx.gas : Nat.div(Nat.mul(gasEstimate, \"0x6\"), \"0x5\"),\n        nonce: nonce,\n        value: value,\n        data: data ? data.toLowerCase() : null\n      };\n    });\n  });\n};\n\n// Transaction -> Bytes\nconst signingData = tx => {\n  return RLP.encode([Bytes.fromNat(tx.nonce), Bytes.fromNat(tx.gasPrice), Bytes.fromNat(tx.gas), tx.to ? tx.to.toLowerCase() : \"0x\", Bytes.fromNat(tx.value), tx.data, Bytes.fromNat(tx.chainId || \"0x1\"), \"0x\", \"0x\"]);\n};\n\n// Transaction, Account -> Bytes\nconst sign = (tx, account) => {\n  const data = signingData(tx);\n  const signature = Account.makeSigner(Nat.toNumber(tx.chainId || \"0x1\") * 2 + 35)(keccak256(data), account.privateKey);\n  const rawTransaction = RLP.decode(data).slice(0, 6).concat(Account.decodeSignature(signature));\n  return RLP.encode(rawTransaction);\n};\n\n// Bytes -> Address\nconst recover = rawTransaction => {\n  const values = RLP.decode(rawTransaction);\n  const signature = Account.encodeSignature(values.slice(6, 9));\n  const recovery = Bytes.toNumber(values[6]);\n  const extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), \"0x\", \"0x\"];\n  const data = values.slice(0, 6).concat(extraData);\n  const dataHex = RLP.encode(data);\n  return Account.recover(keccak256(dataHex), signature);\n};\nmodule.exports = {\n  addDefaults,\n  signingData,\n  sign,\n  recover\n};","map":null,"metadata":{},"sourceType":"script"}