{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{STAKING_REWARDS_INTERFACE}from'constants/abis/staking-rewards';import{UBE}from'constants/tokens';import useCurrentBlockTimestamp from'hooks/useCurrentBlockTimestamp';import{useMemo}from'react';import{useMultipleContractSingleData}from'state/multicall/hooks';import{INT_SECONDS_IN_WEEK}from'./../../constants/index';import{useStakingPools}from'./hooks';// Gets the staking info from the network for the active chain id\nexport default function useStakingInfo(pairToFilterBy,stakingAddress){const{network,address}=useCelo();const chainId=network.chainId;const ube=chainId?UBE[chainId]:undefined;// detect if staking is ended\nconst currentBlockTimestamp=useCurrentBlockTimestamp();const info=useStakingPools(pairToFilterBy,stakingAddress);// These are the staking pools\nconst rewardsAddresses=useMemo(()=>info.map(_ref=>{let{stakingRewardAddress}=_ref;return stakingRewardAddress;}),[info]);const accountArg=useMemo(()=>[address!==null&&address!==void 0?address:undefined],[address]);// get all the info from the staking rewards contracts\nconst balances=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'balanceOf',accountArg);const earnedAmounts=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'earned',accountArg);const totalSupplies=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'totalSupply');// tokens per second, constants\nconst rewardRates=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'rewardRate');const periodFinishes=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'periodFinish');return useMemo(()=>{if(!chainId||!ube)return[];return info.reduce((memo,_ref2,index)=>{let{stakingRewardAddress:rewardsAddress,poolInfo,tokens}=_ref2;// these two are dependent on account\nconst balanceState=balances[index];const earnedAmountState=earnedAmounts[index];// these get fetched regardless of account\nconst totalSupplyState=totalSupplies[index];const rewardRateState=rewardRates[index];const periodFinishState=periodFinishes[index];if(// these may be undefined if not logged in\n!(balanceState!==null&&balanceState!==void 0&&balanceState.loading)&&!(earnedAmountState!==null&&earnedAmountState!==void 0&&earnedAmountState.loading)&&// always need these\ntotalSupplyState&&!totalSupplyState.loading&&rewardRateState&&!rewardRateState.loading&&periodFinishState&&!periodFinishState.loading){var _balanceState$result$,_balanceState$result,_totalSupplyState$res,_poolInfo$nextPeriodR,_poolInfo$nextPeriodR2,_periodFinishState$re,_periodFinishState$re2,_rewardRateState$resu,_earnedAmountState$re,_earnedAmountState$re2;if(balanceState!==null&&balanceState!==void 0&&balanceState.error||earnedAmountState!==null&&earnedAmountState!==void 0&&earnedAmountState.error||totalSupplyState.error||rewardRateState.error||periodFinishState.error){console.error('Failed to load staking rewards info');return memo;}const rewardToken=poolInfo.rewardToken?new Token(chainId,poolInfo.rewardToken,18,poolInfo.rewardTokenSymbol):ube;// get the LP token\nconst liquidityToken=new Token(chainId,poolInfo.stakingToken,18,'ULP','Ubeswap LP Token');// check for account, if no account set to 0\nconst stakedAmount=new TokenAmount(liquidityToken,JSBI.BigInt((_balanceState$result$=balanceState===null||balanceState===void 0?void 0:(_balanceState$result=balanceState.result)===null||_balanceState$result===void 0?void 0:_balanceState$result[0])!==null&&_balanceState$result$!==void 0?_balanceState$result$:0));const totalStakedAmount=new TokenAmount(liquidityToken,JSBI.BigInt((_totalSupplyState$res=totalSupplyState.result)===null||_totalSupplyState$res===void 0?void 0:_totalSupplyState$res[0]));const nextPeriodRewards=new TokenAmount(ube,(_poolInfo$nextPeriodR=(_poolInfo$nextPeriodR2=poolInfo.nextPeriodRewards)===null||_poolInfo$nextPeriodR2===void 0?void 0:_poolInfo$nextPeriodR2.toString())!==null&&_poolInfo$nextPeriodR!==void 0?_poolInfo$nextPeriodR:'0');const getHypotheticalRewardRate=(stakedAmount,totalStakedAmount,totalRewardRates)=>{return[new TokenAmount(rewardToken,JSBI.greaterThan(totalStakedAmount.raw,JSBI.BigInt(0))?JSBI.divide(JSBI.multiply(totalRewardRates[0].raw,stakedAmount.raw),totalStakedAmount.raw):JSBI.BigInt(0))];};const periodFinishSeconds=(_periodFinishState$re=periodFinishState.result)===null||_periodFinishState$re===void 0?void 0:(_periodFinishState$re2=_periodFinishState$re[0])===null||_periodFinishState$re2===void 0?void 0:_periodFinishState$re2.toNumber();const periodFinishMs=periodFinishSeconds*1000;// compare period end timestamp vs current block timestamp (in seconds)\nconst active=periodFinishSeconds&&currentBlockTimestamp?periodFinishSeconds>currentBlockTimestamp.toNumber():false;const rewardsFinished=Math.floor(Date.now()/1000)-periodFinishSeconds>INT_SECONDS_IN_WEEK;const totalRewardRate=new TokenAmount(rewardToken,rewardsFinished?JSBI.BigInt(0):JSBI.BigInt((_rewardRateState$resu=rewardRateState.result)===null||_rewardRateState$resu===void 0?void 0:_rewardRateState$resu[0]));const individualRewardRate=getHypotheticalRewardRate(stakedAmount,totalStakedAmount,[totalRewardRate]);if(!tokens){return memo;}memo.push({stakingRewardAddress:rewardsAddress,stakingToken:totalStakedAmount.token,tokens,stakedAmount,totalStakedAmount,earnedAmounts:[new TokenAmount(rewardToken,JSBI.BigInt((_earnedAmountState$re=earnedAmountState===null||earnedAmountState===void 0?void 0:(_earnedAmountState$re2=earnedAmountState.result)===null||_earnedAmountState$re2===void 0?void 0:_earnedAmountState$re2[0])!==null&&_earnedAmountState$re!==void 0?_earnedAmountState$re:0))],rewardRates:individualRewardRate,totalRewardRates:[totalRewardRate],periodFinish:periodFinishMs>0?new Date(periodFinishMs):undefined,active,getHypotheticalRewardRate,nextPeriodRewards,poolInfo,rewardTokens:[rewardToken]});}return memo;},[]);},[balances,chainId,currentBlockTimestamp,earnedAmounts,info,periodFinishes,rewardRates,totalSupplies,ube]);}// `stakingAddress` is used to differentiate when there are two different farms with the same LP\nexport const usePairStakingInfo=(pairToFilterBy,stakingAddress)=>{var _useStakingInfo$;return(_useStakingInfo$=useStakingInfo(pairToFilterBy,stakingAddress)[0])!==null&&_useStakingInfo$!==void 0?_useStakingInfo$:undefined;};","map":{"version":3,"names":["useCelo","JSBI","Token","TokenAmount","STAKING_REWARDS_INTERFACE","UBE","useCurrentBlockTimestamp","useMemo","useMultipleContractSingleData","INT_SECONDS_IN_WEEK","useStakingPools","useStakingInfo","pairToFilterBy","stakingAddress","network","address","chainId","ube","undefined","currentBlockTimestamp","info","rewardsAddresses","map","_ref","stakingRewardAddress","accountArg","balances","earnedAmounts","totalSupplies","rewardRates","periodFinishes","reduce","memo","_ref2","index","rewardsAddress","poolInfo","tokens","balanceState","earnedAmountState","totalSupplyState","rewardRateState","periodFinishState","loading","_balanceState$result$","_balanceState$result","_totalSupplyState$res","_poolInfo$nextPeriodR","_poolInfo$nextPeriodR2","_periodFinishState$re","_periodFinishState$re2","_rewardRateState$resu","_earnedAmountState$re","_earnedAmountState$re2","error","console","rewardToken","rewardTokenSymbol","liquidityToken","stakingToken","stakedAmount","BigInt","result","totalStakedAmount","nextPeriodRewards","toString","getHypotheticalRewardRate","totalRewardRates","greaterThan","raw","divide","multiply","periodFinishSeconds","toNumber","periodFinishMs","active","rewardsFinished","Math","floor","Date","now","totalRewardRate","individualRewardRate","push","token","periodFinish","rewardTokens","usePairStakingInfo","_useStakingInfo$"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/stake/useStakingInfo.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { ChainId as UbeswapChainId, JSBI, Pair, Token, TokenAmount } from '@ubeswap/sdk'\nimport { STAKING_REWARDS_INTERFACE } from 'constants/abis/staking-rewards'\nimport { UBE } from 'constants/tokens'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\nimport { useMemo } from 'react'\nimport { useMultipleContractSingleData } from 'state/multicall/hooks'\n\nimport { INT_SECONDS_IN_WEEK } from './../../constants/index'\nimport { StakingInfo, useStakingPools } from './hooks'\n\n// Gets the staking info from the network for the active chain id\nexport default function useStakingInfo(pairToFilterBy?: Pair | null, stakingAddress?: string): readonly StakingInfo[] {\n  const { network, address } = useCelo()\n  const chainId = network.chainId as unknown as UbeswapChainId\n  const ube = chainId ? UBE[chainId] : undefined\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp()\n\n  const info = useStakingPools(pairToFilterBy, stakingAddress)\n  // These are the staking pools\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n\n  const accountArg = useMemo(() => [address ?? undefined], [address])\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate')\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish')\n  return useMemo(() => {\n    if (!chainId || !ube) return []\n\n    return info.reduce(\n      (memo: StakingInfo[], { stakingRewardAddress: rewardsAddress, poolInfo, tokens }, index: number) => {\n        // these two are dependent on account\n        const balanceState = balances[index]\n        const earnedAmountState = earnedAmounts[index]\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index]\n        const rewardRateState = rewardRates[index]\n        const periodFinishState = periodFinishes[index]\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading &&\n          rewardRateState &&\n          !rewardRateState.loading &&\n          periodFinishState &&\n          !periodFinishState.loading\n        ) {\n          if (\n            balanceState?.error ||\n            earnedAmountState?.error ||\n            totalSupplyState.error ||\n            rewardRateState.error ||\n            periodFinishState.error\n          ) {\n            console.error('Failed to load staking rewards info')\n            return memo\n          }\n\n          const rewardToken = poolInfo.rewardToken\n            ? new Token(chainId, poolInfo.rewardToken, 18, poolInfo.rewardTokenSymbol)\n            : ube\n\n          // get the LP token\n          const liquidityToken = new Token(chainId, poolInfo.stakingToken, 18, 'ULP', 'Ubeswap LP Token')\n\n          // check for account, if no account set to 0\n          const stakedAmount = new TokenAmount(liquidityToken, JSBI.BigInt(balanceState?.result?.[0] ?? 0))\n          const totalStakedAmount = new TokenAmount(liquidityToken, JSBI.BigInt(totalSupplyState.result?.[0]))\n          const nextPeriodRewards = new TokenAmount(ube, poolInfo.nextPeriodRewards?.toString() ?? '0')\n\n          const getHypotheticalRewardRate = (\n            stakedAmount: TokenAmount,\n            totalStakedAmount: TokenAmount,\n            totalRewardRates: TokenAmount[]\n          ): TokenAmount[] => {\n            return [\n              new TokenAmount(\n                rewardToken,\n                JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n                  ? JSBI.divide(JSBI.multiply(totalRewardRates[0].raw, stakedAmount.raw), totalStakedAmount.raw)\n                  : JSBI.BigInt(0)\n              ),\n            ]\n          }\n\n          const periodFinishSeconds = periodFinishState.result?.[0]?.toNumber()\n          const periodFinishMs = periodFinishSeconds * 1000\n          // compare period end timestamp vs current block timestamp (in seconds)\n          const active =\n            periodFinishSeconds && currentBlockTimestamp\n              ? periodFinishSeconds > currentBlockTimestamp.toNumber()\n              : false\n\n          const rewardsFinished = Math.floor(Date.now() / 1000) - periodFinishSeconds > INT_SECONDS_IN_WEEK\n          const totalRewardRate = new TokenAmount(\n            rewardToken,\n            rewardsFinished ? JSBI.BigInt(0) : JSBI.BigInt(rewardRateState.result?.[0])\n          )\n          const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, [totalRewardRate])\n\n          if (!tokens) {\n            return memo\n          }\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            stakingToken: totalStakedAmount.token,\n            tokens,\n            stakedAmount,\n            totalStakedAmount,\n            earnedAmounts: [new TokenAmount(rewardToken, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0))],\n            rewardRates: individualRewardRate,\n            totalRewardRates: [totalRewardRate],\n            periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n            active,\n            getHypotheticalRewardRate,\n            nextPeriodRewards,\n            poolInfo,\n            rewardTokens: [rewardToken],\n          })\n        }\n        return memo\n      },\n      []\n    )\n  }, [balances, chainId, currentBlockTimestamp, earnedAmounts, info, periodFinishes, rewardRates, totalSupplies, ube])\n}\n\n// `stakingAddress` is used to differentiate when there are two different farms with the same LP\nexport const usePairStakingInfo = (pairToFilterBy?: Pair | null, stakingAddress?: string): StakingInfo | undefined => {\n  return useStakingInfo(pairToFilterBy, stakingAddress)[0] ?? undefined\n}\n"],"mappings":"AAAA,OAASA,OAAO,KAAQ,kBAAkB,CAC1C,OAAoCC,IAAI,CAAQC,KAAK,CAAEC,WAAW,KAAQ,cAAc,CACxF,OAASC,yBAAyB,KAAQ,gCAAgC,CAC1E,OAASC,GAAG,KAAQ,kBAAkB,CACtC,MAAO,CAAAC,wBAAwB,KAAM,gCAAgC,CACrE,OAASC,OAAO,KAAQ,OAAO,CAC/B,OAASC,6BAA6B,KAAQ,uBAAuB,CAErE,OAASC,mBAAmB,KAAQ,yBAAyB,CAC7D,OAAsBC,eAAe,KAAQ,SAAS,CAEtD;AACA,cAAe,SAAS,CAAAC,cAAcA,CAACC,cAA4B,CAAEC,cAAuB,CAA0B,CACpH,KAAM,CAAEC,OAAO,CAAEC,OAAQ,CAAC,CAAGf,OAAO,CAAC,CAAC,CACtC,KAAM,CAAAgB,OAAO,CAAGF,OAAO,CAACE,OAAoC,CAC5D,KAAM,CAAAC,GAAG,CAAGD,OAAO,CAAGX,GAAG,CAACW,OAAO,CAAC,CAAGE,SAAS,CAE9C;AACA,KAAM,CAAAC,qBAAqB,CAAGb,wBAAwB,CAAC,CAAC,CAExD,KAAM,CAAAc,IAAI,CAAGV,eAAe,CAACE,cAAc,CAAEC,cAAc,CAAC,CAC5D;AACA,KAAM,CAAAQ,gBAAgB,CAAGd,OAAO,CAAC,IAAMa,IAAI,CAACE,GAAG,CAACC,IAAA,MAAC,CAAEC,oBAAqB,CAAC,CAAAD,IAAA,OAAK,CAAAC,oBAAoB,GAAC,CAAE,CAACJ,IAAI,CAAC,CAAC,CAE5G,KAAM,CAAAK,UAAU,CAAGlB,OAAO,CAAC,IAAM,CAACQ,OAAO,SAAPA,OAAO,UAAPA,OAAO,CAAIG,SAAS,CAAC,CAAE,CAACH,OAAO,CAAC,CAAC,CAEnE;AACA,KAAM,CAAAW,QAAQ,CAAGlB,6BAA6B,CAACa,gBAAgB,CAAEjB,yBAAyB,CAAE,WAAW,CAAEqB,UAAU,CAAC,CACpH,KAAM,CAAAE,aAAa,CAAGnB,6BAA6B,CAACa,gBAAgB,CAAEjB,yBAAyB,CAAE,QAAQ,CAAEqB,UAAU,CAAC,CACtH,KAAM,CAAAG,aAAa,CAAGpB,6BAA6B,CAACa,gBAAgB,CAAEjB,yBAAyB,CAAE,aAAa,CAAC,CAE/G;AACA,KAAM,CAAAyB,WAAW,CAAGrB,6BAA6B,CAACa,gBAAgB,CAAEjB,yBAAyB,CAAE,YAAY,CAAC,CAC5G,KAAM,CAAA0B,cAAc,CAAGtB,6BAA6B,CAACa,gBAAgB,CAAEjB,yBAAyB,CAAE,cAAc,CAAC,CACjH,MAAO,CAAAG,OAAO,CAAC,IAAM,CACnB,GAAI,CAACS,OAAO,EAAI,CAACC,GAAG,CAAE,MAAO,EAAE,CAE/B,MAAO,CAAAG,IAAI,CAACW,MAAM,CAChB,CAACC,IAAmB,CAAAC,KAAA,CAA8DC,KAAa,GAAK,IAA9E,CAAEV,oBAAoB,CAAEW,cAAc,CAAEC,QAAQ,CAAEC,MAAO,CAAC,CAAAJ,KAAA,CAC9E;AACA,KAAM,CAAAK,YAAY,CAAGZ,QAAQ,CAACQ,KAAK,CAAC,CACpC,KAAM,CAAAK,iBAAiB,CAAGZ,aAAa,CAACO,KAAK,CAAC,CAE9C;AACA,KAAM,CAAAM,gBAAgB,CAAGZ,aAAa,CAACM,KAAK,CAAC,CAC7C,KAAM,CAAAO,eAAe,CAAGZ,WAAW,CAACK,KAAK,CAAC,CAC1C,KAAM,CAAAQ,iBAAiB,CAAGZ,cAAc,CAACI,KAAK,CAAC,CAE/C,GACE;AACA,EAACI,YAAY,SAAZA,YAAY,WAAZA,YAAY,CAAEK,OAAO,GACtB,EAACJ,iBAAiB,SAAjBA,iBAAiB,WAAjBA,iBAAiB,CAAEI,OAAO,GAC3B;AACAH,gBAAgB,EAChB,CAACA,gBAAgB,CAACG,OAAO,EACzBF,eAAe,EACf,CAACA,eAAe,CAACE,OAAO,EACxBD,iBAAiB,EACjB,CAACA,iBAAiB,CAACC,OAAO,CAC1B,KAAAC,qBAAA,CAAAC,oBAAA,CAAAC,qBAAA,CAAAC,qBAAA,CAAAC,sBAAA,CAAAC,qBAAA,CAAAC,sBAAA,CAAAC,qBAAA,CAAAC,qBAAA,CAAAC,sBAAA,CACA,GACEf,YAAY,SAAZA,YAAY,WAAZA,YAAY,CAAEgB,KAAK,EACnBf,iBAAiB,SAAjBA,iBAAiB,WAAjBA,iBAAiB,CAAEe,KAAK,EACxBd,gBAAgB,CAACc,KAAK,EACtBb,eAAe,CAACa,KAAK,EACrBZ,iBAAiB,CAACY,KAAK,CACvB,CACAC,OAAO,CAACD,KAAK,CAAC,qCAAqC,CAAC,CACpD,MAAO,CAAAtB,IAAI,CACb,CAEA,KAAM,CAAAwB,WAAW,CAAGpB,QAAQ,CAACoB,WAAW,CACpC,GAAI,CAAAtD,KAAK,CAACc,OAAO,CAAEoB,QAAQ,CAACoB,WAAW,CAAE,EAAE,CAAEpB,QAAQ,CAACqB,iBAAiB,CAAC,CACxExC,GAAG,CAEP;AACA,KAAM,CAAAyC,cAAc,CAAG,GAAI,CAAAxD,KAAK,CAACc,OAAO,CAAEoB,QAAQ,CAACuB,YAAY,CAAE,EAAE,CAAE,KAAK,CAAE,kBAAkB,CAAC,CAE/F;AACA,KAAM,CAAAC,YAAY,CAAG,GAAI,CAAAzD,WAAW,CAACuD,cAAc,CAAEzD,IAAI,CAAC4D,MAAM,EAAAjB,qBAAA,CAACN,YAAY,SAAZA,YAAY,kBAAAO,oBAAA,CAAZP,YAAY,CAAEwB,MAAM,UAAAjB,oBAAA,iBAApBA,oBAAA,CAAuB,CAAC,CAAC,UAAAD,qBAAA,UAAAA,qBAAA,CAAI,CAAC,CAAC,CAAC,CACjG,KAAM,CAAAmB,iBAAiB,CAAG,GAAI,CAAA5D,WAAW,CAACuD,cAAc,CAAEzD,IAAI,CAAC4D,MAAM,EAAAf,qBAAA,CAACN,gBAAgB,CAACsB,MAAM,UAAAhB,qBAAA,iBAAvBA,qBAAA,CAA0B,CAAC,CAAC,CAAC,CAAC,CACpG,KAAM,CAAAkB,iBAAiB,CAAG,GAAI,CAAA7D,WAAW,CAACc,GAAG,EAAA8B,qBAAA,EAAAC,sBAAA,CAAEZ,QAAQ,CAAC4B,iBAAiB,UAAAhB,sBAAA,iBAA1BA,sBAAA,CAA4BiB,QAAQ,CAAC,CAAC,UAAAlB,qBAAA,UAAAA,qBAAA,CAAI,GAAG,CAAC,CAE7F,KAAM,CAAAmB,yBAAyB,CAAGA,CAChCN,YAAyB,CACzBG,iBAA8B,CAC9BI,gBAA+B,GACb,CAClB,MAAO,CACL,GAAI,CAAAhE,WAAW,CACbqD,WAAW,CACXvD,IAAI,CAACmE,WAAW,CAACL,iBAAiB,CAACM,GAAG,CAAEpE,IAAI,CAAC4D,MAAM,CAAC,CAAC,CAAC,CAAC,CACnD5D,IAAI,CAACqE,MAAM,CAACrE,IAAI,CAACsE,QAAQ,CAACJ,gBAAgB,CAAC,CAAC,CAAC,CAACE,GAAG,CAAET,YAAY,CAACS,GAAG,CAAC,CAAEN,iBAAiB,CAACM,GAAG,CAAC,CAC5FpE,IAAI,CAAC4D,MAAM,CAAC,CAAC,CACnB,CAAC,CACF,CACH,CAAC,CAED,KAAM,CAAAW,mBAAmB,EAAAvB,qBAAA,CAAGP,iBAAiB,CAACoB,MAAM,UAAAb,qBAAA,kBAAAC,sBAAA,CAAxBD,qBAAA,CAA2B,CAAC,CAAC,UAAAC,sBAAA,iBAA7BA,sBAAA,CAA+BuB,QAAQ,CAAC,CAAC,CACrE,KAAM,CAAAC,cAAc,CAAGF,mBAAmB,CAAG,IAAI,CACjD;AACA,KAAM,CAAAG,MAAM,CACVH,mBAAmB,EAAIrD,qBAAqB,CACxCqD,mBAAmB,CAAGrD,qBAAqB,CAACsD,QAAQ,CAAC,CAAC,CACtD,KAAK,CAEX,KAAM,CAAAG,eAAe,CAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAG,IAAI,CAAC,CAAGR,mBAAmB,CAAG/D,mBAAmB,CACjG,KAAM,CAAAwE,eAAe,CAAG,GAAI,CAAA9E,WAAW,CACrCqD,WAAW,CACXoB,eAAe,CAAG3E,IAAI,CAAC4D,MAAM,CAAC,CAAC,CAAC,CAAG5D,IAAI,CAAC4D,MAAM,EAAAV,qBAAA,CAACV,eAAe,CAACqB,MAAM,UAAAX,qBAAA,iBAAtBA,qBAAA,CAAyB,CAAC,CAAC,CAC5E,CAAC,CACD,KAAM,CAAA+B,oBAAoB,CAAGhB,yBAAyB,CAACN,YAAY,CAAEG,iBAAiB,CAAE,CAACkB,eAAe,CAAC,CAAC,CAE1G,GAAI,CAAC5C,MAAM,CAAE,CACX,MAAO,CAAAL,IAAI,CACb,CAEAA,IAAI,CAACmD,IAAI,CAAC,CACR3D,oBAAoB,CAAEW,cAAc,CACpCwB,YAAY,CAAEI,iBAAiB,CAACqB,KAAK,CACrC/C,MAAM,CACNuB,YAAY,CACZG,iBAAiB,CACjBpC,aAAa,CAAE,CAAC,GAAI,CAAAxB,WAAW,CAACqD,WAAW,CAAEvD,IAAI,CAAC4D,MAAM,EAAAT,qBAAA,CAACb,iBAAiB,SAAjBA,iBAAiB,kBAAAc,sBAAA,CAAjBd,iBAAiB,CAAEuB,MAAM,UAAAT,sBAAA,iBAAzBA,sBAAA,CAA4B,CAAC,CAAC,UAAAD,qBAAA,UAAAA,qBAAA,CAAI,CAAC,CAAC,CAAC,CAAC,CAC/FvB,WAAW,CAAEqD,oBAAoB,CACjCf,gBAAgB,CAAE,CAACc,eAAe,CAAC,CACnCI,YAAY,CAAEX,cAAc,CAAG,CAAC,CAAG,GAAI,CAAAK,IAAI,CAACL,cAAc,CAAC,CAAGxD,SAAS,CACvEyD,MAAM,CACNT,yBAAyB,CACzBF,iBAAiB,CACjB5B,QAAQ,CACRkD,YAAY,CAAE,CAAC9B,WAAW,CAC5B,CAAC,CAAC,CACJ,CACA,MAAO,CAAAxB,IAAI,CACb,CAAC,CACD,EACF,CAAC,CACH,CAAC,CAAE,CAACN,QAAQ,CAAEV,OAAO,CAAEG,qBAAqB,CAAEQ,aAAa,CAAEP,IAAI,CAAEU,cAAc,CAAED,WAAW,CAAED,aAAa,CAAEX,GAAG,CAAC,CAAC,CACtH,CAEA;AACA,MAAO,MAAM,CAAAsE,kBAAkB,CAAGA,CAAC3E,cAA4B,CAAEC,cAAuB,GAA8B,KAAA2E,gBAAA,CACpH,OAAAA,gBAAA,CAAO7E,cAAc,CAACC,cAAc,CAAEC,cAAc,CAAC,CAAC,CAAC,CAAC,UAAA2E,gBAAA,UAAAA,gBAAA,CAAItE,SAAS,CACvE,CAAC"},"metadata":{},"sourceType":"module"}