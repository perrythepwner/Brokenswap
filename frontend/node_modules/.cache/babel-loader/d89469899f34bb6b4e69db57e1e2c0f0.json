{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnionType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst none_1 = require(\"./none\");\nconst VALUE_GINDEX = BigInt(2);\nconst SELECTOR_GINDEX = BigInt(3);\n/**\n * Union: union type containing one of the given subtypes\n * - Notation: Union[type_0, type_1, ...], e.g. union[None, uint64, uint32]\n */\nclass UnionType extends composite_1.CompositeType {\n  constructor(types, opts) {\n    var _opts$typeName;\n    super();\n    this.types = types;\n    this.depth = 1;\n    this.maxChunkCount = 1;\n    this.fixedSize = null;\n    this.isList = true;\n    this.isViewMutable = true;\n    if (types.length >= 128) {\n      throw Error(\"Must have less than 128 types\");\n    }\n    if (types.length === 0) {\n      throw Error(\"Must have at least 1 type option\");\n    }\n    if (types[0] instanceof none_1.NoneType && types.length < 2) {\n      throw Error(\"Must have at least 2 type options if the first is None\");\n    }\n    for (let i = 1; i < types.length; i++) {\n      if (types[i] instanceof none_1.NoneType) {\n        throw Error(\"None may only be the first option\");\n      }\n    }\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"Union[\".concat(types.map(t => t.typeName).join(\",\"), \"]\");\n    const minLens = [];\n    const maxLens = [];\n    for (const _type of types) {\n      minLens.push(_type.minSize);\n      maxLens.push(_type.maxSize);\n    }\n    this.minSize = 1 + Math.min(...minLens);\n    this.maxSize = 1 + Math.max(...maxLens);\n    this.maxSelector = this.types.length - 1;\n  }\n  static named(types, opts) {\n    return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);\n  }\n  defaultValue() {\n    return {\n      selector: 0,\n      value: this.types[0].defaultValue()\n    };\n  }\n  getView(tree) {\n    return this.tree_toValue(tree.rootNode);\n  }\n  getViewDU(node) {\n    return this.tree_toValue(node);\n  }\n  cacheOfViewDU() {\n    return;\n  }\n  commitView(view) {\n    return this.value_toTree(view);\n  }\n  commitViewDU(view) {\n    return this.value_toTree(view);\n  }\n  value_serializedSize(value) {\n    return 1 + this.types[value.selector].value_serializedSize(value.value);\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value.selector;\n    return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const selector = data.uint8Array[start];\n    if (selector > this.maxSelector) {\n      throw Error(\"Invalid selector \".concat(selector));\n    }\n    return {\n      selector,\n      value: this.types[selector].value_deserializeFromBytes(data, start + 1, end)\n    };\n  }\n  tree_serializedSize(node) {\n    const selector = arrayBasic_1.getLengthFromRootNode(node);\n    const valueNode = node.left;\n    return 1 + this.types[selector].value_serializedSize(valueNode);\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const selector = arrayBasic_1.getLengthFromRootNode(node);\n    const valueNode = node.left;\n    output.uint8Array[offset] = selector;\n    return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const selector = data.uint8Array[start];\n    if (selector > this.maxSelector) {\n      throw Error(\"Invalid selector \".concat(selector));\n    }\n    const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);\n    return arrayBasic_1.addLengthNode(valueNode, selector);\n  }\n  // Merkleization\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);\n  }\n  getRoots(value) {\n    const valueRoot = this.types[value.selector].hashTreeRoot(value.value);\n    return [valueRoot];\n  }\n  // Proofs\n  getPropertyGindex(prop) {\n    switch (prop) {\n      case \"value\":\n        return VALUE_GINDEX;\n      case \"selector\":\n        return SELECTOR_GINDEX;\n      default:\n        throw new Error(\"Invalid Union type property \".concat(prop));\n    }\n  }\n  getPropertyType() {\n    // a Union has multiple types\n    throw new Error(\"Not applicable for Union type\");\n  }\n  getIndexProperty(index) {\n    if (index === 0) return \"value\";\n    if (index === 1) return \"selector\";\n    throw Error(\"Union index of out bounds\");\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    if (!rootNode) {\n      throw Error(\"rootNode required\");\n    }\n    const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];\n    const selector = arrayBasic_1.getLengthFromRootNode(rootNode);\n    const type = this.types[selector];\n    const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);\n    if (composite_1.isCompositeType(type)) {\n      gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));\n    } else {\n      gindices.push(extendedFieldGindex);\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw new Error(\"JSON must be of type object\");\n    }\n    const union = json;\n    if (typeof union.selector !== \"number\") {\n      throw new Error(\"Invalid JSON Union selector must be number\");\n    }\n    const type = this.types[union.selector];\n    if (!type) {\n      throw new Error(\"Invalid JSON Union selector out of range\");\n    }\n    return {\n      selector: union.selector,\n      value: type.toJson(union.value)\n    };\n  }\n  toJson(value) {\n    return {\n      selector: value.selector,\n      value: this.types[value.selector].toJson(value.value)\n    };\n  }\n  clone(value) {\n    return {\n      selector: value.selector,\n      value: this.types[value.selector].clone(value.value)\n    };\n  }\n  equals(a, b) {\n    if (a.selector !== b.selector) {\n      return false;\n    }\n    return this.types[a.selector].equals(a.value, b.value);\n  }\n}\nexports.UnionType = UnionType;","map":{"version":3,"sources":["../../src/type/union.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnionType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst none_1 = require(\"./none\");\nconst VALUE_GINDEX = BigInt(2);\nconst SELECTOR_GINDEX = BigInt(3);\n/**\n * Union: union type containing one of the given subtypes\n * - Notation: Union[type_0, type_1, ...], e.g. union[None, uint64, uint32]\n */\nclass UnionType extends composite_1.CompositeType {\n    constructor(types, opts) {\n        super();\n        this.types = types;\n        this.depth = 1;\n        this.maxChunkCount = 1;\n        this.fixedSize = null;\n        this.isList = true;\n        this.isViewMutable = true;\n        if (types.length >= 128) {\n            throw Error(\"Must have less than 128 types\");\n        }\n        if (types.length === 0) {\n            throw Error(\"Must have at least 1 type option\");\n        }\n        if (types[0] instanceof none_1.NoneType && types.length < 2) {\n            throw Error(\"Must have at least 2 type options if the first is None\");\n        }\n        for (let i = 1; i < types.length; i++) {\n            if (types[i] instanceof none_1.NoneType) {\n                throw Error(\"None may only be the first option\");\n            }\n        }\n        this.typeName = opts?.typeName ?? `Union[${types.map((t) => t.typeName).join(\",\")}]`;\n        const minLens = [];\n        const maxLens = [];\n        for (const _type of types) {\n            minLens.push(_type.minSize);\n            maxLens.push(_type.maxSize);\n        }\n        this.minSize = 1 + Math.min(...minLens);\n        this.maxSize = 1 + Math.max(...maxLens);\n        this.maxSelector = this.types.length - 1;\n    }\n    static named(types, opts) {\n        return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);\n    }\n    defaultValue() {\n        return {\n            selector: 0,\n            value: this.types[0].defaultValue(),\n        };\n    }\n    getView(tree) {\n        return this.tree_toValue(tree.rootNode);\n    }\n    getViewDU(node) {\n        return this.tree_toValue(node);\n    }\n    cacheOfViewDU() {\n        return;\n    }\n    commitView(view) {\n        return this.value_toTree(view);\n    }\n    commitViewDU(view) {\n        return this.value_toTree(view);\n    }\n    value_serializedSize(value) {\n        return 1 + this.types[value.selector].value_serializedSize(value.value);\n    }\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array[offset] = value.selector;\n        return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);\n    }\n    value_deserializeFromBytes(data, start, end) {\n        const selector = data.uint8Array[start];\n        if (selector > this.maxSelector) {\n            throw Error(`Invalid selector ${selector}`);\n        }\n        return {\n            selector,\n            value: this.types[selector].value_deserializeFromBytes(data, start + 1, end),\n        };\n    }\n    tree_serializedSize(node) {\n        const selector = arrayBasic_1.getLengthFromRootNode(node);\n        const valueNode = node.left;\n        return 1 + this.types[selector].value_serializedSize(valueNode);\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const selector = arrayBasic_1.getLengthFromRootNode(node);\n        const valueNode = node.left;\n        output.uint8Array[offset] = selector;\n        return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const selector = data.uint8Array[start];\n        if (selector > this.maxSelector) {\n            throw Error(`Invalid selector ${selector}`);\n        }\n        const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);\n        return arrayBasic_1.addLengthNode(valueNode, selector);\n    }\n    // Merkleization\n    hashTreeRoot(value) {\n        return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);\n    }\n    getRoots(value) {\n        const valueRoot = this.types[value.selector].hashTreeRoot(value.value);\n        return [valueRoot];\n    }\n    // Proofs\n    getPropertyGindex(prop) {\n        switch (prop) {\n            case \"value\":\n                return VALUE_GINDEX;\n            case \"selector\":\n                return SELECTOR_GINDEX;\n            default:\n                throw new Error(`Invalid Union type property ${prop}`);\n        }\n    }\n    getPropertyType() {\n        // a Union has multiple types\n        throw new Error(\"Not applicable for Union type\");\n    }\n    getIndexProperty(index) {\n        if (index === 0)\n            return \"value\";\n        if (index === 1)\n            return \"selector\";\n        throw Error(\"Union index of out bounds\");\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        if (!rootNode) {\n            throw Error(\"rootNode required\");\n        }\n        const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];\n        const selector = arrayBasic_1.getLengthFromRootNode(rootNode);\n        const type = this.types[selector];\n        const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);\n        if (composite_1.isCompositeType(type)) {\n            gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));\n        }\n        else {\n            gindices.push(extendedFieldGindex);\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json !== \"object\") {\n            throw new Error(\"JSON must be of type object\");\n        }\n        const union = json;\n        if (typeof union.selector !== \"number\") {\n            throw new Error(\"Invalid JSON Union selector must be number\");\n        }\n        const type = this.types[union.selector];\n        if (!type) {\n            throw new Error(\"Invalid JSON Union selector out of range\");\n        }\n        return {\n            selector: union.selector,\n            value: type.toJson(union.value),\n        };\n    }\n    toJson(value) {\n        return {\n            selector: value.selector,\n            value: this.types[value.selector].toJson(value.value),\n        };\n    }\n    clone(value) {\n        return {\n            selector: value.selector,\n            value: this.types[value.selector].clone(value.value),\n        };\n    }\n    equals(a, b) {\n        if (a.selector !== b.selector) {\n            return false;\n        }\n        return this.types[a.selector].equals(a.value, b.value);\n    }\n}\nexports.UnionType = UnionType;\n//# sourceMappingURL=union.js.map"]},"metadata":{},"sourceType":"script"}