{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n  const types = getJSONTypes(schema.type);\n  const hasNull = types.includes(\"null\");\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n    if (schema.nullable === true) types.push(\"null\");\n  }\n  return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n  const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const coerceTo = coerceToTypes(types, opts.coerceTypes);\n  const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n  return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(t => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\nfunction coerceData(it, types, coerceTo) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const dataType = gen.let(\"dataType\", (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"typeof \", \"\"])), data));\n  const coerced = gen.let(\"coerced\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"undefined\"]))));\n  if (opts.coerceTypes === \"array\") {\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" == 'object' && Array.isArray(\", \") && \", \".length == 1\"])), dataType, data, data), () => gen.assign(data, (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \"[0]\"])), data)).assign(dataType, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"typeof \", \"\"])), data)).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n  }\n  gen.if((0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), coerced));\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n      coerceSpecificType(t);\n    }\n  }\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if((0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), coerced), () => {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" == \\\"number\\\" || \", \" == \\\"boolean\\\"\"])), dataType, dataType)).assign(coerced, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\\\"\\\" + \", \"\"])), data)).elseIf((0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" === null\"])), data)).assign(coerced, (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n        return;\n      case \"number\":\n        gen.elseIf((0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" == \\\"boolean\\\" || \", \" === null\\n              || (\", \" == \\\"string\\\" && \", \" && \", \" == +\", \")\"])), dataType, data, dataType, data, data, data)).assign(coerced, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"+\", \"\"])), data));\n        return;\n      case \"integer\":\n        gen.elseIf((0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \" === \\\"boolean\\\" || \", \" === null\\n              || (\", \" === \\\"string\\\" && \", \" && \", \" == +\", \" && !(\", \" % 1))\"])), dataType, data, dataType, data, data, data, data)).assign(coerced, (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"+\", \"\"])), data));\n        return;\n      case \"boolean\":\n        gen.elseIf((0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \" === \\\"false\\\" || \", \" === 0 || \", \" === null\"])), data, data, data)).assign(coerced, false).elseIf((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \" === \\\"true\\\" || \", \" === 1\"])), data, data)).assign(coerced, true);\n        return;\n      case \"null\":\n        gen.elseIf((0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"\", \" === \\\"\\\" || \", \" === 0 || \", \" === false\"])), data, data, data));\n        gen.assign(coerced, null);\n        return;\n      case \"array\":\n        gen.elseIf((0, codegen_1._)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"\", \" === \\\"string\\\" || \", \" === \\\"number\\\"\\n              || \", \" === \\\"boolean\\\" || \", \" === null\"])), dataType, dataType, dataType, data)).assign(coerced, (0, codegen_1._)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"[\", \"]\"])), data));\n    }\n  }\n}\nfunction assignParentData(_ref, expr) {\n  let {\n    gen,\n    parentData,\n    parentDataProperty\n  } = _ref;\n  // TODO use gen.property\n  gen.if((0, codegen_1._)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), parentData), () => gen.assign((0, codegen_1._)(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), parentData, parentDataProperty), expr));\n}\nfunction checkDataType(dataType, data, strictNums) {\n  let correct = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DataType.Correct;\n  const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  let cond;\n  switch (dataType) {\n    case \"null\":\n      return (0, codegen_1._)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \" \", \" null\"])), data, EQ);\n    case \"array\":\n      cond = (0, codegen_1._)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"Array.isArray(\", \")\"])), data);\n      break;\n    case \"object\":\n      cond = (0, codegen_1._)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"\", \" && typeof \", \" == \\\"object\\\" && !Array.isArray(\", \")\"])), data, data, data);\n      break;\n    case \"integer\":\n      cond = numCond((0, codegen_1._)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"!(\", \" % 1) && !isNaN(\", \")\"])), data, data));\n      break;\n    case \"number\":\n      cond = numCond();\n      break;\n    default:\n      return (0, codegen_1._)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"typeof \", \" \", \" \", \"\"])), data, EQ, dataType);\n  }\n  return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n  function numCond() {\n    let _cond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    return (0, codegen_1.and)((0, codegen_1._)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"typeof \", \" == \\\"number\\\"\"])), data), _cond, strictNums ? (0, codegen_1._)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"isFinite(\", \")\"])), data) : codegen_1.nil);\n  }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n  let cond;\n  const types = (0, util_1.toHash)(dataTypes);\n  if (types.array && types.object) {\n    const notObj = (0, codegen_1._)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"])), data);\n    cond = types.null ? notObj : (0, codegen_1._)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"!\", \" || \", \"\"])), data, notObj);\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n  if (types.number) delete types.integer;\n  for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n  return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n  message: _ref2 => {\n    let {\n      schema\n    } = _ref2;\n    return \"must be \".concat(schema);\n  },\n  params: _ref3 => {\n    let {\n      schema,\n      schemaValue\n    } = _ref3;\n    return typeof schema == \"string\" ? (0, codegen_1._)(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"{type: \", \"}\"])), schema) : (0, codegen_1._)(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"{type: \", \"}\"])), schemaValue);\n  }\n};\nfunction reportTypeError(it) {\n  const cxt = getTypeErrorContext(it);\n  (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n  const {\n    gen,\n    data,\n    schema\n  } = it;\n  const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it\n  };\n}","map":null,"metadata":{},"sourceType":"script"}