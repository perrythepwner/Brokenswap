{"ast":null,"code":"\"use strict\";\n\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nfunction runInSeries(_x, _x2, _x3) {\n  return _runInSeries.apply(this, arguments);\n}\nfunction _runInSeries() {\n  _runInSeries = _asyncToGenerator(function* (context, tasks, data) {\n    let error;\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(tasks), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const task = _step.value;\n        {\n          try {\n            if (task.length < 2) {\n              //sync\n              task.call(context, data);\n            } else {\n              yield new Promise((resolve, reject) => {\n                task.call(context, data, error => {\n                  if (error) {\n                    reject(error);\n                  } else {\n                    resolve();\n                  }\n                });\n              });\n            }\n          } catch (e) {\n            error = e;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if (error) {\n      throw error;\n    }\n  });\n  return _runInSeries.apply(this, arguments);\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event) {\n    var _self$_events$event;\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let [data, callback] = args;\n    const self = this;\n    let listeners = (_self$_events$event = self._events[event]) !== null && _self$_events$event !== void 0 ? _self$_events$event : [];\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    }\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    }\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n    return self.listenerCount(event) > 0;\n  }\n  once(event, listener) {\n    const self = this;\n    let _g2;\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      _g2 = function g(e, next) {\n        self.removeListener(event, _g2);\n        void listener(e, next);\n      };\n    } else {\n      _g2 = function _g(e) {\n        self.removeListener(event, _g2);\n        void listener(e, _g2);\n      };\n    }\n    self.on(event, _g2);\n    return self;\n  }\n  first(event, listener) {\n    var _this$_events$event;\n    let listeners = (_this$_events$event = this._events[event]) !== null && _this$_events$event !== void 0 ? _this$_events$event : [];\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    listeners.unshift(listener);\n    return this;\n  }\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    var _this$_events$event2;\n    let listeners = (_this$_events$event2 = this._events[event]) !== null && _this$_events$event2 !== void 0 ? _this$_events$event2 : [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0;\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    index = listeners.length;\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n  eventNames() {\n    return super.eventNames();\n  }\n  listeners(event) {\n    return super.listeners(event);\n  }\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":{"version":3,"sources":["../src/asyncEventEmitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks) {\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            }\n            else {\n                await new Promise((resolve, reject) => {\n                    task.call(context, data, (error) => {\n                        if (error) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        }\n        catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === 'function') {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === 'newListener' || event === 'removeListener') {\n            data = {\n                event: data,\n                fn: callback,\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [listeners];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function (e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        }\n        else {\n            g = function (e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, 'after');\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === 'after' ? 1 : 0;\n        // Contract\n        if (typeof listener !== 'function') {\n            throw new TypeError('listener must be a function');\n        }\n        if (typeof target !== 'function') {\n            throw new TypeError('target must be a function');\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [listeners];\n        }\n        index = listeners.length;\n        for (i = listeners.length; i--;) {\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;\n//# sourceMappingURL=asyncEventEmitter.js.map"]},"metadata":{},"sourceType":"script"}