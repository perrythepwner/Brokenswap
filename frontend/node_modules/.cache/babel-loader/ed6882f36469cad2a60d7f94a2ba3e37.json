{"ast":null,"code":"/**\n * ECIES encrypt/decrypt with Ethereum keys\n * A Typescript implementation of geth/crypto/ecies/ecies.go\n * Modified from https://github.com/LimelabsTech/eth-ecies/blob/master/index.js\n * At commit c858cbd021e9a99d8afa629de33c8c30d923b3e5.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ECIES = exports.Decrypt = exports.Encrypt = exports.AES128DecryptAndHMAC = exports.AES128Decrypt = exports.AES128EncryptAndHMAC = exports.AES128Encrypt = exports.IV_LENGTH = void 0;\nvar crypto_1 = require(\"crypto\");\nexports.IV_LENGTH = 16;\n/**\n * Increments big endian uint32\n *\n * @param {Buffer} ctr 32 bit unsigned big endian integer to increment.\n * @returns Incremented counter.\n */\nvar IncCounter = function IncCounter(ctr) {\n  for (var i = ctr.length - 1; i >= 0; i--) {\n    ctr[i]++;\n    if (ctr[i] !== 0) {\n      return ctr;\n    }\n  }\n  return ctr;\n};\n/**\n * NIST 8000-56C Rev 1 One Step KDF with the following parameters:\n * - H(x) is SHA-256(x)\n * - Fixed info is null\n *\n * TODO:\n * - Implement proper ceiling on reps.\n *\n * @param {Buffer} px Input keying material to derive key from.\n * @param {number} kdLen Length of output in bytes\n * @returns {Buffer} Output keying material of length kdLen bytes.\n */\nvar ConcatKDF = function ConcatKDF(px, kdLen) {\n  var blockSize = 32;\n  var reps = (kdLen + 7) * 8 / (blockSize * 8);\n  var counter = Buffer.from('00000001', 'hex');\n  var k = Buffer.from('00', 'hex');\n  for (var i = 0; i <= reps; i++) {\n    var hash = (0, crypto_1.createHash)('sha256');\n    hash.update(counter);\n    hash.update(px);\n    k = Buffer.concat([k, hash.digest()]);\n    counter = IncCounter(counter);\n  }\n  return k.slice(1, kdLen + 1);\n};\n/**\n * AES-128 CTR encrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128Encrypt(encryptionKey, iv, plaintext) {\n  var cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', encryptionKey, iv);\n  var firstChunk = cipher.update(plaintext);\n  var secondChunk = cipher.final();\n  return Buffer.concat([iv, firstChunk, secondChunk]);\n}\nexports.AES128Encrypt = AES128Encrypt;\n/**\n * AES-128 CTR encrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128EncryptAndHMAC(encryptionKey, macKey, plaintext) {\n  var iv = (0, crypto_1.randomBytes)(exports.IV_LENGTH);\n  var dataToMac = AES128Encrypt(encryptionKey, iv, plaintext);\n  var mac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n  return Buffer.concat([dataToMac, mac]);\n}\nexports.AES128EncryptAndHMAC = AES128EncryptAndHMAC;\n/**\n * AES-128 CTR decrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128Decrypt(encryptionKey, iv, ciphertext) {\n  var cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', encryptionKey, iv);\n  var firstChunk = cipher.update(ciphertext);\n  var secondChunk = cipher.final();\n  return Buffer.concat([firstChunk, secondChunk]);\n}\nexports.AES128Decrypt = AES128Decrypt;\n/**\n * AES-128 CTR decrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128DecryptAndHMAC(encryptionKey, macKey, ciphertext) {\n  var iv = ciphertext.slice(0, exports.IV_LENGTH);\n  var message = ciphertext.slice(exports.IV_LENGTH, ciphertext.length - 32);\n  var mac = ciphertext.slice(ciphertext.length - 32, ciphertext.length);\n  var dataToMac = Buffer.concat([iv, message]);\n  var computedMac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n  if (!mac.equals(computedMac)) {\n    throw new Error('MAC mismatch');\n  }\n  return AES128Decrypt(encryptionKey, iv, message);\n}\nexports.AES128DecryptAndHMAC = AES128DecryptAndHMAC;\n/**\n * ECIES encrypt\n * @param {Buffer} pubKeyTo Ethereum pub key, 64 bytes.\n * @param {Buffer} plaintext Plaintext to be encrypted.\n * @returns {Buffer} Encrypted message, serialized, 113+ bytes\n */\nfunction Encrypt(pubKeyTo, plaintext) {\n  // NOTE: elliptic is disabled elsewhere in this library to prevent\n  // accidental signing of truncated messages.\n  // tslint:disable-next-line:import-blacklist\n  var EC = require('elliptic').ec;\n  var ec = new EC('secp256k1');\n  var ephemPrivKey = ec.keyFromPrivate((0, crypto_1.randomBytes)(32));\n  var ephemPubKey = ephemPrivKey.getPublic(false, 'hex');\n  var ephemPubKeyEncoded = Buffer.from(ephemPubKey, 'hex');\n  var px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic());\n  var hash = ConcatKDF(px.toArrayLike(Buffer), 32);\n  var encryptionKey = hash.slice(0, 16);\n  var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n  var message = AES128EncryptAndHMAC(encryptionKey, macKey, plaintext);\n  var serializedCiphertext = Buffer.concat([ephemPubKeyEncoded, message // iv + ciphertext + mac (min 48 bytes)\n  ]);\n\n  return serializedCiphertext;\n}\nexports.Encrypt = Encrypt;\n/**\n * ECIES decrypt\n * @param {Buffer} privKey Ethereum private key, 32 bytes.\n * @param {Buffer} encrypted Encrypted message, serialized, 113+ bytes\n * @returns {Buffer} plaintext\n */\nfunction Decrypt(privKey, encrypted) {\n  // Read iv, ephemPubKey, mac, ciphertext from encrypted message\n  var ephemPubKeyEncoded = encrypted.slice(0, 65);\n  var symmetricEncrypted = encrypted.slice(65);\n  // NOTE: elliptic is disabled elsewhere in this library to prevent\n  // accidental signing of truncated messages.\n  // tslint:disable-next-line:import-blacklist\n  var EC = require('elliptic').ec;\n  var ec = new EC('secp256k1');\n  var ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();\n  var px = ec.keyFromPrivate(privKey).derive(ephemPubKey);\n  var hash = ConcatKDF(px.toBuffer(), 32);\n  // km, ke\n  var encryptionKey = hash.slice(0, 16);\n  var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n  return AES128DecryptAndHMAC(encryptionKey, macKey, symmetricEncrypted);\n}\nexports.Decrypt = Decrypt;\nexports.ECIES = {\n  Encrypt: Encrypt,\n  Decrypt: Decrypt,\n  AES128EncryptAndHMAC: AES128EncryptAndHMAC,\n  AES128DecryptAndHMAC: AES128DecryptAndHMAC\n};","map":null,"metadata":{},"sourceType":"script"}