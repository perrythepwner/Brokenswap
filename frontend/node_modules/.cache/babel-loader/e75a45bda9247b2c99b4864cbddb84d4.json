{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareLedgerAppVersions = exports.list = exports.tokenInfoByAddressAndChainId = void 0;\n// Copied from '@ledgerhq/hw-app-eth/erc20' because we need to change the path of the blob and support for address+chainId\nvar address_1 = require(\"@celo/base/lib/address\");\nvar data_1 = __importDefault(require(\"./data\"));\n/**\n * Retrieve the token information by a given contract address and chainId if any\n */\nvar tokenInfoByAddressAndChainId = function tokenInfoByAddressAndChainId(contract, chainId) {\n  return get().byContractKey(generateContractKey(contract, chainId));\n};\nexports.tokenInfoByAddressAndChainId = tokenInfoByAddressAndChainId;\n/**\n * list all the ERC20 tokens informations\n */\nvar list = function list() {\n  return get().list();\n};\nexports.list = list;\n/**\n * @return\n * -1: version1 < version2,\n *  0: version1 == version2,\n *  1: version1 > version2\n */\nfunction compareLedgerAppVersions(version1, version2) {\n  var numberV1 = stringVersionToNumber(version1);\n  var numberV2 = stringVersionToNumber(version2);\n  return numberV1 < numberV2 ? -1 : numberV1 === numberV2 ? 0 : 1;\n}\nexports.compareLedgerAppVersions = compareLedgerAppVersions;\nfunction stringVersionToNumber(version) {\n  var parts = version.split('.');\n  return parts.reduce(function (accum, part) {\n    return (accum + Number(part)) * 1000;\n  }, 0);\n}\nfunction generateContractKey(contract, chainId) {\n  return [(0, address_1.normalizeAddressWith0x)(contract), chainId].join('-');\n}\n// this internal get() will lazy load and cache the data from the erc20 data blob\nvar get = function () {\n  var cache;\n  return function () {\n    if (cache) {\n      return cache;\n    }\n    var buf = Buffer.from(data_1.default, 'base64');\n    var byContract = {};\n    var entries = [];\n    var i = 0;\n    while (i < buf.length) {\n      var length_1 = buf.readUInt32BE(i);\n      i += 4;\n      var item = buf.slice(i, i + length_1);\n      var j = 0;\n      var tickerLength = item.readUInt8(j);\n      j += 1;\n      var ticker = item.slice(j, j + tickerLength).toString('ascii');\n      j += tickerLength;\n      var contractAddress = (0, address_1.normalizeAddressWith0x)(item.slice(j, j + 20).toString('hex'));\n      j += 20;\n      var decimals = item.readUInt32BE(j);\n      j += 4;\n      var chainId = item.readUInt32BE(j);\n      j += 4;\n      var signature = item.slice(j);\n      var entry = {\n        ticker: ticker,\n        contractAddress: contractAddress,\n        decimals: decimals,\n        chainId: chainId,\n        signature: signature,\n        data: item\n      };\n      entries.push(entry);\n      byContract[generateContractKey(contractAddress, chainId)] = entry;\n      i += length_1;\n    }\n    var api = {\n      list: function list() {\n        return entries;\n      },\n      byContractKey: function byContractKey(id) {\n        return byContract[id];\n      }\n    };\n    cache = api;\n    return api;\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}