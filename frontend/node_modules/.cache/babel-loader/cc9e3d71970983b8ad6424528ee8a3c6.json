{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { Interface } from '@ethersproject/abi';\nimport IUniswapV2PairABI from '@ubeswap/core/build/abi/IUniswapV2Pair.json';\nimport { Pair, TokenAmount } from '@ubeswap/sdk';\nimport { useMemo } from 'react';\nimport { useMultipleContractSingleData } from '../state/multicall/hooks';\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI);\nexport let PairState = /*#__PURE__*/function (PairState) {\n  PairState[PairState[\"LOADING\"] = 0] = \"LOADING\";\n  PairState[PairState[\"NOT_EXISTS\"] = 1] = \"NOT_EXISTS\";\n  PairState[PairState[\"EXISTS\"] = 2] = \"EXISTS\";\n  PairState[PairState[\"INVALID\"] = 3] = \"INVALID\";\n  return PairState;\n}({});\nexport function usePairs(tokens) {\n  _s();\n  const pairAddresses = useMemo(() => tokens.map(_ref => {\n    let [tokenA, tokenB] = _ref;\n    return tokenA && tokenB && !tokenA.equals(tokenB) ? Pair.getAddress(tokenA, tokenB) : undefined;\n  }), [tokens]);\n  const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves');\n  return useMemo(() => {\n    return results.map((result, i) => {\n      const {\n        result: reserves,\n        loading\n      } = result;\n      const tokenA = tokens[i][0];\n      const tokenB = tokens[i][1];\n      if (loading) return [PairState.LOADING, null];\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null];\n      if (!reserves) return [PairState.NOT_EXISTS, null];\n      const {\n        reserve0,\n        reserve1\n      } = reserves;\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];\n      return [PairState.EXISTS, new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString()))];\n    });\n  }, [results, tokens]);\n}\n_s(usePairs, \"4GJLP77Gutmf6C+sb5uw7teVNis=\", false, function () {\n  return [useMultipleContractSingleData];\n});\nexport function usePair(tokenA, tokenB) {\n  _s2();\n  // if we dont memoize the array then every time this function is ran the tokens variable passed used to create pairAddresses in usePairs is new and therefor no memoization happens :(\n  const tokens = useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB]);\n  return usePairs(tokens)[0];\n}\n_s2(usePair, \"JXKRE8ox4Yp3O7uasOw44B9QN6E=\", false, function () {\n  return [usePairs];\n});","map":{"version":3,"names":["Interface","IUniswapV2PairABI","Pair","TokenAmount","useMemo","useMultipleContractSingleData","PAIR_INTERFACE","PairState","usePairs","tokens","_s","pairAddresses","map","_ref","tokenA","tokenB","equals","getAddress","undefined","results","result","i","reserves","loading","LOADING","INVALID","NOT_EXISTS","reserve0","reserve1","token0","token1","sortsBefore","EXISTS","toString","usePair","_s2"],"sources":["/app/src/data/Reserves.ts"],"sourcesContent":["import { Interface } from '@ethersproject/abi'\nimport IUniswapV2PairABI from '@ubeswap/core/build/abi/IUniswapV2Pair.json'\nimport { Pair, Token, TokenAmount } from '@ubeswap/sdk'\nimport { useMemo } from 'react'\n\nimport { useMultipleContractSingleData } from '../state/multicall/hooks'\n\nconst PAIR_INTERFACE = new Interface(IUniswapV2PairABI)\n\nexport enum PairState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n\nexport function usePairs(\n  tokens: readonly (readonly [Token | undefined, Token | undefined])[]\n): readonly (readonly [PairState, Pair | null])[] {\n  const pairAddresses = useMemo(\n    () =>\n      tokens.map(([tokenA, tokenB]) => {\n        return tokenA && tokenB && !tokenA.equals(tokenB) ? Pair.getAddress(tokenA, tokenB) : undefined\n      }),\n    [tokens]\n  )\n\n  const results = useMultipleContractSingleData(pairAddresses, PAIR_INTERFACE, 'getReserves')\n\n  return useMemo(() => {\n    return results.map((result, i) => {\n      const { result: reserves, loading } = result\n      const tokenA = tokens[i][0]\n      const tokenB = tokens[i][1]\n\n      if (loading) return [PairState.LOADING, null]\n      if (!tokenA || !tokenB || tokenA.equals(tokenB)) return [PairState.INVALID, null]\n      if (!reserves) return [PairState.NOT_EXISTS, null]\n      const { reserve0, reserve1 } = reserves\n      const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n      return [\n        PairState.EXISTS,\n        new Pair(new TokenAmount(token0, reserve0.toString()), new TokenAmount(token1, reserve1.toString())),\n      ]\n    })\n  }, [results, tokens])\n}\n\nexport function usePair(tokenA?: Token, tokenB?: Token): readonly [PairState, Pair | null] {\n  // if we dont memoize the array then every time this function is ran the tokens variable passed used to create pairAddresses in usePairs is new and therefor no memoization happens :(\n  const tokens: readonly [Token | undefined, Token | undefined][] = useMemo(() => [[tokenA, tokenB]], [tokenA, tokenB])\n  return usePairs(tokens)[0]\n}\n"],"mappings":";;AAAA,SAASA,SAAS,QAAQ,oBAAoB;AAC9C,OAAOC,iBAAiB,MAAM,6CAA6C;AAC3E,SAASC,IAAI,EAASC,WAAW,QAAQ,cAAc;AACvD,SAASC,OAAO,QAAQ,OAAO;AAE/B,SAASC,6BAA6B,QAAQ,0BAA0B;AAExE,MAAMC,cAAc,GAAG,IAAIN,SAAS,CAACC,iBAAiB,CAAC;AAEvD,WAAYM,SAAS,0BAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAATA,SAAS,CAATA,SAAS;EAAA,OAATA,SAAS;AAAA;AAOrB,OAAO,SAASC,QAAQA,CACtBC,MAAoE,EACpB;EAAAC,EAAA;EAChD,MAAMC,aAAa,GAAGP,OAAO,CAC3B,MACEK,MAAM,CAACG,GAAG,CAACC,IAAA,IAAsB;IAAA,IAArB,CAACC,MAAM,EAAEC,MAAM,CAAC,GAAAF,IAAA;IAC1B,OAAOC,MAAM,IAAIC,MAAM,IAAI,CAACD,MAAM,CAACE,MAAM,CAACD,MAAM,CAAC,GAAGb,IAAI,CAACe,UAAU,CAACH,MAAM,EAAEC,MAAM,CAAC,GAAGG,SAAS;EACjG,CAAC,CAAC,EACJ,CAACT,MAAM,CACT,CAAC;EAED,MAAMU,OAAO,GAAGd,6BAA6B,CAACM,aAAa,EAAEL,cAAc,EAAE,aAAa,CAAC;EAE3F,OAAOF,OAAO,CAAC,MAAM;IACnB,OAAOe,OAAO,CAACP,GAAG,CAAC,CAACQ,MAAM,EAAEC,CAAC,KAAK;MAChC,MAAM;QAAED,MAAM,EAAEE,QAAQ;QAAEC;MAAQ,CAAC,GAAGH,MAAM;MAC5C,MAAMN,MAAM,GAAGL,MAAM,CAACY,CAAC,CAAC,CAAC,CAAC,CAAC;MAC3B,MAAMN,MAAM,GAAGN,MAAM,CAACY,CAAC,CAAC,CAAC,CAAC,CAAC;MAE3B,IAAIE,OAAO,EAAE,OAAO,CAAChB,SAAS,CAACiB,OAAO,EAAE,IAAI,CAAC;MAC7C,IAAI,CAACV,MAAM,IAAI,CAACC,MAAM,IAAID,MAAM,CAACE,MAAM,CAACD,MAAM,CAAC,EAAE,OAAO,CAACR,SAAS,CAACkB,OAAO,EAAE,IAAI,CAAC;MACjF,IAAI,CAACH,QAAQ,EAAE,OAAO,CAACf,SAAS,CAACmB,UAAU,EAAE,IAAI,CAAC;MAClD,MAAM;QAAEC,QAAQ;QAAEC;MAAS,CAAC,GAAGN,QAAQ;MACvC,MAAM,CAACO,MAAM,EAAEC,MAAM,CAAC,GAAGhB,MAAM,CAACiB,WAAW,CAAChB,MAAM,CAAC,GAAG,CAACD,MAAM,EAAEC,MAAM,CAAC,GAAG,CAACA,MAAM,EAAED,MAAM,CAAC;MACzF,OAAO,CACLP,SAAS,CAACyB,MAAM,EAChB,IAAI9B,IAAI,CAAC,IAAIC,WAAW,CAAC0B,MAAM,EAAEF,QAAQ,CAACM,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI9B,WAAW,CAAC2B,MAAM,EAAEF,QAAQ,CAACK,QAAQ,CAAC,CAAC,CAAC,CAAC,CACrG;IACH,CAAC,CAAC;EACJ,CAAC,EAAE,CAACd,OAAO,EAAEV,MAAM,CAAC,CAAC;AACvB;AAACC,EAAA,CA9BeF,QAAQ;EAAA,QAWNH,6BAA6B;AAAA;AAqB/C,OAAO,SAAS6B,OAAOA,CAACpB,MAAc,EAAEC,MAAc,EAAqC;EAAAoB,GAAA;EACzF;EACA,MAAM1B,MAAyD,GAAGL,OAAO,CAAC,MAAM,CAAC,CAACU,MAAM,EAAEC,MAAM,CAAC,CAAC,EAAE,CAACD,MAAM,EAAEC,MAAM,CAAC,CAAC;EACrH,OAAOP,QAAQ,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5B;AAAC0B,GAAA,CAJeD,OAAO;EAAA,QAGd1B,QAAQ;AAAA"},"metadata":{},"sourceType":"module"}