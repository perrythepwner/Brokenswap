{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n  constructor() {\n    this.permits = 1;\n    this.promiseResolverQueue = [];\n  }\n  /**\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n  acquire() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.permits > 0) {\n        _this.permits -= 1;\n        return Promise.resolve(true);\n      }\n      // If there is no permit available, we return a promise that resolves once the semaphore gets\n      // signaled enough times that permits is equal to one.\n      return new Promise(resolver => _this.promiseResolverQueue.push(resolver));\n    })();\n  }\n  /**\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\n   * continue to execute in a future iteration of the event loop.\n   */\n  release() {\n    this.permits += 1;\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1;\n      const nextResolver = this.promiseResolverQueue.shift();\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  }\n}\nexports.Lock = Lock;","map":{"version":3,"sources":["../src/lock.ts"],"names":[],"mappings":";;;;;;;AAAA;AACA,MAAa,IAAI,CAAA;EAAjB,WAAA,CAAA,EAAA;IACU,IAAA,CAAA,OAAO,GAAW,CAAC;IACnB,IAAA,CAAA,oBAAoB,GAAgC,EAAE;EAsChE;EApCE;;;AAGG;EACU,OAAO,CAAA,EAAA;IAAA,IAAA,KAAA;IAAA,OAAA,iBAAA;MAClB,IAAI,KAAI,CAAC,OAAO,GAAG,CAAC,EAAE;QACpB,KAAI,CAAC,OAAO,IAAI,CAAC;QACjB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC;MAC7B;MAED;MACA;MACA,OAAO,IAAI,OAAO,CAAW,QAAQ,IAAK,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAAA;EACrF;EAEA;;;AAGG;EACI,OAAO,CAAA,EAAA;IACZ,IAAI,CAAC,OAAO,IAAI,CAAC;IAEjB,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;MAC5D;MACA,OAAO,CAAC,IAAI,CAAC,iEAAiE,CAAC;KAChF,MAAM,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE;MACrE;MACA;MACA,IAAI,CAAC,OAAO,IAAI,CAAC;MAEjB,MAAM,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAA,CAAE;MACtD,IAAI,YAAY,EAAE;QAChB,YAAY,CAAC,IAAI,CAAC;MACnB;IACF;EACH;AACD;AAxCD,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor() {\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn('Lock.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock;\n//# sourceMappingURL=lock.js.map"]},"metadata":{},"sourceType":"script"}