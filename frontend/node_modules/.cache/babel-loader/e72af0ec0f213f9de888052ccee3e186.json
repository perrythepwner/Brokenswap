{"ast":null,"code":"// type Var = {\n//   name: String\n//   type: \"uint256\" | \"bytes32\" | ...\n// }\n//\n// type Method = {\n//   name: String\n//   inputs: [Var]\n//   output: [Var]\n//   constant: Bool\n//   payable: Bool\n// }\n\nconst Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst keccak256s = require(\"./hash\").keccak256s;\n\n// (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}\n//   ABI-encodes a single term.\nconst encode = (type, value) => {\n  if (type === \"bytes\") {\n    const length = Bytes.length(value);\n    const nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;\n    const lengthEncoded = encode(\"uint256\", Nat.fromNumber(length)).data;\n    const bytesEncoded = Bytes.padRight(nextMul32, value);\n    return {\n      data: Bytes.concat(lengthEncoded, bytesEncoded),\n      dynamic: true\n    };\n  } else if (type === \"uint256\" || type === \"bytes32\" || type === \"address\") {\n    return {\n      data: Bytes.pad(32, value),\n      dynamic: false\n    };\n  } else {\n    throw \"Eth-lib can't encode ABI type \" + type + \" yet.\";\n  }\n};\n\n// (method : Method), [JSType(method.inputs[i].type)] -> Bytes\n//   ABI-encodes the transaction data to call a method.\nconst methodData = (method, params) => {\n  const methodSig = method.name + \"(\" + method.inputs.map(i => i.type).join(\",\") + \")\";\n  const methodHash = keccak256s(methodSig).slice(0, 10);\n  let encodedParams = params.map((param, i) => encode(method.inputs[i].type, param));\n  var headBlock = \"0x\";\n  let dataBlock = \"0x\";\n  for (var i = 0; i < encodedParams.length; ++i) {\n    if (encodedParams[i].dynamic) {\n      var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);\n      headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));\n      dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);\n    } else {\n      headBlock = Bytes.concat(headBlock, encodedParams[i].data);\n    }\n  }\n  return Bytes.flatten([methodHash, headBlock, dataBlock]);\n};\nmodule.exports = {\n  encode,\n  methodData\n};","map":{"version":3,"names":["Bytes","require","Nat","keccak256s","encode","type","value","length","nextMul32","lengthEncoded","fromNumber","data","bytesEncoded","padRight","concat","dynamic","pad","methodData","method","params","methodSig","name","inputs","map","i","join","methodHash","slice","encodedParams","param","headBlock","dataBlock","dataLoc","flatten","module","exports"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/eth-lib/lib/abi.js"],"sourcesContent":["// type Var = {\n//   name: String\n//   type: \"uint256\" | \"bytes32\" | ...\n// }\n//\n// type Method = {\n//   name: String\n//   inputs: [Var]\n//   output: [Var]\n//   constant: Bool\n//   payable: Bool\n// }\n\nconst Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst keccak256s = require(\"./hash\").keccak256s;\n\n// (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}\n//   ABI-encodes a single term.\nconst encode = (type, value) => {\n  if (type === \"bytes\") {\n    const length = Bytes.length(value);\n    const nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;\n    const lengthEncoded = encode(\"uint256\", Nat.fromNumber(length)).data;\n    const bytesEncoded = Bytes.padRight(nextMul32, value);\n    return { data: Bytes.concat(lengthEncoded, bytesEncoded), dynamic: true };\n  } else if (type === \"uint256\" || type === \"bytes32\" || type === \"address\") {\n    return { data: Bytes.pad(32, value), dynamic: false };\n  } else {\n    throw \"Eth-lib can't encode ABI type \" + type + \" yet.\";\n  }\n};\n\n// (method : Method), [JSType(method.inputs[i].type)] -> Bytes\n//   ABI-encodes the transaction data to call a method.\nconst methodData = (method, params) => {\n  const methodSig = method.name + \"(\" + method.inputs.map(i => i.type).join(\",\") + \")\";\n  const methodHash = keccak256s(methodSig).slice(0, 10);\n  let encodedParams = params.map((param, i) => encode(method.inputs[i].type, param));\n  var headBlock = \"0x\";\n  let dataBlock = \"0x\";\n  for (var i = 0; i < encodedParams.length; ++i) {\n    if (encodedParams[i].dynamic) {\n      var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);\n      headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));\n      dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);\n    } else {\n      headBlock = Bytes.concat(headBlock, encodedParams[i].data);\n    }\n  }\n  return Bytes.flatten([methodHash, headBlock, dataBlock]);\n};\n\nmodule.exports = {\n  encode,\n  methodData\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}