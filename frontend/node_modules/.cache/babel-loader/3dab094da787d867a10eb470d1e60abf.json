{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _errors = require(\"@ledgerhq/errors\");\nconst Tag = 0x05;\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\n\nconst createHIDframing = (channel, packetSize) => {\n  return {\n    makeBlocks(apdu) {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data,\n      // fill data with padding\n      Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n    reduceResponse(acc, chunk) {\n      let {\n        data,\n        dataLength,\n        sequence\n      } = acc || initialAcc;\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new _errors.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new _errors.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new _errors.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n      return {\n        data,\n        dataLength,\n        sequence\n      };\n    },\n    getReducedResult(acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\nvar _default = createHIDframing;\nexports.default = _default;","map":{"version":3,"sources":["../src/hid-framing.js"],"names":["Tag","asUInt16BE","value","b","Buffer","alloc","writeUInt16BE","initialAcc","data","dataLength","sequence","createHIDframing","channel","packetSize","makeBlocks","apdu","concat","length","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt16BE","TransportError","readUInt8","chunkData","getReducedResult"],"mappings":"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","sourcesContent":["// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number,\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"]},"metadata":{},"sourceType":"script"}