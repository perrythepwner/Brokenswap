{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;\nconst as_sha256_1 = require(\"@chainsafe/as-sha256\");\nconst zeros_1 = require(\"./zeros\");\nfunction hash64(bytes32A, bytes32B) {\n  return as_sha256_1.digest2Bytes32(bytes32A, bytes32B);\n}\nexports.hash64 = hash64;\nfunction merkleize(chunks, padFor) {\n  const layerCount = bitLength(nextPowerOf2(padFor) - 1);\n  if (chunks.length == 0) {\n    return zeros_1.zeroHash(layerCount);\n  }\n  let chunkCount = chunks.length;\n  // Instead of pushing on all padding zero chunks at the leaf level\n  // we push on zero hash chunks at the highest possible level to avoid over-hashing\n  for (let l = 0; l < layerCount; l++) {\n    const padCount = chunkCount % 2;\n    const paddedChunkCount = chunkCount + padCount;\n    // if the chunks.length is odd\n    // we need to push on the zero-hash of that level to merkleize that level\n    for (let i = 0; i < padCount; i++) {\n      chunks[chunkCount + i] = zeros_1.zeroHash(l);\n    }\n    for (let i = 0; i < paddedChunkCount; i += 2) {\n      chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);\n    }\n    chunkCount = paddedChunkCount / 2;\n  }\n  return chunks[0];\n}\nexports.merkleize = merkleize;\n/**\n * Split a long Uint8Array into Uint8Array of exactly 32 bytes\n */\nfunction splitIntoRootChunks(longChunk) {\n  const chunkCount = Math.ceil(longChunk.length / 32);\n  const chunks = new Array(chunkCount);\n  for (let i = 0; i < chunkCount; i++) {\n    const chunk = new Uint8Array(32);\n    chunk.set(longChunk.slice(i * 32, (i + 1) * 32));\n    chunks[i] = chunk;\n  }\n  return chunks;\n}\nexports.splitIntoRootChunks = splitIntoRootChunks;\n/** @ignore */\nfunction mixInLength(root, length) {\n  const lengthBuf = Buffer.alloc(32);\n  lengthBuf.writeUIntLE(length, 0, 6);\n  return hash64(root, lengthBuf);\n}\nexports.mixInLength = mixInLength;\n// x2 faster than bitLengthStr() which uses Number.toString(2)\nfunction bitLength(i) {\n  if (i === 0) {\n    return 0;\n  }\n  return Math.floor(Math.log2(i)) + 1;\n}\nexports.bitLength = bitLength;\n/**\n * Given maxChunkCount return the chunkDepth\n * ```\n * n: [0,1,2,3,4,5,6,7,8,9]\n * d: [0,0,1,2,2,3,3,3,3,4]\n * ```\n */\nfunction maxChunksToDepth(n) {\n  if (n === 0) return 0;\n  return Math.ceil(Math.log2(n));\n}\nexports.maxChunksToDepth = maxChunksToDepth;\n/** @ignore */\nfunction nextPowerOf2(n) {\n  return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\nexports.nextPowerOf2 = nextPowerOf2;","map":{"version":3,"sources":["../../src/util/merkleize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;\nconst as_sha256_1 = require(\"@chainsafe/as-sha256\");\nconst zeros_1 = require(\"./zeros\");\nfunction hash64(bytes32A, bytes32B) {\n    return as_sha256_1.digest2Bytes32(bytes32A, bytes32B);\n}\nexports.hash64 = hash64;\nfunction merkleize(chunks, padFor) {\n    const layerCount = bitLength(nextPowerOf2(padFor) - 1);\n    if (chunks.length == 0) {\n        return zeros_1.zeroHash(layerCount);\n    }\n    let chunkCount = chunks.length;\n    // Instead of pushing on all padding zero chunks at the leaf level\n    // we push on zero hash chunks at the highest possible level to avoid over-hashing\n    for (let l = 0; l < layerCount; l++) {\n        const padCount = chunkCount % 2;\n        const paddedChunkCount = chunkCount + padCount;\n        // if the chunks.length is odd\n        // we need to push on the zero-hash of that level to merkleize that level\n        for (let i = 0; i < padCount; i++) {\n            chunks[chunkCount + i] = zeros_1.zeroHash(l);\n        }\n        for (let i = 0; i < paddedChunkCount; i += 2) {\n            chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);\n        }\n        chunkCount = paddedChunkCount / 2;\n    }\n    return chunks[0];\n}\nexports.merkleize = merkleize;\n/**\n * Split a long Uint8Array into Uint8Array of exactly 32 bytes\n */\nfunction splitIntoRootChunks(longChunk) {\n    const chunkCount = Math.ceil(longChunk.length / 32);\n    const chunks = new Array(chunkCount);\n    for (let i = 0; i < chunkCount; i++) {\n        const chunk = new Uint8Array(32);\n        chunk.set(longChunk.slice(i * 32, (i + 1) * 32));\n        chunks[i] = chunk;\n    }\n    return chunks;\n}\nexports.splitIntoRootChunks = splitIntoRootChunks;\n/** @ignore */\nfunction mixInLength(root, length) {\n    const lengthBuf = Buffer.alloc(32);\n    lengthBuf.writeUIntLE(length, 0, 6);\n    return hash64(root, lengthBuf);\n}\nexports.mixInLength = mixInLength;\n// x2 faster than bitLengthStr() which uses Number.toString(2)\nfunction bitLength(i) {\n    if (i === 0) {\n        return 0;\n    }\n    return Math.floor(Math.log2(i)) + 1;\n}\nexports.bitLength = bitLength;\n/**\n * Given maxChunkCount return the chunkDepth\n * ```\n * n: [0,1,2,3,4,5,6,7,8,9]\n * d: [0,0,1,2,2,3,3,3,3,4]\n * ```\n */\nfunction maxChunksToDepth(n) {\n    if (n === 0)\n        return 0;\n    return Math.ceil(Math.log2(n));\n}\nexports.maxChunksToDepth = maxChunksToDepth;\n/** @ignore */\nfunction nextPowerOf2(n) {\n    return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\nexports.nextPowerOf2 = nextPowerOf2;\n//# sourceMappingURL=merkleize.js.map"]},"metadata":{},"sourceType":"script"}