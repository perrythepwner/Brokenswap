{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nfunction minSizeArrayComposite(elementType, minCount) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    return minCount * (4 + elementType.minSize);\n  }\n  // Fixed length\n  else {\n    return minCount * elementType.minSize;\n  }\n}\nexports.minSizeArrayComposite = minSizeArrayComposite;\nfunction maxSizeArrayComposite(elementType, maxCount) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    return maxCount * (4 + elementType.maxSize);\n  }\n  // Fixed length\n  else {\n    return maxCount * elementType.maxSize;\n  }\n}\nexports.maxSizeArrayComposite = maxSizeArrayComposite;\nfunction value_serializedSizeArrayComposite(elementType, length, value) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    let size = 0;\n    for (let i = 0; i < length; i++) {\n      size += 4 + elementType.value_serializedSize(value[i]);\n    }\n    return size;\n  }\n  // Fixed length\n  else {\n    return length * elementType.fixedSize;\n  }\n}\nexports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayComposite(elementType, length, output, offset, value) {\n  // Variable length\n  if (elementType.fixedSize === null) {\n    let variableIndex = offset + length * 4;\n    for (let i = 0; i < length; i++) {\n      // write offset\n      output.dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n      // write serialized element to variable section\n      variableIndex = elementType.value_serializeToBytes(output, variableIndex, value[i]);\n    }\n    return variableIndex;\n  }\n  // Fixed length\n  else {\n    for (let i = 0; i < length; i++) {\n      elementType.value_serializeToBytes(output, offset + i * elementType.fixedSize, value[i]);\n    }\n    return offset + length * elementType.fixedSize;\n  }\n}\nexports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;\nfunction value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {\n  const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n  const length = offsets.length; // Capture length before pushing end offset\n  const values = new Array(length);\n  // offests include the last element end\n  for (let i = 0; i < length; i++) {\n    // The offsets are relative to the start\n    const startEl = start + offsets[i];\n    const endEl = i === length - 1 ? end : start + offsets[i + 1];\n    values[i] = elementType.value_deserializeFromBytes(data, startEl, endEl);\n  }\n  return values;\n}\nexports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializedSizeArrayComposite(elementType, length, depth, node) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n    let size = 0;\n    for (let i = 0; i < nodes.length; i++) {\n      size += 4 + elementType.tree_serializedSize(nodes[i]);\n    }\n    return size;\n  }\n  // Fixed length\n  else {\n    return length * elementType.fixedSize;\n  }\n}\nexports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayComposite(elementType, length, depth, node, output, offset) {\n  const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n  // Variable Length\n  // Indices contain offsets, which are indices deeper in the byte array\n  if (elementType.fixedSize === null) {\n    let variableIndex = offset + length * 4;\n    const {\n      dataView\n    } = output;\n    for (let i = 0; i < nodes.length; i++) {\n      // write offset\n      dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n      // write serialized element to variable section\n      variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i]);\n    }\n    return variableIndex;\n  }\n  // Fixed length\n  else {\n    for (let i = 0; i < nodes.length; i++) {\n      offset = elementType.tree_serializeToBytes(output, offset, nodes[i]);\n    }\n    return offset;\n  }\n}\nexports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;\nfunction tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {\n  const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n  const length = offsets.length; // Capture length before pushing end offset\n  const nodes = new Array(length);\n  // offests include the last element end\n  for (let i = 0; i < length; i++) {\n    // The offsets are relative to the start\n    const startEl = start + offsets[i];\n    const endEl = i === length - 1 ? end : start + offsets[i + 1];\n    nodes[i] = elementType.tree_deserializeFromBytes(data, startEl, endEl);\n  }\n  // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n  const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);\n  // TODO: Add LeafNode.fromUint()\n  if (arrayProps.isList) {\n    return arrayBasic_1.addLengthNode(chunksNode, length);\n  } else {\n    return chunksNode;\n  }\n}\nexports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_getRootsArrayComposite(elementType, length, value) {\n  const roots = new Array(length);\n  for (let i = 0; i < length; i++) {\n    roots[i] = elementType.hashTreeRoot(value[i]);\n  }\n  return roots;\n}\nexports.value_getRootsArrayComposite = value_getRootsArrayComposite;\nfunction readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {\n  const size = end - start;\n  let offsets;\n  // Variable Length\n  // Indices contain offsets, which are indices deeper in the byte array\n  if (elementFixedSize === null) {\n    offsets = readVariableOffsetsArrayComposite(data, start, size);\n  }\n  // Fixed length\n  else {\n    // There's no valid CompositeType with fixed size 0, it's un-rechable code. But prevents diving by zero\n    /* istanbul ignore if */\n    if (elementFixedSize === 0) {\n      throw Error(\"element fixed length is 0\");\n    }\n    if (size % elementFixedSize !== 0) {\n      throw Error(\"size \".concat(size, \" is not multiple of element fixedSize \").concat(elementFixedSize));\n    }\n    const length = size / elementFixedSize;\n    offsets = new Uint32Array(length);\n    for (let i = 0; i < length; i++) {\n      offsets[i] = i * elementFixedSize;\n    }\n  }\n  // Vector + List length validation\n  arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);\n  return offsets;\n}\n/**\n * Reads the values of contiguous variable offsets. Provided buffer includes offsets that point to position\n * within `size`. This function also validates that all offsets are in range.\n */\nfunction readVariableOffsetsArrayComposite(dataView, start, size) {\n  if (size === 0) {\n    return new Uint32Array(0);\n  }\n  // all elements are variable-sized\n  // indices contain offsets, which are indices deeper in the byte array\n  // The serialized data will start with offsets of all the serialized objects (BYTES_PER_LENGTH_OFFSET bytes each)\n  const firstOffset = dataView.getUint32(start, true);\n  // Using the first offset, we can compute the length of the list (divide by BYTES_PER_LENGTH_OFFSET), as it gives\n  // us the total number of bytes in the offset data\n  const offsetDataLength = firstOffset;\n  if (firstOffset === 0) {\n    throw Error(\"First offset must be > 0\");\n  }\n  if (offsetDataLength % 4 !== 0) {\n    throw Error(\"Offset data length not multiple of 4\");\n  }\n  const offsetCount = offsetDataLength / 4;\n  const offsets = new Uint32Array(offsetCount);\n  offsets[0] = firstOffset;\n  // ArrayComposite has a contiguous section of offsets, then the data\n  //\n  //    [offset 1] [offset 2] [data 1 ..........] [data 2 ..]\n  // 0x 08000000   0e000000   010002000300        01000200\n  //\n  // Ensure that:\n  // - Offsets point to regions of > 0 bytes, i.e. are increasing\n  // - Offsets don't point to bytes outside of the array's size\n  //\n  // In the example above the first offset is 8, so 8 / 4 = 2 offsets.\n  // Then, read the rest of offsets to get offsets = [8, 14]\n  for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {\n    const offset = dataView.getUint32(start + offsetIdx * 4, true);\n    offsets[offsetIdx] = offset;\n    // Offsets must point to data within the Array bytes section\n    if (offset > size) {\n      throw new Error(\"Offset out of bounds \".concat(offset, \" > \").concat(size));\n    }\n    if (offset < offsets[offsetIdx - 1]) {\n      throw new Error(\"Offsets must be increasing \".concat(offset, \" < \").concat(offsets[offsetIdx - 1]));\n    }\n  }\n  return offsets;\n}","map":null,"metadata":{},"sourceType":"script"}