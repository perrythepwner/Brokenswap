{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;\nconst multi_1 = require(\"./multi\");\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar ProofType;\n(function (ProofType) {\n  ProofType[\"single\"] = \"single\";\n  ProofType[\"treeOffset\"] = \"treeOffset\";\n  ProofType[\"multi\"] = \"multi\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [ProofType.single, ProofType.treeOffset, ProofType.multi // 2\n];\n\nfunction createProof(rootNode, input) {\n  switch (input.type) {\n    case ProofType.single:\n      {\n        const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n        return {\n          type: ProofType.single,\n          gindex: input.gindex,\n          leaf,\n          witnesses\n        };\n      }\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n    case ProofType.multi:\n      {\n        const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n        return {\n          type: ProofType.multi,\n          leaves,\n          witnesses,\n          gindices\n        };\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n      return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n    case ProofType.treeOffset:\n      return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n    case ProofType.multi:\n      return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n    case ProofType.treeOffset:\n      {\n        const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n        output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n        treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n        return output;\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n  const proofType = exports.ProofTypeSerialized[data[0]];\n  if (!proofType) {\n    throw new Error(\"Invalid proof type\");\n  }\n  switch (proofType) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.deserializeProof = deserializeProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","deserializeProof","serializeProof","createNodeFromProof","createProof","ProofTypeSerialized","ProofType","multi_1","require","single_1","treeOffset_1","single","treeOffset","multi","rootNode","input","type","leaf","witnesses","createSingleProof","gindex","offsets","leaves","createTreeOffsetProof","gindices","createMultiProof","Error","proof","createNodeFromSingleProof","createNodeFromTreeOffsetProof","createNodeFromMultiProof","output","Uint8Array","computeTreeOffsetProofSerializedLength","indexOf","serializeTreeOffsetProof","data","proofType","deserializeTreeOffsetProof"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;\nconst multi_1 = require(\"./multi\");\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar ProofType;\n(function (ProofType) {\n    ProofType[\"single\"] = \"single\";\n    ProofType[\"treeOffset\"] = \"treeOffset\";\n    ProofType[\"multi\"] = \"multi\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [\n    ProofType.single,\n    ProofType.treeOffset,\n    ProofType.multi, // 2\n];\nfunction createProof(rootNode, input) {\n    switch (input.type) {\n        case ProofType.single: {\n            const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n            return {\n                type: ProofType.single,\n                gindex: input.gindex,\n                leaf,\n                witnesses,\n            };\n        }\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        case ProofType.multi: {\n            const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n            return {\n                type: ProofType.multi,\n                leaves,\n                witnesses,\n                gindices,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n            return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n        case ProofType.treeOffset:\n            return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n        case ProofType.multi:\n            return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n        case ProofType.multi:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n            output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n            treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n            return output;\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n    const proofType = exports.ProofTypeSerialized[data[0]];\n    if (!proofType) {\n        throw new Error(\"Invalid proof type\");\n    }\n    switch (proofType) {\n        case ProofType.single:\n        case ProofType.multi:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.deserializeProof = deserializeProof;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}