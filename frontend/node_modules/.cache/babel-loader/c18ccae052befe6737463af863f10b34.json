{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: \"\".concat(it.errSchemaPath, \"/\").concat(keyword),\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"await \"])))), e => gen.assign(valid, false).if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" instanceof \", \"\"])), e, it.ValidationError), () => gen.assign(ruleErrs, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \".errors\"])), e)), () => gen.throw(e)));\n    return ruleErrs;\n  }\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".errors\"])), validateRef);\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n  function assignValid() {\n    let _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"await \"]))) : codegen_1.nil;\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \"\", \"\"])), _await, (0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)), def.modifying);\n  }\n  function reportErrs(errors) {\n    var _a;\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), it.parentData, it.parentDataProperty)));\n}\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"Array.isArray(\", \")\"])), errs), () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \" === null ? \", \" : \", \".concat(\", \")\"])), names_1.default.vErrors, errs, names_1.default.vErrors, errs)).assign(names_1.default.errors, (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".length\"])), names_1.default.vErrors));\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\nfunction checkAsyncKeyword(_ref, def) {\n  let {\n    schemaEnv\n  } = _ref;\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(\"keyword \\\"\".concat(keyword, \"\\\" failed to compile\"));\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\nfunction validSchemaType(schema, schemaType) {\n  let allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage(_ref2, def, keyword) {\n  let {\n    schema,\n    opts,\n    self,\n    errSchemaPath\n  } = _ref2;\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n  const deps = def.dependencies;\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(\"parent schema must have dependencies of \".concat(keyword, \": \").concat(deps.join(\",\")));\n  }\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n    if (!valid) {\n      const msg = \"keyword \\\"\".concat(keyword, \"\\\" value is invalid at path \\\"\").concat(errSchemaPath, \"\\\": \") + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"sources":["../../../lib/compile/validate/keyword.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map"]},"metadata":{},"sourceType":"script"}