{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;\nconst zeroNode_1 = require(\"./zeroNode\");\nconst gindex_1 = require(\"./gindex\");\nconst node_1 = require(\"./node\");\nconst proof_1 = require(\"./proof\");\nconst single_1 = require(\"./proof/single\");\n/**\n * Binary merkle tree\n *\n * Wrapper around immutable `Node` to support mutability.\n *\n * Mutability between a parent tree and subtree is achieved by maintaining a `hook` callback, which updates the parent when the subtree is updated.\n */\nclass Tree {\n  constructor(node, hook) {\n    this._rootNode = node;\n    if (hook) {\n      if (typeof WeakRef === \"undefined\") {\n        this.hook = hook;\n      } else {\n        this.hook = new WeakRef(hook);\n      }\n    }\n  }\n  /**\n   * Create a `Tree` from a `Proof` object\n   */\n  static createFromProof(proof) {\n    return new Tree(proof_1.createNodeFromProof(proof));\n  }\n  /**\n   * The root node of the tree\n   */\n  get rootNode() {\n    return this._rootNode;\n  }\n  /**\n   *\n   * Setting the root node will trigger a call to the tree's `hook` if it exists.\n   */\n  set rootNode(newRootNode) {\n    this._rootNode = newRootNode;\n    if (this.hook) {\n      // WeakRef should not change status during a program's execution\n      // So, use WeakRef feature detection to assume the type of this.hook\n      // to minimize the memory footprint of Tree\n      if (typeof WeakRef === \"undefined\") {\n        this.hook(newRootNode);\n      } else {\n        const hookVar = this.hook.deref();\n        if (hookVar) {\n          hookVar(newRootNode);\n        } else {\n          // Hook has been garbage collected, no need to keep the hookRef\n          this.hook = undefined;\n        }\n      }\n    }\n  }\n  /**\n   * The root hash of the tree\n   */\n  get root() {\n    return this.rootNode.root;\n  }\n  /**\n   * Return a copy of the tree\n   */\n  clone() {\n    return new Tree(this.rootNode);\n  }\n  /**\n   * Return the subtree at the specified gindex.\n   *\n   * Note: The returned subtree will have a `hook` attached to the parent tree.\n   * Updates to the subtree will result in updates to the parent.\n   */\n  getSubtree(index) {\n    return new Tree(this.getNode(index), node => this.setNode(index, node));\n  }\n  /**\n   * Return the node at the specified gindex.\n   */\n  getNode(gindex) {\n    return getNode(this.rootNode, gindex);\n  }\n  /**\n   * Return the node at the specified depth and index.\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  getNodeAtDepth(depth, index) {\n    return getNodeAtDepth(this.rootNode, depth, index);\n  }\n  /**\n   * Return the hash at the specified gindex.\n   */\n  getRoot(index) {\n    return this.getNode(index).root;\n  }\n  /**\n   * Set the node at at the specified gindex.\n   */\n  setNode(gindex, n) {\n    this.rootNode = setNode(this.rootNode, gindex, n);\n  }\n  /**\n   * Traverse to the node at the specified gindex,\n   * then apply the function to get a new node and set the node at the specified gindex with the result.\n   *\n   * This is a convenient method to avoid traversing the tree 2 times to\n   * get and set.\n   */\n  setNodeWithFn(gindex, getNewNode) {\n    this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);\n  }\n  /**\n   * Set the node at the specified depth and index.\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  setNodeAtDepth(depth, index, node) {\n    this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);\n  }\n  /**\n   * Set the hash at the specified gindex.\n   *\n   * Note: This will set a new `LeafNode` at the specified gindex.\n   */\n  setRoot(index, root) {\n    this.setNode(index, node_1.LeafNode.fromRoot(root));\n  }\n  /**\n   * Fast read-only iteration\n   * In-order traversal of nodes at `depth`\n   * starting from the `startIndex`-indexed node\n   * iterating through `count` nodes\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  getNodesAtDepth(depth, startIndex, count) {\n    return getNodesAtDepth(this.rootNode, depth, startIndex, count);\n  }\n  /**\n   * Fast read-only iteration\n   * In-order traversal of nodes at `depth`\n   * starting from the `startIndex`-indexed node\n   * iterating through `count` nodes\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  iterateNodesAtDepth(depth, startIndex, count) {\n    return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);\n  }\n  /**\n   * Return a merkle proof for the node at the specified gindex.\n   */\n  getSingleProof(index) {\n    return single_1.createSingleProof(this.rootNode, index)[1];\n  }\n  /**\n   * Return a merkle proof for the proof input.\n   *\n   * This method can be used to create multiproofs.\n   */\n  getProof(input) {\n    return proof_1.createProof(this.rootNode, input);\n  }\n}\nexports.Tree = Tree;\n/**\n * Return the node at the specified gindex.\n */\nfunction getNode(rootNode, gindex) {\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  let node = rootNode;\n  for (let i = 1; i < gindexBitstring.length; i++) {\n    if (node.isLeaf()) {\n      throw new Error(\"Invalid tree - found leaf at depth \".concat(i));\n    }\n    // If bit is set, means navigate right\n    node = gindexBitstring[i] === \"1\" ? node.right : node.left;\n  }\n  return node;\n}\nexports.getNode = getNode;\n/**\n * Set the node at at the specified gindex.\n * Returns the new root node.\n */\nfunction setNode(rootNode, gindex, n) {\n  // Pre-compute entire bitstring instead of using an iterator (25% faster)\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  const parentNodes = getParentNodes(rootNode, gindexBitstring);\n  return rebindNodeToRoot(gindexBitstring, parentNodes, n);\n}\nexports.setNode = setNode;\n/**\n * Traverse to the node at the specified gindex,\n * then apply the function to get a new node and set the node at the specified gindex with the result.\n *\n * This is a convenient method to avoid traversing the tree 2 times to\n * get and set.\n *\n * Returns the new root node.\n */\nfunction setNodeWithFn(rootNode, gindex, getNewNode) {\n  // Pre-compute entire bitstring instead of using an iterator (25% faster)\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  const parentNodes = getParentNodes(rootNode, gindexBitstring);\n  const lastParentNode = parentNodes[parentNodes.length - 1];\n  const lastBit = gindexBitstring[gindexBitstring.length - 1];\n  const oldNode = lastBit === \"1\" ? lastParentNode.right : lastParentNode.left;\n  const newNode = getNewNode(oldNode);\n  return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);\n}\nexports.setNodeWithFn = setNodeWithFn;\n/**\n * Traverse the tree from root node, ignore the last bit to get all parent nodes\n * of the specified bitstring.\n */\nfunction getParentNodes(rootNode, bitstring) {\n  let node = rootNode;\n  // Keep a list of all parent nodes of node at gindex `index`. Then walk the list\n  // backwards to rebind them \"recursively\" with the new nodes without using functions\n  const parentNodes = [rootNode];\n  // Ignore the first bit, left right directions are at bits [1,..]\n  // Ignore the last bit, no need to push the target node to the parentNodes array\n  for (let i = 1; i < bitstring.length - 1; i++) {\n    // Compare to string directly to prevent unnecessary type conversions\n    if (bitstring[i] === \"1\") {\n      node = node.right;\n    } else {\n      node = node.left;\n    }\n    parentNodes.push(node);\n  }\n  return parentNodes;\n}\n/**\n * Build a new tree structure from bitstring, parentNodes and a new node.\n * Returns the new root node.\n */\nfunction rebindNodeToRoot(bitstring, parentNodes, newNode) {\n  let node = newNode;\n  // Ignore the first bit, left right directions are at bits [1,..]\n  // Iterate the list backwards including the last bit, but offset the parentNodes array\n  // by one since the first bit in bitstring was ignored in the previous loop\n  for (let i = bitstring.length - 1; i >= 1; i--) {\n    if (bitstring[i] === \"1\") {\n      node = new node_1.BranchNode(parentNodes[i - 1].left, node);\n    } else {\n      node = new node_1.BranchNode(node, parentNodes[i - 1].right);\n    }\n  }\n  return node;\n}\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction getNodeAtDepth(rootNode, depth, index) {\n  if (depth === 0) {\n    return rootNode;\n  }\n  if (depth === 1) {\n    return index === 0 ? rootNode.left : rootNode.right;\n  }\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let node = rootNode;\n  for (let d = depthiRoot; d >= depthiParent; d--) {\n    node = isLeftNode(d, index) ? node.left : node.right;\n  }\n  return node;\n}\nexports.getNodeAtDepth = getNodeAtDepth;\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {\n  // TODO: OPTIMIZE (if necessary)\n  return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);\n}\nexports.setNodeAtDepth = setNodeAtDepth;\n/**\n * Set multiple nodes in batch, editing and traversing nodes strictly once.\n *\n * - gindexes MUST be sorted in ascending order beforehand.\n * - All gindexes must be at the exact same depth.\n * - Depth must be > 0, if 0 just replace the root node.\n *\n * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,\n * and create a new parent. Then calculate the closest common depth with the next\n * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {\n  // depth depthi   gindexes   indexes\n  // 0     1           1          0\n  // 1     0         2   3      0   1\n  // 2     -        4 5 6 7    0 1 2 3\n  // '10' means, at depth 1, node is at the left\n  //\n  // For index N check if the bit at position depthi is set to navigate right at depthi\n  // ```\n  // mask = 1 << depthi\n  // goRight = (N & mask) == mask\n  // ```\n  // If depth is 0 there's only one node max and the optimization below will cause a navigation error.\n  // For this case, check if there's a new root node and return it, otherwise the current rootNode.\n  if (nodesDepth === 0) {\n    return nodes.length > 0 ? nodes[0] : rootNode;\n  }\n  /**\n   * Contiguous filled stack of parent nodes. It get filled in the first descent\n   * Indexed by depthi\n   */\n  const parentNodeStack = new Array(nodesDepth);\n  /**\n   * Temp stack of left parent nodes, index by depthi.\n   * Node leftParentNodeStack[depthi] is a node at d = depthi - 1, such that:\n   * ```\n   * parentNodeStack[depthi].left = leftParentNodeStack[depthi]\n   * ```\n   */\n  const leftParentNodeStack = new Array(nodesDepth);\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = nodesDepth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  // TODO: Iterate to depth 32 to allow using bit ops\n  // for (; depthi >= 32; depthi--) {\n  //   node = node.left;\n  // }\n  for (let i = 0; i < indexes.length; i++) {\n    const index = indexes[i];\n    // Navigate down until parent depth, and store the chain of nodes\n    //\n    // Starts from latest common depth, so node is the parent node at `depthi`\n    // When persisting the next node, store at the `d - 1` since its the child of node at `depthi`\n    //\n    // Stops at the level above depthiParent. For the re-binding routing below node must be at depthiParent\n    for (let d = depthi; d > depthiParent; d--) {\n      node = isLeftNode(d, index) ? node.left : node.right;\n      parentNodeStack[d - 1] = node;\n    }\n    depthi = depthiParent;\n    // If this is the left node, check first it the next node is on the right\n    //\n    //   -    If both nodes exist, create new\n    //  / \\\n    // x   x\n    //\n    //   -    If only the left node exists, rebind left\n    //  / \\\n    // x   -\n    //\n    //   -    If this is the right node, only the right node exists, rebind right\n    //  / \\\n    // -   x\n    // d = 0, mask = 1 << d = 1\n    const isLeftLeafNode = (index & 1) !== 1;\n    if (isLeftLeafNode) {\n      // Next node is the very next to the right of current node\n      if (index + 1 === indexes[i + 1]) {\n        node = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n        // Move pointer one extra forward since node has consumed two nodes\n        i++;\n      } else {\n        node = new node_1.BranchNode(nodes[i], node.right);\n      }\n    } else {\n      node = new node_1.BranchNode(node.left, nodes[i]);\n    }\n    // Here `node` is the new BranchNode at depthi `depthiParent`\n    // Now climb upwards until finding the common node with the next index\n    // For the last iteration, climb to the root at `depthiRoot`\n    const isLastIndex = i >= indexes.length - 1;\n    const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]);\n    // When climbing up from a left node there are two possible paths\n    // 1. Go to the right of the parent: Store left node to rebind latter\n    // 2. Go another level up: Will never visit the left node again, so must rebind now\n    // 🡼 \\     Rebind left only, will never visit this node again\n    // 🡽 /\\\n    //\n    //    / 🡽  Rebind left only (same as above)\n    // 🡽 /\\\n    //\n    // 🡽 /\\ 🡾  Store left node to rebind the entire node when returning\n    //\n    // 🡼 \\     Rebind right with left if exists, will never visit this node again\n    //   /\\ 🡼\n    //\n    //    / 🡽  Rebind right with left if exists (same as above)\n    //   /\\ 🡼\n    for (let d = depthiParent + 1; d <= diffDepthi; d++) {\n      // If node is on the left, store for latter\n      // If node is on the right merge with stored left node\n      if (isLeftNode(d, index)) {\n        if (isLastIndex || d !== diffDepthi) {\n          // If it's last index, bind with parent since it won't navigate to the right anymore\n          // Also, if still has to move upwards, rebind since the node won't be visited anymore\n          node = new node_1.BranchNode(node, parentNodeStack[d].right);\n        } else {\n          // Only store the left node if it's at d = diffDepth\n          leftParentNodeStack[d] = node;\n          node = parentNodeStack[d];\n        }\n      } else {\n        const leftNode = leftParentNodeStack[d];\n        if (leftNode !== undefined) {\n          node = new node_1.BranchNode(leftNode, node);\n          leftParentNodeStack[d] = undefined;\n        } else {\n          node = new node_1.BranchNode(parentNodeStack[d].left, node);\n        }\n      }\n    }\n    // Prepare next loop\n    // Go to the parent of the depth with diff, to switch branches to the right\n    depthi = diffDepthi;\n  }\n  // Done, return new root node\n  return node;\n}\nexports.setNodesAtDepth = setNodesAtDepth;\n/**\n * Fast read-only iteration\n * In-order traversal of nodes at `depth`\n * starting from the `startIndex`-indexed node\n * iterating through `count` nodes\n *\n * **Strategy**\n * 1. Navigate down to parentDepth storing a stack of parents\n * 2. At target level push current node\n * 3. Go up to the first level that navigated left\n * 4. Repeat (1) for next index\n */\nfunction getNodesAtDepth(rootNode, depth, startIndex, count) {\n  // Optimized paths for short trees (x20 times faster)\n  if (depth === 0) {\n    return startIndex === 0 && count > 0 ? [rootNode] : [];\n  } else if (depth === 1) {\n    if (count === 0) {\n      return [];\n    } else if (count === 1) {\n      return startIndex === 0 ? [rootNode.left] : [rootNode.right];\n    } else {\n      return [rootNode.left, rootNode.right];\n    }\n  }\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Contiguous filled stack of parent nodes. It get filled in the first descent\n  // Indexed by depthi\n  const parentNodeStack = new Array(depth);\n  const isLeftStack = new Array(depth);\n  const nodes = new Array(count);\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  for (let i = 0; i < count; i++) {\n    for (let d = depthi; d >= depthiParent; d--) {\n      if (d !== depthi) {\n        parentNodeStack[d] = node;\n      }\n      const isLeft = isLeftNode(d, startIndex + i);\n      isLeftStack[d] = isLeft;\n      node = isLeft ? node.left : node.right;\n    }\n    nodes[i] = node;\n    // Find the first depth where navigation when left.\n    // Store that height and go right from there\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n      if (isLeftStack[d] === true) {\n        depthi = d;\n        break;\n      }\n    }\n    node = parentNodeStack[depthi];\n  }\n  return nodes;\n}\nexports.getNodesAtDepth = getNodesAtDepth;\n/**\n * @see getNodesAtDepth but instead of pushing to an array, it yields\n */\nfunction* iterateNodesAtDepth(rootNode, depth, startIndex, count) {\n  const endIndex = startIndex + count;\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Contiguous filled stack of parent nodes. It get filled in the first descent\n  // Indexed by depthi\n  const parentNodeStack = new Array(depth);\n  const isLeftStack = new Array(depth);\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  for (let index = startIndex; index < endIndex; index++) {\n    for (let d = depthi; d >= depthiParent; d--) {\n      if (d !== depthi) {\n        parentNodeStack[d] = node;\n      }\n      const isLeft = isLeftNode(d, index);\n      isLeftStack[d] = isLeft;\n      node = isLeft ? node.left : node.right;\n    }\n    yield node;\n    // Find the first depth where navigation when left.\n    // Store that height and go right from there\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n      if (isLeftStack[d] === true) {\n        depthi = d;\n        break;\n      }\n    }\n    node = parentNodeStack[depthi];\n  }\n}\nexports.iterateNodesAtDepth = iterateNodesAtDepth;\n/**\n * Zero's all nodes right of index with constant depth of `nodesDepth`.\n *\n * For example, zero-ing this tree at depth 2 after index 0\n * ```\n *    X              X\n *  X   X    ->    X   0\n * X X X X        X 0 0 0\n * ```\n *\n * Or, zero-ing this tree at depth 3 after index 2\n * ```\n *        X                     X\n *    X       X             X       0\n *  X   X   X   X    ->   X   X   0   0\n * X X X X X X X X       X X X 0 0 0 0 0\n * ```\n *\n * The strategy is to first navigate down to `nodesDepth` and `index` and keep a stack of parents.\n * Then navigate up re-binding:\n * - If navigated to the left rebind with zeroNode()\n * - If navigated to the right rebind with parent.left from the stack\n */\nfunction treeZeroAfterIndex(rootNode, nodesDepth, index) {\n  // depth depthi   gindexes   indexes\n  // 0     1           1          0\n  // 1     0         2   3      0   1\n  // 2     -        4 5 6 7    0 1 2 3\n  // '10' means, at depth 1, node is at the left\n  //\n  // For index N check if the bit at position depthi is set to navigate right at depthi\n  // ```\n  // mask = 1 << depthi\n  // goRight = (N & mask) == mask\n  // ```\n  // Degenerate case where tree is zero after a negative index (-1).\n  // All positive indexes are zero, so the entire tree is zero. Return cached zero node as root.\n  if (index < 0) {\n    return zeroNode_1.zeroNode(nodesDepth);\n  }\n  /**\n   * Contiguous filled stack of parent nodes. It get filled in the first descent\n   * Indexed by depthi\n   */\n  const parentNodeStack = new Array(nodesDepth);\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = nodesDepth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  // Navigate down until parent depth, and store the chain of nodes\n  //\n  // Stops at the depthiParent level. To rebind below down to `nodesDepth`\n  for (let d = depthi; d >= depthiParent; d--) {\n    node = isLeftNode(d, index) ? node.left : node.right;\n    parentNodeStack[d - 1] = node;\n  }\n  depthi = depthiParent;\n  // Now climb up re-binding with either zero of existing tree.\n  for (let d = depthiParent; d <= depthiRoot; d++) {\n    if (isLeftNode(d, index)) {\n      // If navigated to the left, then all the child nodes of the right node are NOT part of the new tree.\n      // So re-bind new `node` with a zeroNode at the current depth.\n      node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));\n    } else {\n      // If navigated to the right, then all the child nodes of the left node are part of the new tree.\n      // So re-bind new `node` with the existing left node of the parent.\n      node = new node_1.BranchNode(parentNodeStack[d].left, node);\n    }\n  }\n  // Done, return new root node\n  return node;\n}\nexports.treeZeroAfterIndex = treeZeroAfterIndex;\n/**\n * Returns true if the `index` at `depth` is a left node, false if it is a right node.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n * In Eth2 case the biggest tree's index is 2**40 (VALIDATOR_REGISTRY_LIMIT)\n */\nfunction isLeftNode(depthi, index) {\n  if (depthi > 31) {\n    // Javascript can only do bitwise ops with 32 bit numbers.\n    // Shifting left 1 by 32 wraps around and becomes 1.\n    // Get the high part of `index` and adjust depthi\n    const indexHi = index / 2 ** 32 >>> 0;\n    const mask = 1 << depthi - 32;\n    return (indexHi & mask) !== mask;\n  }\n  const mask = 1 << depthi;\n  return (index & mask) !== mask;\n}\n/**\n * depth depthi   gindexes   indexes\n * 0     1           1          0\n * 1     0         2   3      0   1\n * 2     -        4 5 6 7    0 1 2 3\n *\n * **Conditions**:\n * - `from` and `to` must not be equal\n *\n * @param from Index\n * @param to Index\n */\nfunction findDiffDepthi(from, to) {\n  return (\n    // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2\n    Math.ceil(Math.log2(-~(from ^ to))) -\n    // Must offset by one to match the depthi scale\n    1\n  );\n}","map":null,"metadata":{},"sourceType":"script"}