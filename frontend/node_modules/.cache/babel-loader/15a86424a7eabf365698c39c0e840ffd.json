{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: \"must NOT have additional properties\",\n  params: _ref => {\n    let {\n      params: _params\n    } = _ref;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{additionalProperty: \", \"}\"])), _params.additionalProperty);\n  }\n};\nconst def = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      errsCount,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\");\n    const {\n      allErrors,\n      opts\n    } = it;\n    it.props = true;\n    if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema)) return;\n    const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n    const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n    checkAdditionalProperties();\n    cxt.ok((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), errsCount, names_1.default.errors));\n    function checkAdditionalProperties() {\n      gen.forIn(\"key\", data, key => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key);else gen.if(isAdditional(key), () => additionalPropertyCode(key));\n      });\n    }\n    function isAdditional(key) {\n      let definedProp;\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n        definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n      } else if (props.length) {\n        definedProp = (0, codegen_1.or)(...props.map(p => (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), key, p)));\n      } else {\n        definedProp = codegen_1.nil;\n      }\n      if (patProps.length) {\n        definedProp = (0, codegen_1.or)(definedProp, ...patProps.map(p => (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), (0, code_1.usePattern)(cxt, p), key)));\n      }\n      return (0, codegen_1.not)(definedProp);\n    }\n    function deleteAdditional(key) {\n      gen.code((0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"delete \", \"[\", \"]\"])), data, key));\n    }\n    function additionalPropertyCode(key) {\n      if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n        deleteAdditional(key);\n        return;\n      }\n      if (schema === false) {\n        cxt.setParams({\n          additionalProperty: key\n        });\n        cxt.error();\n        if (!allErrors) gen.break();\n        return;\n      }\n      if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.name(\"valid\");\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false);\n          gen.if((0, codegen_1.not)(valid), () => {\n            cxt.reset();\n            deleteAdditional(key);\n          });\n        } else {\n          applyAdditionalSchema(key, valid);\n          if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n        }\n      }\n    }\n    function applyAdditionalSchema(key, valid, errors) {\n      const subschema = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: util_1.Type.Str\n      };\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        });\n      }\n      cxt.subschema(subschema, valid);\n    }\n  }\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}