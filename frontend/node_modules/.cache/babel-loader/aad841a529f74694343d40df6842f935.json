{"ast":null,"code":"\"use strict\";\n\nvar _wrapRegExp = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/wrapRegExp.js\").default;\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zeroValue = exports.structHash = exports.encodeData = exports.typeHash = exports.encodeType = exports.generateTypedDataHash = exports.noString = exports.noNumber = exports.noBool = exports.defined = exports.eip712OptionalSchema = exports.eip712OptionalType = exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES = exports.EIP712_ATOMIC_TYPES = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar t = __importStar(require(\"io-ts\"));\nvar web3_eth_abi_1 = __importDefault(require(\"web3-eth-abi\"));\n/** Array of all EIP-712 atomic type names. */\nexports.EIP712_ATOMIC_TYPES = ['bytes1', 'bytes32', 'uint8', 'uint64', 'uint256',\n// This list should technically include all types from uint8 to uint256, and int8 to int256\n'int8', 'int256', 'bool', 'address'];\nexports.EIP712_DYNAMIC_TYPES = ['bytes', 'string'];\nexports.EIP712_BUILTIN_TYPES = exports.EIP712_ATOMIC_TYPES.concat(exports.EIP712_DYNAMIC_TYPES);\n// Regular expression used to identify and parse EIP-712 array type strings.\nvar EIP712_ARRAY_REGEXP = /*#__PURE__*/_wrapRegExp(/^([\\w<>\\[\\]_\\-]+)(\\[(\\d+)?\\])$/, {\n  memberType: 1,\n  fixedLength: 3\n});\n// Regular experssion used to identity EIP-712 integer types (e.g. int256, uint256, uint8).\nvar EIP712_INT_REGEXP = /^u?int\\d*$/;\n/**\n * Utility to build EIP712Optional<T> types to insert in EIP-712 type arrays.\n * @param typeName EIP-712 string type name. Should be builtin or defined in the EIP712Types\n * structure into which this type will be merged.\n */\nvar eip712OptionalType = function eip712OptionalType(typeName) {\n  var _a;\n  return _a = {}, _a[\"Optional<\".concat(typeName, \">\")] = [{\n    name: 'defined',\n    type: 'bool'\n  }, {\n    name: 'value',\n    type: typeName\n  }], _a;\n};\nexports.eip712OptionalType = eip712OptionalType;\n/**\n * Utility to build EIP712Optional<T> schemas for encoding and decoding with io-ts.\n * @param schema io-ts type (a.k.a. schema or codec) describing the inner type.\n */\nvar eip712OptionalSchema = function eip712OptionalSchema(schema) {\n  return t.type({\n    defined: t.boolean,\n    value: schema\n  });\n};\nexports.eip712OptionalSchema = eip712OptionalSchema;\n/** Utility to construct an defined EIP712Optional value with inferred type. */\nvar defined = function defined(value) {\n  return {\n    defined: true,\n    value: value\n  };\n};\nexports.defined = defined;\n/** Undefined EIP712Optional type with value type boolean. */\nexports.noBool = {\n  defined: false,\n  value: false\n};\n/** Undefined EIP712Optional type with value type number. */\nexports.noNumber = {\n  defined: false,\n  value: 0\n};\n/** Undefined EIP712Optional type with value type string. */\nexports.noString = {\n  defined: false,\n  value: ''\n};\n/**\n * Generates the EIP712 Typed Data hash for signing\n * @param   typedData An object that conforms to the EIP712TypedData interface\n * @return  A Buffer containing the hash of the typed data.\n */\nfunction generateTypedDataHash(typedData) {\n  return (0, ethereumjs_util_1.keccak)(Buffer.concat([Buffer.from('1901', 'hex'), structHash('EIP712Domain', typedData.domain, typedData.types), structHash(typedData.primaryType, typedData.message, typedData.types)]));\n}\nexports.generateTypedDataHash = generateTypedDataHash;\n/**\n * Given the primary type, and dictionary of types, this function assembles a sorted list\n * representing the transitive dependency closure of the primary type. (Inclusive of the primary\n * type itself.)\n */\nfunction findDependencies(primaryType, types, found) {\n  var e_1, _a;\n  var _b;\n  if (found === void 0) {\n    found = [];\n  }\n  // If we have aready found the dependencies of this type, or it is a builtin, return early.\n  if (found.includes(primaryType) || exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {\n    return [];\n  }\n  // If this is an array type, return the results for its member type.\n  if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n    var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n    var memberType = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.memberType;\n    return findDependencies(memberType, types, found);\n  }\n  // If this is not a builtin and is not defined, we cannot correctly construct a type encoding.\n  if (types[primaryType] === undefined) {\n    throw new Error(\"Unrecognized type \".concat(primaryType, \" is not included in the EIP-712 type list\"));\n  }\n  // Execute a depth-first search to populate the (inclusive) dependencies list.\n  // By the first invarient of this function, the resulting list should not contain duplicates.\n  var dependencies = [primaryType];\n  try {\n    for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var field = _d.value;\n      dependencies.push.apply(dependencies, __spreadArray([], __read(findDependencies(field.type, types, found.concat(dependencies))), false));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return dependencies;\n}\n/**\n * Creates a string encoding of the primary type, including all dependencies.\n * E.g. \"Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)\"\n */\nfunction encodeType(primaryType, types) {\n  var e_2, _a;\n  var deps = findDependencies(primaryType, types);\n  deps = deps.filter(function (d) {\n    return d !== primaryType;\n  });\n  deps = [primaryType].concat(deps.sort());\n  var result = '';\n  try {\n    for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n      var dep = deps_1_1.value;\n      result += \"\".concat(dep, \"(\").concat(types[dep].map(function (_a) {\n        var name = _a.name,\n          type = _a.type;\n        return \"\".concat(type, \" \").concat(name);\n      }).join(','), \")\");\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return result;\n}\nexports.encodeType = encodeType;\nfunction typeHash(primaryType, types) {\n  return (0, ethereumjs_util_1.keccak)(encodeType(primaryType, types));\n}\nexports.typeHash = typeHash;\n/** Encodes a single EIP-712 value to a 32-byte buffer */\nfunction encodeValue(valueType, value, types) {\n  var _a;\n  // Encode the atomic types as their corresponding soldity ABI type.\n  if (exports.EIP712_ATOMIC_TYPES.includes(valueType)) {\n    // @ts-ignore TypeScript does not believe encodeParameter exists.\n    var hexEncoded = web3_eth_abi_1.default.encodeParameter(valueType, normalizeValue(valueType, value));\n    return Buffer.from((0, address_1.trimLeading0x)(hexEncoded), 'hex');\n  }\n  // Encode `string` and `bytes` types as their keccak hash.\n  if (valueType === 'string') {\n    // Converting to Buffer before passing to `keccak` prevents an issue where the string is\n    // interpretted as a hex-encoded string when is starts with 0x.\n    // https://github.com/ethereumjs/ethereumjs-util/blob/7e3be1d97b4e11fbc4924836b8c444e644f643ac/index.js#L155-L183\n    return (0, ethereumjs_util_1.keccak)(Buffer.from(value, 'utf8'));\n  }\n  if (valueType === 'bytes') {\n    // Allow the user to use either utf8 (plain string) or hex encoding for their bytes.\n    // Note: keccak throws if the value cannot be converted into a Buffer,\n    return (0, ethereumjs_util_1.keccak)(value);\n  }\n  // Encode structs as its hashStruct (e.g. keccak(typeHash || encodeData(struct)) ).\n  if (types[valueType] !== undefined) {\n    // tslint:disable-next-line:no-unnecessary-type-assertion.\n    return structHash(valueType, value, types);\n  }\n  // Encode arrays as the hash of the concatenated encoding of the underlying types.\n  if (EIP712_ARRAY_REGEXP.test(valueType)) {\n    // Note: If a fixed length is provided in the type, it is not checked.\n    var match = EIP712_ARRAY_REGEXP.exec(valueType);\n    var memberType_1 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat(value.map(function (member) {\n      return encodeValue(memberType_1, member, types);\n    })));\n  }\n  throw new Error(\"Unrecognized or unsupported type in EIP-712 encoding: \".concat(valueType));\n}\nfunction normalizeValue(type, value) {\n  var normalizedValue = EIP712_INT_REGEXP.test(type) && bignumber_js_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n  return normalizedValue;\n}\n/**\n * Constructs the struct encoding of the data as the primary type.\n */\nfunction encodeData(primaryType, data, types) {\n  var fields = types[primaryType];\n  if (fields === undefined) {\n    throw new Error(\"Unrecognized primary type in EIP-712 encoding: \".concat(primaryType));\n  }\n  return Buffer.concat(fields.map(function (field) {\n    return encodeValue(field.type, data[field.name], types);\n  }));\n}\nexports.encodeData = encodeData;\nfunction structHash(primaryType, data, types) {\n  return (0, ethereumjs_util_1.keccak)(Buffer.concat([typeHash(primaryType, types), encodeData(primaryType, data, types)]));\n}\nexports.structHash = structHash;\n/**\n * Produce the zero value for a given type.\n *\n * @remarks\n * All atomic types will encode as the 32-byte zero value. Dynamic types as an empty hash.\n * Dynamic arrays will return an empty array. Fixed length arrays will have members set to zero.\n * Structs will have the values of all fields set to zero recursively.\n *\n * Note that EIP-712 does not specify zero values, and so this is non-standard.\n */\nfunction zeroValue(primaryType, types) {\n  var _a, _b;\n  if (types === void 0) {\n    types = {};\n  }\n  // If the type is a built-in, return a pre-defined zero value.\n  if (['bytes', 'bytes1', 'bytes32'].includes(primaryType)) {\n    return Buffer.alloc(0);\n  }\n  if (['uint8', 'uint256', 'int8', 'int256'].includes(primaryType)) {\n    return 0;\n  }\n  if (primaryType === 'bool') {\n    return false;\n  }\n  if (primaryType === 'address') {\n    return address_1.NULL_ADDRESS;\n  }\n  if (primaryType === 'string') {\n    return '';\n  }\n  // If the type is an array, return an empty array or an array of the given fixed length.\n  if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n    var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n    var memberType_2 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n    var fixedLengthStr = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.fixedLength;\n    var fixedLength = fixedLengthStr === undefined ? 0 : parseInt(fixedLengthStr, 10);\n    return __spreadArray([], __read(Array(fixedLength).keys()), false).map(function () {\n      return zeroValue(memberType_2, types);\n    });\n  }\n  // Must be user-defined type. Return an object with all fields set to their zero value.\n  var fields = types[primaryType];\n  if (fields === undefined) {\n    throw new Error(\"Unrecognized primary type for EIP-712 zero value: \".concat(primaryType));\n  }\n  return fields.reduce(function (obj, field) {\n    var _a;\n    return __assign(__assign({}, obj), (_a = {}, _a[field.name] = zeroValue(field.type, types), _a));\n  }, {});\n}\nexports.zeroValue = zeroValue;","map":{"version":3,"sources":["../src/sign-typed-data-utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.zeroValue = exports.structHash = exports.encodeData = exports.typeHash = exports.encodeType = exports.generateTypedDataHash = exports.noString = exports.noNumber = exports.noBool = exports.defined = exports.eip712OptionalSchema = exports.eip712OptionalType = exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES = exports.EIP712_ATOMIC_TYPES = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar t = __importStar(require(\"io-ts\"));\nvar web3_eth_abi_1 = __importDefault(require(\"web3-eth-abi\"));\n/** Array of all EIP-712 atomic type names. */\nexports.EIP712_ATOMIC_TYPES = [\n    'bytes1',\n    'bytes32',\n    'uint8',\n    'uint64',\n    'uint256',\n    // This list should technically include all types from uint8 to uint256, and int8 to int256\n    'int8',\n    'int256',\n    'bool',\n    'address',\n];\nexports.EIP712_DYNAMIC_TYPES = ['bytes', 'string'];\nexports.EIP712_BUILTIN_TYPES = exports.EIP712_ATOMIC_TYPES.concat(exports.EIP712_DYNAMIC_TYPES);\n// Regular expression used to identify and parse EIP-712 array type strings.\nvar EIP712_ARRAY_REGEXP = /^(?<memberType>[\\w<>\\[\\]_\\-]+)(\\[(?<fixedLength>\\d+)?\\])$/;\n// Regular experssion used to identity EIP-712 integer types (e.g. int256, uint256, uint8).\nvar EIP712_INT_REGEXP = /^u?int\\d*$/;\n/**\n * Utility to build EIP712Optional<T> types to insert in EIP-712 type arrays.\n * @param typeName EIP-712 string type name. Should be builtin or defined in the EIP712Types\n * structure into which this type will be merged.\n */\nvar eip712OptionalType = function (typeName) {\n    var _a;\n    return (_a = {},\n        _a[\"Optional<\".concat(typeName, \">\")] = [\n            { name: 'defined', type: 'bool' },\n            { name: 'value', type: typeName },\n        ],\n        _a);\n};\nexports.eip712OptionalType = eip712OptionalType;\n/**\n * Utility to build EIP712Optional<T> schemas for encoding and decoding with io-ts.\n * @param schema io-ts type (a.k.a. schema or codec) describing the inner type.\n */\nvar eip712OptionalSchema = function (schema) {\n    return t.type({\n        defined: t.boolean,\n        value: schema,\n    });\n};\nexports.eip712OptionalSchema = eip712OptionalSchema;\n/** Utility to construct an defined EIP712Optional value with inferred type. */\nvar defined = function (value) { return ({\n    defined: true,\n    value: value,\n}); };\nexports.defined = defined;\n/** Undefined EIP712Optional type with value type boolean. */\nexports.noBool = {\n    defined: false,\n    value: false,\n};\n/** Undefined EIP712Optional type with value type number. */\nexports.noNumber = {\n    defined: false,\n    value: 0,\n};\n/** Undefined EIP712Optional type with value type string. */\nexports.noString = {\n    defined: false,\n    value: '',\n};\n/**\n * Generates the EIP712 Typed Data hash for signing\n * @param   typedData An object that conforms to the EIP712TypedData interface\n * @return  A Buffer containing the hash of the typed data.\n */\nfunction generateTypedDataHash(typedData) {\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat([\n        Buffer.from('1901', 'hex'),\n        structHash('EIP712Domain', typedData.domain, typedData.types),\n        structHash(typedData.primaryType, typedData.message, typedData.types),\n    ]));\n}\nexports.generateTypedDataHash = generateTypedDataHash;\n/**\n * Given the primary type, and dictionary of types, this function assembles a sorted list\n * representing the transitive dependency closure of the primary type. (Inclusive of the primary\n * type itself.)\n */\nfunction findDependencies(primaryType, types, found) {\n    var e_1, _a;\n    var _b;\n    if (found === void 0) { found = []; }\n    // If we have aready found the dependencies of this type, or it is a builtin, return early.\n    if (found.includes(primaryType) || exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {\n        return [];\n    }\n    // If this is an array type, return the results for its member type.\n    if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n        var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n        var memberType = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.memberType;\n        return findDependencies(memberType, types, found);\n    }\n    // If this is not a builtin and is not defined, we cannot correctly construct a type encoding.\n    if (types[primaryType] === undefined) {\n        throw new Error(\"Unrecognized type \".concat(primaryType, \" is not included in the EIP-712 type list\"));\n    }\n    // Execute a depth-first search to populate the (inclusive) dependencies list.\n    // By the first invarient of this function, the resulting list should not contain duplicates.\n    var dependencies = [primaryType];\n    try {\n        for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var field = _d.value;\n            dependencies.push.apply(dependencies, __spreadArray([], __read(findDependencies(field.type, types, found.concat(dependencies))), false));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return dependencies;\n}\n/**\n * Creates a string encoding of the primary type, including all dependencies.\n * E.g. \"Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)\"\n */\nfunction encodeType(primaryType, types) {\n    var e_2, _a;\n    var deps = findDependencies(primaryType, types);\n    deps = deps.filter(function (d) { return d !== primaryType; });\n    deps = [primaryType].concat(deps.sort());\n    var result = '';\n    try {\n        for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n            var dep = deps_1_1.value;\n            result += \"\".concat(dep, \"(\").concat(types[dep].map(function (_a) {\n                var name = _a.name, type = _a.type;\n                return \"\".concat(type, \" \").concat(name);\n            }).join(','), \")\");\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return result;\n}\nexports.encodeType = encodeType;\nfunction typeHash(primaryType, types) {\n    return (0, ethereumjs_util_1.keccak)(encodeType(primaryType, types));\n}\nexports.typeHash = typeHash;\n/** Encodes a single EIP-712 value to a 32-byte buffer */\nfunction encodeValue(valueType, value, types) {\n    var _a;\n    // Encode the atomic types as their corresponding soldity ABI type.\n    if (exports.EIP712_ATOMIC_TYPES.includes(valueType)) {\n        // @ts-ignore TypeScript does not believe encodeParameter exists.\n        var hexEncoded = web3_eth_abi_1.default.encodeParameter(valueType, normalizeValue(valueType, value));\n        return Buffer.from((0, address_1.trimLeading0x)(hexEncoded), 'hex');\n    }\n    // Encode `string` and `bytes` types as their keccak hash.\n    if (valueType === 'string') {\n        // Converting to Buffer before passing to `keccak` prevents an issue where the string is\n        // interpretted as a hex-encoded string when is starts with 0x.\n        // https://github.com/ethereumjs/ethereumjs-util/blob/7e3be1d97b4e11fbc4924836b8c444e644f643ac/index.js#L155-L183\n        return (0, ethereumjs_util_1.keccak)(Buffer.from(value, 'utf8'));\n    }\n    if (valueType === 'bytes') {\n        // Allow the user to use either utf8 (plain string) or hex encoding for their bytes.\n        // Note: keccak throws if the value cannot be converted into a Buffer,\n        return (0, ethereumjs_util_1.keccak)(value);\n    }\n    // Encode structs as its hashStruct (e.g. keccak(typeHash || encodeData(struct)) ).\n    if (types[valueType] !== undefined) {\n        // tslint:disable-next-line:no-unnecessary-type-assertion.\n        return structHash(valueType, value, types);\n    }\n    // Encode arrays as the hash of the concatenated encoding of the underlying types.\n    if (EIP712_ARRAY_REGEXP.test(valueType)) {\n        // Note: If a fixed length is provided in the type, it is not checked.\n        var match = EIP712_ARRAY_REGEXP.exec(valueType);\n        var memberType_1 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n        return (0, ethereumjs_util_1.keccak)(Buffer.concat(value.map(function (member) { return encodeValue(memberType_1, member, types); })));\n    }\n    throw new Error(\"Unrecognized or unsupported type in EIP-712 encoding: \".concat(valueType));\n}\nfunction normalizeValue(type, value) {\n    var normalizedValue = EIP712_INT_REGEXP.test(type) && bignumber_js_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n    return normalizedValue;\n}\n/**\n * Constructs the struct encoding of the data as the primary type.\n */\nfunction encodeData(primaryType, data, types) {\n    var fields = types[primaryType];\n    if (fields === undefined) {\n        throw new Error(\"Unrecognized primary type in EIP-712 encoding: \".concat(primaryType));\n    }\n    return Buffer.concat(fields.map(function (field) { return encodeValue(field.type, data[field.name], types); }));\n}\nexports.encodeData = encodeData;\nfunction structHash(primaryType, data, types) {\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat([typeHash(primaryType, types), encodeData(primaryType, data, types)]));\n}\nexports.structHash = structHash;\n/**\n * Produce the zero value for a given type.\n *\n * @remarks\n * All atomic types will encode as the 32-byte zero value. Dynamic types as an empty hash.\n * Dynamic arrays will return an empty array. Fixed length arrays will have members set to zero.\n * Structs will have the values of all fields set to zero recursively.\n *\n * Note that EIP-712 does not specify zero values, and so this is non-standard.\n */\nfunction zeroValue(primaryType, types) {\n    var _a, _b;\n    if (types === void 0) { types = {}; }\n    // If the type is a built-in, return a pre-defined zero value.\n    if (['bytes', 'bytes1', 'bytes32'].includes(primaryType)) {\n        return Buffer.alloc(0);\n    }\n    if (['uint8', 'uint256', 'int8', 'int256'].includes(primaryType)) {\n        return 0;\n    }\n    if (primaryType === 'bool') {\n        return false;\n    }\n    if (primaryType === 'address') {\n        return address_1.NULL_ADDRESS;\n    }\n    if (primaryType === 'string') {\n        return '';\n    }\n    // If the type is an array, return an empty array or an array of the given fixed length.\n    if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n        var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n        var memberType_2 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n        var fixedLengthStr = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.fixedLength;\n        var fixedLength = fixedLengthStr === undefined ? 0 : parseInt(fixedLengthStr, 10);\n        return __spreadArray([], __read(Array(fixedLength).keys()), false).map(function () { return zeroValue(memberType_2, types); });\n    }\n    // Must be user-defined type. Return an object with all fields set to their zero value.\n    var fields = types[primaryType];\n    if (fields === undefined) {\n        throw new Error(\"Unrecognized primary type for EIP-712 zero value: \".concat(primaryType));\n    }\n    return fields.reduce(function (obj, field) {\n        var _a;\n        return (__assign(__assign({}, obj), (_a = {}, _a[field.name] = zeroValue(field.type, types), _a)));\n    }, {});\n}\nexports.zeroValue = zeroValue;\n//# sourceMappingURL=sign-typed-data-utils.js.map"]},"metadata":{},"sourceType":"script"}