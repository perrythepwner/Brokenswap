{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n'use strict';\n\nvar _objectSpread = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar EthersTransactionUtils = require('@ethersproject/transactions');\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n  this.requestManager = options.requestManager;\n  // reference to eth.accounts\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n  this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n  this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager;\n  // reference to eth.accounts\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  Object.defineProperty(func, 'call', {\n    configurable: true,\n    writable: true,\n    value: this.call\n  });\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  Object.defineProperty(func, 'call', {\n    configurable: true,\n    writable: true,\n    value: this.call\n  });\n  var name = this.name.split('.');\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n  return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n  if (!this.inputFormatter) {\n    return args;\n  }\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n  if (Array.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res, this === null || this === void 0 ? void 0 : this.hexFormat) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result, this === null || this === void 0 ? void 0 : this.hexFormat) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n  return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n    promiseResolved = false,\n    canUnsubscribe = true,\n    timeoutCount = 0,\n    confirmationCount = 0,\n    intervalId = null,\n    blockHeaderTimeoutId = null,\n    lastBlock = null,\n    receiptJSON = '',\n    gasProvided = !!payload.params[0] && typeof payload.params[0] === 'object' && payload.params[0].gas ? payload.params[0].gas : null,\n    isContractDeployment = !!payload.params[0] && typeof payload.params[0] === 'object' && payload.params[0].data && payload.params[0].from && !payload.params[0].to,\n    hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n  // add custom send Methods\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Method({\n    name: 'getTransactionByHash',\n    call: 'eth_getTransactionByHash',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionFormatter\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })];\n  // attach methods to this._ethereumCall\n  var _ethereumCall = {};\n  _ethereumCalls.forEach(mthd => {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  });\n  // fire \"receipt\" and confirmation events and resolve after\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n            clearTimeout(blockHeaderTimeoutId);\n          }\n        };\n      }\n      // if we have a valid receipt we don't need to send a request\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)\n      // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      })\n      // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (receipt) {\n          if (!receipt || !receipt.blockHash) {\n            throw new Error('Receipt missing or blockHash null');\n          }\n          // apply extra formatters\n          if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n            receipt = method.extraFormatters.receiptFormatter(receipt);\n          }\n          // check if confirmation listener exists\n          if (defer.eventEmitter.listeners('confirmation').length > 0) {\n            var block;\n            // If there was an immediately retrieved receipt, it's already\n            // been confirmed by the direct call to checkConfirmation needed\n            // for parity instant-seal\n            if (existingReceipt === undefined || confirmationCount !== 0) {\n              // Get latest block to emit with confirmation\n              var latestBlock = yield _ethereumCall.getBlockByNumber('latest');\n              var latestBlockHash = latestBlock ? latestBlock.hash : null;\n              if (isPolling) {\n                // Check if actually a new block is existing on polling\n                if (lastBlock) {\n                  block = yield _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                  if (block) {\n                    lastBlock = block;\n                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                  }\n                } else {\n                  block = yield _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                }\n              } else {\n                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n              }\n            }\n            if (isPolling && block || !isPolling) {\n              confirmationCount++;\n            }\n            canUnsubscribe = false;\n            if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n              // add 1 so we account for conf 0\n              sub.unsubscribe();\n              defer.eventEmitter.removeAllListeners();\n            }\n          }\n          return receipt;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }())\n      // CHECK for CONTRACT DEPLOYMENT\n      .then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (receipt) {\n          if (isContractDeployment && !promiseResolved) {\n            if (!receipt.contractAddress) {\n              if (canUnsubscribe) {\n                sub.unsubscribe();\n                promiseResolved = true;\n              }\n              utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              return;\n            }\n            var code;\n            try {\n              code = yield _ethereumCall.getCode(receipt.contractAddress);\n            } catch (err) {\n              // ignore;\n            }\n            if (!code) {\n              return;\n            }\n            // If deployment is status.true and there was a real\n            // bytecode string, assume it was successful.\n            var deploymentSuccess = receipt.status === true && hasBytecode;\n            if (deploymentSuccess || code.length > 2) {\n              defer.eventEmitter.emit('receipt', receipt);\n              // if contract, return instance instead of receipt\n              if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n              } else {\n                defer.resolve(receipt);\n              }\n              // need to remove listeners, as they aren't removed automatically when succesfull\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n            }\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n            promiseResolved = true;\n          }\n          return receipt;\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }())\n      // CHECK for normal tx check for receipt only\n      .then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (receipt) {\n          if (!isContractDeployment && !promiseResolved) {\n            if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n              defer.eventEmitter.emit('receipt', receipt);\n              defer.resolve(receipt);\n              // need to remove listeners, as they aren't removed automatically when succesfull\n              if (canUnsubscribe) {\n                defer.eventEmitter.removeAllListeners();\n              }\n            } else {\n              receiptJSON = JSON.stringify(receipt, null, 2);\n              if (receipt.status === false || receipt.status === '0x0') {\n                try {\n                  var revertMessage = null;\n                  if (method.handleRevert && (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                    var txReplayOptions = payload.params[0];\n                    // If send was raw, fetch the transaction and reconstitute the\n                    // original params so they can be replayed with `eth_call`\n                    if (method.call === 'eth_sendRawTransaction') {\n                      var rawTransactionHex = payload.params[0];\n                      var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                      txReplayOptions = formatters.inputTransactionFormatter({\n                        data: parsedTx.data,\n                        to: parsedTx.to,\n                        from: parsedTx.from,\n                        gas: parsedTx.gasLimit.toHexString(),\n                        gasPrice: parsedTx.gasPrice ? parsedTx.gasPrice.toHexString() : undefined,\n                        value: parsedTx.value.toHexString()\n                      });\n                    }\n                    // Get revert reason string with eth_call\n                    revertMessage = yield method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                    if (revertMessage) {\n                      // Only throw a revert error if a revert reason is existing\n                      utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    } else {\n                      throw false; // Throw false and let the try/catch statement handle the error correctly after\n                    }\n                  } else {\n                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                  }\n                } catch (error) {\n                  // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                  utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                }\n              } else {\n                // Throw OOG if status is not existing and provided gas and used gas are equal\n                utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n              }\n            }\n            if (canUnsubscribe) {\n              sub.unsubscribe();\n            }\n            promiseResolved = true;\n          }\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }())\n      // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++;\n        // check to see if we are http polling\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  };\n  // start watching for confirmation depending on the support features of the provider\n  var startWatching = function (existingReceipt) {\n    let blockHeaderArrived = false;\n    const startInterval = () => {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n    };\n    // If provider do not support event subscription use polling\n    if (!this.requestManager.provider.on) {\n      return startInterval();\n    }\n    // Subscribe to new block headers to look for tx receipt\n    _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n      blockHeaderArrived = true;\n      if (err || !blockHeader) {\n        // fall back to polling\n        return startInterval();\n      }\n      checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n    });\n    // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n    blockHeaderTimeoutId = setTimeout(() => {\n      if (!blockHeaderArrived) {\n        startInterval();\n      }\n    }, this.blockHeaderTimeout * 1000);\n  }.bind(this);\n  // first check if we already have a confirmed transaction\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null;\n  // is index given\n  if (typeof from === 'number') {\n    wallet = accounts.wallet[from];\n    // is account given\n  } else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n    wallet = from;\n    // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n  return wallet;\n};\nMethod.prototype.buildCall = function () {\n  var method = this,\n    isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction',\n    // || method.call === 'personal_sendTransaction'\n    isCall = method.call === 'eth_call';\n  // actual send function\n  var send = function send() {\n    let args = Array.prototype.slice.call(arguments);\n    var defer = promiEvent(!isSendTx),\n      payload = method.toPayload(args);\n    method.hexFormat = false;\n    if (method.call === 'eth_getTransactionReceipt' || method.call === 'eth_getTransactionByHash' || method.name === 'getBlock') {\n      method.hexFormat = payload.params.length < args.length && args[args.length - 1] === 'hex';\n    }\n    // CALLBACK function\n    var sendTxCallback = function sendTxCallback(err, result) {\n      if (method.handleRevert && isCall && method.abiCoder) {\n        var reasonData;\n        // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n        // Geth >= 1.9.15 attaches the reason data to an error object.\n        // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n        if (!err && method.isRevertReasonString(result)) {\n          reasonData = result.substring(10);\n        } else if (err && err.data) {\n          // workaround embedded error details got from some providers like MetaMask\n          if (typeof err.data === 'object') {\n            var _err$data$originalErr;\n            // Ganache has no `originalError` sub-object unlike others\n            var originalError = (_err$data$originalErr = err.data.originalError) !== null && _err$data$originalErr !== void 0 ? _err$data$originalErr : err.data;\n            reasonData = originalError.data.substring(10);\n          } else {\n            reasonData = err.data.substring(10);\n          }\n        }\n        if (reasonData) {\n          var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n          var signature = 'Error(String)';\n          utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n            reason: reason,\n            signature: signature\n          });\n          return;\n        }\n      }\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n      if (result instanceof Error) {\n        err = result;\n      }\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      }\n      // return PROMISE\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        }\n        // return PROMIEVENT\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n        method._confirmTransaction(defer, result, payload);\n      }\n    };\n    // SENDS the SIGNED SIGNATURE\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _objectSpread(_objectSpread({}, payload), {}, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet;\n        // ETH_SENDTRANSACTION\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(!!tx && typeof tx === 'object' ? tx.from : null, method.accounts);\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var tx = JSON.parse(JSON.stringify(tx));\n            delete tx.from;\n            if (method.defaultChain && !tx.chain) {\n              tx.chain = method.defaultChain;\n            }\n            if (method.defaultHardfork && !tx.hardfork) {\n              tx.hardfork = method.defaultHardfork;\n            }\n            if (method.defaultCommon && !tx.common) {\n              tx.common = method.defaultCommon;\n            }\n            method.accounts.signTransaction(tx, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                try {\n                  defer.eventEmitter.emit('error', err);\n                } catch (err) {\n                  // Ignore userland error prevent it to bubble up within web3.\n                }\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n              defer.reject(err);\n            });\n            return;\n          }\n          // ETH_SIGN\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts);\n          // If wallet was found, sign tx, and send using sendRawTransaction\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n      return method.requestManager.send(payload, sendTxCallback);\n    };\n    const hasSendTxObject = isSendTx && !!payload.params[0] && typeof payload.params[0] === 'object';\n    if (hasSendTxObject && payload.params[0].type === '0x1' && typeof payload.params[0].accessList === 'undefined') {\n      payload.params[0].accessList = [];\n    }\n    // Send the actual transaction\n    if (hasSendTxObject && typeof payload.params[0].gasPrice === 'undefined' && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined' || typeof payload.params[0].maxFeePerGas === 'undefined')) {\n      _handleTxPricing(method, payload.params[0]).then(txPricing => {\n        if (txPricing.gasPrice !== undefined) {\n          payload.params[0].gasPrice = txPricing.gasPrice;\n        } else if (txPricing.maxPriorityFeePerGas !== undefined && txPricing.maxFeePerGas !== undefined) {\n          payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n          payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n        }\n        if (isSendTx) {\n          setTimeout(() => {\n            defer.eventEmitter.emit('sending', payload);\n          }, 0);\n        }\n        sendRequest(payload, method);\n      });\n    } else {\n      if (isSendTx) {\n        setTimeout(() => {\n          defer.eventEmitter.emit('sending', payload);\n        }, 0);\n      }\n      sendRequest(payload, method);\n    }\n    if (isSendTx) {\n      setTimeout(() => {\n        defer.eventEmitter.emit('sent', payload);\n      }, 0);\n    }\n    return defer.eventEmitter;\n  };\n  // necessary to attach things to the method\n  send.method = method;\n  // necessary for batch requests\n  send.request = this.request.bind(this);\n  return send;\n};\nfunction _handleTxPricing(method, tx) {\n  return new Promise((resolve, reject) => {\n    try {\n      var getBlockByNumber = new Method({\n        name: 'getBlockByNumber',\n        call: 'eth_getBlockByNumber',\n        params: 2,\n        inputFormatter: [function (blockNumber) {\n          return blockNumber ? utils.toHex(blockNumber) : 'latest';\n        }, function () {\n          return false;\n        }]\n      }).createFunction(method.requestManager);\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      Promise.all([getBlockByNumber(), getGasPrice()]).then(responses => {\n        const [block, gasPrice] = responses;\n        if ((tx.type === '0x2' || tx.type === undefined) && block && block.baseFeePerGas) {\n          // The network supports EIP-1559\n          // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n          let maxPriorityFeePerGas, maxFeePerGas;\n          if (tx.gasPrice) {\n            // Using legacy gasPrice property on an eip-1559 network,\n            // so use gasPrice as both fee properties\n            maxPriorityFeePerGas = tx.gasPrice;\n            maxFeePerGas = tx.gasPrice;\n            delete tx.gasPrice;\n          } else {\n            maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n            maxFeePerGas = tx.maxFeePerGas || utils.toHex(utils.toBN(block.baseFeePerGas).mul(utils.toBN(2)).add(utils.toBN(maxPriorityFeePerGas)));\n          }\n          resolve({\n            maxFeePerGas,\n            maxPriorityFeePerGas\n          });\n        } else {\n          if (tx.maxPriorityFeePerGas || tx.maxFeePerGas) throw Error(\"Network doesn't support eip-1559\");\n          resolve({\n            gasPrice\n          });\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    new Method({\n      name: 'call',\n      call: 'eth_call',\n      params: 2,\n      abiCoder: self.abiCoder,\n      handleRevert: true\n    }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function () {\n      resolve(false);\n    }).catch(function (error) {\n      if (error.reason) {\n        resolve({\n          reason: error.reason,\n          signature: error.signature\n        });\n      } else {\n        reject(error);\n      }\n    });\n  });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n  return typeof data === 'string' && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\nmodule.exports = Method;","map":{"version":3,"names":["_objectSpread","require","default","_asyncToGenerator","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","EthersTransactionUtils","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","abiCoder","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","transactionPollingInterval","blockHeaderTimeout","defaultCommon","defaultChain","defaultHardfork","handleRevert","prototype","setRequestManager","createFunction","func","buildCall","Object","defineProperty","configurable","writable","value","attachToObject","obj","split","length","getCall","args","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","Array","isArray","res","hexFormat","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","blockHeaderTimeoutId","lastBlock","receiptJSON","gasProvided","gas","isContractDeployment","data","from","to","hasBytecode","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","outputTransactionFormatter","type","subscriptionName","_ethereumCall","forEach","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","clearTimeout","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","_ref","receipt","blockHash","receiptFormatter","listeners","block","undefined","latestBlock","getBlockByNumber","latestBlockHash","hash","number","emit","blockNumber","removeAllListeners","_x","apply","arguments","_ref2","contractAddress","NoContractAddressFoundError","code","getCode","deploymentSuccess","status","contractDeployFormatter","ContractCodeNotStoredError","_x2","_ref3","outOfGas","gasUsed","JSON","stringify","revertMessage","txReplayOptions","rawTransactionHex","parsedTx","parse","inputTransactionFormatter","gasLimit","toHexString","gasPrice","getRevertReason","TransactionRevertInstructionError","reason","signature","error","TransactionRevertedWithoutReasonError","TransactionOutOfGasError","_x3","TransactionError","startWatching","blockHeaderArrived","startInterval","setInterval","bind","provider","on","subscribe","setTimeout","getWallet","wallet","address","privateKey","toLowerCase","isSendTx","isCall","send","slice","sendTxCallback","reasonData","isRevertReasonString","substring","_err$data$originalErr","originalError","decodeParameter","RevertInstructionError","e","sendSignedTx","sign","signedPayload","rawTransaction","sendRequest","tx","chain","hardfork","common","signTransaction","hasSendTxObject","accessList","maxPriorityFeePerGas","maxFeePerGas","_handleTxPricing","txPricing","request","Promise","toHex","getGasPrice","all","responses","baseFeePerGas","toBN","mul","add","txOptions","self","numberToHex","format","module","exports"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/web3-core-method/lib/index.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n'use strict';\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\nvar EthersTransactionUtils = require('@ethersproject/transactions');\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n    this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    Object.defineProperty(func, 'call', { configurable: true, writable: true, value: this.call });\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    Object.defineProperty(func, 'call', { configurable: true, writable: true, value: this.call });\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (typeof (args[args.length - 1]) === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n    if (Array.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res, this?.hexFormat) : res;\n        });\n    }\n    else {\n        return this.outputFormatter && result ? this.outputFormatter(result, this?.hexFormat) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = '', gasProvided = ((!!payload.params[0] && typeof payload.params[0] === 'object') && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = (!!payload.params[0] && typeof payload.params[0] === 'object') &&\n        payload.params[0].data &&\n        payload.params[0].from &&\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                    return !!val;\n                }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _ethereumCalls.forEach(mthd => {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                        clearTimeout(blockHeaderTimeoutId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n                // catch error from requesting receipt\n                .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: 'Failed to check for transaction receipt:',\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) { // Check if actually a new block is existing on polling\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            }\n                            else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n                        else {\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if ((isPolling && block) || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    }\n                    catch (err) {\n                        // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        }\n                        else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert &&\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === 'eth_sendRawTransaction') {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice ? parsedTx.gasPrice.toHexString() : undefined,\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    }\n                                    else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                }\n                                else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            }\n                            catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        }\n                        else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n                else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        }\n        else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        let blockHeaderArrived = false;\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n        };\n        // If provider do not support event subscription use polling\n        if (!this.requestManager.provider.on) {\n            return startInterval();\n        }\n        // Subscribe to new block headers to look for tx receipt\n        _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n            blockHeaderArrived = true;\n            if (err || !blockHeader) {\n                // fall back to polling\n                return startInterval();\n            }\n            checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        });\n        // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n        blockHeaderTimeoutId = setTimeout(() => {\n            if (!blockHeaderArrived) {\n                startInterval();\n            }\n        }, this.blockHeaderTimeout * 1000);\n    }.bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        }\n        else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n        .catch(function () {\n        if (!promiseResolved)\n            startWatching();\n    });\n};\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n    // is index given\n    if (typeof from === 'number') {\n        wallet = accounts.wallet[from];\n        // is account given\n    }\n    else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n        wallet = from;\n        // search in wallet for address\n    }\n    else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function () {\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n    isCall = (method.call === 'eth_call');\n    // actual send function\n    var send = function () {\n        let args = Array.prototype.slice.call(arguments);\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(args);\n        method.hexFormat = false;\n        if (method.call === 'eth_getTransactionReceipt'\n            || method.call === 'eth_getTransactionByHash'\n            || method.name === 'getBlock') {\n            method.hexFormat = (payload.params.length < args.length && args[args.length - 1] === 'hex');\n        }\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                }\n                else if (err && err.data) {\n                    // workaround embedded error details got from some providers like MetaMask\n                    if (typeof err.data === 'object') {\n                        // Ganache has no `originalError` sub-object unlike others\n                        var originalError = err.data.originalError ?? err.data;\n                        reasonData = originalError.data.substring(10);\n                    }\n                    else {\n                        reasonData = err.data.substring(10);\n                    }\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            }\n            catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            }\n            else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n                // return PROMIEVENT\n            }\n            else {\n                defer.eventEmitter.emit('transactionHash', result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n            var signedPayload = { ...payload,\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            };\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function (payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((!!tx && typeof tx === 'object') ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var tx = JSON.parse(JSON.stringify(tx));\n                        delete tx.from;\n                        if (method.defaultChain && !tx.chain) {\n                            tx.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !tx.hardfork) {\n                            tx.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !tx.common) {\n                            tx.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(tx, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                            if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                                try {\n                                    defer.eventEmitter.emit('error', err);\n                                }\n                                catch (err) {\n                                    // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function () {\n                                });\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                    // ETH_SIGN\n                }\n                else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        const hasSendTxObject = isSendTx\n            && !!payload.params[0]\n            && typeof payload.params[0] === 'object';\n        if (hasSendTxObject &&\n            payload.params[0].type === '0x1'\n            && typeof payload.params[0].accessList === 'undefined') {\n            payload.params[0].accessList = [];\n        }\n        // Send the actual transaction\n        if (hasSendTxObject\n            && (typeof payload.params[0].gasPrice === 'undefined'\n                && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined'\n                    || typeof payload.params[0].maxFeePerGas === 'undefined'))) {\n            _handleTxPricing(method, payload.params[0]).then(txPricing => {\n                if (txPricing.gasPrice !== undefined) {\n                    payload.params[0].gasPrice = txPricing.gasPrice;\n                }\n                else if (txPricing.maxPriorityFeePerGas !== undefined\n                    && txPricing.maxFeePerGas !== undefined) {\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n                }\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        }\n        else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\nfunction _handleTxPricing(method, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            var getBlockByNumber = (new Method({\n                name: 'getBlockByNumber',\n                call: 'eth_getBlockByNumber',\n                params: 2,\n                inputFormatter: [function (blockNumber) {\n                        return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                    }, function () {\n                        return false;\n                    }]\n            })).createFunction(method.requestManager);\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n            Promise.all([\n                getBlockByNumber(),\n                getGasPrice()\n            ]).then(responses => {\n                const [block, gasPrice] = responses;\n                if ((tx.type === '0x2' || tx.type === undefined) &&\n                    (block && block.baseFeePerGas)) {\n                    // The network supports EIP-1559\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                    let maxPriorityFeePerGas, maxFeePerGas;\n                    if (tx.gasPrice) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        maxPriorityFeePerGas = tx.gasPrice;\n                        maxFeePerGas = tx.gasPrice;\n                        delete tx.gasPrice;\n                    }\n                    else {\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                        maxFeePerGas = tx.maxFeePerGas ||\n                            utils.toHex(utils.toBN(block.baseFeePerGas)\n                                .mul(utils.toBN(2))\n                                .add(utils.toBN(maxPriorityFeePerGas)));\n                    }\n                    resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                }\n                else {\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                        throw Error(\"Network doesn't support eip-1559\");\n                    resolve({ gasPrice });\n                }\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n            resolve(false);\n        })\n            .catch(function (error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            }\n            else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return typeof data === 'string' && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}