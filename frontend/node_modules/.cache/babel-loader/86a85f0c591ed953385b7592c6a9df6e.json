{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\n// @ts-nocheck\n\nimport { JSBI, Percent, TokenAmount } from '@ubeswap/sdk';\nimport { useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useTokenBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nexport function useBurnState() {\n  _s();\n  return useSelector(state => state.burn);\n}\n_s(useBurnState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\nexport function useDerivedBurnInfo(currencyA, currencyB) {\n  _s2();\n  var _account, _pair$liquidityToken$, _pair$liquidityToken;\n  const {\n    independentField,\n    typedValue\n  } = useBurnState();\n\n  // pair + totalsupply\n  const [, pair] = usePair(currencyA, currencyB);\n\n  // balances\n  const relevantTokenBalances = useTokenBalances((_account = account) !== null && _account !== void 0 ? _account : undefined, [pair === null || pair === void 0 ? void 0 : pair.liquidityToken]);\n  const userLiquidity = relevantTokenBalances === null || relevantTokenBalances === void 0 ? void 0 : relevantTokenBalances[(_pair$liquidityToken$ = pair === null || pair === void 0 ? void 0 : (_pair$liquidityToken = pair.liquidityToken) === null || _pair$liquidityToken === void 0 ? void 0 : _pair$liquidityToken.address) !== null && _pair$liquidityToken$ !== void 0 ? _pair$liquidityToken$ : ''];\n  const [tokenA, tokenB] = [currencyA, currencyB];\n  const tokens = {\n    [Field.CURRENCY_A]: tokenA,\n    [Field.CURRENCY_B]: tokenB,\n    [Field.LIQUIDITY]: pair === null || pair === void 0 ? void 0 : pair.liquidityToken\n  };\n\n  // liquidity values\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const liquidityValueA = pair && totalSupply && userLiquidity && tokenA &&\n  // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalSupply.raw, userLiquidity.raw) ? new TokenAmount(tokenA, pair.getLiquidityValue(tokenA, totalSupply, userLiquidity, false).raw) : undefined;\n  const liquidityValueB = pair && totalSupply && userLiquidity && tokenB &&\n  // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n  JSBI.greaterThanOrEqual(totalSupply.raw, userLiquidity.raw) ? new TokenAmount(tokenB, pair.getLiquidityValue(tokenB, totalSupply, userLiquidity, false).raw) : undefined;\n  const liquidityValues = {\n    [Field.CURRENCY_A]: liquidityValueA,\n    [Field.CURRENCY_B]: liquidityValueB\n  };\n  let percentToRemove = new Percent('0', '100');\n  // user specified a %\n  if (independentField === Field.LIQUIDITY_PERCENT) {\n    percentToRemove = new Percent(typedValue, '100');\n  }\n  // user specified a specific amount of liquidity tokens\n  else if (independentField === Field.LIQUIDITY) {\n    if (pair !== null && pair !== void 0 && pair.liquidityToken) {\n      const independentAmount = tryParseAmount(typedValue, pair.liquidityToken);\n      if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {\n        percentToRemove = new Percent(independentAmount.raw, userLiquidity.raw);\n      }\n    }\n  }\n  // user specified a specific amount of token a or b\n  else {\n    if (tokens[independentField]) {\n      const independentAmount = tryParseAmount(typedValue, tokens[independentField]);\n      const liquidityValue = liquidityValues[independentField];\n      if (independentAmount && liquidityValue && !independentAmount.greaterThan(liquidityValue)) {\n        percentToRemove = new Percent(independentAmount.raw, liquidityValue.raw);\n      }\n    }\n  }\n  const parsedAmounts = {\n    [Field.LIQUIDITY_PERCENT]: percentToRemove,\n    [Field.LIQUIDITY]: userLiquidity && percentToRemove && percentToRemove.greaterThan('0') ? new TokenAmount(userLiquidity.token, percentToRemove.multiply(userLiquidity.raw).quotient) : undefined,\n    [Field.CURRENCY_A]: tokenA && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueA ? new TokenAmount(tokenA, percentToRemove.multiply(liquidityValueA.raw).quotient) : undefined,\n    [Field.CURRENCY_B]: tokenB && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueB ? new TokenAmount(tokenB, percentToRemove.multiply(liquidityValueB.raw).quotient) : undefined\n  };\n  let error;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmounts[Field.LIQUIDITY] || !parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error;\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Enter an amount';\n  }\n  return {\n    pair,\n    parsedAmounts,\n    error\n  };\n}\n_s2(useDerivedBurnInfo, \"fX4ZVzVFCQoHY4Cs2IgmHaSP+Dc=\", false, function () {\n  return [useBurnState, usePair, useTokenBalances, useTotalSupply];\n});\nexport function useBurnActionHandlers() {\n  _s3();\n  const dispatch = useDispatch();\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  return {\n    onUserInput\n  };\n}\n_s3(useBurnActionHandlers, \"lEPT7YuAO+/A5u9H2YSu9Ik8G/0=\", false, function () {\n  return [useDispatch];\n});","map":{"version":3,"names":["JSBI","Percent","TokenAmount","useCallback","useDispatch","useSelector","usePair","useTotalSupply","tryParseAmount","useTokenBalances","Field","typeInput","useBurnState","_s","state","burn","useDerivedBurnInfo","currencyA","currencyB","_s2","_account","_pair$liquidityToken$","_pair$liquidityToken","independentField","typedValue","pair","relevantTokenBalances","account","undefined","liquidityToken","userLiquidity","address","tokenA","tokenB","tokens","CURRENCY_A","CURRENCY_B","LIQUIDITY","totalSupply","liquidityValueA","greaterThanOrEqual","raw","getLiquidityValue","liquidityValueB","liquidityValues","percentToRemove","LIQUIDITY_PERCENT","independentAmount","greaterThan","liquidityValue","parsedAmounts","token","multiply","quotient","error","_error","useBurnActionHandlers","_s3","dispatch","onUserInput","field"],"sources":["/app/src/state/burn/hooks.ts"],"sourcesContent":["// @ts-nocheck\nimport { useCelo } from '@celo/react-celo'\nimport { JSBI, Pair, Percent, Token, TokenAmount } from '@ubeswap/sdk'\nimport { useCallback } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { usePair } from '../../data/Reserves'\nimport { useTotalSupply } from '../../data/TotalSupply'\nimport { AppDispatch, AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useTokenBalances } from '../wallet/hooks'\nimport { Field, typeInput } from './actions'\n\nexport function useBurnState(): AppState['burn'] {\n  return useSelector<AppState, AppState['burn']>((state) => state.burn)\n}\n\nexport function useDerivedBurnInfo(\n  currencyA: Token | undefined,\n  currencyB: Token | undefined\n): {\n  pair?: Pair | null\n  parsedAmounts: {\n    [Field.LIQUIDITY_PERCENT]: Percent\n    [Field.LIQUIDITY]?: TokenAmount\n    [Field.CURRENCY_A]?: TokenAmount\n    [Field.CURRENCY_B]?: TokenAmount\n  }\n  error?: string\n} {\n  \n\n  const { independentField, typedValue } = useBurnState()\n\n  // pair + totalsupply\n  const [, pair] = usePair(currencyA, currencyB)\n\n  // balances\n  const relevantTokenBalances = useTokenBalances(account ?? undefined, [pair?.liquidityToken])\n  const userLiquidity: undefined | TokenAmount = relevantTokenBalances?.[pair?.liquidityToken?.address ?? '']\n\n  const [tokenA, tokenB] = [currencyA as Token, currencyB as Token]\n  const tokens = {\n    [Field.CURRENCY_A]: tokenA,\n    [Field.CURRENCY_B]: tokenB,\n    [Field.LIQUIDITY]: pair?.liquidityToken,\n  }\n\n  // liquidity values\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n  const liquidityValueA =\n    pair &&\n    totalSupply &&\n    userLiquidity &&\n    tokenA &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalSupply.raw, userLiquidity.raw)\n      ? new TokenAmount(tokenA, pair.getLiquidityValue(tokenA, totalSupply, userLiquidity, false).raw)\n      : undefined\n  const liquidityValueB =\n    pair &&\n    totalSupply &&\n    userLiquidity &&\n    tokenB &&\n    // this condition is a short-circuit in the case where useTokenBalance updates sooner than useTotalSupply\n    JSBI.greaterThanOrEqual(totalSupply.raw, userLiquidity.raw)\n      ? new TokenAmount(tokenB, pair.getLiquidityValue(tokenB, totalSupply, userLiquidity, false).raw)\n      : undefined\n  const liquidityValues: { [Field.CURRENCY_A]?: TokenAmount; [Field.CURRENCY_B]?: TokenAmount } = {\n    [Field.CURRENCY_A]: liquidityValueA,\n    [Field.CURRENCY_B]: liquidityValueB,\n  }\n\n  let percentToRemove: Percent = new Percent('0', '100')\n  // user specified a %\n  if (independentField === Field.LIQUIDITY_PERCENT) {\n    percentToRemove = new Percent(typedValue, '100')\n  }\n  // user specified a specific amount of liquidity tokens\n  else if (independentField === Field.LIQUIDITY) {\n    if (pair?.liquidityToken) {\n      const independentAmount = tryParseAmount(typedValue, pair.liquidityToken)\n      if (independentAmount && userLiquidity && !independentAmount.greaterThan(userLiquidity)) {\n        percentToRemove = new Percent(independentAmount.raw, userLiquidity.raw)\n      }\n    }\n  }\n  // user specified a specific amount of token a or b\n  else {\n    if (tokens[independentField]) {\n      const independentAmount = tryParseAmount(typedValue, tokens[independentField])\n      const liquidityValue = liquidityValues[independentField]\n      if (independentAmount && liquidityValue && !independentAmount.greaterThan(liquidityValue)) {\n        percentToRemove = new Percent(independentAmount.raw, liquidityValue.raw)\n      }\n    }\n  }\n\n  const parsedAmounts: {\n    [Field.LIQUIDITY_PERCENT]: Percent\n    [Field.LIQUIDITY]?: TokenAmount\n    [Field.CURRENCY_A]?: TokenAmount\n    [Field.CURRENCY_B]?: TokenAmount\n  } = {\n    [Field.LIQUIDITY_PERCENT]: percentToRemove,\n    [Field.LIQUIDITY]:\n      userLiquidity && percentToRemove && percentToRemove.greaterThan('0')\n        ? new TokenAmount(userLiquidity.token, percentToRemove.multiply(userLiquidity.raw).quotient)\n        : undefined,\n    [Field.CURRENCY_A]:\n      tokenA && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueA\n        ? new TokenAmount(tokenA, percentToRemove.multiply(liquidityValueA.raw).quotient)\n        : undefined,\n    [Field.CURRENCY_B]:\n      tokenB && percentToRemove && percentToRemove.greaterThan('0') && liquidityValueB\n        ? new TokenAmount(tokenB, percentToRemove.multiply(liquidityValueB.raw).quotient)\n        : undefined,\n  }\n\n  let error: string | undefined\n  if (!account) {\n    error = 'Connect Wallet'\n  }\n\n  if (!parsedAmounts[Field.LIQUIDITY] || !parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? 'Enter an amount'\n  }\n\n  return { pair, parsedAmounts, error }\n}\n\nexport function useBurnActionHandlers(): {\n  onUserInput: (field: Field, typedValue: string) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onUserInput,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}