{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;\nconst hash_1 = require(\"./hash\");\nconst TWO_POWER_32 = 2 ** 32;\n/**\n * An immutable binary merkle tree node\n */\nclass Node {\n  constructor(h0, h1, h2, h3, h4, h5, h6, h7) {\n    this.h0 = h0;\n    this.h1 = h1;\n    this.h2 = h2;\n    this.h3 = h3;\n    this.h4 = h4;\n    this.h5 = h5;\n    this.h6 = h6;\n    this.h7 = h7;\n  }\n  applyHash(root) {\n    this.h0 = root.h0;\n    this.h1 = root.h1;\n    this.h2 = root.h2;\n    this.h3 = root.h3;\n    this.h4 = root.h4;\n    this.h5 = root.h5;\n    this.h6 = root.h6;\n    this.h7 = root.h7;\n  }\n}\nexports.Node = Node;\n/**\n * An immutable binary merkle tree node that has a `left` and `right` child\n */\nclass BranchNode extends Node {\n  constructor(_left, _right) {\n    // First null value is to save an extra variable to check if a node has a root or not\n    super(null, 0, 0, 0, 0, 0, 0, 0);\n    this._left = _left;\n    this._right = _right;\n    if (!_left) {\n      throw new Error(\"Left node is undefined\");\n    }\n    if (!_right) {\n      throw new Error(\"Right node is undefined\");\n    }\n  }\n  get rootHashObject() {\n    if (this.h0 === null) {\n      super.applyHash(hash_1.hashTwoObjects(this.left.rootHashObject, this.right.rootHashObject));\n    }\n    return this;\n  }\n  get root() {\n    return hash_1.hashObjectToUint8Array(this.rootHashObject);\n  }\n  isLeaf() {\n    return false;\n  }\n  get left() {\n    return this._left;\n  }\n  get right() {\n    return this._right;\n  }\n}\nexports.BranchNode = BranchNode;\n/**\n * An immutable binary merkle tree node that has no children\n */\nclass LeafNode extends Node {\n  static fromRoot(root) {\n    return this.fromHashObject(hash_1.uint8ArrayToHashObject(root));\n  }\n  /**\n   * New LeafNode from existing HashObject.\n   */\n  static fromHashObject(ho) {\n    return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);\n  }\n  /**\n   * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.\n   */\n  static fromZero() {\n    return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n  /**\n   * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.\n   */\n  static fromUint32(uint32) {\n    return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);\n  }\n  /**\n   * Create a new LeafNode with the same internal values. The returned instance is safe to mutate\n   */\n  clone() {\n    return LeafNode.fromHashObject(this);\n  }\n  get rootHashObject() {\n    return this;\n  }\n  get root() {\n    return hash_1.hashObjectToUint8Array(this);\n  }\n  isLeaf() {\n    return true;\n  }\n  get left() {\n    throw Error(\"LeafNode has no left node\");\n  }\n  get right() {\n    throw Error(\"LeafNode has no right node\");\n  }\n  writeToBytes(data, start, size) {\n    // TODO: Optimize\n    data.set(this.root.slice(0, size), start);\n  }\n  getUint(uintBytes, offsetBytes, clipInfinity) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      const h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        return 0xff & h >> bitIndex;\n      } else {\n        return 0xffff & h >> bitIndex;\n      }\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      return getNodeH(this, hIndex) >>> 0;\n    }\n    // number spans 2 h values\n    else if (uintBytes === 8) {\n      const low = getNodeH(this, hIndex);\n      const high = getNodeH(this, hIndex + 1);\n      if (high === 0) {\n        return low >>> 0;\n      } else if (high === -1 && low === -1 && clipInfinity) {\n        // Limit uint returns\n        return Infinity;\n      } else {\n        return (low >>> 0) + (high >>> 0) * TWO_POWER_32;\n      }\n    }\n    // Bigger uint can't be represented\n    else {\n      throw Error(\"uintBytes > 8\");\n    }\n  }\n  getUintBigint(uintBytes, offsetBytes) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      const h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        return BigInt(0xff & h >> bitIndex);\n      } else {\n        return BigInt(0xffff & h >> bitIndex);\n      }\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      return BigInt(getNodeH(this, hIndex) >>> 0);\n    }\n    // number spans multiple h values\n    else {\n      const hRange = Math.ceil(uintBytes / 4);\n      let v = BigInt(0);\n      for (let i = 0; i < hRange; i++) {\n        v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);\n      }\n      return v;\n    }\n  }\n  setUint(uintBytes, offsetBytes, value, clipInfinity) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      let h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        h &= ~(0xff << bitIndex);\n        h |= (0xff && value) << bitIndex;\n      } else {\n        h &= ~(0xffff << bitIndex);\n        h |= (0xffff && value) << bitIndex;\n      }\n      setNodeH(this, hIndex, h);\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      setNodeH(this, hIndex, value);\n    }\n    // number spans 2 h values\n    else if (uintBytes === 8) {\n      if (value === Infinity && clipInfinity) {\n        setNodeH(this, hIndex, -1);\n        setNodeH(this, hIndex + 1, -1);\n      } else {\n        setNodeH(this, hIndex, value & 0xffffffff);\n        setNodeH(this, hIndex + 1, value / TWO_POWER_32 & 0xffffffff);\n      }\n    }\n    // Bigger uint can't be represented\n    else {\n      throw Error(\"uintBytes > 8\");\n    }\n  }\n  setUintBigint(uintBytes, offsetBytes, valueBN) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const value = Number(valueBN);\n      const bitIndex = offsetBytes % 4 * 8;\n      let h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        h &= ~(0xff << bitIndex);\n        h |= (0xff && value) << bitIndex;\n      } else {\n        h &= ~(0xffff << bitIndex);\n        h |= (0xffff && value) << bitIndex;\n      }\n      setNodeH(this, hIndex, h);\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      setNodeH(this, hIndex, Number(valueBN));\n    }\n    // number spans multiple h values\n    else {\n      const hEnd = hIndex + Math.ceil(uintBytes / 4);\n      for (let i = hIndex; i < hEnd; i++) {\n        setNodeH(this, i, Number(valueBN & BigInt(0xffffffff)));\n        valueBN = valueBN >> BigInt(32);\n      }\n    }\n  }\n  bitwiseOrUint(uintBytes, offsetBytes, value) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      bitwiseOrNodeH(this, hIndex, value << bitIndex);\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      bitwiseOrNodeH(this, hIndex, value);\n    }\n    // number spans multiple h values\n    else {\n      const hEnd = hIndex + Math.ceil(uintBytes / 4);\n      for (let i = hIndex; i < hEnd; i++) {\n        bitwiseOrNodeH(this, i, value & 0xffffffff);\n        value >>= 32;\n      }\n    }\n  }\n}\nexports.LeafNode = LeafNode;\nfunction identity(n) {\n  return n;\n}\nexports.identity = identity;\nfunction compose(inner, outer) {\n  return function (n) {\n    return outer(inner(n));\n  };\n}\nexports.compose = compose;\nfunction getNodeH(node, hIndex) {\n  if (hIndex === 0) return node.h0;else if (hIndex === 1) return node.h1;else if (hIndex === 2) return node.h2;else if (hIndex === 3) return node.h3;else if (hIndex === 4) return node.h4;else if (hIndex === 5) return node.h5;else if (hIndex === 6) return node.h6;else if (hIndex === 7) return node.h7;else throw Error(\"hIndex > 7\");\n}\nexports.getNodeH = getNodeH;\nfunction setNodeH(node, hIndex, value) {\n  if (hIndex === 0) node.h0 = value;else if (hIndex === 1) node.h1 = value;else if (hIndex === 2) node.h2 = value;else if (hIndex === 3) node.h3 = value;else if (hIndex === 4) node.h4 = value;else if (hIndex === 5) node.h5 = value;else if (hIndex === 6) node.h6 = value;else if (hIndex === 7) node.h7 = value;else throw Error(\"hIndex > 7\");\n}\nexports.setNodeH = setNodeH;\nfunction bitwiseOrNodeH(node, hIndex, value) {\n  if (hIndex === 0) node.h0 |= value;else if (hIndex === 1) node.h1 |= value;else if (hIndex === 2) node.h2 |= value;else if (hIndex === 3) node.h3 |= value;else if (hIndex === 4) node.h4 |= value;else if (hIndex === 5) node.h5 |= value;else if (hIndex === 6) node.h6 |= value;else if (hIndex === 7) node.h7 |= value;else throw Error(\"hIndex > 7\");\n}\nexports.bitwiseOrNodeH = bitwiseOrNodeH;","map":null,"metadata":{},"sourceType":"script"}