{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{ChainId,useCelo,useProvider}from'@celo/react-celo';import{BigNumber}from'@ethersproject/bignumber';import{ChainId as UbeswapChainId,JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{POOL_MANAGER}from'constants/poolManager';import{UBE}from'constants/tokens';import{MoolaStakingRewards__factory}from'generated/';import{useAllTokens}from'hooks/Tokens';import useCurrentBlockTimestamp from'hooks/useCurrentBlockTimestamp';import zip from'lodash/zip';// Hooks\nimport React,{useEffect,useMemo}from'react';import ERC_20_INTERFACE from'../../constants/abis/erc20';import{STAKING_REWARDS_INTERFACE}from'../../constants/abis/staking-rewards';// Interfaces\nimport{UNISWAP_V2_PAIR_INTERFACE}from'../../constants/abis/uniswap-v2-pair';import{usePoolManagerContract,useTokenContract}from'../../hooks/useContract';import{useFarmRegistry}from'../../pages/Earn/useFarmRegistry';import{NEVER_RELOAD,useMultipleContractSingleData,useSingleCallResult,useSingleContractMultipleData}from'../multicall/hooks';import{tryParseAmount}from'../swap/hooks';import{useMultiStakeRewards}from'./useDualStakeRewards';import useStakingInfo from'./useStakingInfo';export const STAKING_GENESIS=1619100000;const ACTIVE_CONTRACT_UPDATED_THRESHOLD=5259492;const UNPREDICTABLE_GAS_LIMIT_ERROR_CODE='UNPREDICTABLE_GAS_LIMIT';export const useMultiRewardPools=()=>{const library=useProvider();const farmSummaries=useFarmRegistry();const[multiRewardPools,setMultiRewardPools]=React.useState([]);const call=React.useCallback(/*#__PURE__*/_asyncToGenerator(function*(){const multiRwdPools=[];yield Promise.all(farmSummaries.map(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(function*(fs){let poolContract=MoolaStakingRewards__factory.connect(fs.stakingAddress,library);const rewardsTokens=[];const externalStakingRwdAddresses=[];// the first reward token at the top level\nrewardsTokens.push(yield poolContract.rewardsToken());// last time the contract was updated - set isActive to false if it has been longer than 2 months\nlet periodFinish=yield poolContract.periodFinish();let isActive=Math.floor(Date.now()/1000)-periodFinish.toNumber()<ACTIVE_CONTRACT_UPDATED_THRESHOLD;let baseContractFound=false;// recursivley find underlying and base pool contracts\nwhile(!baseContractFound){try{// find the underlying contract if one exists\nconst externalStakingRewardAddr=yield poolContract.externalStakingRewards();externalStakingRwdAddresses.push(externalStakingRewardAddr);// capture the contract's reward token\npoolContract=MoolaStakingRewards__factory.connect(externalStakingRewardAddr,library);rewardsTokens.push(yield poolContract.rewardsToken());// determine if the underlying contract is active or not\nperiodFinish=yield poolContract.periodFinish();isActive=Math.floor(Date.now()/1000)-periodFinish.toNumber()<ACTIVE_CONTRACT_UPDATED_THRESHOLD||isActive;}catch(e){//if the error is not what is expected - log it\nif(e.code!==UNPREDICTABLE_GAS_LIMIT_ERROR_CODE){console.log(e);}//set true when externalStakingRewards() throws an error\nbaseContractFound=true;}}if(externalStakingRwdAddresses.length){multiRwdPools.push({address:fs.stakingAddress,underlyingPool:externalStakingRwdAddresses[0],basePool:externalStakingRwdAddresses[externalStakingRwdAddresses.length-1],numRewards:rewardsTokens.length,active:isActive});}});return function(_x){return _ref2.apply(this,arguments);};}()));setMultiRewardPools(multiRwdPools);}),[farmSummaries,library]);useEffect(()=>{call();},[call]);return multiRewardPools;};export const usePairMultiStakingInfo=(stakingInfo,stakingAddress)=>{var _multiRewardPool$acti,_multiRewardPool$acti2;const multiRewardPools=useMultiRewardPools();const multiRewardPool=useMemo(()=>{return multiRewardPools.filter(x=>x.address.toLowerCase()===stakingAddress.toLowerCase()).find(x=>x.basePool.toLowerCase()===(stakingInfo===null||stakingInfo===void 0?void 0:stakingInfo.poolInfo.poolAddress.toLowerCase()));},[multiRewardPools,stakingAddress,stakingInfo===null||stakingInfo===void 0?void 0:stakingInfo.poolInfo.poolAddress]);const isTriple=(multiRewardPool===null||multiRewardPool===void 0?void 0:multiRewardPool.numRewards)===3;const dualPool=useMultiStakeRewards(isTriple?multiRewardPool===null||multiRewardPool===void 0?void 0:multiRewardPool.underlyingPool:multiRewardPool===null||multiRewardPool===void 0?void 0:multiRewardPool.address,stakingInfo,2,isTriple?true:(_multiRewardPool$acti=multiRewardPool===null||multiRewardPool===void 0?void 0:multiRewardPool.active)!==null&&_multiRewardPool$acti!==void 0?_multiRewardPool$acti:false);const triplePool=useMultiStakeRewards(isTriple?multiRewardPool===null||multiRewardPool===void 0?void 0:multiRewardPool.address:undefined,dualPool,3,(_multiRewardPool$acti2=multiRewardPool===null||multiRewardPool===void 0?void 0:multiRewardPool.active)!==null&&_multiRewardPool$acti2!==void 0?_multiRewardPool$acti2:false);return triplePool||dualPool;};export const useUnclaimedStakingRewards=()=>{var _useSingleCallResult$,_poolsCountBigNumber$,_balances$reduce,_rewardRates$;const{network}=useCelo();const{chainId}=network;const ube=chainId?UBE[chainId]:undefined;const ubeContract=useTokenContract(ube===null||ube===void 0?void 0:ube.address);const poolManagerContract=usePoolManagerContract([ChainId.Mainnet,ChainId.Alfajores].includes(chainId)?POOL_MANAGER[chainId]:undefined);const poolsCountBigNumber=(_useSingleCallResult$=useSingleCallResult(poolManagerContract,'poolsCount').result)===null||_useSingleCallResult$===void 0?void 0:_useSingleCallResult$[0];const poolsCount=(_poolsCountBigNumber$=poolsCountBigNumber===null||poolsCountBigNumber===void 0?void 0:poolsCountBigNumber.toNumber())!==null&&_poolsCountBigNumber$!==void 0?_poolsCountBigNumber$:0;const poolAddresses=useStakingPoolAddresses(poolManagerContract,poolsCount);// compute amount that is locked up\nconst balancesRaw=useSingleContractMultipleData(ubeContract,'balanceOf',poolAddresses.map(addr=>[addr]));const balances=balancesRaw.find(b=>!b.result)?null:balancesRaw.map(b=>{var _b$result$,_b$result;return(_b$result$=(_b$result=b.result)===null||_b$result===void 0?void 0:_b$result[0])!==null&&_b$result$!==void 0?_b$result$:BigNumber.from(0);});const balanceRemaining=(_balances$reduce=balances===null||balances===void 0?void 0:balances.reduce((sum,b)=>b.add(sum),BigNumber.from(0)))!==null&&_balances$reduce!==void 0?_balances$reduce:null;// tokens per second, constants\nconst rewardRates=useMultipleContractSingleData(poolAddresses,STAKING_REWARDS_INTERFACE,'rewardRate',undefined,NEVER_RELOAD);const periodFinishes=useMultipleContractSingleData(poolAddresses,STAKING_REWARDS_INTERFACE,'periodFinish',undefined,NEVER_RELOAD);const now=useCurrentBlockTimestamp();const amounts=now?zip(rewardRates,periodFinishes).map(_ref3=>{var _rate$result,_finish$result;let[rate,finish]=_ref3;const rawRate=rate===null||rate===void 0?void 0:(_rate$result=rate.result)===null||_rate$result===void 0?void 0:_rate$result[0];const finishTime=finish===null||finish===void 0?void 0:(_finish$result=finish.result)===null||_finish$result===void 0?void 0:_finish$result[0];if(rawRate&&finishTime&&finishTime.gt(now)){return rawRate.mul(finishTime.sub(now).toNumber());}return BigNumber.from(0);}):undefined;const earned=rewardRates!==null&&rewardRates!==void 0&&(_rewardRates$=rewardRates[0])!==null&&_rewardRates$!==void 0&&_rewardRates$.loading||!amounts?null:amounts.reduce((sum,amt)=>sum.add(amt),BigNumber.from(0));return{balanceRemaining,earned,noncirculatingSupply:balanceRemaining&&earned?balanceRemaining.sub(earned):null};};export function useStakingPools(pairToFilterBy,stakingAddress){var _useSingleCallResult$2,_poolsCountBigNumber$2;const{network}=useCelo();const chainId=network.chainId;const ube=chainId?UBE[chainId]:undefined;const poolManagerContract=usePoolManagerContract(chainId!==UbeswapChainId.BAKLAVA?POOL_MANAGER[chainId]:undefined);const poolsCountBigNumber=(_useSingleCallResult$2=useSingleCallResult(poolManagerContract,'poolsCount').result)===null||_useSingleCallResult$2===void 0?void 0:_useSingleCallResult$2[0];const poolsCount=(_poolsCountBigNumber$2=poolsCountBigNumber===null||poolsCountBigNumber===void 0?void 0:poolsCountBigNumber.toNumber())!==null&&_poolsCountBigNumber$2!==void 0?_poolsCountBigNumber$2:0;const poolAddresses=useStakingPoolAddresses(poolManagerContract,poolsCount);const pools=useStakingPoolsInfo(poolManagerContract,poolAddresses);const stakingTokens=pools.map(p=>p===null||p===void 0?void 0:p.stakingToken);const poolPairs=usePairDataFromAddresses(stakingTokens);return useMemo(()=>{var _pools$reduce$filter;if(!ube||!pools||!poolPairs)return[];return(_pools$reduce$filter=pools.reduce((memo,poolInfo,index)=>{return[...memo,{stakingRewardAddress:poolInfo.poolAddress,tokens:poolPairs[index],poolInfo}];},[]).filter(stakingRewardInfo=>{if(stakingAddress){return stakingAddress.toLowerCase()===stakingRewardInfo.stakingRewardAddress.toLowerCase();}if(pairToFilterBy===undefined){return true;}if(pairToFilterBy===null){return false;}return stakingRewardInfo.tokens&&pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0])&&pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]);}))!==null&&_pools$reduce$filter!==void 0?_pools$reduce$filter:[];},[ube,pools,poolPairs,pairToFilterBy,stakingAddress]);}export function useStakingPoolAddresses(poolManagerContract,poolsCount){// Get rewards pools addresses\nconst inputs=[...Array(poolsCount).keys()].map(i=>[i]);const poolAddresses=useSingleContractMultipleData(poolManagerContract,'poolsByIndex',inputs);return useMemo(()=>{return!poolAddresses.length||!poolAddresses[0]||poolAddresses[0].loading?[]:poolAddresses.map(p=>{var _p$result;return p===null||p===void 0?void 0:(_p$result=p.result)===null||_p$result===void 0?void 0:_p$result[0];}).filter(x=>!!x);},[poolAddresses]);}const EXTERNAL_POOLS=[{index:-1,poolAddress:'0x33F819986FE80A4f4A9032260A24770918511849',stakingToken:'0xF97E6168283e38FC42725082FC63b47B6cD16B18',rewardToken:'0x18414Ce6dAece0365f935F3e78A7C1993e77d8Cd',rewardTokenSymbol:'LAPIS',weight:0},{index:-1,poolAddress:'0xD409B7C4F67F5C845c53505b3d3B5aCD44e479AB',stakingToken:'0x573bcEBD09Ff805eD32df2cb1A968418DC74DCf7',rewardToken:'0x18414Ce6dAece0365f935F3e78A7C1993e77d8Cd',rewardTokenSymbol:'LAPIS',weight:0},{index:-1,poolAddress:'0x478b8D37eE976228d17704d95B5430Cd93a31b87',stakingToken:'0x12E42ccf14B283Ef0a36A791892D18BF75Da5c80',rewardToken:'0x94140c2eA9D208D8476cA4E3045254169791C59e',rewardTokenSymbol:'PREMIO',weight:0}];export function useStakingPoolsInfo(poolManagerContract,poolAddresses){const pools=useSingleContractMultipleData(poolManagerContract,'pools',poolAddresses.map(addr=>[addr]));const rawPools=useMemo(()=>{return!pools||!pools[0]||pools[0].loading?[]:pools.map(p=>p===null||p===void 0?void 0:p.result).filter(x=>!!x);},[pools]);const nextPeriod=useSingleCallResult(poolManagerContract,'nextPeriod');const poolRewards=useSingleContractMultipleData(poolManagerContract,'computeAmountForPool',rawPools.map(p=>{var _nextPeriod$result;return[p.stakingToken,nextPeriod===null||nextPeriod===void 0?void 0:(_nextPeriod$result=nextPeriod.result)===null||_nextPeriod$result===void 0?void 0:_nextPeriod$result[0]];}));return rawPools.concat(EXTERNAL_POOLS).map((pool,i)=>{var _poolRewards$i$result,_poolRewards$i,_poolRewards$i$result2;return _objectSpread(_objectSpread({},pool),{},{nextPeriodRewards:(_poolRewards$i$result=poolRewards===null||poolRewards===void 0?void 0:(_poolRewards$i=poolRewards[i])===null||_poolRewards$i===void 0?void 0:(_poolRewards$i$result2=_poolRewards$i.result)===null||_poolRewards$i$result2===void 0?void 0:_poolRewards$i$result2[0])!==null&&_poolRewards$i$result!==void 0?_poolRewards$i$result:null});});}export function usePairDataFromAddresses(pairAddresses){const{network}=useCelo();const chainId=network.chainId;const token0Data=useMultipleContractSingleData(pairAddresses,UNISWAP_V2_PAIR_INTERFACE,'token0',undefined,NEVER_RELOAD);const token1Data=useMultipleContractSingleData(pairAddresses,UNISWAP_V2_PAIR_INTERFACE,'token1',undefined,NEVER_RELOAD);const tokens0=token0Data.map(t=>{var _t$result;return t===null||t===void 0?void 0:(_t$result=t.result)===null||_t$result===void 0?void 0:_t$result[0];});const tokens1=token1Data.map(t=>{var _t$result2;return t===null||t===void 0?void 0:(_t$result2=t.result)===null||_t$result2===void 0?void 0:_t$result2[0];});const tokensDb=useAllTokens();// Construct a set of all the unique token addresses that are not in the tokenlists.\nconst tokenAddressesNeededToFetch=useMemo(()=>[...new Set([...tokens0,...tokens1])].filter(addr=>addr!==undefined&&!tokensDb[addr]),[tokensDb,tokens0,tokens1]);const names=useMultipleContractSingleData(tokenAddressesNeededToFetch,ERC_20_INTERFACE,'name',undefined,NEVER_RELOAD);const symbols=useMultipleContractSingleData(tokenAddressesNeededToFetch,ERC_20_INTERFACE,'symbol',undefined,NEVER_RELOAD);const tokenDecimals=useMultipleContractSingleData(tokenAddressesNeededToFetch,ERC_20_INTERFACE,'decimals',undefined,NEVER_RELOAD);// Construct the full token data\nconst tokensNeededToFetch=useMemo(()=>{if(!tokenAddressesNeededToFetch.length||!names.length||!symbols.length||!tokenDecimals.length)return null;if(names[0].loading||tokenDecimals[0].loading||symbols[0].loading)return null;if(!names[0].result||!tokenDecimals[0].result||!symbols[0].result)return null;return tokenAddressesNeededToFetch.reduce((memo,address,index)=>{var _tokenDecimals$index$,_names$index$result,_names$index$result2,_symbols$index$result,_symbols$index$result2;const decimals=(_tokenDecimals$index$=tokenDecimals[index].result)===null||_tokenDecimals$index$===void 0?void 0:_tokenDecimals$index$[0];const name=((_names$index$result=names[index].result)===null||_names$index$result===void 0?void 0:_names$index$result[0])==='Celo Gold'?'Celo':(_names$index$result2=names[index].result)===null||_names$index$result2===void 0?void 0:_names$index$result2[0];const symbol=((_symbols$index$result=symbols[index].result)===null||_symbols$index$result===void 0?void 0:_symbols$index$result[0])==='cGLD'?'CELO':(_symbols$index$result2=symbols[index].result)===null||_symbols$index$result2===void 0?void 0:_symbols$index$result2[0];// todo - remove hardcoded symbol swap for CELO\n// Sometimes, decimals/name/symbol can be undefined, causing an error. TODO: Look into a root cause\nif(chainId&&address&&decimals&&symbol&&name){const token=new Token(chainId,address,decimals,symbol,name);return[...memo,token];}return memo;},[]);},[chainId,tokenAddressesNeededToFetch,names,symbols,tokenDecimals]);const pairsData=useMemo(()=>{const tokens=tokensNeededToFetch!==null&&tokensNeededToFetch!==void 0?tokensNeededToFetch:[];return tokens0.reduce((pairs,token0Address,index)=>{var _tokensDb$token0Addre,_tokensDb$token1Addre;if(!token0Address){return[...pairs,undefined];}const token1Address=tokens1[index];if(!token1Address){return[...pairs,undefined];}const token0=(_tokensDb$token0Addre=tokensDb[token0Address])!==null&&_tokensDb$token0Addre!==void 0?_tokensDb$token0Addre:tokens.find(t=>t.address===token0Address);const token1=(_tokensDb$token1Addre=tokensDb[token1Address])!==null&&_tokensDb$token1Addre!==void 0?_tokensDb$token1Addre:tokens.find(t=>t.address===token1Address);if(!token0||!token1){return[...pairs,undefined];}return[...pairs,[token0,token1]];},[]);},[tokensNeededToFetch,tokens0,tokens1,tokensDb]);return pairsData;}export function useTotalUbeEarned(){const{network}=useCelo();const{chainId}=network;const ube=chainId?UBE[chainId]:undefined;const stakingInfos=useStakingInfo();return useMemo(()=>{var _stakingInfos$filter$;if(!ube)return undefined;return(_stakingInfos$filter$=stakingInfos===null||stakingInfos===void 0?void 0:stakingInfos.filter(stakingInfo=>stakingInfo.rewardTokens.includes(ube)).reduce((accumulator,stakingInfo)=>{var _stakingInfo$earnedAm,_stakingInfo$earnedAm2;return accumulator.add((_stakingInfo$earnedAm=(_stakingInfo$earnedAm2=stakingInfo.earnedAmounts)===null||_stakingInfo$earnedAm2===void 0?void 0:_stakingInfo$earnedAm2.find(earnedAmount=>earnedAmount.token==ube))!==null&&_stakingInfo$earnedAm!==void 0?_stakingInfo$earnedAm:new TokenAmount(ube,'0'));},new TokenAmount(ube,'0')))!==null&&_stakingInfos$filter$!==void 0?_stakingInfos$filter$:new TokenAmount(ube,'0');},[stakingInfos,ube]);}export function useFilteredStakingInfo(stakingAddresses){const{network}=useCelo();const{chainId}=network;const ube=chainId?UBE[chainId]:undefined;const stakingInfos=useStakingInfo();return useMemo(()=>{if(!ube)return;return stakingInfos.filter(stakingInfo=>stakingInfo.stakingToken.address&&stakingAddresses.includes(stakingInfo.stakingToken.address));},[stakingInfos,ube,stakingAddresses]);}export function useFarmRewardsInfo(stakingAddresses){const{network}=useCelo();const{chainId}=network;const ube=chainId?UBE[chainId]:undefined;const stakingInfos=useStakingInfo();return useMemo(()=>{if(!ube)return;return stakingInfos.filter(stakingInfo=>stakingInfo.stakingToken.address&&stakingAddresses.includes(stakingInfo.stakingToken.address));},[stakingInfos,ube,stakingAddresses]);}// based on typed value\nexport function useDerivedStakeInfo(typedValue,stakingToken,userLiquidityUnstaked){const{address}=useCelo();const parsedInput=tryParseAmount(typedValue,stakingToken!==null&&stakingToken!==void 0?stakingToken:undefined);const parsedAmount=parsedInput&&userLiquidityUnstaked&&JSBI.lessThanOrEqual(parsedInput.raw,userLiquidityUnstaked.raw)?parsedInput:undefined;let error;if(!address){error='Connect Wallet';}if(!parsedAmount){var _error;error=(_error=error)!==null&&_error!==void 0?_error:'Enter an amount';}return{parsedAmount,error};}// based on typed value\nexport function useDerivedUnstakeInfo(typedValue,stakingAmount){const{address}=useCelo();const parsedInput=tryParseAmount(typedValue,stakingAmount.token);const parsedAmount=parsedInput&&JSBI.lessThanOrEqual(parsedInput.raw,stakingAmount.raw)?parsedInput:undefined;let error;if(!address){error='Connect Wallet';}if(!parsedAmount){var _error2;error=(_error2=error)!==null&&_error2!==void 0?_error2:'Enter an amount';}return{parsedAmount,error};}","map":null,"metadata":{},"sourceType":"module"}