{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayBasicTreeViewDU = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayBasicTreeViewDU extends abstract_1.TreeViewDU {\n  constructor(type, _rootNode, cache) {\n    super();\n    this.type = type;\n    this._rootNode = _rootNode;\n    this.nodesChanged = new Set();\n    this.dirtyLength = false;\n    if (cache) {\n      this.nodes = cache.nodes;\n      this._length = cache.length;\n      this.nodesPopulated = cache.nodesPopulated;\n    } else {\n      this.nodes = [];\n      this._length = this.type.tree_getLength(_rootNode);\n      this.nodesPopulated = false;\n    }\n  }\n  /**\n   * Number of elements in the array. Equal to un-commited length of the array\n   */\n  get length() {\n    return this._length;\n  }\n  get node() {\n    return this._rootNode;\n  }\n  get cache() {\n    return {\n      nodes: this.nodes,\n      length: this._length,\n      nodesPopulated: this.nodesPopulated\n    };\n  }\n  /**\n   * Get element at `index`. Returns the Basic element type value directly\n   */\n  get(index) {\n    // First walk through the tree to get the root node for that index\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    let node = this.nodes[chunkIndex];\n    if (node === undefined) {\n      node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n      this.nodes[chunkIndex] = node;\n    }\n    return this.type.elementType.tree_getFromPackedNode(node, index);\n  }\n  /**\n   * Set Basic element type `value` at `index`\n   */\n  set(index, value) {\n    if (index >= this._length) {\n      throw Error(\"Error setting index over length \".concat(index, \" > \").concat(this._length));\n    }\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    // Create new node if current leafNode is not dirty\n    let nodeChanged;\n    if (this.nodesChanged.has(chunkIndex)) {\n      // TODO: This assumes that node has already been populated\n      nodeChanged = this.nodes[chunkIndex];\n    } else {\n      var _this$nodes$chunkInde;\n      const nodePrev = (_this$nodes$chunkInde = this.nodes[chunkIndex]) !== null && _this$nodes$chunkInde !== void 0 ? _this$nodes$chunkInde : persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n      nodeChanged = nodePrev.clone();\n      // Store the changed node in the nodes cache\n      this.nodes[chunkIndex] = nodeChanged;\n      this.nodesChanged.add(chunkIndex);\n    }\n    this.type.elementType.tree_setToPackedNode(nodeChanged, index, value);\n  }\n  /**\n   * Get all values of this array as Basic element type values, from index zero to `this.length - 1`\n   */\n  getAll() {\n    if (!this.nodesPopulated) {\n      const nodesPrev = this.nodes;\n      const chunksNode = this.type.tree_getChunksNode(this.node);\n      const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);\n      this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);\n      // Re-apply changed nodes\n      for (const index of this.nodesChanged) {\n        this.nodes[index] = nodesPrev[index];\n      }\n      this.nodesPopulated = true;\n    }\n    const values = new Array(this._length);\n    const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below\n    const lenFullNodes = Math.floor(this._length / itemsPerChunk);\n    const remainder = this._length % itemsPerChunk;\n    // TODO Optimize: caching the variables used in the loop above it\n    for (let n = 0; n < lenFullNodes; n++) {\n      const leafNode = this.nodes[n];\n      // TODO: Implement add a fast bulk packed element reader in the elementType\n      // ```\n      // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;\n      // ```\n      // if performance here is a problem\n      for (let i = 0; i < itemsPerChunk; i++) {\n        values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    if (remainder > 0) {\n      const leafNode = this.nodes[lenFullNodes];\n      for (let i = 0; i < remainder; i++) {\n        values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    return values;\n  }\n  commit() {\n    if (this.nodesChanged.size === 0) {\n      return;\n    }\n    // Numerical sort ascending\n    const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);\n    const nodes = new Array(indexes.length);\n    for (let i = 0; i < indexes.length; i++) {\n      nodes[i] = this.nodes[indexes[i]];\n    }\n    const chunksNode = this.type.tree_getChunksNode(this._rootNode);\n    // TODO: Ensure fast setNodesAtDepth() method is correct\n    const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);\n    this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : undefined);\n    this.nodesChanged.clear();\n    this.dirtyLength = false;\n  }\n  clearCache() {\n    this.nodes = [];\n    this.nodesPopulated = false;\n    // Must clear nodesChanged, otherwise a subsequent commit call will break, because it assumes a node is there\n    this.nodesChanged.clear();\n    // Reset cached length only if it has been mutated\n    if (this.dirtyLength) {\n      this._length = this.type.tree_getLength(this._rootNode);\n      this.dirtyLength = false;\n    }\n  }\n}\nexports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;","map":null,"metadata":{},"sourceType":"script"}