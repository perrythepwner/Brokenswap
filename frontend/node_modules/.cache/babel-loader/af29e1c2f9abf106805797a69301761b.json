{"ast":null,"code":"import _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"message\", \"explanation\"];\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n        message,\n        explanation\n      } = failure,\n      rest = _objectWithoutProperties(failure, _excluded);\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \".concat(path.join('.'), \" -- \").concat(message);\n    super(explanation !== null && explanation !== void 0 ? explanation : msg);\n    if (explanation != null) this.cause = msg;\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      var _cached;\n      return (_cached = cached) !== null && _cached !== void 0 ? _cached : cached = [failure, ...failures()];\n    };\n  }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n  if (typeof value === 'symbol') {\n    return value.toString();\n  }\n  return typeof value === 'string' ? JSON.stringify(value) : \"\".concat(value);\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\".concat(type, \"`\").concat(refinement ? \" with refinement `\".concat(refinement, \"`\") : '', \", but received: `\").concat(print(value), \"`\")\n  } = result;\n  return _objectSpread(_objectSpread({\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch\n  }, result), {}, {\n    message\n  });\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction run(value, struct) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function* () {\n    const {\n      path = [],\n      branch = [value],\n      coerce = false,\n      mask = false\n    } = options;\n    const ctx = {\n      path,\n      branch\n    };\n    if (coerce) {\n      value = struct.coercer(value, ctx);\n      if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n        for (const key in value) {\n          if (struct.schema[key] === undefined) {\n            delete value[key];\n          }\n        }\n      }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n      failure.explanation = options.message;\n      status = 'not_valid';\n      yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n      const ts = run(v, s, {\n        path: k === undefined ? path : [...path, k],\n        branch: k === undefined ? branch : [...branch, v],\n        coerce,\n        mask,\n        message: options.message\n      });\n      for (const t of ts) {\n        if (t[0]) {\n          status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n          yield [t[0], undefined];\n        } else if (coerce) {\n          v = t[1];\n          if (k === undefined) {\n            value = v;\n          } else if (value instanceof Map) {\n            value.set(k, v);\n          } else if (value instanceof Set) {\n            value.add(v);\n          } else if (isObject(value)) {\n            if (v !== undefined || k in value) value[k] = v;\n          }\n        }\n      }\n    }\n    if (status !== 'not_valid') {\n      for (const failure of struct.refiner(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_refined';\n        yield [failure, undefined];\n      }\n    }\n    if (status === 'valid') {\n      yield [undefined, value];\n    }\n  }();\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  assert(value, message) {\n    return assert(value, this, message);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n  create(value, message) {\n    return create(value, this, message);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n  mask(value, message) {\n    return mask(value, this, message);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n  validate(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return validate(value, this, options);\n  }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n  const result = validate(value, struct, {\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n  const result = validate(value, struct, {\n    coerce: true,\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true,\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n  const isType = Structs[0].type === 'type';\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  }));\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      var _struct;\n      (_struct = struct) !== null && _struct !== void 0 ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      var _struct2;\n      (_struct2 = struct) !== null && _struct2 !== void 0 ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      var _struct3;\n      (_struct3 = struct) !== null && _struct3 !== void 0 ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      var _struct4;\n      (_struct4 = struct) !== null && _struct4 !== void 0 ? _struct4 : struct = fn();\n      return struct.refiner(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = _objectSpread({}, schema);\n  for (const key of keys) {\n    delete subschema[key];\n  }\n  switch (struct.type) {\n    case 'type':\n      return type(subschema);\n    default:\n      return object(subschema);\n  }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? _objectSpread({}, struct.schema) : _objectSpread({}, struct);\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n  return define('bigint', value => {\n    return typeof value === 'bigint';\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \".concat(print(value));\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n  for (const key of values) {\n    schema[key] = key;\n  }\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\".concat(description, \"`, but received: \").concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \".concat(print(value));\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\".concat(Class.name, \"` instance, but received: \").concat(print(value));\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \".concat(print(value));\n  });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return value === constant || \"Expected the literal `\".concat(description, \"`, but received: \").concat(print(value));\n    }\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  }));\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \".concat(print(value));\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \".concat(print(value));\n    },\n    coercer(value) {\n      return isObject(value) ? _objectSpread({}, value) : value;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  }));\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \".concat(print(value));\n  });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \".concat(print(value));\n    },\n    coercer(value) {\n      return isObject(value) ? _objectSpread({}, value) : value;\n    }\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value) {\n      for (const S of Structs) {\n        const [error, coerced] = S.validate(value, {\n          coerce: true\n        });\n        if (!error) {\n          return coerced;\n        }\n      }\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n      return [\"Expected the value to satisfy a union of `\".concat(description, \"`, but received: \").concat(print(value)), ...failures];\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, _coercer) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  }));\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n    if (x === undefined) {\n      return f;\n    }\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = _objectSpread({}, x);\n      let changed = false;\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n      if (changed) {\n        return ret;\n      }\n    }\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n  return refine(struct, 'empty', value => {\n    const size = getSize(value);\n    return size === 0 || \"Expected an empty \".concat(struct.type, \" but received one with a size of `\").concat(size, \"`\");\n  });\n}\nfunction getSize(value) {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  } else {\n    return value.length;\n  }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \".concat(struct.type, \" less than \").concat(exclusive ? '' : 'or equal to ').concat(threshold, \" but received `\").concat(value, \"`\");\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \".concat(struct.type, \" greater than \").concat(exclusive ? '' : 'or equal to ').concat(threshold, \" but received `\").concat(value, \"`\");\n  });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n  return refine(struct, 'nonempty', value => {\n    const size = getSize(value);\n    return size > 0 || \"Expected a nonempty \".concat(struct.type, \" but received an empty one\");\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \".concat(struct.type, \" matching `/\").concat(regexp.source, \"/` but received \\\"\").concat(value, \"\\\"\");\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  const expected = \"Expected a \".concat(struct.type);\n  const of = min === max ? \"of `\".concat(min, \"`\") : \"between `\".concat(min, \"` and `\").concat(max, \"`\");\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || \"\".concat(expected, \" \").concat(of, \" but received `\").concat(value, \"`\");\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || \"\".concat(expected, \" with a size \").concat(of, \" but received one with a size of `\").concat(size, \"`\");\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || \"\".concat(expected, \" with a length \").concat(of, \" but received one with a length of `\").concat(length, \"`\");\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n  return new Struct(_objectSpread(_objectSpread({}, struct), {}, {\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n      for (const failure of failures) {\n        yield _objectSpread(_objectSpread({}, failure), {}, {\n          refinement: name\n        });\n      }\n    }\n  }));\n}\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };","map":{"version":3,"sources":["../src/error.ts","../src/utils.ts","../src/struct.ts","../src/structs/utilities.ts","../src/structs/types.ts","../src/structs/coercions.ts","../src/structs/refinements.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const schema = struct instanceof Struct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n"]},"metadata":{},"sourceType":"module"}