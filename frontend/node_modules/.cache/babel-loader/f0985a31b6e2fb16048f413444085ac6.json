{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useCelo } from '@celo/react-celo';\nimport { JSBI, Token, TokenAmount } from '@ubeswap/sdk';\nimport { STAKING_REWARDS_INTERFACE } from 'constants/abis/staking-rewards';\nimport { UBE } from 'constants/tokens';\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp';\nimport { useMemo } from 'react';\nimport { useMultipleContractSingleData } from 'state/multicall/hooks';\nimport { INT_SECONDS_IN_WEEK } from './../../constants/index';\nimport { useStakingPools } from './hooks';\n\n// Gets the staking info from the network for the active chain id\nexport default function useStakingInfo(pairToFilterBy, stakingAddress) {\n  _s();\n  const {\n    network,\n    address\n  } = useCelo();\n  const chainId = network.chainId;\n  const ube = chainId ? UBE[chainId] : undefined;\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp();\n  const info = useStakingPools(pairToFilterBy, stakingAddress);\n  // These are the staking pools\n  const rewardsAddresses = useMemo(() => info.map(_ref => {\n    let {\n      stakingRewardAddress\n    } = _ref;\n    return stakingRewardAddress;\n  }), [info]);\n  const accountArg = useMemo(() => [address !== null && address !== void 0 ? address : undefined], [address]);\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg);\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg);\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply');\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate');\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish');\n  return useMemo(() => {\n    if (!chainId || !ube) return [];\n    return info.reduce((memo, _ref2, index) => {\n      let {\n        stakingRewardAddress: rewardsAddress,\n        poolInfo,\n        tokens\n      } = _ref2;\n      // these two are dependent on account\n      const balanceState = balances[index];\n      const earnedAmountState = earnedAmounts[index];\n\n      // these get fetched regardless of account\n      const totalSupplyState = totalSupplies[index];\n      const rewardRateState = rewardRates[index];\n      const periodFinishState = periodFinishes[index];\n      if (\n      // these may be undefined if not logged in\n      !(balanceState !== null && balanceState !== void 0 && balanceState.loading) && !(earnedAmountState !== null && earnedAmountState !== void 0 && earnedAmountState.loading) &&\n      // always need these\n      totalSupplyState && !totalSupplyState.loading && rewardRateState && !rewardRateState.loading && periodFinishState && !periodFinishState.loading) {\n        var _balanceState$result$, _balanceState$result, _totalSupplyState$res, _poolInfo$nextPeriodR, _poolInfo$nextPeriodR2, _periodFinishState$re, _periodFinishState$re2, _rewardRateState$resu, _earnedAmountState$re, _earnedAmountState$re2;\n        if (balanceState !== null && balanceState !== void 0 && balanceState.error || earnedAmountState !== null && earnedAmountState !== void 0 && earnedAmountState.error || totalSupplyState.error || rewardRateState.error || periodFinishState.error) {\n          console.error('Failed to load staking rewards info');\n          return memo;\n        }\n        const rewardToken = poolInfo.rewardToken ? new Token(chainId, poolInfo.rewardToken, 18, poolInfo.rewardTokenSymbol) : ube;\n\n        // get the LP token\n        const liquidityToken = new Token(chainId, poolInfo.stakingToken, 18, 'ULP', 'Ubeswap LP Token');\n\n        // check for account, if no account set to 0\n        const stakedAmount = new TokenAmount(liquidityToken, JSBI.BigInt((_balanceState$result$ = balanceState === null || balanceState === void 0 ? void 0 : (_balanceState$result = balanceState.result) === null || _balanceState$result === void 0 ? void 0 : _balanceState$result[0]) !== null && _balanceState$result$ !== void 0 ? _balanceState$result$ : 0));\n        const totalStakedAmount = new TokenAmount(liquidityToken, JSBI.BigInt((_totalSupplyState$res = totalSupplyState.result) === null || _totalSupplyState$res === void 0 ? void 0 : _totalSupplyState$res[0]));\n        const nextPeriodRewards = new TokenAmount(ube, (_poolInfo$nextPeriodR = (_poolInfo$nextPeriodR2 = poolInfo.nextPeriodRewards) === null || _poolInfo$nextPeriodR2 === void 0 ? void 0 : _poolInfo$nextPeriodR2.toString()) !== null && _poolInfo$nextPeriodR !== void 0 ? _poolInfo$nextPeriodR : '0');\n        const getHypotheticalRewardRate = (stakedAmount, totalStakedAmount, totalRewardRates) => {\n          return [new TokenAmount(rewardToken, JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0)) ? JSBI.divide(JSBI.multiply(totalRewardRates[0].raw, stakedAmount.raw), totalStakedAmount.raw) : JSBI.BigInt(0))];\n        };\n        const periodFinishSeconds = (_periodFinishState$re = periodFinishState.result) === null || _periodFinishState$re === void 0 ? void 0 : (_periodFinishState$re2 = _periodFinishState$re[0]) === null || _periodFinishState$re2 === void 0 ? void 0 : _periodFinishState$re2.toNumber();\n        const periodFinishMs = periodFinishSeconds * 1000;\n        // compare period end timestamp vs current block timestamp (in seconds)\n        const active = periodFinishSeconds && currentBlockTimestamp ? periodFinishSeconds > currentBlockTimestamp.toNumber() : false;\n        const rewardsFinished = Math.floor(Date.now() / 1000) - periodFinishSeconds > INT_SECONDS_IN_WEEK;\n        const totalRewardRate = new TokenAmount(rewardToken, rewardsFinished ? JSBI.BigInt(0) : JSBI.BigInt((_rewardRateState$resu = rewardRateState.result) === null || _rewardRateState$resu === void 0 ? void 0 : _rewardRateState$resu[0]));\n        const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, [totalRewardRate]);\n        if (!tokens) {\n          return memo;\n        }\n        memo.push({\n          stakingRewardAddress: rewardsAddress,\n          stakingToken: totalStakedAmount.token,\n          tokens,\n          stakedAmount,\n          totalStakedAmount,\n          earnedAmounts: [new TokenAmount(rewardToken, JSBI.BigInt((_earnedAmountState$re = earnedAmountState === null || earnedAmountState === void 0 ? void 0 : (_earnedAmountState$re2 = earnedAmountState.result) === null || _earnedAmountState$re2 === void 0 ? void 0 : _earnedAmountState$re2[0]) !== null && _earnedAmountState$re !== void 0 ? _earnedAmountState$re : 0))],\n          rewardRates: individualRewardRate,\n          totalRewardRates: [totalRewardRate],\n          periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n          active,\n          getHypotheticalRewardRate,\n          nextPeriodRewards,\n          poolInfo,\n          rewardTokens: [rewardToken]\n        });\n      }\n      return memo;\n    }, []);\n  }, [balances, chainId, currentBlockTimestamp, earnedAmounts, info, periodFinishes, rewardRates, totalSupplies, ube]);\n}\n\n// `stakingAddress` is used to differentiate when there are two different farms with the same LP\n_s(useStakingInfo, \"n6WTiejiIgpajNZt3AacCHF7I3E=\", false, function () {\n  return [useCelo, useCurrentBlockTimestamp, useStakingPools, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData];\n});\nexport const usePairStakingInfo = (pairToFilterBy, stakingAddress) => {\n  _s2();\n  var _useStakingInfo$;\n  return (_useStakingInfo$ = useStakingInfo(pairToFilterBy, stakingAddress)[0]) !== null && _useStakingInfo$ !== void 0 ? _useStakingInfo$ : undefined;\n};\n_s2(usePairStakingInfo, \"/LIRiXg29NNEbOgUVvS30/pv3No=\", false, function () {\n  return [useStakingInfo];\n});","map":{"version":3,"names":["useCelo","JSBI","Token","TokenAmount","STAKING_REWARDS_INTERFACE","UBE","useCurrentBlockTimestamp","useMemo","useMultipleContractSingleData","INT_SECONDS_IN_WEEK","useStakingPools","useStakingInfo","pairToFilterBy","stakingAddress","_s","network","address","chainId","ube","undefined","currentBlockTimestamp","info","rewardsAddresses","map","_ref","stakingRewardAddress","accountArg","balances","earnedAmounts","totalSupplies","rewardRates","periodFinishes","reduce","memo","_ref2","index","rewardsAddress","poolInfo","tokens","balanceState","earnedAmountState","totalSupplyState","rewardRateState","periodFinishState","loading","_balanceState$result$","_balanceState$result","_totalSupplyState$res","_poolInfo$nextPeriodR","_poolInfo$nextPeriodR2","_periodFinishState$re","_periodFinishState$re2","_rewardRateState$resu","_earnedAmountState$re","_earnedAmountState$re2","error","console","rewardToken","rewardTokenSymbol","liquidityToken","stakingToken","stakedAmount","BigInt","result","totalStakedAmount","nextPeriodRewards","toString","getHypotheticalRewardRate","totalRewardRates","greaterThan","raw","divide","multiply","periodFinishSeconds","toNumber","periodFinishMs","active","rewardsFinished","Math","floor","Date","now","totalRewardRate","individualRewardRate","push","token","periodFinish","rewardTokens","usePairStakingInfo","_s2","_useStakingInfo$"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/stake/useStakingInfo.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { ChainId as UbeswapChainId, JSBI, Pair, Token, TokenAmount } from '@ubeswap/sdk'\nimport { STAKING_REWARDS_INTERFACE } from 'constants/abis/staking-rewards'\nimport { UBE } from 'constants/tokens'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\nimport { useMemo } from 'react'\nimport { useMultipleContractSingleData } from 'state/multicall/hooks'\n\nimport { INT_SECONDS_IN_WEEK } from './../../constants/index'\nimport { StakingInfo, useStakingPools } from './hooks'\n\n// Gets the staking info from the network for the active chain id\nexport default function useStakingInfo(pairToFilterBy?: Pair | null, stakingAddress?: string): readonly StakingInfo[] {\n  const { network, address } = useCelo()\n  const chainId = network.chainId as unknown as UbeswapChainId\n  const ube = chainId ? UBE[chainId] : undefined\n\n  // detect if staking is ended\n  const currentBlockTimestamp = useCurrentBlockTimestamp()\n\n  const info = useStakingPools(pairToFilterBy, stakingAddress)\n  // These are the staking pools\n  const rewardsAddresses = useMemo(() => info.map(({ stakingRewardAddress }) => stakingRewardAddress), [info])\n\n  const accountArg = useMemo(() => [address ?? undefined], [address])\n\n  // get all the info from the staking rewards contracts\n  const balances = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'balanceOf', accountArg)\n  const earnedAmounts = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'earned', accountArg)\n  const totalSupplies = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'totalSupply')\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate')\n  const periodFinishes = useMultipleContractSingleData(rewardsAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish')\n  return useMemo(() => {\n    if (!chainId || !ube) return []\n\n    return info.reduce(\n      (memo: StakingInfo[], { stakingRewardAddress: rewardsAddress, poolInfo, tokens }, index: number) => {\n        // these two are dependent on account\n        const balanceState = balances[index]\n        const earnedAmountState = earnedAmounts[index]\n\n        // these get fetched regardless of account\n        const totalSupplyState = totalSupplies[index]\n        const rewardRateState = rewardRates[index]\n        const periodFinishState = periodFinishes[index]\n\n        if (\n          // these may be undefined if not logged in\n          !balanceState?.loading &&\n          !earnedAmountState?.loading &&\n          // always need these\n          totalSupplyState &&\n          !totalSupplyState.loading &&\n          rewardRateState &&\n          !rewardRateState.loading &&\n          periodFinishState &&\n          !periodFinishState.loading\n        ) {\n          if (\n            balanceState?.error ||\n            earnedAmountState?.error ||\n            totalSupplyState.error ||\n            rewardRateState.error ||\n            periodFinishState.error\n          ) {\n            console.error('Failed to load staking rewards info')\n            return memo\n          }\n\n          const rewardToken = poolInfo.rewardToken\n            ? new Token(chainId, poolInfo.rewardToken, 18, poolInfo.rewardTokenSymbol)\n            : ube\n\n          // get the LP token\n          const liquidityToken = new Token(chainId, poolInfo.stakingToken, 18, 'ULP', 'Ubeswap LP Token')\n\n          // check for account, if no account set to 0\n          const stakedAmount = new TokenAmount(liquidityToken, JSBI.BigInt(balanceState?.result?.[0] ?? 0))\n          const totalStakedAmount = new TokenAmount(liquidityToken, JSBI.BigInt(totalSupplyState.result?.[0]))\n          const nextPeriodRewards = new TokenAmount(ube, poolInfo.nextPeriodRewards?.toString() ?? '0')\n\n          const getHypotheticalRewardRate = (\n            stakedAmount: TokenAmount,\n            totalStakedAmount: TokenAmount,\n            totalRewardRates: TokenAmount[]\n          ): TokenAmount[] => {\n            return [\n              new TokenAmount(\n                rewardToken,\n                JSBI.greaterThan(totalStakedAmount.raw, JSBI.BigInt(0))\n                  ? JSBI.divide(JSBI.multiply(totalRewardRates[0].raw, stakedAmount.raw), totalStakedAmount.raw)\n                  : JSBI.BigInt(0)\n              ),\n            ]\n          }\n\n          const periodFinishSeconds = periodFinishState.result?.[0]?.toNumber()\n          const periodFinishMs = periodFinishSeconds * 1000\n          // compare period end timestamp vs current block timestamp (in seconds)\n          const active =\n            periodFinishSeconds && currentBlockTimestamp\n              ? periodFinishSeconds > currentBlockTimestamp.toNumber()\n              : false\n\n          const rewardsFinished = Math.floor(Date.now() / 1000) - periodFinishSeconds > INT_SECONDS_IN_WEEK\n          const totalRewardRate = new TokenAmount(\n            rewardToken,\n            rewardsFinished ? JSBI.BigInt(0) : JSBI.BigInt(rewardRateState.result?.[0])\n          )\n          const individualRewardRate = getHypotheticalRewardRate(stakedAmount, totalStakedAmount, [totalRewardRate])\n\n          if (!tokens) {\n            return memo\n          }\n\n          memo.push({\n            stakingRewardAddress: rewardsAddress,\n            stakingToken: totalStakedAmount.token,\n            tokens,\n            stakedAmount,\n            totalStakedAmount,\n            earnedAmounts: [new TokenAmount(rewardToken, JSBI.BigInt(earnedAmountState?.result?.[0] ?? 0))],\n            rewardRates: individualRewardRate,\n            totalRewardRates: [totalRewardRate],\n            periodFinish: periodFinishMs > 0 ? new Date(periodFinishMs) : undefined,\n            active,\n            getHypotheticalRewardRate,\n            nextPeriodRewards,\n            poolInfo,\n            rewardTokens: [rewardToken],\n          })\n        }\n        return memo\n      },\n      []\n    )\n  }, [balances, chainId, currentBlockTimestamp, earnedAmounts, info, periodFinishes, rewardRates, totalSupplies, ube])\n}\n\n// `stakingAddress` is used to differentiate when there are two different farms with the same LP\nexport const usePairStakingInfo = (pairToFilterBy?: Pair | null, stakingAddress?: string): StakingInfo | undefined => {\n  return useStakingInfo(pairToFilterBy, stakingAddress)[0] ?? undefined\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}