{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;\nconst zeroNode_1 = require(\"./zeroNode\");\nconst gindex_1 = require(\"./gindex\");\nconst node_1 = require(\"./node\");\nconst proof_1 = require(\"./proof\");\nconst single_1 = require(\"./proof/single\");\n/**\n * Binary merkle tree\n *\n * Wrapper around immutable `Node` to support mutability.\n *\n * Mutability between a parent tree and subtree is achieved by maintaining a `hook` callback, which updates the parent when the subtree is updated.\n */\nclass Tree {\n  constructor(node, hook) {\n    this._rootNode = node;\n    if (hook) {\n      if (typeof WeakRef === \"undefined\") {\n        this.hook = hook;\n      } else {\n        this.hook = new WeakRef(hook);\n      }\n    }\n  }\n  /**\n   * Create a `Tree` from a `Proof` object\n   */\n  static createFromProof(proof) {\n    return new Tree(proof_1.createNodeFromProof(proof));\n  }\n  /**\n   * The root node of the tree\n   */\n  get rootNode() {\n    return this._rootNode;\n  }\n  /**\n   *\n   * Setting the root node will trigger a call to the tree's `hook` if it exists.\n   */\n  set rootNode(newRootNode) {\n    this._rootNode = newRootNode;\n    if (this.hook) {\n      // WeakRef should not change status during a program's execution\n      // So, use WeakRef feature detection to assume the type of this.hook\n      // to minimize the memory footprint of Tree\n      if (typeof WeakRef === \"undefined\") {\n        this.hook(newRootNode);\n      } else {\n        const hookVar = this.hook.deref();\n        if (hookVar) {\n          hookVar(newRootNode);\n        } else {\n          // Hook has been garbage collected, no need to keep the hookRef\n          this.hook = undefined;\n        }\n      }\n    }\n  }\n  /**\n   * The root hash of the tree\n   */\n  get root() {\n    return this.rootNode.root;\n  }\n  /**\n   * Return a copy of the tree\n   */\n  clone() {\n    return new Tree(this.rootNode);\n  }\n  /**\n   * Return the subtree at the specified gindex.\n   *\n   * Note: The returned subtree will have a `hook` attached to the parent tree.\n   * Updates to the subtree will result in updates to the parent.\n   */\n  getSubtree(index) {\n    return new Tree(this.getNode(index), node => this.setNode(index, node));\n  }\n  /**\n   * Return the node at the specified gindex.\n   */\n  getNode(gindex) {\n    return getNode(this.rootNode, gindex);\n  }\n  /**\n   * Return the node at the specified depth and index.\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  getNodeAtDepth(depth, index) {\n    return getNodeAtDepth(this.rootNode, depth, index);\n  }\n  /**\n   * Return the hash at the specified gindex.\n   */\n  getRoot(index) {\n    return this.getNode(index).root;\n  }\n  /**\n   * Set the node at at the specified gindex.\n   */\n  setNode(gindex, n) {\n    this.rootNode = setNode(this.rootNode, gindex, n);\n  }\n  /**\n   * Traverse to the node at the specified gindex,\n   * then apply the function to get a new node and set the node at the specified gindex with the result.\n   *\n   * This is a convenient method to avoid traversing the tree 2 times to\n   * get and set.\n   */\n  setNodeWithFn(gindex, getNewNode) {\n    this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);\n  }\n  /**\n   * Set the node at the specified depth and index.\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  setNodeAtDepth(depth, index, node) {\n    this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);\n  }\n  /**\n   * Set the hash at the specified gindex.\n   *\n   * Note: This will set a new `LeafNode` at the specified gindex.\n   */\n  setRoot(index, root) {\n    this.setNode(index, node_1.LeafNode.fromRoot(root));\n  }\n  /**\n   * Fast read-only iteration\n   * In-order traversal of nodes at `depth`\n   * starting from the `startIndex`-indexed node\n   * iterating through `count` nodes\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  getNodesAtDepth(depth, startIndex, count) {\n    return getNodesAtDepth(this.rootNode, depth, startIndex, count);\n  }\n  /**\n   * Fast read-only iteration\n   * In-order traversal of nodes at `depth`\n   * starting from the `startIndex`-indexed node\n   * iterating through `count` nodes\n   *\n   * Supports index up to `Number.MAX_SAFE_INTEGER`.\n   */\n  iterateNodesAtDepth(depth, startIndex, count) {\n    return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);\n  }\n  /**\n   * Return a merkle proof for the node at the specified gindex.\n   */\n  getSingleProof(index) {\n    return single_1.createSingleProof(this.rootNode, index)[1];\n  }\n  /**\n   * Return a merkle proof for the proof input.\n   *\n   * This method can be used to create multiproofs.\n   */\n  getProof(input) {\n    return proof_1.createProof(this.rootNode, input);\n  }\n}\nexports.Tree = Tree;\n/**\n * Return the node at the specified gindex.\n */\nfunction getNode(rootNode, gindex) {\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  let node = rootNode;\n  for (let i = 1; i < gindexBitstring.length; i++) {\n    if (node.isLeaf()) {\n      throw new Error(\"Invalid tree - found leaf at depth \".concat(i));\n    }\n    // If bit is set, means navigate right\n    node = gindexBitstring[i] === \"1\" ? node.right : node.left;\n  }\n  return node;\n}\nexports.getNode = getNode;\n/**\n * Set the node at at the specified gindex.\n * Returns the new root node.\n */\nfunction setNode(rootNode, gindex, n) {\n  // Pre-compute entire bitstring instead of using an iterator (25% faster)\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  const parentNodes = getParentNodes(rootNode, gindexBitstring);\n  return rebindNodeToRoot(gindexBitstring, parentNodes, n);\n}\nexports.setNode = setNode;\n/**\n * Traverse to the node at the specified gindex,\n * then apply the function to get a new node and set the node at the specified gindex with the result.\n *\n * This is a convenient method to avoid traversing the tree 2 times to\n * get and set.\n *\n * Returns the new root node.\n */\nfunction setNodeWithFn(rootNode, gindex, getNewNode) {\n  // Pre-compute entire bitstring instead of using an iterator (25% faster)\n  const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n  const parentNodes = getParentNodes(rootNode, gindexBitstring);\n  const lastParentNode = parentNodes[parentNodes.length - 1];\n  const lastBit = gindexBitstring[gindexBitstring.length - 1];\n  const oldNode = lastBit === \"1\" ? lastParentNode.right : lastParentNode.left;\n  const newNode = getNewNode(oldNode);\n  return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);\n}\nexports.setNodeWithFn = setNodeWithFn;\n/**\n * Traverse the tree from root node, ignore the last bit to get all parent nodes\n * of the specified bitstring.\n */\nfunction getParentNodes(rootNode, bitstring) {\n  let node = rootNode;\n  // Keep a list of all parent nodes of node at gindex `index`. Then walk the list\n  // backwards to rebind them \"recursively\" with the new nodes without using functions\n  const parentNodes = [rootNode];\n  // Ignore the first bit, left right directions are at bits [1,..]\n  // Ignore the last bit, no need to push the target node to the parentNodes array\n  for (let i = 1; i < bitstring.length - 1; i++) {\n    // Compare to string directly to prevent unnecessary type conversions\n    if (bitstring[i] === \"1\") {\n      node = node.right;\n    } else {\n      node = node.left;\n    }\n    parentNodes.push(node);\n  }\n  return parentNodes;\n}\n/**\n * Build a new tree structure from bitstring, parentNodes and a new node.\n * Returns the new root node.\n */\nfunction rebindNodeToRoot(bitstring, parentNodes, newNode) {\n  let node = newNode;\n  // Ignore the first bit, left right directions are at bits [1,..]\n  // Iterate the list backwards including the last bit, but offset the parentNodes array\n  // by one since the first bit in bitstring was ignored in the previous loop\n  for (let i = bitstring.length - 1; i >= 1; i--) {\n    if (bitstring[i] === \"1\") {\n      node = new node_1.BranchNode(parentNodes[i - 1].left, node);\n    } else {\n      node = new node_1.BranchNode(node, parentNodes[i - 1].right);\n    }\n  }\n  return node;\n}\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction getNodeAtDepth(rootNode, depth, index) {\n  if (depth === 0) {\n    return rootNode;\n  }\n  if (depth === 1) {\n    return index === 0 ? rootNode.left : rootNode.right;\n  }\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let node = rootNode;\n  for (let d = depthiRoot; d >= depthiParent; d--) {\n    node = isLeftNode(d, index) ? node.left : node.right;\n  }\n  return node;\n}\nexports.getNodeAtDepth = getNodeAtDepth;\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {\n  // TODO: OPTIMIZE (if necessary)\n  return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);\n}\nexports.setNodeAtDepth = setNodeAtDepth;\n/**\n * Set multiple nodes in batch, editing and traversing nodes strictly once.\n *\n * - gindexes MUST be sorted in ascending order beforehand.\n * - All gindexes must be at the exact same depth.\n * - Depth must be > 0, if 0 just replace the root node.\n *\n * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,\n * and create a new parent. Then calculate the closest common depth with the next\n * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {\n  // depth depthi   gindexes   indexes\n  // 0     1           1          0\n  // 1     0         2   3      0   1\n  // 2     -        4 5 6 7    0 1 2 3\n  // '10' means, at depth 1, node is at the left\n  //\n  // For index N check if the bit at position depthi is set to navigate right at depthi\n  // ```\n  // mask = 1 << depthi\n  // goRight = (N & mask) == mask\n  // ```\n  // If depth is 0 there's only one node max and the optimization below will cause a navigation error.\n  // For this case, check if there's a new root node and return it, otherwise the current rootNode.\n  if (nodesDepth === 0) {\n    return nodes.length > 0 ? nodes[0] : rootNode;\n  }\n  /**\n   * Contiguous filled stack of parent nodes. It get filled in the first descent\n   * Indexed by depthi\n   */\n  const parentNodeStack = new Array(nodesDepth);\n  /**\n   * Temp stack of left parent nodes, index by depthi.\n   * Node leftParentNodeStack[depthi] is a node at d = depthi - 1, such that:\n   * ```\n   * parentNodeStack[depthi].left = leftParentNodeStack[depthi]\n   * ```\n   */\n  const leftParentNodeStack = new Array(nodesDepth);\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = nodesDepth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  // TODO: Iterate to depth 32 to allow using bit ops\n  // for (; depthi >= 32; depthi--) {\n  //   node = node.left;\n  // }\n  for (let i = 0; i < indexes.length; i++) {\n    const index = indexes[i];\n    // Navigate down until parent depth, and store the chain of nodes\n    //\n    // Starts from latest common depth, so node is the parent node at `depthi`\n    // When persisting the next node, store at the `d - 1` since its the child of node at `depthi`\n    //\n    // Stops at the level above depthiParent. For the re-binding routing below node must be at depthiParent\n    for (let d = depthi; d > depthiParent; d--) {\n      node = isLeftNode(d, index) ? node.left : node.right;\n      parentNodeStack[d - 1] = node;\n    }\n    depthi = depthiParent;\n    // If this is the left node, check first it the next node is on the right\n    //\n    //   -    If both nodes exist, create new\n    //  / \\\n    // x   x\n    //\n    //   -    If only the left node exists, rebind left\n    //  / \\\n    // x   -\n    //\n    //   -    If this is the right node, only the right node exists, rebind right\n    //  / \\\n    // -   x\n    // d = 0, mask = 1 << d = 1\n    const isLeftLeafNode = (index & 1) !== 1;\n    if (isLeftLeafNode) {\n      // Next node is the very next to the right of current node\n      if (index + 1 === indexes[i + 1]) {\n        node = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n        // Move pointer one extra forward since node has consumed two nodes\n        i++;\n      } else {\n        node = new node_1.BranchNode(nodes[i], node.right);\n      }\n    } else {\n      node = new node_1.BranchNode(node.left, nodes[i]);\n    }\n    // Here `node` is the new BranchNode at depthi `depthiParent`\n    // Now climb upwards until finding the common node with the next index\n    // For the last iteration, climb to the root at `depthiRoot`\n    const isLastIndex = i >= indexes.length - 1;\n    const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]);\n    // When climbing up from a left node there are two possible paths\n    // 1. Go to the right of the parent: Store left node to rebind latter\n    // 2. Go another level up: Will never visit the left node again, so must rebind now\n    // ðŸ¡¼ \\     Rebind left only, will never visit this node again\n    // ðŸ¡½ /\\\n    //\n    //    / ðŸ¡½  Rebind left only (same as above)\n    // ðŸ¡½ /\\\n    //\n    // ðŸ¡½ /\\ ðŸ¡¾  Store left node to rebind the entire node when returning\n    //\n    // ðŸ¡¼ \\     Rebind right with left if exists, will never visit this node again\n    //   /\\ ðŸ¡¼\n    //\n    //    / ðŸ¡½  Rebind right with left if exists (same as above)\n    //   /\\ ðŸ¡¼\n    for (let d = depthiParent + 1; d <= diffDepthi; d++) {\n      // If node is on the left, store for latter\n      // If node is on the right merge with stored left node\n      if (isLeftNode(d, index)) {\n        if (isLastIndex || d !== diffDepthi) {\n          // If it's last index, bind with parent since it won't navigate to the right anymore\n          // Also, if still has to move upwards, rebind since the node won't be visited anymore\n          node = new node_1.BranchNode(node, parentNodeStack[d].right);\n        } else {\n          // Only store the left node if it's at d = diffDepth\n          leftParentNodeStack[d] = node;\n          node = parentNodeStack[d];\n        }\n      } else {\n        const leftNode = leftParentNodeStack[d];\n        if (leftNode !== undefined) {\n          node = new node_1.BranchNode(leftNode, node);\n          leftParentNodeStack[d] = undefined;\n        } else {\n          node = new node_1.BranchNode(parentNodeStack[d].left, node);\n        }\n      }\n    }\n    // Prepare next loop\n    // Go to the parent of the depth with diff, to switch branches to the right\n    depthi = diffDepthi;\n  }\n  // Done, return new root node\n  return node;\n}\nexports.setNodesAtDepth = setNodesAtDepth;\n/**\n * Fast read-only iteration\n * In-order traversal of nodes at `depth`\n * starting from the `startIndex`-indexed node\n * iterating through `count` nodes\n *\n * **Strategy**\n * 1. Navigate down to parentDepth storing a stack of parents\n * 2. At target level push current node\n * 3. Go up to the first level that navigated left\n * 4. Repeat (1) for next index\n */\nfunction getNodesAtDepth(rootNode, depth, startIndex, count) {\n  // Optimized paths for short trees (x20 times faster)\n  if (depth === 0) {\n    return startIndex === 0 && count > 0 ? [rootNode] : [];\n  } else if (depth === 1) {\n    if (count === 0) {\n      return [];\n    } else if (count === 1) {\n      return startIndex === 0 ? [rootNode.left] : [rootNode.right];\n    } else {\n      return [rootNode.left, rootNode.right];\n    }\n  }\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Contiguous filled stack of parent nodes. It get filled in the first descent\n  // Indexed by depthi\n  const parentNodeStack = new Array(depth);\n  const isLeftStack = new Array(depth);\n  const nodes = new Array(count);\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  for (let i = 0; i < count; i++) {\n    for (let d = depthi; d >= depthiParent; d--) {\n      if (d !== depthi) {\n        parentNodeStack[d] = node;\n      }\n      const isLeft = isLeftNode(d, startIndex + i);\n      isLeftStack[d] = isLeft;\n      node = isLeft ? node.left : node.right;\n    }\n    nodes[i] = node;\n    // Find the first depth where navigation when left.\n    // Store that height and go right from there\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n      if (isLeftStack[d] === true) {\n        depthi = d;\n        break;\n      }\n    }\n    node = parentNodeStack[depthi];\n  }\n  return nodes;\n}\nexports.getNodesAtDepth = getNodesAtDepth;\n/**\n * @see getNodesAtDepth but instead of pushing to an array, it yields\n */\nfunction* iterateNodesAtDepth(rootNode, depth, startIndex, count) {\n  const endIndex = startIndex + count;\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = depth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Contiguous filled stack of parent nodes. It get filled in the first descent\n  // Indexed by depthi\n  const parentNodeStack = new Array(depth);\n  const isLeftStack = new Array(depth);\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  for (let index = startIndex; index < endIndex; index++) {\n    for (let d = depthi; d >= depthiParent; d--) {\n      if (d !== depthi) {\n        parentNodeStack[d] = node;\n      }\n      const isLeft = isLeftNode(d, index);\n      isLeftStack[d] = isLeft;\n      node = isLeft ? node.left : node.right;\n    }\n    yield node;\n    // Find the first depth where navigation when left.\n    // Store that height and go right from there\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n      if (isLeftStack[d] === true) {\n        depthi = d;\n        break;\n      }\n    }\n    node = parentNodeStack[depthi];\n  }\n}\nexports.iterateNodesAtDepth = iterateNodesAtDepth;\n/**\n * Zero's all nodes right of index with constant depth of `nodesDepth`.\n *\n * For example, zero-ing this tree at depth 2 after index 0\n * ```\n *    X              X\n *  X   X    ->    X   0\n * X X X X        X 0 0 0\n * ```\n *\n * Or, zero-ing this tree at depth 3 after index 2\n * ```\n *        X                     X\n *    X       X             X       0\n *  X   X   X   X    ->   X   X   0   0\n * X X X X X X X X       X X X 0 0 0 0 0\n * ```\n *\n * The strategy is to first navigate down to `nodesDepth` and `index` and keep a stack of parents.\n * Then navigate up re-binding:\n * - If navigated to the left rebind with zeroNode()\n * - If navigated to the right rebind with parent.left from the stack\n */\nfunction treeZeroAfterIndex(rootNode, nodesDepth, index) {\n  // depth depthi   gindexes   indexes\n  // 0     1           1          0\n  // 1     0         2   3      0   1\n  // 2     -        4 5 6 7    0 1 2 3\n  // '10' means, at depth 1, node is at the left\n  //\n  // For index N check if the bit at position depthi is set to navigate right at depthi\n  // ```\n  // mask = 1 << depthi\n  // goRight = (N & mask) == mask\n  // ```\n  // Degenerate case where tree is zero after a negative index (-1).\n  // All positive indexes are zero, so the entire tree is zero. Return cached zero node as root.\n  if (index < 0) {\n    return zeroNode_1.zeroNode(nodesDepth);\n  }\n  /**\n   * Contiguous filled stack of parent nodes. It get filled in the first descent\n   * Indexed by depthi\n   */\n  const parentNodeStack = new Array(nodesDepth);\n  // Ignore first bit \"1\", then substract 1 to get to the parent\n  const depthiRoot = nodesDepth - 1;\n  const depthiParent = 0;\n  let depthi = depthiRoot;\n  let node = rootNode;\n  // Insert root node to make the loop below general\n  parentNodeStack[depthiRoot] = rootNode;\n  // Navigate down until parent depth, and store the chain of nodes\n  //\n  // Stops at the depthiParent level. To rebind below down to `nodesDepth`\n  for (let d = depthi; d >= depthiParent; d--) {\n    node = isLeftNode(d, index) ? node.left : node.right;\n    parentNodeStack[d - 1] = node;\n  }\n  depthi = depthiParent;\n  // Now climb up re-binding with either zero of existing tree.\n  for (let d = depthiParent; d <= depthiRoot; d++) {\n    if (isLeftNode(d, index)) {\n      // If navigated to the left, then all the child nodes of the right node are NOT part of the new tree.\n      // So re-bind new `node` with a zeroNode at the current depth.\n      node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));\n    } else {\n      // If navigated to the right, then all the child nodes of the left node are part of the new tree.\n      // So re-bind new `node` with the existing left node of the parent.\n      node = new node_1.BranchNode(parentNodeStack[d].left, node);\n    }\n  }\n  // Done, return new root node\n  return node;\n}\nexports.treeZeroAfterIndex = treeZeroAfterIndex;\n/**\n * Returns true if the `index` at `depth` is a left node, false if it is a right node.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n * In Eth2 case the biggest tree's index is 2**40 (VALIDATOR_REGISTRY_LIMIT)\n */\nfunction isLeftNode(depthi, index) {\n  if (depthi > 31) {\n    // Javascript can only do bitwise ops with 32 bit numbers.\n    // Shifting left 1 by 32 wraps around and becomes 1.\n    // Get the high part of `index` and adjust depthi\n    const indexHi = index / 2 ** 32 >>> 0;\n    const mask = 1 << depthi - 32;\n    return (indexHi & mask) !== mask;\n  }\n  const mask = 1 << depthi;\n  return (index & mask) !== mask;\n}\n/**\n * depth depthi   gindexes   indexes\n * 0     1           1          0\n * 1     0         2   3      0   1\n * 2     -        4 5 6 7    0 1 2 3\n *\n * **Conditions**:\n * - `from` and `to` must not be equal\n *\n * @param from Index\n * @param to Index\n */\nfunction findDiffDepthi(from, to) {\n  return (\n    // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2\n    Math.ceil(Math.log2(-~(from ^ to))) -\n    // Must offset by one to match the depthi scale\n    1\n  );\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","treeZeroAfterIndex","iterateNodesAtDepth","getNodesAtDepth","setNodesAtDepth","setNodeAtDepth","getNodeAtDepth","setNodeWithFn","setNode","getNode","Tree","zeroNode_1","require","gindex_1","node_1","proof_1","single_1","constructor","node","hook","_rootNode","WeakRef","createFromProof","proof","createNodeFromProof","rootNode","newRootNode","hookVar","deref","undefined","root","clone","getSubtree","index","gindex","depth","getRoot","n","getNewNode","setRoot","LeafNode","fromRoot","startIndex","count","getSingleProof","createSingleProof","getProof","input","createProof","gindexBitstring","convertGindexToBitstring","i","length","isLeaf","Error","concat","right","left","parentNodes","getParentNodes","rebindNodeToRoot","lastParentNode","lastBit","oldNode","newNode","bitstring","push","BranchNode","depthiRoot","depthiParent","d","isLeftNode","nodesDepth","nodeChanged","indexes","nodes","parentNodeStack","Array","leftParentNodeStack","depthi","isLeftLeafNode","isLastIndex","diffDepthi","findDiffDepthi","leftNode","isLeftStack","isLeft","endIndex","zeroNode","indexHi","mask","from","to","Math","ceil","log2"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.treeZeroAfterIndex = exports.iterateNodesAtDepth = exports.getNodesAtDepth = exports.setNodesAtDepth = exports.setNodeAtDepth = exports.getNodeAtDepth = exports.setNodeWithFn = exports.setNode = exports.getNode = exports.Tree = void 0;\nconst zeroNode_1 = require(\"./zeroNode\");\nconst gindex_1 = require(\"./gindex\");\nconst node_1 = require(\"./node\");\nconst proof_1 = require(\"./proof\");\nconst single_1 = require(\"./proof/single\");\n/**\n * Binary merkle tree\n *\n * Wrapper around immutable `Node` to support mutability.\n *\n * Mutability between a parent tree and subtree is achieved by maintaining a `hook` callback, which updates the parent when the subtree is updated.\n */\nclass Tree {\n    constructor(node, hook) {\n        this._rootNode = node;\n        if (hook) {\n            if (typeof WeakRef === \"undefined\") {\n                this.hook = hook;\n            }\n            else {\n                this.hook = new WeakRef(hook);\n            }\n        }\n    }\n    /**\n     * Create a `Tree` from a `Proof` object\n     */\n    static createFromProof(proof) {\n        return new Tree(proof_1.createNodeFromProof(proof));\n    }\n    /**\n     * The root node of the tree\n     */\n    get rootNode() {\n        return this._rootNode;\n    }\n    /**\n     *\n     * Setting the root node will trigger a call to the tree's `hook` if it exists.\n     */\n    set rootNode(newRootNode) {\n        this._rootNode = newRootNode;\n        if (this.hook) {\n            // WeakRef should not change status during a program's execution\n            // So, use WeakRef feature detection to assume the type of this.hook\n            // to minimize the memory footprint of Tree\n            if (typeof WeakRef === \"undefined\") {\n                this.hook(newRootNode);\n            }\n            else {\n                const hookVar = this.hook.deref();\n                if (hookVar) {\n                    hookVar(newRootNode);\n                }\n                else {\n                    // Hook has been garbage collected, no need to keep the hookRef\n                    this.hook = undefined;\n                }\n            }\n        }\n    }\n    /**\n     * The root hash of the tree\n     */\n    get root() {\n        return this.rootNode.root;\n    }\n    /**\n     * Return a copy of the tree\n     */\n    clone() {\n        return new Tree(this.rootNode);\n    }\n    /**\n     * Return the subtree at the specified gindex.\n     *\n     * Note: The returned subtree will have a `hook` attached to the parent tree.\n     * Updates to the subtree will result in updates to the parent.\n     */\n    getSubtree(index) {\n        return new Tree(this.getNode(index), (node) => this.setNode(index, node));\n    }\n    /**\n     * Return the node at the specified gindex.\n     */\n    getNode(gindex) {\n        return getNode(this.rootNode, gindex);\n    }\n    /**\n     * Return the node at the specified depth and index.\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    getNodeAtDepth(depth, index) {\n        return getNodeAtDepth(this.rootNode, depth, index);\n    }\n    /**\n     * Return the hash at the specified gindex.\n     */\n    getRoot(index) {\n        return this.getNode(index).root;\n    }\n    /**\n     * Set the node at at the specified gindex.\n     */\n    setNode(gindex, n) {\n        this.rootNode = setNode(this.rootNode, gindex, n);\n    }\n    /**\n     * Traverse to the node at the specified gindex,\n     * then apply the function to get a new node and set the node at the specified gindex with the result.\n     *\n     * This is a convenient method to avoid traversing the tree 2 times to\n     * get and set.\n     */\n    setNodeWithFn(gindex, getNewNode) {\n        this.rootNode = setNodeWithFn(this.rootNode, gindex, getNewNode);\n    }\n    /**\n     * Set the node at the specified depth and index.\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    setNodeAtDepth(depth, index, node) {\n        this.rootNode = setNodeAtDepth(this.rootNode, depth, index, node);\n    }\n    /**\n     * Set the hash at the specified gindex.\n     *\n     * Note: This will set a new `LeafNode` at the specified gindex.\n     */\n    setRoot(index, root) {\n        this.setNode(index, node_1.LeafNode.fromRoot(root));\n    }\n    /**\n     * Fast read-only iteration\n     * In-order traversal of nodes at `depth`\n     * starting from the `startIndex`-indexed node\n     * iterating through `count` nodes\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    getNodesAtDepth(depth, startIndex, count) {\n        return getNodesAtDepth(this.rootNode, depth, startIndex, count);\n    }\n    /**\n     * Fast read-only iteration\n     * In-order traversal of nodes at `depth`\n     * starting from the `startIndex`-indexed node\n     * iterating through `count` nodes\n     *\n     * Supports index up to `Number.MAX_SAFE_INTEGER`.\n     */\n    iterateNodesAtDepth(depth, startIndex, count) {\n        return iterateNodesAtDepth(this.rootNode, depth, startIndex, count);\n    }\n    /**\n     * Return a merkle proof for the node at the specified gindex.\n     */\n    getSingleProof(index) {\n        return single_1.createSingleProof(this.rootNode, index)[1];\n    }\n    /**\n     * Return a merkle proof for the proof input.\n     *\n     * This method can be used to create multiproofs.\n     */\n    getProof(input) {\n        return proof_1.createProof(this.rootNode, input);\n    }\n}\nexports.Tree = Tree;\n/**\n * Return the node at the specified gindex.\n */\nfunction getNode(rootNode, gindex) {\n    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n    let node = rootNode;\n    for (let i = 1; i < gindexBitstring.length; i++) {\n        if (node.isLeaf()) {\n            throw new Error(`Invalid tree - found leaf at depth ${i}`);\n        }\n        // If bit is set, means navigate right\n        node = gindexBitstring[i] === \"1\" ? node.right : node.left;\n    }\n    return node;\n}\nexports.getNode = getNode;\n/**\n * Set the node at at the specified gindex.\n * Returns the new root node.\n */\nfunction setNode(rootNode, gindex, n) {\n    // Pre-compute entire bitstring instead of using an iterator (25% faster)\n    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n    const parentNodes = getParentNodes(rootNode, gindexBitstring);\n    return rebindNodeToRoot(gindexBitstring, parentNodes, n);\n}\nexports.setNode = setNode;\n/**\n * Traverse to the node at the specified gindex,\n * then apply the function to get a new node and set the node at the specified gindex with the result.\n *\n * This is a convenient method to avoid traversing the tree 2 times to\n * get and set.\n *\n * Returns the new root node.\n */\nfunction setNodeWithFn(rootNode, gindex, getNewNode) {\n    // Pre-compute entire bitstring instead of using an iterator (25% faster)\n    const gindexBitstring = gindex_1.convertGindexToBitstring(gindex);\n    const parentNodes = getParentNodes(rootNode, gindexBitstring);\n    const lastParentNode = parentNodes[parentNodes.length - 1];\n    const lastBit = gindexBitstring[gindexBitstring.length - 1];\n    const oldNode = lastBit === \"1\" ? lastParentNode.right : lastParentNode.left;\n    const newNode = getNewNode(oldNode);\n    return rebindNodeToRoot(gindexBitstring, parentNodes, newNode);\n}\nexports.setNodeWithFn = setNodeWithFn;\n/**\n * Traverse the tree from root node, ignore the last bit to get all parent nodes\n * of the specified bitstring.\n */\nfunction getParentNodes(rootNode, bitstring) {\n    let node = rootNode;\n    // Keep a list of all parent nodes of node at gindex `index`. Then walk the list\n    // backwards to rebind them \"recursively\" with the new nodes without using functions\n    const parentNodes = [rootNode];\n    // Ignore the first bit, left right directions are at bits [1,..]\n    // Ignore the last bit, no need to push the target node to the parentNodes array\n    for (let i = 1; i < bitstring.length - 1; i++) {\n        // Compare to string directly to prevent unnecessary type conversions\n        if (bitstring[i] === \"1\") {\n            node = node.right;\n        }\n        else {\n            node = node.left;\n        }\n        parentNodes.push(node);\n    }\n    return parentNodes;\n}\n/**\n * Build a new tree structure from bitstring, parentNodes and a new node.\n * Returns the new root node.\n */\nfunction rebindNodeToRoot(bitstring, parentNodes, newNode) {\n    let node = newNode;\n    // Ignore the first bit, left right directions are at bits [1,..]\n    // Iterate the list backwards including the last bit, but offset the parentNodes array\n    // by one since the first bit in bitstring was ignored in the previous loop\n    for (let i = bitstring.length - 1; i >= 1; i--) {\n        if (bitstring[i] === \"1\") {\n            node = new node_1.BranchNode(parentNodes[i - 1].left, node);\n        }\n        else {\n            node = new node_1.BranchNode(node, parentNodes[i - 1].right);\n        }\n    }\n    return node;\n}\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction getNodeAtDepth(rootNode, depth, index) {\n    if (depth === 0) {\n        return rootNode;\n    }\n    if (depth === 1) {\n        return index === 0 ? rootNode.left : rootNode.right;\n    }\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = depth - 1;\n    const depthiParent = 0;\n    let node = rootNode;\n    for (let d = depthiRoot; d >= depthiParent; d--) {\n        node = isLeftNode(d, index) ? node.left : node.right;\n    }\n    return node;\n}\nexports.getNodeAtDepth = getNodeAtDepth;\n/**\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodeAtDepth(rootNode, nodesDepth, index, nodeChanged) {\n    // TODO: OPTIMIZE (if necessary)\n    return setNodesAtDepth(rootNode, nodesDepth, [index], [nodeChanged]);\n}\nexports.setNodeAtDepth = setNodeAtDepth;\n/**\n * Set multiple nodes in batch, editing and traversing nodes strictly once.\n *\n * - gindexes MUST be sorted in ascending order beforehand.\n * - All gindexes must be at the exact same depth.\n * - Depth must be > 0, if 0 just replace the root node.\n *\n * Strategy: for each gindex in `gindexes` navigate to the depth of its parent,\n * and create a new parent. Then calculate the closest common depth with the next\n * gindex and navigate upwards creating or caching nodes as necessary. Loop and repeat.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n */\nfunction setNodesAtDepth(rootNode, nodesDepth, indexes, nodes) {\n    // depth depthi   gindexes   indexes\n    // 0     1           1          0\n    // 1     0         2   3      0   1\n    // 2     -        4 5 6 7    0 1 2 3\n    // '10' means, at depth 1, node is at the left\n    //\n    // For index N check if the bit at position depthi is set to navigate right at depthi\n    // ```\n    // mask = 1 << depthi\n    // goRight = (N & mask) == mask\n    // ```\n    // If depth is 0 there's only one node max and the optimization below will cause a navigation error.\n    // For this case, check if there's a new root node and return it, otherwise the current rootNode.\n    if (nodesDepth === 0) {\n        return nodes.length > 0 ? nodes[0] : rootNode;\n    }\n    /**\n     * Contiguous filled stack of parent nodes. It get filled in the first descent\n     * Indexed by depthi\n     */\n    const parentNodeStack = new Array(nodesDepth);\n    /**\n     * Temp stack of left parent nodes, index by depthi.\n     * Node leftParentNodeStack[depthi] is a node at d = depthi - 1, such that:\n     * ```\n     * parentNodeStack[depthi].left = leftParentNodeStack[depthi]\n     * ```\n     */\n    const leftParentNodeStack = new Array(nodesDepth);\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = nodesDepth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    // TODO: Iterate to depth 32 to allow using bit ops\n    // for (; depthi >= 32; depthi--) {\n    //   node = node.left;\n    // }\n    for (let i = 0; i < indexes.length; i++) {\n        const index = indexes[i];\n        // Navigate down until parent depth, and store the chain of nodes\n        //\n        // Starts from latest common depth, so node is the parent node at `depthi`\n        // When persisting the next node, store at the `d - 1` since its the child of node at `depthi`\n        //\n        // Stops at the level above depthiParent. For the re-binding routing below node must be at depthiParent\n        for (let d = depthi; d > depthiParent; d--) {\n            node = isLeftNode(d, index) ? node.left : node.right;\n            parentNodeStack[d - 1] = node;\n        }\n        depthi = depthiParent;\n        // If this is the left node, check first it the next node is on the right\n        //\n        //   -    If both nodes exist, create new\n        //  / \\\n        // x   x\n        //\n        //   -    If only the left node exists, rebind left\n        //  / \\\n        // x   -\n        //\n        //   -    If this is the right node, only the right node exists, rebind right\n        //  / \\\n        // -   x\n        // d = 0, mask = 1 << d = 1\n        const isLeftLeafNode = (index & 1) !== 1;\n        if (isLeftLeafNode) {\n            // Next node is the very next to the right of current node\n            if (index + 1 === indexes[i + 1]) {\n                node = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n                // Move pointer one extra forward since node has consumed two nodes\n                i++;\n            }\n            else {\n                node = new node_1.BranchNode(nodes[i], node.right);\n            }\n        }\n        else {\n            node = new node_1.BranchNode(node.left, nodes[i]);\n        }\n        // Here `node` is the new BranchNode at depthi `depthiParent`\n        // Now climb upwards until finding the common node with the next index\n        // For the last iteration, climb to the root at `depthiRoot`\n        const isLastIndex = i >= indexes.length - 1;\n        const diffDepthi = isLastIndex ? depthiRoot : findDiffDepthi(index, indexes[i + 1]);\n        // When climbing up from a left node there are two possible paths\n        // 1. Go to the right of the parent: Store left node to rebind latter\n        // 2. Go another level up: Will never visit the left node again, so must rebind now\n        // ðŸ¡¼ \\     Rebind left only, will never visit this node again\n        // ðŸ¡½ /\\\n        //\n        //    / ðŸ¡½  Rebind left only (same as above)\n        // ðŸ¡½ /\\\n        //\n        // ðŸ¡½ /\\ ðŸ¡¾  Store left node to rebind the entire node when returning\n        //\n        // ðŸ¡¼ \\     Rebind right with left if exists, will never visit this node again\n        //   /\\ ðŸ¡¼\n        //\n        //    / ðŸ¡½  Rebind right with left if exists (same as above)\n        //   /\\ ðŸ¡¼\n        for (let d = depthiParent + 1; d <= diffDepthi; d++) {\n            // If node is on the left, store for latter\n            // If node is on the right merge with stored left node\n            if (isLeftNode(d, index)) {\n                if (isLastIndex || d !== diffDepthi) {\n                    // If it's last index, bind with parent since it won't navigate to the right anymore\n                    // Also, if still has to move upwards, rebind since the node won't be visited anymore\n                    node = new node_1.BranchNode(node, parentNodeStack[d].right);\n                }\n                else {\n                    // Only store the left node if it's at d = diffDepth\n                    leftParentNodeStack[d] = node;\n                    node = parentNodeStack[d];\n                }\n            }\n            else {\n                const leftNode = leftParentNodeStack[d];\n                if (leftNode !== undefined) {\n                    node = new node_1.BranchNode(leftNode, node);\n                    leftParentNodeStack[d] = undefined;\n                }\n                else {\n                    node = new node_1.BranchNode(parentNodeStack[d].left, node);\n                }\n            }\n        }\n        // Prepare next loop\n        // Go to the parent of the depth with diff, to switch branches to the right\n        depthi = diffDepthi;\n    }\n    // Done, return new root node\n    return node;\n}\nexports.setNodesAtDepth = setNodesAtDepth;\n/**\n * Fast read-only iteration\n * In-order traversal of nodes at `depth`\n * starting from the `startIndex`-indexed node\n * iterating through `count` nodes\n *\n * **Strategy**\n * 1. Navigate down to parentDepth storing a stack of parents\n * 2. At target level push current node\n * 3. Go up to the first level that navigated left\n * 4. Repeat (1) for next index\n */\nfunction getNodesAtDepth(rootNode, depth, startIndex, count) {\n    // Optimized paths for short trees (x20 times faster)\n    if (depth === 0) {\n        return startIndex === 0 && count > 0 ? [rootNode] : [];\n    }\n    else if (depth === 1) {\n        if (count === 0) {\n            return [];\n        }\n        else if (count === 1) {\n            return startIndex === 0 ? [rootNode.left] : [rootNode.right];\n        }\n        else {\n            return [rootNode.left, rootNode.right];\n        }\n    }\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = depth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Contiguous filled stack of parent nodes. It get filled in the first descent\n    // Indexed by depthi\n    const parentNodeStack = new Array(depth);\n    const isLeftStack = new Array(depth);\n    const nodes = new Array(count);\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    for (let i = 0; i < count; i++) {\n        for (let d = depthi; d >= depthiParent; d--) {\n            if (d !== depthi) {\n                parentNodeStack[d] = node;\n            }\n            const isLeft = isLeftNode(d, startIndex + i);\n            isLeftStack[d] = isLeft;\n            node = isLeft ? node.left : node.right;\n        }\n        nodes[i] = node;\n        // Find the first depth where navigation when left.\n        // Store that height and go right from there\n        for (let d = depthiParent; d <= depthiRoot; d++) {\n            if (isLeftStack[d] === true) {\n                depthi = d;\n                break;\n            }\n        }\n        node = parentNodeStack[depthi];\n    }\n    return nodes;\n}\nexports.getNodesAtDepth = getNodesAtDepth;\n/**\n * @see getNodesAtDepth but instead of pushing to an array, it yields\n */\nfunction* iterateNodesAtDepth(rootNode, depth, startIndex, count) {\n    const endIndex = startIndex + count;\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = depth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Contiguous filled stack of parent nodes. It get filled in the first descent\n    // Indexed by depthi\n    const parentNodeStack = new Array(depth);\n    const isLeftStack = new Array(depth);\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    for (let index = startIndex; index < endIndex; index++) {\n        for (let d = depthi; d >= depthiParent; d--) {\n            if (d !== depthi) {\n                parentNodeStack[d] = node;\n            }\n            const isLeft = isLeftNode(d, index);\n            isLeftStack[d] = isLeft;\n            node = isLeft ? node.left : node.right;\n        }\n        yield node;\n        // Find the first depth where navigation when left.\n        // Store that height and go right from there\n        for (let d = depthiParent; d <= depthiRoot; d++) {\n            if (isLeftStack[d] === true) {\n                depthi = d;\n                break;\n            }\n        }\n        node = parentNodeStack[depthi];\n    }\n}\nexports.iterateNodesAtDepth = iterateNodesAtDepth;\n/**\n * Zero's all nodes right of index with constant depth of `nodesDepth`.\n *\n * For example, zero-ing this tree at depth 2 after index 0\n * ```\n *    X              X\n *  X   X    ->    X   0\n * X X X X        X 0 0 0\n * ```\n *\n * Or, zero-ing this tree at depth 3 after index 2\n * ```\n *        X                     X\n *    X       X             X       0\n *  X   X   X   X    ->   X   X   0   0\n * X X X X X X X X       X X X 0 0 0 0 0\n * ```\n *\n * The strategy is to first navigate down to `nodesDepth` and `index` and keep a stack of parents.\n * Then navigate up re-binding:\n * - If navigated to the left rebind with zeroNode()\n * - If navigated to the right rebind with parent.left from the stack\n */\nfunction treeZeroAfterIndex(rootNode, nodesDepth, index) {\n    // depth depthi   gindexes   indexes\n    // 0     1           1          0\n    // 1     0         2   3      0   1\n    // 2     -        4 5 6 7    0 1 2 3\n    // '10' means, at depth 1, node is at the left\n    //\n    // For index N check if the bit at position depthi is set to navigate right at depthi\n    // ```\n    // mask = 1 << depthi\n    // goRight = (N & mask) == mask\n    // ```\n    // Degenerate case where tree is zero after a negative index (-1).\n    // All positive indexes are zero, so the entire tree is zero. Return cached zero node as root.\n    if (index < 0) {\n        return zeroNode_1.zeroNode(nodesDepth);\n    }\n    /**\n     * Contiguous filled stack of parent nodes. It get filled in the first descent\n     * Indexed by depthi\n     */\n    const parentNodeStack = new Array(nodesDepth);\n    // Ignore first bit \"1\", then substract 1 to get to the parent\n    const depthiRoot = nodesDepth - 1;\n    const depthiParent = 0;\n    let depthi = depthiRoot;\n    let node = rootNode;\n    // Insert root node to make the loop below general\n    parentNodeStack[depthiRoot] = rootNode;\n    // Navigate down until parent depth, and store the chain of nodes\n    //\n    // Stops at the depthiParent level. To rebind below down to `nodesDepth`\n    for (let d = depthi; d >= depthiParent; d--) {\n        node = isLeftNode(d, index) ? node.left : node.right;\n        parentNodeStack[d - 1] = node;\n    }\n    depthi = depthiParent;\n    // Now climb up re-binding with either zero of existing tree.\n    for (let d = depthiParent; d <= depthiRoot; d++) {\n        if (isLeftNode(d, index)) {\n            // If navigated to the left, then all the child nodes of the right node are NOT part of the new tree.\n            // So re-bind new `node` with a zeroNode at the current depth.\n            node = new node_1.BranchNode(node, zeroNode_1.zeroNode(d));\n        }\n        else {\n            // If navigated to the right, then all the child nodes of the left node are part of the new tree.\n            // So re-bind new `node` with the existing left node of the parent.\n            node = new node_1.BranchNode(parentNodeStack[d].left, node);\n        }\n    }\n    // Done, return new root node\n    return node;\n}\nexports.treeZeroAfterIndex = treeZeroAfterIndex;\n/**\n * Returns true if the `index` at `depth` is a left node, false if it is a right node.\n *\n * Supports index up to `Number.MAX_SAFE_INTEGER`.\n * In Eth2 case the biggest tree's index is 2**40 (VALIDATOR_REGISTRY_LIMIT)\n */\nfunction isLeftNode(depthi, index) {\n    if (depthi > 31) {\n        // Javascript can only do bitwise ops with 32 bit numbers.\n        // Shifting left 1 by 32 wraps around and becomes 1.\n        // Get the high part of `index` and adjust depthi\n        const indexHi = (index / 2 ** 32) >>> 0;\n        const mask = 1 << (depthi - 32);\n        return (indexHi & mask) !== mask;\n    }\n    const mask = 1 << depthi;\n    return (index & mask) !== mask;\n}\n/**\n * depth depthi   gindexes   indexes\n * 0     1           1          0\n * 1     0         2   3      0   1\n * 2     -        4 5 6 7    0 1 2 3\n *\n * **Conditions**:\n * - `from` and `to` must not be equal\n *\n * @param from Index\n * @param to Index\n */\nfunction findDiffDepthi(from, to) {\n    return (\n    // (0,0) -> 0 | (0,1) -> 1 | (0,2) -> 2\n    Math.ceil(Math.log2(-~(from ^ to))) -\n        // Must offset by one to match the depthi scale\n        1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}