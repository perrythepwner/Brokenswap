{"ast":null,"code":"import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo}from'@celo/react-celo';import{useEffect,useMemo,useRef}from'react';import{useDispatch,useSelector}from'react-redux';import{useMulticallContract}from'../../hooks/useContract';import useDebounce from'../../hooks/useDebounce';import chunkArray from'../../utils/chunkArray';import{CancelledError,retry,RetryableError}from'../../utils/retry';import{useBlockNumber}from'../application/hooks';import{errorFetchingMulticallResults,fetchingMulticallResults,parseCallKey,updateMulticallResults}from'./actions';// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE=500;/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */function fetchChunk(_x,_x2,_x3){return _fetchChunk.apply(this,arguments);}/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */function _fetchChunk(){_fetchChunk=_asyncToGenerator(function*(multicallContract,chunk,minBlockNumber){console.debug('Fetching chunk',multicallContract,chunk,minBlockNumber);let resultsBlockNumber,returnData;try{;[resultsBlockNumber,returnData]=yield multicallContract.aggregate(chunk.map(obj=>[obj.address,obj.callData]));}catch(error){console.debug('Failed to fetch chunk inside retry',error);throw error;}if(resultsBlockNumber.toNumber()<minBlockNumber){console.debug(\"Fetched results for old block number: \".concat(resultsBlockNumber.toString(),\" vs. \").concat(minBlockNumber));throw new RetryableError('Fetched for old block number');}return{results:returnData,blockNumber:resultsBlockNumber.toNumber()};});return _fetchChunk.apply(this,arguments);}export function activeListeningKeys(allListeners,chainId){if(!allListeners||!chainId)return{};const listeners=allListeners[chainId];if(!listeners)return{};return Object.keys(listeners).reduce((memo,callKey)=>{const keyListeners=listeners[callKey];memo[callKey]=Object.keys(keyListeners).filter(key=>{const blocksPerFetch=parseInt(key);if(blocksPerFetch<=0)return false;return keyListeners[blocksPerFetch]>0;}).reduce((previousMin,current)=>{return Math.min(previousMin,parseInt(current));},Infinity);return memo;},{});}/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */export function outdatedListeningKeys(callResults,listeningKeys,chainId,latestBlockNumber){if(!chainId||!latestBlockNumber)return[];const results=callResults[chainId];// no results at all, load everything\nif(!results)return Object.keys(listeningKeys);return Object.keys(listeningKeys).filter(callKey=>{const blocksPerFetch=listeningKeys[callKey];const data=callResults[chainId][callKey];// no data, must fetch\nif(!data)return true;const minDataBlockNumber=latestBlockNumber-(blocksPerFetch-1);// already fetching it for a recent enough block, don't refetch it\nif(data.fetchingBlockNumber&&data.fetchingBlockNumber>=minDataBlockNumber)return false;// if data is older than minDataBlockNumber, fetch it\nreturn!data.blockNumber||data.blockNumber<minDataBlockNumber;});}export default function Updater(){const dispatch=useDispatch();const state=useSelector(state=>state.multicall);// wait for listeners to settle before triggering updates\nconst debouncedListeners=useDebounce(state.callListeners,100);const latestBlockNumber=useBlockNumber();const{network}=useCelo();const chainId=network.chainId;const multicallContract=useMulticallContract();const cancellations=useRef();const listeningKeys=useMemo(()=>{return activeListeningKeys(debouncedListeners,chainId);},[debouncedListeners,chainId]);const unserializedOutdatedCallKeys=useMemo(()=>{return outdatedListeningKeys(state.callResults,listeningKeys,chainId,latestBlockNumber);},[chainId,state.callResults,listeningKeys,latestBlockNumber]);const serializedOutdatedCallKeys=useMemo(()=>JSON.stringify(unserializedOutdatedCallKeys.sort()),[unserializedOutdatedCallKeys]);useEffect(()=>{var _cancellations$curren;if(!latestBlockNumber||!chainId||!multicallContract)return;const outdatedCallKeys=JSON.parse(serializedOutdatedCallKeys);if(outdatedCallKeys.length===0)return;const calls=outdatedCallKeys.map(key=>parseCallKey(key));const chunkedCalls=chunkArray(calls,CALL_CHUNK_SIZE);if(cancellations.current&&latestBlockNumber-((_cancellations$curren=cancellations.current)===null||_cancellations$curren===void 0?void 0:_cancellations$curren.blockNumber)>2){var _cancellations$curren2,_cancellations$curren3;(_cancellations$curren2=cancellations.current)===null||_cancellations$curren2===void 0?void 0:(_cancellations$curren3=_cancellations$curren2.cancellations)===null||_cancellations$curren3===void 0?void 0:_cancellations$curren3.forEach(c=>c());}dispatch(fetchingMulticallResults({calls,chainId,fetchingBlockNumber:latestBlockNumber}));cancellations.current={blockNumber:latestBlockNumber,cancellations:chunkedCalls.map((chunk,index)=>{const{cancel,promise}=retry(()=>fetchChunk(multicallContract,chunk,latestBlockNumber),{n:Infinity,minWait:2500,maxWait:3500});promise.then(_ref=>{let{results:returnData,blockNumber:fetchBlockNumber}=_ref;cancellations.current={cancellations:[],blockNumber:latestBlockNumber};// accumulates the length of all previous indices\nconst firstCallKeyIndex=chunkedCalls.slice(0,index).reduce((memo,curr)=>memo+curr.length,0);const lastCallKeyIndex=firstCallKeyIndex+returnData.length;dispatch(updateMulticallResults({chainId,results:outdatedCallKeys.slice(firstCallKeyIndex,lastCallKeyIndex).reduce((memo,callKey,i)=>{var _returnData$i;memo[callKey]=(_returnData$i=returnData[i])!==null&&_returnData$i!==void 0?_returnData$i:null;return memo;},{}),blockNumber:fetchBlockNumber}));}).catch(error=>{if(error instanceof CancelledError){console.debug('Cancelled fetch for blockNumber',latestBlockNumber);return;}console.error('Failed to fetch multicall chunk',chunk,chainId,error);dispatch(errorFetchingMulticallResults({calls:chunk,chainId,fetchingBlockNumber:latestBlockNumber}));});return cancel;})};},[chainId,multicallContract,dispatch,serializedOutdatedCallKeys,latestBlockNumber]);return null;}","map":null,"metadata":{},"sourceType":"module"}