{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{useEffect,useMemo}from'react';import{useDispatch,useSelector}from'react-redux';import{useBlockNumber}from'../application/hooks';import{addMulticallListeners,parseCallKey,removeMulticallListeners,toCallKey}from'./actions';function isMethodArg(x){return['string','number'].indexOf(typeof x)!==-1;}function isValidMethodArgs(x){return x===undefined||Array.isArray(x)&&x.every(xi=>isMethodArg(xi)||Array.isArray(xi)&&xi.every(isMethodArg));}const INVALID_RESULT={valid:false,blockNumber:undefined,data:undefined};// use this options object\nexport const NEVER_RELOAD={blocksPerFetch:Infinity};// the lowest level call for subscribing to contract data\nfunction useCallsData(calls,options){const{network}=useCelo();const chainId=network.chainId;const callResults=useSelector(state=>state.multicall.callResults);const dispatch=useDispatch();const serializedCallKeys=useMemo(()=>{var _calls$filter$map$sor,_calls$filter,_calls$filter$map;return JSON.stringify((_calls$filter$map$sor=calls===null||calls===void 0?void 0:(_calls$filter=calls.filter(c=>Boolean(c)))===null||_calls$filter===void 0?void 0:(_calls$filter$map=_calls$filter.map(toCallKey))===null||_calls$filter$map===void 0?void 0:_calls$filter$map.sort())!==null&&_calls$filter$map$sor!==void 0?_calls$filter$map$sor:[]);},[calls]);// update listeners when there is an actual change that persists for at least 100ms\nuseEffect(()=>{const callKeys=JSON.parse(serializedCallKeys);if(!chainId||callKeys.length===0)return undefined;const calls=callKeys.map(key=>parseCallKey(key));dispatch(addMulticallListeners({chainId,calls,options}));return()=>{dispatch(removeMulticallListeners({chainId,calls,options}));};},[chainId,dispatch,options,serializedCallKeys]);return useMemo(()=>calls.map(call=>{var _callResults$chainId;if(!chainId||!call)return INVALID_RESULT;const result=(_callResults$chainId=callResults[chainId])===null||_callResults$chainId===void 0?void 0:_callResults$chainId[toCallKey(call)];let data;if(result!==null&&result!==void 0&&result.data&&(result===null||result===void 0?void 0:result.data)!=='0x'){data=result.data;}return{valid:true,data,blockNumber:result===null||result===void 0?void 0:result.blockNumber};}),[callResults,calls,chainId]);}const INVALID_CALL_STATE={valid:false,result:undefined,loading:false,syncing:false,error:false};const LOADING_CALL_STATE={valid:true,result:undefined,loading:true,syncing:true,error:false};function toCallState(callResult,contractInterface,fragment,latestBlockNumber){if(!callResult)return INVALID_CALL_STATE;const{valid,data,blockNumber}=callResult;if(!valid)return INVALID_CALL_STATE;if(valid&&!blockNumber)return LOADING_CALL_STATE;if(!contractInterface||!fragment||!latestBlockNumber)return LOADING_CALL_STATE;const success=data&&data.length>2;const syncing=(blockNumber!==null&&blockNumber!==void 0?blockNumber:0)<latestBlockNumber;let result=undefined;if(success&&data){try{result=contractInterface.decodeFunctionResult(fragment,data);}catch(error){console.debug('Result data parsing failed',fragment,data);return{valid:true,loading:false,error:true,syncing,result};}}return{valid:true,loading:false,syncing,result:result,error:!success};}export function useSingleContractMultipleData(contract,methodName,callInputs,options){const fragment=useMemo(()=>{var _contract$interface;return contract===null||contract===void 0?void 0:(_contract$interface=contract.interface)===null||_contract$interface===void 0?void 0:_contract$interface.getFunction(methodName);},[contract,methodName]);const calls=useMemo(()=>contract&&fragment&&callInputs&&callInputs.length>0?callInputs.map(inputs=>{return{address:contract.address,callData:contract.interface.encodeFunctionData(fragment,inputs)};}):[],[callInputs,contract,fragment]);const results=useCallsData(calls,options);const latestBlockNumber=useBlockNumber();return useMemo(()=>{return results.map(result=>toCallState(result,contract===null||contract===void 0?void 0:contract.interface,fragment,latestBlockNumber));},[fragment,contract,results,latestBlockNumber]);}export function useMultipleContractSingleData(addresses,contractInterface,methodName,callInputs,options){const fragment=useMemo(()=>contractInterface.getFunction(methodName),[contractInterface,methodName]);const callData=useMemo(()=>fragment&&isValidMethodArgs(callInputs)?contractInterface.encodeFunctionData(fragment,callInputs):undefined,[callInputs,contractInterface,fragment]);const calls=useMemo(()=>fragment&&addresses&&addresses.length>0&&callData?addresses.map(address=>{return address&&callData?{address,callData}:undefined;}):[],[addresses,callData,fragment]);const results=useCallsData(calls,options);const latestBlockNumber=useBlockNumber();return useMemo(()=>{return results.map(result=>toCallState(result,contractInterface,fragment,latestBlockNumber));},[fragment,results,contractInterface,latestBlockNumber]);}export function useSingleCallResult(contract,methodName,inputs,options){const fragment=useMemo(()=>{var _contract$interface2;return contract===null||contract===void 0?void 0:(_contract$interface2=contract.interface)===null||_contract$interface2===void 0?void 0:_contract$interface2.getFunction(methodName);},[contract,methodName]);const calls=useMemo(()=>{return contract&&fragment&&isValidMethodArgs(inputs)?[{address:contract.address,callData:contract.interface.encodeFunctionData(fragment,inputs)}]:[];},[contract,fragment,inputs]);const result=useCallsData(calls,options)[0];const latestBlockNumber=useBlockNumber();return useMemo(()=>{return toCallState(result,contract===null||contract===void 0?void 0:contract.interface,fragment,latestBlockNumber);},[result,contract,fragment,latestBlockNumber]);}","map":{"version":3,"names":["useCelo","useEffect","useMemo","useDispatch","useSelector","useBlockNumber","addMulticallListeners","parseCallKey","removeMulticallListeners","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","network","chainId","callResults","state","multicall","dispatch","serializedCallKeys","_calls$filter$map$sor","_calls$filter","_calls$filter$map","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","_callResults$chainId","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","_contract$interface","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult","_contract$interface2"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/multicall/hooks.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { FunctionFragment, Interface } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addMulticallListeners,\n  Call,\n  ListenerOptions,\n  parseCallKey,\n  removeMulticallListeners,\n  toCallKey,\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const { network } = useCelo()\n  const chainId = network.chainId\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(\n    (state) => state.multicall.callResults\n  )\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map((key) => parseCallKey(key))\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options,\n      })\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options,\n        })\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>((call) => {\n        if (!chainId || !call) return INVALID_RESULT\n\n        const result = callResults[chainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, chainId]\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success,\n  }\n}\n\nexport function useSingleContractMultipleData<T extends Contract = Contract>(\n  contract: T | null | undefined,\n  methodName: keyof T['estimateGas'] & string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions\n): readonly CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>((inputs) => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\n            }\n          })\n        : [],\n    [callInputs, contract, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: readonly (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  )\n\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>((address) => {\n            return address && callData\n              ? {\n                  address,\n                  callData,\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\n          },\n        ]\n      : []\n  }, [contract, fragment, inputs])\n\n  const result = useCallsData(calls, options)[0]\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\n  }, [result, contract, fragment, latestBlockNumber])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}