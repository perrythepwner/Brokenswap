{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport jt, { EventEmitter as N } from \"events\";\nimport Yt from \"@walletconnect/keyvaluestorage\";\nimport { HEARTBEAT_EVENTS as j, HeartBeat as Gt } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger as f, getLoggerContext as E, pino as ye, getDefaultLoggerOptions as me } from \"@walletconnect/logger\";\nimport { IMessageTracker as Ht, IPublisher as Jt, ISubscriber as Wt, IRelayer as Xt, IStore as Qt, IJsonRpcHistory as Zt, IExpirer as ei, IVerify as ti, ICore as ii } from \"@walletconnect/types\";\nimport { safeJsonStringify as si, safeJsonParse as ri } from \"@walletconnect/safe-json\";\nimport * as Y from \"@walletconnect/relay-auth\";\nimport { getInternalError as l, mapToObj as be, objToMap as fe, generateKeyPair as ni, generateRandomBytes32 as te, deriveSymKey as ai, hashKey as oi, validateEncoding as hi, isTypeOneEnvelope as Ee, encrypt as ci, validateDecoding as ui, decrypt as li, deserialize as we, decodeTypeByte as di, BASE16 as gi, hashMessage as ie, getRelayProtocolName as se, createExpiringPromise as M, getRelayProtocolApi as G, isUndefined as re, getSdkError as k, isValidArray as pi, isOnline as ve, formatRelayRpcUrl as Di, subscribeToNetworkChange as yi, isProposalStruct as mi, isSessionStruct as bi, TYPE_1 as fi, calcExpiry as H, formatUri as Ei, parseUri as wi, createDelayedPromise as vi, engineEvent as ne, isExpired as Ie, isValidParams as ae, isValidUrl as Ii, isValidString as Ci, parseExpirerTarget as Ri, formatTopicTarget as _i, formatIdTarget as Si, isReactNative as Pi, isBrowser as Ti, isNode as xi } from \"@walletconnect/utils\";\nimport { toString as Oi } from \"uint8arrays\";\nimport { ONE_DAY as L, SIX_HOURS as Ai, ONE_SECOND as Ce, THIRTY_DAYS as J, FIVE_SECONDS as Re, THIRTY_SECONDS as _e, toMiliseconds as U, TEN_SECONDS as zi, Watch as Ni, FIVE_MINUTES as Se } from \"@walletconnect/time\";\nimport { JsonRpcProvider as Li } from \"@walletconnect/jsonrpc-provider\";\nimport { getBigIntRpcId as Ui, isJsonRpcRequest as Pe, isJsonRpcResponse as Te, formatJsonRpcResult as xe, formatJsonRpcRequest as Oe, formatJsonRpcError as Fi, isJsonRpcResult as $i, isJsonRpcError as Ae } from \"@walletconnect/jsonrpc-utils\";\nimport Mi from \"@walletconnect/jsonrpc-ws-connection\";\nimport ki from \"lodash.isequal\";\nfunction Ki(r, e) {\n  if (r.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n  for (var s = 0; s < r.length; s++) {\n    var n = r.charAt(s),\n      a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = s;\n  }\n  var o = r.length,\n    h = r.charAt(0),\n    u = Math.log(o) / Math.log(256),\n    d = Math.log(256) / Math.log(o);\n  function p(c) {\n    if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (c.length === 0) return \"\";\n    for (var m = 0, z = 0, I = 0, _ = c.length; I !== _ && c[I] === 0;) I++, m++;\n    for (var S = (_ - I) * d + 1 >>> 0, b = new Uint8Array(S); I !== _;) {\n      for (var P = c[I], A = 0, C = S - 1; (P !== 0 || A < z) && C !== -1; C--, A++) P += 256 * b[C] >>> 0, b[C] = P % o >>> 0, P = P / o >>> 0;\n      if (P !== 0) throw new Error(\"Non-zero carry\");\n      z = A, I++;\n    }\n    for (var x = S - z; x !== S && b[x] === 0;) x++;\n    for (var q = h.repeat(m); x < S; ++x) q += r.charAt(b[x]);\n    return q;\n  }\n  function y(c) {\n    if (typeof c != \"string\") throw new TypeError(\"Expected String\");\n    if (c.length === 0) return new Uint8Array();\n    var m = 0;\n    if (c[m] !== \" \") {\n      for (var z = 0, I = 0; c[m] === h;) z++, m++;\n      for (var _ = (c.length - m) * u + 1 >>> 0, S = new Uint8Array(_); c[m];) {\n        var b = t[c.charCodeAt(m)];\n        if (b === 255) return;\n        for (var P = 0, A = _ - 1; (b !== 0 || P < I) && A !== -1; A--, P++) b += o * S[A] >>> 0, S[A] = b % 256 >>> 0, b = b / 256 >>> 0;\n        if (b !== 0) throw new Error(\"Non-zero carry\");\n        I = P, m++;\n      }\n      if (c[m] !== \" \") {\n        for (var C = _ - I; C !== _ && S[C] === 0;) C++;\n        for (var x = new Uint8Array(z + (_ - C)), q = z; C !== _;) x[q++] = S[C++];\n        return x;\n      }\n    }\n  }\n  function $(c) {\n    var m = y(c);\n    if (m) return m;\n    throw new Error(\"Non-\".concat(e, \" character\"));\n  }\n  return {\n    encode: p,\n    decodeUnsafe: y,\n    decode: $\n  };\n}\nvar Bi = Ki,\n  Vi = Bi;\nconst ze = r => {\n    if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\") return r;\n    if (r instanceof ArrayBuffer) return new Uint8Array(r);\n    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  qi = r => new TextEncoder().encode(r),\n  ji = r => new TextDecoder().decode(r);\nclass Yi {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return \"\".concat(this.prefix).concat(this.baseEncode(e));\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Gi {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(\"Unable to decode multibase string \".concat(JSON.stringify(e), \", \").concat(this.name, \" decoder only supports inputs prefixed with \").concat(this.prefix));\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Ne(this, e);\n  }\n}\nclass Hi {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Ne(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(\"Unable to decode multibase string \".concat(JSON.stringify(e), \", only inputs prefixed with \").concat(Object.keys(this.decoders), \" are supported\"));\n  }\n}\nconst Ne = (r, e) => new Hi(_objectSpread(_objectSpread({}, r.decoders || {\n  [r.prefix]: r\n}), e.decoders || {\n  [e.prefix]: e\n}));\nclass Ji {\n  constructor(e, t, i, s) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = s, this.encoder = new Yi(e, t, i), this.decoder = new Gi(e, t, s);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst W = _ref => {\n    let {\n      name: r,\n      prefix: e,\n      encode: t,\n      decode: i\n    } = _ref;\n    return new Ji(r, e, t, i);\n  },\n  K = _ref2 => {\n    let {\n      prefix: r,\n      name: e,\n      alphabet: t\n    } = _ref2;\n    const {\n      encode: i,\n      decode: s\n    } = Vi(t, e);\n    return W({\n      prefix: r,\n      name: e,\n      encode: i,\n      decode: n => ze(s(n))\n    });\n  },\n  Wi = (r, e, t, i) => {\n    const s = {};\n    for (let d = 0; d < e.length; ++d) s[e[d]] = d;\n    let n = r.length;\n    for (; r[n - 1] === \"=\";) --n;\n    const a = new Uint8Array(n * t / 8 | 0);\n    let o = 0,\n      h = 0,\n      u = 0;\n    for (let d = 0; d < n; ++d) {\n      const p = s[r[d]];\n      if (p === void 0) throw new SyntaxError(\"Non-\".concat(i, \" character\"));\n      h = h << t | p, o += t, o >= 8 && (o -= 8, a[u++] = 255 & h >> o);\n    }\n    if (o >= t || 255 & h << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  Xi = (r, e, t) => {\n    const i = e[e.length - 1] === \"=\",\n      s = (1 << t) - 1;\n    let n = \"\",\n      a = 0,\n      o = 0;\n    for (let h = 0; h < r.length; ++h) for (o = o << 8 | r[h], a += 8; a > t;) a -= t, n += e[s & o >> a];\n    if (a && (n += e[s & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n    return n;\n  },\n  g = _ref3 => {\n    let {\n      name: r,\n      prefix: e,\n      bitsPerChar: t,\n      alphabet: i\n    } = _ref3;\n    return W({\n      prefix: e,\n      name: r,\n      encode(s) {\n        return Xi(s, i, t);\n      },\n      decode(s) {\n        return Wi(s, i, t, r);\n      }\n    });\n  },\n  Qi = W({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: r => ji(r),\n    decode: r => qi(r)\n  });\nvar Zi = Object.freeze({\n  __proto__: null,\n  identity: Qi\n});\nconst es = g({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar ts = Object.freeze({\n  __proto__: null,\n  base2: es\n});\nconst is = g({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar ss = Object.freeze({\n  __proto__: null,\n  base8: is\n});\nconst rs = K({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar ns = Object.freeze({\n  __proto__: null,\n  base10: rs\n});\nconst as = g({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  os = g({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar hs = Object.freeze({\n  __proto__: null,\n  base16: as,\n  base16upper: os\n});\nconst cs = g({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  us = g({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  ls = g({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  ds = g({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  gs = g({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  ps = g({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  Ds = g({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  ys = g({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  ms = g({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar bs = Object.freeze({\n  __proto__: null,\n  base32: cs,\n  base32upper: us,\n  base32pad: ls,\n  base32padupper: ds,\n  base32hex: gs,\n  base32hexupper: ps,\n  base32hexpad: Ds,\n  base32hexpadupper: ys,\n  base32z: ms\n});\nconst fs = K({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  Es = K({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar ws = Object.freeze({\n  __proto__: null,\n  base36: fs,\n  base36upper: Es\n});\nconst vs = K({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  Is = K({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar Cs = Object.freeze({\n  __proto__: null,\n  base58btc: vs,\n  base58flickr: Is\n});\nconst Rs = g({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  _s = g({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  Ss = g({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  Ps = g({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar Ts = Object.freeze({\n  __proto__: null,\n  base64: Rs,\n  base64pad: _s,\n  base64url: Ss,\n  base64urlpad: Ps\n});\nconst Le = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  xs = Le.reduce((r, e, t) => (r[t] = e, r), []),\n  Os = Le.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction As(r) {\n  return r.reduce((e, t) => (e += xs[t], e), \"\");\n}\nfunction zs(r) {\n  const e = [];\n  for (const t of r) {\n    const i = Os[t.codePointAt(0)];\n    if (i === void 0) throw new Error(\"Non-base256emoji character: \".concat(t));\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst Ns = W({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: As,\n  decode: zs\n});\nvar Ls = Object.freeze({\n    __proto__: null,\n    base256emoji: Ns\n  }),\n  Us = Fe,\n  Ue = 128,\n  Fs = 127,\n  $s = ~Fs,\n  Ms = Math.pow(2, 31);\nfunction Fe(r, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; r >= Ms;) e[t++] = r & 255 | Ue, r /= 128;\n  for (; r & $s;) e[t++] = r & 255 | Ue, r >>>= 7;\n  return e[t] = r | 0, Fe.bytes = t - i + 1, e;\n}\nvar ks = oe,\n  Ks = 128,\n  $e = 127;\nfunction oe(r, i) {\n  var t = 0,\n    i = i || 0,\n    s = 0,\n    n = i,\n    a,\n    o = r.length;\n  do {\n    if (n >= o) throw oe.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = r[n++], t += s < 28 ? (a & $e) << s : (a & $e) * Math.pow(2, s), s += 7;\n  } while (a >= Ks);\n  return oe.bytes = n - i, t;\n}\nvar Bs = Math.pow(2, 7),\n  Vs = Math.pow(2, 14),\n  qs = Math.pow(2, 21),\n  js = Math.pow(2, 28),\n  Ys = Math.pow(2, 35),\n  Gs = Math.pow(2, 42),\n  Hs = Math.pow(2, 49),\n  Js = Math.pow(2, 56),\n  Ws = Math.pow(2, 63),\n  Xs = function Xs(r) {\n    return r < Bs ? 1 : r < Vs ? 2 : r < qs ? 3 : r < js ? 4 : r < Ys ? 5 : r < Gs ? 6 : r < Hs ? 7 : r < Js ? 8 : r < Ws ? 9 : 10;\n  },\n  Qs = {\n    encode: Us,\n    decode: ks,\n    encodingLength: Xs\n  },\n  Me = Qs;\nconst ke = function ke(r, e) {\n    let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    return Me.encode(r, e, t), e;\n  },\n  Ke = r => Me.encodingLength(r),\n  he = (r, e) => {\n    const t = e.byteLength,\n      i = Ke(r),\n      s = i + Ke(t),\n      n = new Uint8Array(s + t);\n    return ke(r, n, 0), ke(t, n, i), n.set(e, s), new Zs(r, t, e, n);\n  };\nclass Zs {\n  constructor(e, t, i, s) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = s;\n  }\n}\nconst Be = _ref4 => {\n  let {\n    name: r,\n    code: e,\n    encode: t\n  } = _ref4;\n  return new er(r, e, t);\n};\nclass er {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? he(this.code, t) : t.then(i => he(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst Ve = r => /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator(function* (e) {\n      return new Uint8Array(yield crypto.subtle.digest(r, e));\n    });\n    return function (_x) {\n      return _ref5.apply(this, arguments);\n    };\n  }(),\n  tr = Be({\n    name: \"sha2-256\",\n    code: 18,\n    encode: Ve(\"SHA-256\")\n  }),\n  ir = Be({\n    name: \"sha2-512\",\n    code: 19,\n    encode: Ve(\"SHA-512\")\n  });\nvar sr = Object.freeze({\n  __proto__: null,\n  sha256: tr,\n  sha512: ir\n});\nconst qe = 0,\n  rr = \"identity\",\n  je = ze,\n  nr = r => he(qe, je(r)),\n  ar = {\n    code: qe,\n    name: rr,\n    encode: je,\n    digest: nr\n  };\nvar or = Object.freeze({\n  __proto__: null,\n  identity: ar\n});\nnew TextEncoder(), new TextDecoder();\nconst Ye = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, Zi), ts), ss), ns), hs), bs), ws), Cs), Ts), Ls);\n_objectSpread(_objectSpread({}, sr), or);\nfunction Ge(r) {\n  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;\n}\nfunction hr() {\n  let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);\n}\nfunction He(r, e, t, i) {\n  return {\n    name: r,\n    prefix: e,\n    encoder: {\n      name: r,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Je = He(\"utf8\", \"u\", r => \"u\" + new TextDecoder(\"utf8\").decode(r), r => new TextEncoder().encode(r.substring(1))),\n  ce = He(\"ascii\", \"a\", r => {\n    let e = \"a\";\n    for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);\n    return e;\n  }, r => {\n    r = r.substring(1);\n    const e = hr(r.length);\n    for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);\n    return e;\n  }),\n  cr = _objectSpread({\n    utf8: Je,\n    \"utf-8\": Je,\n    hex: Ye.base16,\n    latin1: ce,\n    ascii: ce,\n    binary: ce\n  }, Ye);\nfunction ur(r) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n  const t = cr[e];\n  if (!t) throw new Error(\"Unsupported encoding \\\"\".concat(e, \"\\\"\"));\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge(globalThis.Buffer.from(r, \"utf-8\")) : t.decoder.decode(\"\".concat(t.prefix).concat(r));\n}\nconst ue = \"wc\",\n  We = 2,\n  X = \"core\",\n  O = \"\".concat(ue, \"@2:\").concat(X, \":\"),\n  Xe = {\n    name: X,\n    logger: \"error\"\n  },\n  Qe = {\n    database: \":memory:\"\n  },\n  Ze = \"crypto\",\n  le = \"client_ed25519_seed\",\n  et = L,\n  tt = \"keychain\",\n  it = \"0.3\",\n  st = \"messages\",\n  rt = \"0.3\",\n  nt = Ai,\n  at = \"publisher\",\n  ot = \"irn\",\n  ht = \"error\",\n  de = \"wss://relay.walletconnect.com\",\n  ge = \"wss://relay.walletconnect.org\",\n  ct = \"relayer\",\n  D = {\n    message: \"relayer_message\",\n    message_ack: \"relayer_message_ack\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  ut = \"_subscription\",\n  T = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  lt = Ce,\n  lr = {\n    database: \":memory:\"\n  },\n  dt = \"2.10.2\",\n  gt = 1e4,\n  pt = \"0.3\",\n  Dt = \"WALLETCONNECT_CLIENT_ID\",\n  w = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  dr = J,\n  yt = \"subscription\",\n  mt = \"0.3\",\n  bt = Re * 1e3,\n  ft = \"pairing\",\n  Et = \"0.3\",\n  gr = J,\n  F = {\n    wc_pairingDelete: {\n      req: {\n        ttl: L,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: L,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: _e,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: _e,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: L,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: L,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  B = {\n    create: \"pairing_create\",\n    expire: \"pairing_expire\",\n    delete: \"pairing_delete\",\n    ping: \"pairing_ping\"\n  },\n  R = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  wt = \"history\",\n  vt = \"0.3\",\n  It = \"expirer\",\n  v = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  Ct = \"0.3\",\n  pr = L,\n  Q = \"verify-api\",\n  Z = \"https://verify.walletconnect.com\",\n  pe = \"https://verify.walletconnect.org\";\nclass Rt {\n  constructor(e, t) {\n    var _this = this;\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = tt, this.version = it, this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      if (!_this.initialized) {\n        const i = yield _this.getKeyChain();\n        typeof i < \"u\" && (_this.keychain = i), _this.initialized = !0;\n      }\n    }), this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator(function* (i, s) {\n        _this.isInitialized(), _this.keychain.set(i, s), yield _this.persist();\n      });\n      return function (_x2, _x3) {\n        return _ref7.apply(this, arguments);\n      };\n    }(), this.get = i => {\n      this.isInitialized();\n      const s = this.keychain.get(i);\n      if (typeof s > \"u\") {\n        const {\n          message: n\n        } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(i));\n        throw new Error(n);\n      }\n      return s;\n    }, this.del = /*#__PURE__*/function () {\n      var _ref8 = _asyncToGenerator(function* (i) {\n        _this.isInitialized(), _this.keychain.delete(i), yield _this.persist();\n      });\n      return function (_x4) {\n        return _ref8.apply(this, arguments);\n      };\n    }(), this.core = e, this.logger = f(t, this.name);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  setKeyChain(e) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.core.storage.setItem(_this2.storageKey, be(e));\n    })();\n  }\n  getKeyChain() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const e = yield _this3.core.storage.getItem(_this3.storageKey);\n      return typeof e < \"u\" ? fe(e) : void 0;\n    })();\n  }\n  persist() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.setKeyChain(_this4.keychain);\n    })();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass _t {\n  constructor(e, t, i) {\n    var _this5 = this;\n    this.core = e, this.logger = t, this.name = Ze, this.initialized = !1, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this5.initialized || (yield _this5.keychain.init(), _this5.initialized = !0);\n    }), this.hasKeys = s => (this.isInitialized(), this.keychain.has(s)), this.getClientId = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this5.isInitialized();\n      const s = yield _this5.getClientSeed(),\n        n = Y.generateKeyPair(s);\n      return Y.encodeIss(n.publicKey);\n    }), this.generateKeyPair = () => {\n      this.isInitialized();\n      const s = ni();\n      return this.setPrivateKey(s.publicKey, s.privateKey);\n    }, this.signJWT = /*#__PURE__*/function () {\n      var _ref11 = _asyncToGenerator(function* (s) {\n        _this5.isInitialized();\n        const n = yield _this5.getClientSeed(),\n          a = Y.generateKeyPair(n),\n          o = te(),\n          h = et;\n        return yield Y.signJWT(o, s, h, a);\n      });\n      return function (_x5) {\n        return _ref11.apply(this, arguments);\n      };\n    }(), this.generateSharedKey = (s, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(s),\n        h = ai(o, n);\n      return this.setSymKey(h, a);\n    }, this.setSymKey = /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator(function* (s, n) {\n        _this5.isInitialized();\n        const a = n || oi(s);\n        return yield _this5.keychain.set(a, s), a;\n      });\n      return function (_x6, _x7) {\n        return _ref12.apply(this, arguments);\n      };\n    }(), this.deleteKeyPair = /*#__PURE__*/function () {\n      var _ref13 = _asyncToGenerator(function* (s) {\n        _this5.isInitialized(), yield _this5.keychain.del(s);\n      });\n      return function (_x8) {\n        return _ref13.apply(this, arguments);\n      };\n    }(), this.deleteSymKey = /*#__PURE__*/function () {\n      var _ref14 = _asyncToGenerator(function* (s) {\n        _this5.isInitialized(), yield _this5.keychain.del(s);\n      });\n      return function (_x9) {\n        return _ref14.apply(this, arguments);\n      };\n    }(), this.encode = /*#__PURE__*/function () {\n      var _ref15 = _asyncToGenerator(function* (s, n, a) {\n        _this5.isInitialized();\n        const o = hi(a),\n          h = si(n);\n        if (Ee(o)) {\n          const y = o.senderPublicKey,\n            $ = o.receiverPublicKey;\n          s = yield _this5.generateSharedKey(y, $);\n        }\n        const u = _this5.getSymKey(s),\n          {\n            type: d,\n            senderPublicKey: p\n          } = o;\n        return ci({\n          type: d,\n          symKey: u,\n          message: h,\n          senderPublicKey: p\n        });\n      });\n      return function (_x10, _x11, _x12) {\n        return _ref15.apply(this, arguments);\n      };\n    }(), this.decode = /*#__PURE__*/function () {\n      var _ref16 = _asyncToGenerator(function* (s, n, a) {\n        _this5.isInitialized();\n        const o = ui(n, a);\n        if (Ee(o)) {\n          const h = o.receiverPublicKey,\n            u = o.senderPublicKey;\n          s = yield _this5.generateSharedKey(h, u);\n        }\n        try {\n          const h = _this5.getSymKey(s),\n            u = li({\n              symKey: h,\n              encoded: n\n            });\n          return ri(u);\n        } catch (h) {\n          _this5.logger.error(\"Failed to decode message from topic: '\".concat(s, \"', clientId: '\").concat(yield _this5.getClientId(), \"'\")), _this5.logger.error(h);\n        }\n      });\n      return function (_x13, _x14, _x15) {\n        return _ref16.apply(this, arguments);\n      };\n    }(), this.getPayloadType = s => {\n      const n = we(s);\n      return di(n.type);\n    }, this.getPayloadSenderPublicKey = s => {\n      const n = we(s);\n      return n.senderPublicKey ? Oi(n.senderPublicKey, gi) : void 0;\n    }, this.core = e, this.logger = f(t, this.name), this.keychain = i || new Rt(this.core, this.logger);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  setPrivateKey(e, t) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this6.keychain.set(e, t), e;\n    })();\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  getClientSeed() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      let e = \"\";\n      try {\n        e = _this7.keychain.get(le);\n      } catch (_unused) {\n        e = te(), yield _this7.keychain.set(le, e);\n      }\n      return ur(e, \"base16\");\n    })();\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass St extends Ht {\n  constructor(e, t) {\n    var _this8;\n    (super(e, t), _this8 = this), this.logger = e, this.core = t, this.messages = new Map(), this.name = st, this.version = rt, this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      if (!_this8.initialized) {\n        _this8.logger.trace(\"Initialized\");\n        try {\n          const i = yield _this8.getRelayerMessages();\n          typeof i < \"u\" && (_this8.messages = i), _this8.logger.debug(\"Successfully Restored records for \".concat(_this8.name)), _this8.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: _this8.messages.size\n          });\n        } catch (i) {\n          _this8.logger.debug(\"Failed to Restore records for \".concat(_this8.name)), _this8.logger.error(i);\n        } finally {\n          _this8.initialized = !0;\n        }\n      }\n    }), this.set = /*#__PURE__*/function () {\n      var _ref18 = _asyncToGenerator(function* (i, s) {\n        _this8.isInitialized();\n        const n = ie(s);\n        let a = _this8.messages.get(i);\n        return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = s, _this8.messages.set(i, a), yield _this8.persist()), n;\n      });\n      return function (_x16, _x17) {\n        return _ref18.apply(this, arguments);\n      };\n    }(), this.get = i => {\n      this.isInitialized();\n      let s = this.messages.get(i);\n      return typeof s > \"u\" && (s = {}), s;\n    }, this.has = (i, s) => {\n      this.isInitialized();\n      const n = this.get(i),\n        a = ie(s);\n      return typeof n[a] < \"u\";\n    }, this.del = /*#__PURE__*/function () {\n      var _ref19 = _asyncToGenerator(function* (i) {\n        _this8.isInitialized(), _this8.messages.delete(i), yield _this8.persist();\n      });\n      return function (_x18) {\n        return _ref19.apply(this, arguments);\n      };\n    }(), this.logger = f(e, this.name), this.core = t;\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  setRelayerMessages(e) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.core.storage.setItem(_this9.storageKey, be(e));\n    })();\n  }\n  getRelayerMessages() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const e = yield _this10.core.storage.getItem(_this10.storageKey);\n      return typeof e < \"u\" ? fe(e) : void 0;\n    })();\n  }\n  persist() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      yield _this11.setRelayerMessages(_this11.messages);\n    })();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Dr extends Jt {\n  constructor(e, t) {\n    var _this12;\n    (super(e, t), _this12 = this), this.relayer = e, this.logger = t, this.events = new N(), this.name = at, this.queue = new Map(), this.publishTimeout = U(zi), this.needsTransportRestart = !1, this.publish = /*#__PURE__*/function () {\n      var _ref20 = _asyncToGenerator(function* (i, s, n) {\n        var a;\n        _this12.logger.debug(\"Publishing Payload\"), _this12.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: s,\n            opts: n\n          }\n        });\n        try {\n          const o = (n === null || n === void 0 ? void 0 : n.ttl) || nt,\n            h = se(n),\n            u = (n === null || n === void 0 ? void 0 : n.prompt) || !1,\n            d = (n === null || n === void 0 ? void 0 : n.tag) || 0,\n            p = (n === null || n === void 0 ? void 0 : n.id) || Ui().toString(),\n            y = {\n              topic: i,\n              message: s,\n              opts: {\n                ttl: o,\n                relay: h,\n                prompt: u,\n                tag: d,\n                id: p\n              }\n            },\n            $ = setTimeout(() => _this12.queue.set(p, y), _this12.publishTimeout);\n          try {\n            yield yield M(_this12.rpcPublish(i, s, o, h, u, d, p), _this12.publishTimeout, \"Failed to publish payload, please try again.\"), _this12.removeRequestFromQueue(p), _this12.relayer.events.emit(D.publish, y);\n          } catch (c) {\n            if (_this12.logger.debug(\"Publishing Payload stalled\"), _this12.needsTransportRestart = !0, (a = n === null || n === void 0 ? void 0 : n.internal) != null && a.throwOnFailedPublish) throw _this12.removeRequestFromQueue(p), c;\n            return;\n          } finally {\n            clearTimeout($);\n          }\n          _this12.logger.debug(\"Successfully Published Payload\"), _this12.logger.trace({\n            type: \"method\",\n            method: \"publish\",\n            params: {\n              topic: i,\n              message: s,\n              opts: n\n            }\n          });\n        } catch (o) {\n          throw _this12.logger.debug(\"Failed to Publish Payload\"), _this12.logger.error(o), o;\n        }\n      });\n      return function (_x19, _x20, _x21) {\n        return _ref20.apply(this, arguments);\n      };\n    }(), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.relayer = e, this.logger = f(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return E(this.logger);\n  }\n  rpcPublish(e, t, i, s, n, a, o) {\n    var h, u, d, p;\n    const y = {\n      method: G(s.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      },\n      id: o\n    };\n    return re((h = y.params) == null ? void 0 : h.prompt) && ((u = y.params) == null || delete u.prompt), re((d = y.params) == null ? void 0 : d.tag) && ((p = y.params) == null || delete p.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: y\n    }), this.relayer.request(y);\n  }\n  removeRequestFromQueue(e) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    var _this13 = this;\n    this.queue.forEach( /*#__PURE__*/function () {\n      var _ref21 = _asyncToGenerator(function* (e) {\n        const {\n          topic: t,\n          message: i,\n          opts: s\n        } = e;\n        yield _this13.publish(t, i, s);\n      });\n      return function (_x22) {\n        return _ref21.apply(this, arguments);\n      };\n    }());\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(j.pulse, () => {\n      if (this.needsTransportRestart) {\n        this.needsTransportRestart = !1, this.relayer.events.emit(D.connection_stalled);\n        return;\n      }\n      this.checkQueue();\n    }), this.relayer.on(D.message_ack, e => {\n      this.removeRequestFromQueue(e.id.toString());\n    });\n  }\n}\nclass yr {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const s = i.filter(n => n !== t);\n      if (!s.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, s);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar mr = Object.defineProperty,\n  br = Object.defineProperties,\n  fr = Object.getOwnPropertyDescriptors,\n  Pt = Object.getOwnPropertySymbols,\n  Er = Object.prototype.hasOwnProperty,\n  wr = Object.prototype.propertyIsEnumerable,\n  Tt = (r, e, t) => e in r ? mr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  V = (r, e) => {\n    for (var t in e || (e = {})) Er.call(e, t) && Tt(r, t, e[t]);\n    if (Pt) for (var t of Pt(e)) wr.call(e, t) && Tt(r, t, e[t]);\n    return r;\n  },\n  De = (r, e) => br(r, fr(e));\nclass xt extends Wt {\n  constructor(e, t) {\n    var _this14;\n    (super(e, t), _this14 = this), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new yr(), this.events = new N(), this.name = yt, this.version = mt, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pollingInterval = 20, this.storagePrefix = O, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this14.initialized || (_this14.logger.trace(\"Initialized\"), _this14.registerEventListeners(), _this14.clientId = yield _this14.relayer.core.crypto.getClientId());\n    }), this.subscribe = /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator(function* (i, s) {\n        yield _this14.restartToComplete(), _this14.isInitialized(), _this14.logger.debug(\"Subscribing Topic\"), _this14.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: s\n          }\n        });\n        try {\n          const n = se(s),\n            a = {\n              topic: i,\n              relay: n\n            };\n          _this14.pending.set(i, a);\n          const o = yield _this14.rpcSubscribe(i, n);\n          return _this14.onSubscribe(o, a), _this14.logger.debug(\"Successfully Subscribed Topic\"), _this14.logger.trace({\n            type: \"method\",\n            method: \"subscribe\",\n            params: {\n              topic: i,\n              opts: s\n            }\n          }), o;\n        } catch (n) {\n          throw _this14.logger.debug(\"Failed to Subscribe Topic\"), _this14.logger.error(n), n;\n        }\n      });\n      return function (_x23, _x24) {\n        return _ref23.apply(this, arguments);\n      };\n    }(), this.unsubscribe = /*#__PURE__*/function () {\n      var _ref24 = _asyncToGenerator(function* (i, s) {\n        yield _this14.restartToComplete(), _this14.isInitialized(), typeof (s === null || s === void 0 ? void 0 : s.id) < \"u\" ? yield _this14.unsubscribeById(i, s.id, s) : yield _this14.unsubscribeByTopic(i, s);\n      });\n      return function (_x25, _x26) {\n        return _ref24.apply(this, arguments);\n      };\n    }(), this.isSubscribed = /*#__PURE__*/function () {\n      var _ref25 = _asyncToGenerator(function* (i) {\n        return _this14.topics.includes(i) ? !0 : yield new Promise((s, n) => {\n          const a = new Ni();\n          a.start(_this14.pendingSubscriptionWatchLabel);\n          const o = setInterval(() => {\n            !_this14.pending.has(i) && _this14.topics.includes(i) && (clearInterval(o), a.stop(_this14.pendingSubscriptionWatchLabel), s(!0)), a.elapsed(_this14.pendingSubscriptionWatchLabel) >= bt && (clearInterval(o), a.stop(_this14.pendingSubscriptionWatchLabel), n(new Error(\"Subscription resolution timeout\")));\n          }, _this14.pollingInterval);\n        }).catch(() => !1);\n      });\n      return function (_x27) {\n        return _ref25.apply(this, arguments);\n      };\n    }(), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.restart = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this14.restartInProgress = !0, yield _this14.restore(), yield _this14.reset(), _this14.restartInProgress = !1;\n    }), this.relayer = e, this.logger = f(t, this.name), this.clientId = \"\";\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch (_unused2) {}\n    return i;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();\n  }\n  unsubscribeByTopic(e, t) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const i = _this15.topicMap.get(e);\n      yield Promise.all(i.map( /*#__PURE__*/function () {\n        var _ref27 = _asyncToGenerator(function* (s) {\n          return yield _this15.unsubscribeById(e, s, t);\n        });\n        return function (_x28) {\n          return _ref27.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  unsubscribeById(e, t, i) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      _this16.logger.debug(\"Unsubscribing Topic\"), _this16.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n      try {\n        const s = se(i);\n        yield _this16.rpcUnsubscribe(e, t, s);\n        const n = k(\"USER_DISCONNECTED\", \"\".concat(_this16.name, \", \").concat(e));\n        yield _this16.onUnsubscribe(e, t, n), _this16.logger.debug(\"Successfully Unsubscribed Topic\"), _this16.logger.trace({\n          type: \"method\",\n          method: \"unsubscribe\",\n          params: {\n            topic: e,\n            id: t,\n            opts: i\n          }\n        });\n      } catch (s) {\n        throw _this16.logger.debug(\"Failed to Unsubscribe Topic\"), _this16.logger.error(s), s;\n      }\n    })();\n  }\n  rpcSubscribe(e, t) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const i = {\n        method: G(t.protocol).subscribe,\n        params: {\n          topic: e\n        }\n      };\n      _this17.logger.debug(\"Outgoing Relay Payload\"), _this17.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request: i\n      });\n      try {\n        yield yield M(_this17.relayer.request(i), _this17.subscribeTimeout);\n      } catch (_unused3) {\n        _this17.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"), _this17.relayer.events.emit(D.connection_stalled);\n      }\n      return ie(e + _this17.clientId);\n    })();\n  }\n  rpcBatchSubscribe(e) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (!e.length) return;\n      const t = e[0].relay,\n        i = {\n          method: G(t.protocol).batchSubscribe,\n          params: {\n            topics: e.map(s => s.topic)\n          }\n        };\n      _this18.logger.debug(\"Outgoing Relay Payload\"), _this18.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request: i\n      });\n      try {\n        return yield yield M(_this18.relayer.request(i), _this18.subscribeTimeout);\n      } catch (_unused4) {\n        _this18.logger.debug(\"Outgoing Relay Payload stalled\"), _this18.relayer.events.emit(D.connection_stalled);\n      }\n    })();\n  }\n  rpcUnsubscribe(e, t, i) {\n    const s = {\n      method: G(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    }), this.relayer.request(s);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, De(V({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onBatchSubscribe(e) {\n    e.length && e.forEach(t => {\n      this.setSubscription(t.id, V({}, t)), this.pending.delete(t.topic);\n    });\n  }\n  onUnsubscribe(e, t, i) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      _this19.events.removeAllListeners(t), _this19.hasSubscription(t, e) && _this19.deleteSubscription(t, i), yield _this19.relayer.messages.del(e);\n    })();\n  }\n  setRelayerSubscriptions(e) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      yield _this20.relayer.core.storage.setItem(_this20.storageKey, e);\n    })();\n  }\n  getRelayerSubscriptions() {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this21.relayer.core.storage.getItem(_this21.storageKey);\n    })();\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, V({}, t)), this.topicMap.set(t.topic, e), this.events.emit(w.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(w.deleted, De(V({}, i), {\n      reason: t\n    }));\n  }\n  persist() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      yield _this22.setRelayerSubscriptions(_this22.values), _this22.events.emit(w.sync);\n    })();\n  }\n  reset() {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      if (_this23.cached.length) {\n        const e = Math.ceil(_this23.cached.length / _this23.batchSubscribeTopicsLimit);\n        for (let t = 0; t < e; t++) {\n          const i = _this23.cached.splice(0, _this23.batchSubscribeTopicsLimit);\n          yield _this23.batchSubscribe(i);\n        }\n      }\n      _this23.events.emit(w.resubscribed);\n    })();\n  }\n  restore() {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this24.getRelayerSubscriptions();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this24.subscriptions.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this24.name);\n          throw _this24.logger.error(t), _this24.logger.error(\"\".concat(_this24.name, \": \").concat(JSON.stringify(_this24.values))), new Error(t);\n        }\n        _this24.cached = e, _this24.logger.debug(\"Successfully Restored subscriptions for \".concat(_this24.name)), _this24.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          subscriptions: _this24.values\n        });\n      } catch (e) {\n        _this24.logger.debug(\"Failed to Restore subscriptions for \".concat(_this24.name)), _this24.logger.error(e);\n      }\n    })();\n  }\n  batchSubscribe(e) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      if (!e.length) return;\n      const t = yield _this25.rpcBatchSubscribe(e);\n      pi(t) && _this25.onBatchSubscribe(t.map((i, s) => De(V({}, e[s]), {\n        id: i\n      })));\n    })();\n  }\n  onConnect() {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      _this26.restartInProgress || (yield _this26.restart(), _this26.onEnable());\n    })();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  checkPending() {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this27.initialized || _this27.relayer.transportExplicitlyClosed) return;\n      const e = [];\n      _this27.pending.forEach(t => {\n        e.push(t);\n      }), yield _this27.batchSubscribe(e);\n    })();\n  }\n  registerEventListeners() {\n    var _this28 = this;\n    this.relayer.core.heartbeat.on(j.pulse, /*#__PURE__*/_asyncToGenerator(function* () {\n      yield _this28.checkPending();\n    })), this.relayer.on(D.connect, /*#__PURE__*/_asyncToGenerator(function* () {\n      yield _this28.onConnect();\n    })), this.relayer.on(D.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(w.created, /*#__PURE__*/function () {\n      var _ref30 = _asyncToGenerator(function* (e) {\n        const t = w.created;\n        _this28.logger.info(\"Emitting \".concat(t)), _this28.logger.debug({\n          type: \"event\",\n          event: t,\n          data: e\n        }), yield _this28.persist();\n      });\n      return function (_x29) {\n        return _ref30.apply(this, arguments);\n      };\n    }()), this.events.on(w.deleted, /*#__PURE__*/function () {\n      var _ref31 = _asyncToGenerator(function* (e) {\n        const t = w.deleted;\n        _this28.logger.info(\"Emitting \".concat(t)), _this28.logger.debug({\n          type: \"event\",\n          event: t,\n          data: e\n        }), yield _this28.persist();\n      });\n      return function (_x30) {\n        return _ref31.apply(this, arguments);\n      };\n    }());\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  restartToComplete() {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      _this29.restartInProgress && (yield new Promise(e => {\n        const t = setInterval(() => {\n          _this29.restartInProgress || (clearInterval(t), e());\n        }, _this29.pollingInterval);\n      }));\n    })();\n  }\n}\nvar vr = Object.defineProperty,\n  Ot = Object.getOwnPropertySymbols,\n  Ir = Object.prototype.hasOwnProperty,\n  Cr = Object.prototype.propertyIsEnumerable,\n  At = (r, e, t) => e in r ? vr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  Rr = (r, e) => {\n    for (var t in e || (e = {})) Ir.call(e, t) && At(r, t, e[t]);\n    if (Ot) for (var t of Ot(e)) Cr.call(e, t) && At(r, t, e[t]);\n    return r;\n  };\nclass zt extends Xt {\n  constructor(e) {\n    var _this30;\n    (super(e), _this30 = this), this.protocol = \"wc\", this.version = 2, this.events = new N(), this.name = ct, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = [\"socket hang up\", \"socket stalled\"], this.hasExperiencedNetworkDisruption = !1, this.request = /*#__PURE__*/function () {\n      var _ref32 = _asyncToGenerator(function* (t) {\n        _this30.logger.debug(\"Publishing Request Payload\");\n        try {\n          return yield _this30.toEstablishConnection(), yield _this30.provider.request(t);\n        } catch (i) {\n          throw _this30.logger.debug(\"Failed to Publish Request\"), _this30.logger.error(i), i;\n        }\n      });\n      return function (_x31) {\n        return _ref32.apply(this, arguments);\n      };\n    }(), this.onPayloadHandler = t => {\n      this.onProviderPayload(t);\n    }, this.onConnectHandler = () => {\n      this.events.emit(D.connect);\n    }, this.onDisconnectHandler = () => {\n      this.onProviderDisconnect();\n    }, this.onProviderErrorHandler = t => {\n      this.logger.error(t), this.events.emit(D.error, t), this.logger.info(\"Fatal socket error received, closing transport\"), this.transportClose();\n    }, this.registerProviderListeners = () => {\n      this.provider.on(T.payload, this.onPayloadHandler), this.provider.on(T.connect, this.onConnectHandler), this.provider.on(T.disconnect, this.onDisconnectHandler), this.provider.on(T.error, this.onProviderErrorHandler);\n    }, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? f(e.logger, this.name) : ye(me({\n      level: e.logger || ht\n    })), this.messages = new St(this.logger, e.core), this.subscriber = new xt(this, this.logger), this.publisher = new Dr(this, this.logger), this.relayUrl = (e === null || e === void 0 ? void 0 : e.relayUrl) || de, this.projectId = e.projectId, this.provider = {};\n  }\n  init() {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      _this31.logger.trace(\"Initialized\"), _this31.registerEventListeners(), yield _this31.createProvider(), yield Promise.all([_this31.messages.init(), _this31.subscriber.init()]);\n      try {\n        yield _this31.transportOpen();\n      } catch (_unused5) {\n        _this31.logger.warn(\"Connection via \".concat(_this31.relayUrl, \" failed, attempting to connect via failover domain \").concat(ge, \"...\")), yield _this31.restartTransport(ge);\n      }\n      _this31.initialized = !0, setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n        _this31.subscriber.topics.length === 0 && (_this31.logger.info(\"No topics subscribed to after init, closing transport\"), yield _this31.transportClose(), _this31.transportExplicitlyClosed = !1);\n      }), gt);\n    })();\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  publish(e, t, i) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      _this32.isInitialized(), yield _this32.publisher.publish(e, t, i), yield _this32.recordMessageEvent({\n        topic: e,\n        message: t,\n        publishedAt: Date.now()\n      });\n    })();\n  }\n  subscribe(e, t) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      var i;\n      _this33.isInitialized();\n      let s = ((i = _this33.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || \"\";\n      if (s) return s;\n      let n;\n      const a = o => {\n        o.topic === e && (_this33.subscriber.off(w.created, a), n());\n      };\n      return yield Promise.all([new Promise(o => {\n        n = o, _this33.subscriber.on(w.created, a);\n      }), new Promise( /*#__PURE__*/function () {\n        var _ref34 = _asyncToGenerator(function* (o) {\n          s = yield _this33.subscriber.subscribe(e, t), o();\n        });\n        return function (_x32) {\n          return _ref34.apply(this, arguments);\n        };\n      }())]), s;\n    })();\n  }\n  unsubscribe(e, t) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      _this34.isInitialized(), yield _this34.subscriber.unsubscribe(e, t);\n    })();\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  transportClose() {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      _this35.transportExplicitlyClosed = !0, _this35.hasExperiencedNetworkDisruption && _this35.connected ? yield M(_this35.provider.disconnect(), 1e3, \"provider.disconnect()\").catch(() => _this35.onProviderDisconnect()) : _this35.connected && (yield _this35.provider.disconnect());\n    })();\n  }\n  transportOpen(e) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      if (_this36.transportExplicitlyClosed = !1, yield _this36.confirmOnlineStateOrThrow(), !_this36.connectionAttemptInProgress) {\n        e && e !== _this36.relayUrl && (_this36.relayUrl = e, yield _this36.transportClose(), yield _this36.createProvider()), _this36.connectionAttemptInProgress = !0;\n        try {\n          yield Promise.all([new Promise(t => {\n            if (!_this36.initialized) return t();\n            _this36.subscriber.once(w.resubscribed, () => {\n              t();\n            });\n          }), new Promise( /*#__PURE__*/function () {\n            var _ref35 = _asyncToGenerator(function* (t, i) {\n              try {\n                yield M(_this36.provider.connect(), 1e4, \"Socket stalled when trying to connect to \".concat(_this36.relayUrl));\n              } catch (s) {\n                i(s);\n                return;\n              }\n              t();\n            });\n            return function (_x33, _x34) {\n              return _ref35.apply(this, arguments);\n            };\n          }())]);\n        } catch (t) {\n          _this36.logger.error(t);\n          const i = t;\n          if (!_this36.isConnectionStalled(i.message)) throw t;\n          _this36.provider.events.emit(T.disconnect);\n        } finally {\n          _this36.connectionAttemptInProgress = !1, _this36.hasExperiencedNetworkDisruption = !1;\n        }\n      }\n    })();\n  }\n  restartTransport(e) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      yield _this37.confirmOnlineStateOrThrow(), !_this37.connectionAttemptInProgress && (_this37.relayUrl = e || _this37.relayUrl, yield _this37.transportClose(), yield _this37.createProvider(), yield _this37.transportOpen());\n    })();\n  }\n  confirmOnlineStateOrThrow() {\n    return _asyncToGenerator(function* () {\n      if (!(yield ve())) throw new Error(\"No internet connection detected. Please restart your network and try again.\");\n    })();\n  }\n  isConnectionStalled(e) {\n    return this.staleConnectionErrors.some(t => e.includes(t));\n  }\n  createProvider() {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      _this38.provider.connection && _this38.unregisterProviderListeners();\n      const e = yield _this38.core.crypto.signJWT(_this38.relayUrl);\n      _this38.provider = new Li(new Mi(Di({\n        sdkVersion: dt,\n        protocol: _this38.protocol,\n        version: _this38.version,\n        relayUrl: _this38.relayUrl,\n        projectId: _this38.projectId,\n        auth: e,\n        useOnCloseEvent: !0\n      }))), _this38.registerProviderListeners();\n    })();\n  }\n  recordMessageEvent(e) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      yield _this39.messages.set(t, i);\n    })();\n  }\n  shouldIgnoreMessageEvent(e) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      if (!i || i.length === 0) return _this40.logger.debug(\"Ignoring invalid/empty message: \".concat(i)), !0;\n      if (!(yield _this40.subscriber.isSubscribed(t))) return _this40.logger.debug(\"Ignoring message for non-subscribed topic \".concat(t)), !0;\n      const s = _this40.messages.has(t, i);\n      return s && _this40.logger.debug(\"Ignoring duplicate message: \".concat(i)), s;\n    })();\n  }\n  onProviderPayload(e) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      if (_this41.logger.debug(\"Incoming Relay Payload\"), _this41.logger.trace({\n        type: \"payload\",\n        direction: \"incoming\",\n        payload: e\n      }), Pe(e)) {\n        if (!e.method.endsWith(ut)) return;\n        const t = e.params,\n          {\n            topic: i,\n            message: s,\n            publishedAt: n\n          } = t.data,\n          a = {\n            topic: i,\n            message: s,\n            publishedAt: n\n          };\n        _this41.logger.debug(\"Emitting Relayer Payload\"), _this41.logger.trace(Rr({\n          type: \"event\",\n          event: t.id\n        }, a)), _this41.events.emit(t.id, a), yield _this41.acknowledgePayload(e), yield _this41.onMessageEvent(a);\n      } else Te(e) && _this41.events.emit(D.message_ack, e);\n    })();\n  }\n  onMessageEvent(e) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      (yield _this42.shouldIgnoreMessageEvent(e)) || (_this42.events.emit(D.message, e), yield _this42.recordMessageEvent(e));\n    })();\n  }\n  acknowledgePayload(e) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      const t = xe(e.id, !0);\n      yield _this43.provider.connection.send(t);\n    })();\n  }\n  unregisterProviderListeners() {\n    this.provider.off(T.payload, this.onPayloadHandler), this.provider.off(T.connect, this.onConnectHandler), this.provider.off(T.disconnect, this.onDisconnectHandler), this.provider.off(T.error, this.onProviderErrorHandler);\n  }\n  registerEventListeners() {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      _this44.events.on(D.connection_stalled, () => {\n        _this44.restartTransport().catch(t => _this44.logger.error(t));\n      });\n      let e = yield ve();\n      yi( /*#__PURE__*/function () {\n        var _ref36 = _asyncToGenerator(function* (t) {\n          _this44.initialized && e !== t && (e = t, t ? yield _this44.restartTransport().catch(i => _this44.logger.error(i)) : (_this44.hasExperiencedNetworkDisruption = !0, yield _this44.transportClose().catch(i => _this44.logger.error(i))));\n        });\n        return function (_x35) {\n          return _ref36.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  onProviderDisconnect() {\n    this.events.emit(D.disconnect), this.attemptToReconnect();\n  }\n  attemptToReconnect() {\n    var _this45 = this;\n    this.transportExplicitlyClosed || (this.logger.info(\"attemptToReconnect called. Connecting...\"), setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n      yield _this45.restartTransport().catch(e => _this45.logger.error(e));\n    }), U(lt)));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  toEstablishConnection() {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      if (yield _this46.confirmOnlineStateOrThrow(), !_this46.connected) {\n        if (_this46.connectionAttemptInProgress) return yield new Promise(e => {\n          const t = setInterval(() => {\n            _this46.connected && (clearInterval(t), e());\n          }, _this46.connectionStatusPollingInterval);\n        });\n        yield _this46.restartTransport();\n      }\n    })();\n  }\n}\nvar _r = Object.defineProperty,\n  Nt = Object.getOwnPropertySymbols,\n  Sr = Object.prototype.hasOwnProperty,\n  Pr = Object.prototype.propertyIsEnumerable,\n  Lt = (r, e, t) => e in r ? _r(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  Ut = (r, e) => {\n    for (var t in e || (e = {})) Sr.call(e, t) && Lt(r, t, e[t]);\n    if (Nt) for (var t of Nt(e)) Pr.call(e, t) && Lt(r, t, e[t]);\n    return r;\n  };\nclass Ft extends Qt {\n  constructor(e, t, i) {\n    var _this47;\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : O;\n    let n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;\n    (super(e, t, i, s), _this47 = this), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = pt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this47.initialized || (_this47.logger.trace(\"Initialized\"), yield _this47.restore(), _this47.cached.forEach(a => {\n        _this47.getKey && a !== null && !re(a) ? _this47.map.set(_this47.getKey(a), a) : mi(a) ? _this47.map.set(a.id, a) : bi(a) && _this47.map.set(a.topic, a);\n      }), _this47.cached = [], _this47.initialized = !0);\n    }), this.set = /*#__PURE__*/function () {\n      var _ref39 = _asyncToGenerator(function* (a, o) {\n        _this47.isInitialized(), _this47.map.has(a) ? yield _this47.update(a, o) : (_this47.logger.debug(\"Setting value\"), _this47.logger.trace({\n          type: \"method\",\n          method: \"set\",\n          key: a,\n          value: o\n        }), _this47.map.set(a, o), yield _this47.persist());\n      });\n      return function (_x36, _x37) {\n        return _ref39.apply(this, arguments);\n      };\n    }(), this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => (this.isInitialized(), a ? this.values.filter(o => Object.keys(a).every(h => ki(o[h], a[h]))) : this.values), this.update = /*#__PURE__*/function () {\n      var _ref40 = _asyncToGenerator(function* (a, o) {\n        _this47.isInitialized(), _this47.logger.debug(\"Updating value\"), _this47.logger.trace({\n          type: \"method\",\n          method: \"update\",\n          key: a,\n          update: o\n        });\n        const h = Ut(Ut({}, _this47.getData(a)), o);\n        _this47.map.set(a, h), yield _this47.persist();\n      });\n      return function (_x38, _x39) {\n        return _ref40.apply(this, arguments);\n      };\n    }(), this.delete = /*#__PURE__*/function () {\n      var _ref41 = _asyncToGenerator(function* (a, o) {\n        _this47.isInitialized(), _this47.map.has(a) && (_this47.logger.debug(\"Deleting value\"), _this47.logger.trace({\n          type: \"method\",\n          method: \"delete\",\n          key: a,\n          reason: o\n        }), _this47.map.delete(a), yield _this47.persist());\n      });\n      return function (_x40, _x41) {\n        return _ref41.apply(this, arguments);\n      };\n    }(), this.logger = f(t, this.name), this.storagePrefix = s, this.getKey = n;\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  setDataStore(e) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      yield _this48.core.storage.setItem(_this48.storageKey, e);\n    })();\n  }\n  getDataStore() {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this49.core.storage.getItem(_this49.storageKey);\n    })();\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  persist() {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      yield _this50.setDataStore(_this50.values);\n    })();\n  }\n  restore() {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this51.getDataStore();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this51.map.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this51.name);\n          throw _this51.logger.error(t), new Error(t);\n        }\n        _this51.cached = e, _this51.logger.debug(\"Successfully Restored value for \".concat(_this51.name)), _this51.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          value: _this51.values\n        });\n      } catch (e) {\n        _this51.logger.debug(\"Failed to Restore value for \".concat(_this51.name)), _this51.logger.error(e);\n      }\n    })();\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass $t {\n  constructor(e, t) {\n    var _this52 = this;\n    this.core = e, this.logger = t, this.name = ft, this.version = Et, this.events = new jt(), this.initialized = !1, this.storagePrefix = O, this.ignoredPayloadTypes = [fi], this.registeredMethods = [], this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this52.initialized || (yield _this52.pairings.init(), yield _this52.cleanup(), _this52.registerRelayerEvents(), _this52.registerExpirerEvents(), _this52.initialized = !0, _this52.logger.trace(\"Initialized\"));\n    }), this.register = _ref43 => {\n      let {\n        methods: i\n      } = _ref43;\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...i])];\n    }, this.create = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this52.isInitialized();\n      const i = te(),\n        s = yield _this52.core.crypto.setSymKey(i),\n        n = H(Se),\n        a = {\n          protocol: ot\n        },\n        o = {\n          topic: s,\n          expiry: n,\n          relay: a,\n          active: !1\n        },\n        h = Ei({\n          protocol: _this52.core.protocol,\n          version: _this52.core.version,\n          topic: s,\n          symKey: i,\n          relay: a\n        });\n      return yield _this52.pairings.set(s, o), yield _this52.core.relayer.subscribe(s), _this52.core.expirer.set(s, n), {\n        topic: s,\n        uri: h\n      };\n    }), this.pair = /*#__PURE__*/function () {\n      var _ref45 = _asyncToGenerator(function* (i) {\n        _this52.isInitialized(), _this52.isValidPair(i);\n        const {\n          topic: s,\n          symKey: n,\n          relay: a\n        } = wi(i.uri);\n        let o;\n        if (_this52.pairings.keys.includes(s) && (o = _this52.pairings.get(s), o.active)) throw new Error(\"Pairing already exists: \".concat(s, \". Please try again with a new connection URI.\"));\n        _this52.core.crypto.keychain.has(s) || (yield _this52.core.crypto.setSymKey(n, s), yield _this52.core.relayer.subscribe(s, {\n          relay: a\n        }));\n        const h = H(Se),\n          u = {\n            topic: s,\n            relay: a,\n            expiry: h,\n            active: !1\n          };\n        return yield _this52.pairings.set(s, u), _this52.core.expirer.set(s, h), i.activatePairing && (yield _this52.activate({\n          topic: s\n        })), _this52.events.emit(B.create, u), u;\n      });\n      return function (_x42) {\n        return _ref45.apply(this, arguments);\n      };\n    }(), this.activate = /*#__PURE__*/function () {\n      var _ref47 = _asyncToGenerator(function* (_ref46) {\n        let {\n          topic: i\n        } = _ref46;\n        _this52.isInitialized();\n        const s = H(J);\n        yield _this52.pairings.update(i, {\n          active: !0,\n          expiry: s\n        }), _this52.core.expirer.set(i, s);\n      });\n      return function (_x43) {\n        return _ref47.apply(this, arguments);\n      };\n    }(), this.ping = /*#__PURE__*/function () {\n      var _ref48 = _asyncToGenerator(function* (i) {\n        _this52.isInitialized(), yield _this52.isValidPing(i);\n        const {\n          topic: s\n        } = i;\n        if (_this52.pairings.keys.includes(s)) {\n          const n = yield _this52.sendRequest(s, \"wc_pairingPing\", {}),\n            {\n              done: a,\n              resolve: o,\n              reject: h\n            } = vi();\n          _this52.events.once(ne(\"pairing_ping\", n), _ref49 => {\n            let {\n              error: u\n            } = _ref49;\n            u ? h(u) : o();\n          }), yield a();\n        }\n      });\n      return function (_x44) {\n        return _ref48.apply(this, arguments);\n      };\n    }(), this.updateExpiry = /*#__PURE__*/function () {\n      var _ref51 = _asyncToGenerator(function* (_ref50) {\n        let {\n          topic: i,\n          expiry: s\n        } = _ref50;\n        _this52.isInitialized(), yield _this52.pairings.update(i, {\n          expiry: s\n        });\n      });\n      return function (_x45) {\n        return _ref51.apply(this, arguments);\n      };\n    }(), this.updateMetadata = /*#__PURE__*/function () {\n      var _ref53 = _asyncToGenerator(function* (_ref52) {\n        let {\n          topic: i,\n          metadata: s\n        } = _ref52;\n        _this52.isInitialized(), yield _this52.pairings.update(i, {\n          peerMetadata: s\n        });\n      });\n      return function (_x46) {\n        return _ref53.apply(this, arguments);\n      };\n    }(), this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = /*#__PURE__*/function () {\n      var _ref54 = _asyncToGenerator(function* (i) {\n        _this52.isInitialized(), yield _this52.isValidDisconnect(i);\n        const {\n          topic: s\n        } = i;\n        _this52.pairings.keys.includes(s) && (yield _this52.sendRequest(s, \"wc_pairingDelete\", k(\"USER_DISCONNECTED\")), yield _this52.deletePairing(s));\n      });\n      return function (_x47) {\n        return _ref54.apply(this, arguments);\n      };\n    }(), this.sendRequest = /*#__PURE__*/function () {\n      var _ref55 = _asyncToGenerator(function* (i, s, n) {\n        const a = Oe(s, n),\n          o = yield _this52.core.crypto.encode(i, a),\n          h = F[s].req;\n        return _this52.core.history.set(i, a), _this52.core.relayer.publish(i, o, h), a.id;\n      });\n      return function (_x48, _x49, _x50) {\n        return _ref55.apply(this, arguments);\n      };\n    }(), this.sendResult = /*#__PURE__*/function () {\n      var _ref56 = _asyncToGenerator(function* (i, s, n) {\n        const a = xe(i, n),\n          o = yield _this52.core.crypto.encode(s, a),\n          h = yield _this52.core.history.get(s, i),\n          u = F[h.request.method].res;\n        yield _this52.core.relayer.publish(s, o, u), yield _this52.core.history.resolve(a);\n      });\n      return function (_x51, _x52, _x53) {\n        return _ref56.apply(this, arguments);\n      };\n    }(), this.sendError = /*#__PURE__*/function () {\n      var _ref57 = _asyncToGenerator(function* (i, s, n) {\n        const a = Fi(i, n),\n          o = yield _this52.core.crypto.encode(s, a),\n          h = yield _this52.core.history.get(s, i),\n          u = F[h.request.method] ? F[h.request.method].res : F.unregistered_method.res;\n        yield _this52.core.relayer.publish(s, o, u), yield _this52.core.history.resolve(a);\n      });\n      return function (_x54, _x55, _x56) {\n        return _ref57.apply(this, arguments);\n      };\n    }(), this.deletePairing = /*#__PURE__*/function () {\n      var _ref58 = _asyncToGenerator(function* (i, s) {\n        yield _this52.core.relayer.unsubscribe(i), yield Promise.all([_this52.pairings.delete(i, k(\"USER_DISCONNECTED\")), _this52.core.crypto.deleteSymKey(i), s ? Promise.resolve() : _this52.core.expirer.del(i)]);\n      });\n      return function (_x57, _x58) {\n        return _ref58.apply(this, arguments);\n      };\n    }(), this.cleanup = /*#__PURE__*/_asyncToGenerator(function* () {\n      const i = _this52.pairings.getAll().filter(s => Ie(s.expiry));\n      yield Promise.all(i.map(s => _this52.deletePairing(s.topic)));\n    }), this.onRelayEventRequest = i => {\n      const {\n        topic: s,\n        payload: n\n      } = i;\n      switch (n.method) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(s, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(s, n);\n        default:\n          return this.onUnknownRpcMethodRequest(s, n);\n      }\n    }, this.onRelayEventResponse = /*#__PURE__*/function () {\n      var _ref60 = _asyncToGenerator(function* (i) {\n        const {\n            topic: s,\n            payload: n\n          } = i,\n          a = (yield _this52.core.history.get(s, n.id)).request.method;\n        switch (a) {\n          case \"wc_pairingPing\":\n            return _this52.onPairingPingResponse(s, n);\n          default:\n            return _this52.onUnknownRpcMethodResponse(a);\n        }\n      });\n      return function (_x59) {\n        return _ref60.apply(this, arguments);\n      };\n    }(), this.onPairingPingRequest = /*#__PURE__*/function () {\n      var _ref61 = _asyncToGenerator(function* (i, s) {\n        const {\n          id: n\n        } = s;\n        try {\n          _this52.isValidPing({\n            topic: i\n          }), yield _this52.sendResult(n, i, !0), _this52.events.emit(B.ping, {\n            id: n,\n            topic: i\n          });\n        } catch (a) {\n          yield _this52.sendError(n, i, a), _this52.logger.error(a);\n        }\n      });\n      return function (_x60, _x61) {\n        return _ref61.apply(this, arguments);\n      };\n    }(), this.onPairingPingResponse = (i, s) => {\n      const {\n        id: n\n      } = s;\n      setTimeout(() => {\n        $i(s) ? this.events.emit(ne(\"pairing_ping\", n), {}) : Ae(s) && this.events.emit(ne(\"pairing_ping\", n), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onPairingDeleteRequest = /*#__PURE__*/function () {\n      var _ref62 = _asyncToGenerator(function* (i, s) {\n        const {\n          id: n\n        } = s;\n        try {\n          _this52.isValidDisconnect({\n            topic: i\n          }), yield _this52.deletePairing(i), _this52.events.emit(B.delete, {\n            id: n,\n            topic: i\n          });\n        } catch (a) {\n          yield _this52.sendError(n, i, a), _this52.logger.error(a);\n        }\n      });\n      return function (_x62, _x63) {\n        return _ref62.apply(this, arguments);\n      };\n    }(), this.onUnknownRpcMethodRequest = /*#__PURE__*/function () {\n      var _ref63 = _asyncToGenerator(function* (i, s) {\n        const {\n          id: n,\n          method: a\n        } = s;\n        try {\n          if (_this52.registeredMethods.includes(a)) return;\n          const o = k(\"WC_METHOD_UNSUPPORTED\", a);\n          yield _this52.sendError(n, i, o), _this52.logger.error(o);\n        } catch (o) {\n          yield _this52.sendError(n, i, o), _this52.logger.error(o);\n        }\n      });\n      return function (_x64, _x65) {\n        return _ref63.apply(this, arguments);\n      };\n    }(), this.onUnknownRpcMethodResponse = i => {\n      this.registeredMethods.includes(i) || this.logger.error(k(\"WC_METHOD_UNSUPPORTED\", i));\n    }, this.isValidPair = i => {\n      if (!ae(i)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", \"pair() params: \".concat(i));\n        throw new Error(s);\n      }\n      if (!Ii(i.uri)) {\n        const {\n          message: s\n        } = l(\"MISSING_OR_INVALID\", \"pair() uri: \".concat(i.uri));\n        throw new Error(s);\n      }\n    }, this.isValidPing = /*#__PURE__*/function () {\n      var _ref64 = _asyncToGenerator(function* (i) {\n        if (!ae(i)) {\n          const {\n            message: n\n          } = l(\"MISSING_OR_INVALID\", \"ping() params: \".concat(i));\n          throw new Error(n);\n        }\n        const {\n          topic: s\n        } = i;\n        yield _this52.isValidPairingTopic(s);\n      });\n      return function (_x66) {\n        return _ref64.apply(this, arguments);\n      };\n    }(), this.isValidDisconnect = /*#__PURE__*/function () {\n      var _ref65 = _asyncToGenerator(function* (i) {\n        if (!ae(i)) {\n          const {\n            message: n\n          } = l(\"MISSING_OR_INVALID\", \"disconnect() params: \".concat(i));\n          throw new Error(n);\n        }\n        const {\n          topic: s\n        } = i;\n        yield _this52.isValidPairingTopic(s);\n      });\n      return function (_x67) {\n        return _ref65.apply(this, arguments);\n      };\n    }(), this.isValidPairingTopic = /*#__PURE__*/function () {\n      var _ref66 = _asyncToGenerator(function* (i) {\n        if (!Ci(i, !1)) {\n          const {\n            message: s\n          } = l(\"MISSING_OR_INVALID\", \"pairing topic should be a string: \".concat(i));\n          throw new Error(s);\n        }\n        if (!_this52.pairings.keys.includes(i)) {\n          const {\n            message: s\n          } = l(\"NO_MATCHING_KEY\", \"pairing topic doesn't exist: \".concat(i));\n          throw new Error(s);\n        }\n        if (Ie(_this52.pairings.get(i).expiry)) {\n          yield _this52.deletePairing(i);\n          const {\n            message: s\n          } = l(\"EXPIRED\", \"pairing topic: \".concat(i));\n          throw new Error(s);\n        }\n      });\n      return function (_x68) {\n        return _ref66.apply(this, arguments);\n      };\n    }(), this.core = e, this.logger = f(t, this.name), this.pairings = new Ft(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    var _this53 = this;\n    this.core.relayer.on(D.message, /*#__PURE__*/function () {\n      var _ref67 = _asyncToGenerator(function* (e) {\n        const {\n          topic: t,\n          message: i\n        } = e;\n        if (!_this53.pairings.keys.includes(t) || _this53.ignoredPayloadTypes.includes(_this53.core.crypto.getPayloadType(i))) return;\n        const s = yield _this53.core.crypto.decode(t, i);\n        try {\n          Pe(s) ? (_this53.core.history.set(t, s), _this53.onRelayEventRequest({\n            topic: t,\n            payload: s\n          })) : Te(s) && (yield _this53.core.history.resolve(s), yield _this53.onRelayEventResponse({\n            topic: t,\n            payload: s\n          }), _this53.core.history.delete(t, s.id));\n        } catch (n) {\n          _this53.logger.error(n);\n        }\n      });\n      return function (_x69) {\n        return _ref67.apply(this, arguments);\n      };\n    }());\n  }\n  registerExpirerEvents() {\n    var _this54 = this;\n    this.core.expirer.on(v.expired, /*#__PURE__*/function () {\n      var _ref68 = _asyncToGenerator(function* (e) {\n        const {\n          topic: t\n        } = Ri(e.target);\n        t && _this54.pairings.keys.includes(t) && (yield _this54.deletePairing(t, !0), _this54.events.emit(B.expire, {\n          topic: t\n        }));\n      });\n      return function (_x70) {\n        return _ref68.apply(this, arguments);\n      };\n    }());\n  }\n}\nclass Mt extends Zt {\n  constructor(e, t) {\n    var _this55;\n    (super(e, t), _this55 = this), this.core = e, this.logger = t, this.records = new Map(), this.events = new N(), this.name = wt, this.version = vt, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this55.initialized || (_this55.logger.trace(\"Initialized\"), yield _this55.restore(), _this55.cached.forEach(i => _this55.records.set(i.id, i)), _this55.cached = [], _this55.registerEventListeners(), _this55.initialized = !0);\n    }), this.set = (i, s, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: i,\n        request: s,\n        chainId: n\n      }), this.records.has(s.id)) return;\n      const a = {\n        id: s.id,\n        topic: i,\n        request: {\n          method: s.method,\n          params: s.params || null\n        },\n        chainId: n,\n        expiry: H(J)\n      };\n      this.records.set(a.id, a), this.events.emit(R.created, a);\n    }, this.resolve = /*#__PURE__*/function () {\n      var _ref70 = _asyncToGenerator(function* (i) {\n        if (_this55.isInitialized(), _this55.logger.debug(\"Updating JSON-RPC response history record\"), _this55.logger.trace({\n          type: \"method\",\n          method: \"update\",\n          response: i\n        }), !_this55.records.has(i.id)) return;\n        const s = yield _this55.getRecord(i.id);\n        typeof s.response > \"u\" && (s.response = Ae(i) ? {\n          error: i.error\n        } : {\n          result: i.result\n        }, _this55.records.set(s.id, s), _this55.events.emit(R.updated, s));\n      });\n      return function (_x71) {\n        return _ref70.apply(this, arguments);\n      };\n    }(), this.get = /*#__PURE__*/function () {\n      var _ref71 = _asyncToGenerator(function* (i, s) {\n        return _this55.isInitialized(), _this55.logger.debug(\"Getting record\"), _this55.logger.trace({\n          type: \"method\",\n          method: \"get\",\n          topic: i,\n          id: s\n        }), yield _this55.getRecord(s);\n      });\n      return function (_x72, _x73) {\n        return _ref71.apply(this, arguments);\n      };\n    }(), this.delete = (i, s) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: s\n      }), this.values.forEach(n => {\n        if (n.topic === i) {\n          if (typeof s < \"u\" && n.id !== s) return;\n          this.records.delete(n.id), this.events.emit(R.deleted, n);\n        }\n      });\n    }, this.exists = /*#__PURE__*/function () {\n      var _ref72 = _asyncToGenerator(function* (i, s) {\n        return _this55.isInitialized(), _this55.records.has(s) ? (yield _this55.getRecord(s)).topic === i : !1;\n      });\n      return function (_x74, _x75) {\n        return _ref72.apply(this, arguments);\n      };\n    }(), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = f(t, this.name);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const i = {\n        topic: t.topic,\n        request: Oe(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(i);\n    }), e;\n  }\n  setJsonRpcRecords(e) {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      yield _this56.core.storage.setItem(_this56.storageKey, e);\n    })();\n  }\n  getJsonRpcRecords() {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this57.core.storage.getItem(_this57.storageKey);\n    })();\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw new Error(i);\n    }\n    return t;\n  }\n  persist() {\n    var _this58 = this;\n    return _asyncToGenerator(function* () {\n      yield _this58.setJsonRpcRecords(_this58.values), _this58.events.emit(R.sync);\n    })();\n  }\n  restore() {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this59.getJsonRpcRecords();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this59.records.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this59.name);\n          throw _this59.logger.error(t), new Error(t);\n        }\n        _this59.cached = e, _this59.logger.debug(\"Successfully Restored records for \".concat(_this59.name)), _this59.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          records: _this59.values\n        });\n      } catch (e) {\n        _this59.logger.debug(\"Failed to Restore records for \".concat(_this59.name)), _this59.logger.error(e);\n      }\n    })();\n  }\n  registerEventListeners() {\n    this.events.on(R.created, e => {\n      const t = R.created;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(R.updated, e => {\n      const t = R.updated;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(R.deleted, e => {\n      const t = R.deleted;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.core.heartbeat.on(j.pulse, () => {\n      this.cleanup();\n    });\n  }\n  cleanup() {\n    try {\n      this.records.forEach(e => {\n        U(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(\"Deleting expired history log: \".concat(e.id)), this.delete(e.topic, e.id));\n      });\n    } catch (e) {\n      this.logger.warn(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass kt extends ei {\n  constructor(e, t) {\n    var _this60;\n    (super(e, t), _this60 = this), this.core = e, this.logger = t, this.expirations = new Map(), this.events = new N(), this.name = It, this.version = Ct, this.cached = [], this.initialized = !1, this.storagePrefix = O, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this60.initialized || (_this60.logger.trace(\"Initialized\"), yield _this60.restore(), _this60.cached.forEach(i => _this60.expirations.set(i.target, i)), _this60.cached = [], _this60.registerEventListeners(), _this60.initialized = !0);\n    }), this.has = i => {\n      try {\n        const s = this.formatTarget(i);\n        return typeof this.getExpiration(s) < \"u\";\n      } catch (_unused6) {\n        return !1;\n      }\n    }, this.set = (i, s) => {\n      this.isInitialized();\n      const n = this.formatTarget(i),\n        a = {\n          target: n,\n          expiry: s\n        };\n      this.expirations.set(n, a), this.checkExpiry(n, a), this.events.emit(v.created, {\n        target: n,\n        expiration: a\n      });\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.formatTarget(i);\n      return this.getExpiration(s);\n    }, this.del = i => {\n      if (this.isInitialized(), this.has(i)) {\n        const s = this.formatTarget(i),\n          n = this.getExpiration(s);\n        this.expirations.delete(s), this.events.emit(v.deleted, {\n          target: s,\n          expiration: n\n        });\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = f(t, this.name);\n  }\n  get context() {\n    return E(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + this.core.customStoragePrefix + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return _i(e);\n    if (typeof e == \"number\") return Si(e);\n    const {\n      message: t\n    } = l(\"UNKNOWN_TYPE\", \"Target type: \".concat(typeof e));\n    throw new Error(t);\n  }\n  setExpirations(e) {\n    var _this61 = this;\n    return _asyncToGenerator(function* () {\n      yield _this61.core.storage.setItem(_this61.storageKey, e);\n    })();\n  }\n  getExpirations() {\n    var _this62 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this62.core.storage.getItem(_this62.storageKey);\n    })();\n  }\n  persist() {\n    var _this63 = this;\n    return _asyncToGenerator(function* () {\n      yield _this63.setExpirations(_this63.values), _this63.events.emit(v.sync);\n    })();\n  }\n  restore() {\n    var _this64 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const e = yield _this64.getExpirations();\n        if (typeof e > \"u\" || !e.length) return;\n        if (_this64.expirations.size) {\n          const {\n            message: t\n          } = l(\"RESTORE_WILL_OVERRIDE\", _this64.name);\n          throw _this64.logger.error(t), new Error(t);\n        }\n        _this64.cached = e, _this64.logger.debug(\"Successfully Restored expirations for \".concat(_this64.name)), _this64.logger.trace({\n          type: \"method\",\n          method: \"restore\",\n          expirations: _this64.values\n        });\n      } catch (e) {\n        _this64.logger.debug(\"Failed to Restore expirations for \".concat(_this64.name)), _this64.logger.error(e);\n      }\n    })();\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = l(\"NO_MATCHING_KEY\", \"\".concat(this.name, \": \").concat(e));\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: i\n    } = t;\n    U(i) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(v.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(j.pulse, () => this.checkExpirations()), this.events.on(v.created, e => {\n      const t = v.created;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(v.expired, e => {\n      const t = v.expired;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(v.deleted, e => {\n      const t = v.deleted;\n      this.logger.info(\"Emitting \".concat(t)), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = l(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Kt extends ti {\n  constructor(e, t) {\n    var _this65;\n    (super(e, t), _this65 = this), this.projectId = e, this.logger = t, this.name = Q, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      if (_this65.verifyDisabled || Pi() || !Ti()) return;\n      const i = Z;\n      _this65.verifyUrl !== i && _this65.removeIframe(), _this65.verifyUrl = i;\n      try {\n        yield _this65.createIframe();\n      } catch (s) {\n        _this65.logger.info(\"Verify iframe failed to load: \".concat(_this65.verifyUrl)), _this65.logger.info(s);\n      }\n      if (!_this65.initialized) {\n        _this65.removeIframe(), _this65.verifyUrl = pe;\n        try {\n          yield _this65.createIframe();\n        } catch (s) {\n          _this65.logger.info(\"Verify iframe failed to load: \".concat(_this65.verifyUrl)), _this65.logger.info(s), _this65.verifyDisabled = !0;\n        }\n      }\n    }), this.register = /*#__PURE__*/function () {\n      var _ref75 = _asyncToGenerator(function* (i) {\n        _this65.initialized ? _this65.sendPost(i.attestationId) : (_this65.addToQueue(i.attestationId), yield _this65.init());\n      });\n      return function (_x76) {\n        return _ref75.apply(this, arguments);\n      };\n    }(), this.resolve = /*#__PURE__*/function () {\n      var _ref76 = _asyncToGenerator(function* (i) {\n        if (_this65.isDevEnv) return \"\";\n        const s = (i === null || i === void 0 ? void 0 : i.verifyUrl) || Z;\n        let n;\n        try {\n          n = yield _this65.fetchAttestation(i.attestationId, s);\n        } catch (a) {\n          _this65.logger.info(\"failed to resolve attestation: \".concat(i.attestationId, \" from url: \").concat(s)), _this65.logger.info(a), n = yield _this65.fetchAttestation(i.attestationId, pe);\n        }\n        return n;\n      });\n      return function (_x77) {\n        return _ref76.apply(this, arguments);\n      };\n    }(), this.fetchAttestation = /*#__PURE__*/function () {\n      var _ref77 = _asyncToGenerator(function* (i, s) {\n        _this65.logger.info(\"resolving attestation: \".concat(i, \" from url: \").concat(s));\n        const n = _this65.startAbortTimer(Ce * 2),\n          a = yield fetch(\"\".concat(s, \"/attestation/\").concat(i), {\n            signal: _this65.abortController.signal\n          });\n        return clearTimeout(n), a.status === 200 ? yield a.json() : void 0;\n      });\n      return function (_x78, _x79) {\n        return _ref77.apply(this, arguments);\n      };\n    }(), this.addToQueue = i => {\n      this.queue.push(i);\n    }, this.processQueue = () => {\n      this.queue.length !== 0 && (this.queue.forEach(i => this.sendPost(i)), this.queue = []);\n    }, this.sendPost = i => {\n      var s;\n      try {\n        if (!this.iframe) return;\n        (s = this.iframe.contentWindow) == null || s.postMessage(i, \"*\"), this.logger.info(\"postMessage sent: \".concat(i, \" \").concat(this.verifyUrl));\n      } catch (_unused7) {}\n    }, this.createIframe = /*#__PURE__*/_asyncToGenerator(function* () {\n      let i;\n      const s = n => {\n        n.data === \"verify_ready\" && (_this65.initialized = !0, _this65.processQueue(), window.removeEventListener(\"message\", s), i());\n      };\n      yield Promise.race([new Promise(n => {\n        if (document.getElementById(Q)) return n();\n        window.addEventListener(\"message\", s);\n        const a = document.createElement(\"iframe\");\n        a.id = Q, a.src = \"\".concat(_this65.verifyUrl, \"/\").concat(_this65.projectId), a.style.display = \"none\", document.body.append(a), _this65.iframe = a, i = n;\n      }), new Promise((n, a) => setTimeout(() => {\n        window.removeEventListener(\"message\", s), a(\"verify iframe load timeout\");\n      }, U(Re)))]);\n    }), this.removeIframe = () => {\n      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1);\n    }, this.logger = f(t, this.name), this.verifyUrl = Z, this.abortController = new AbortController(), this.isDevEnv = xi() && process.env.IS_VITEST;\n  }\n  get context() {\n    return E(this.logger);\n  }\n  startAbortTimer(e) {\n    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), U(e));\n  }\n}\nvar Tr = Object.defineProperty,\n  Bt = Object.getOwnPropertySymbols,\n  xr = Object.prototype.hasOwnProperty,\n  Or = Object.prototype.propertyIsEnumerable,\n  Vt = (r, e, t) => e in r ? Tr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  qt = (r, e) => {\n    for (var t in e || (e = {})) xr.call(e, t) && Vt(r, t, e[t]);\n    if (Bt) for (var t of Bt(e)) Or.call(e, t) && Vt(r, t, e[t]);\n    return r;\n  };\nclass ee extends ii {\n  constructor(e) {\n    super(e), this.protocol = ue, this.version = We, this.name = X, this.events = new N(), this.initialized = !1, this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.projectId = e === null || e === void 0 ? void 0 : e.projectId, this.relayUrl = (e === null || e === void 0 ? void 0 : e.relayUrl) || de, this.customStoragePrefix = e != null && e.customStoragePrefix ? \":\".concat(e.customStoragePrefix) : \"\";\n    const t = typeof (e === null || e === void 0 ? void 0 : e.logger) < \"u\" && typeof (e === null || e === void 0 ? void 0 : e.logger) != \"string\" ? e.logger : ye(me({\n      level: (e === null || e === void 0 ? void 0 : e.logger) || Xe.logger\n    }));\n    this.logger = f(t, this.name), this.heartbeat = new Gt(), this.crypto = new _t(this, this.logger, e === null || e === void 0 ? void 0 : e.keychain), this.history = new Mt(this, this.logger), this.expirer = new kt(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Yt(qt(qt({}, Qe), e === null || e === void 0 ? void 0 : e.storageOptions)), this.relayer = new zt({\n      core: this,\n      logger: this.logger,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new $t(this, this.logger), this.verify = new Kt(this.projectId || \"\", this.logger);\n  }\n  static init(e) {\n    return _asyncToGenerator(function* () {\n      const t = new ee(e);\n      yield t.initialize();\n      const i = yield t.crypto.getClientId();\n      return yield t.storage.setItem(Dt, i), t;\n    })();\n  }\n  get context() {\n    return E(this.logger);\n  }\n  start() {\n    var _this66 = this;\n    return _asyncToGenerator(function* () {\n      _this66.initialized || (yield _this66.initialize());\n    })();\n  }\n  initialize() {\n    var _this67 = this;\n    return _asyncToGenerator(function* () {\n      _this67.logger.trace(\"Initialized\");\n      try {\n        yield _this67.crypto.init(), yield _this67.history.init(), yield _this67.expirer.init(), yield _this67.relayer.init(), yield _this67.heartbeat.init(), yield _this67.pairing.init(), _this67.initialized = !0, _this67.logger.info(\"Core Initialization Success\");\n      } catch (e) {\n        throw _this67.logger.warn(\"Core Initialization Failure at epoch \".concat(Date.now()), e), _this67.logger.error(e.message), e;\n      }\n    })();\n  }\n}\nconst Ar = ee;\nexport { X as CORE_CONTEXT, Xe as CORE_DEFAULT, ue as CORE_PROTOCOL, Qe as CORE_STORAGE_OPTIONS, O as CORE_STORAGE_PREFIX, We as CORE_VERSION, le as CRYPTO_CLIENT_SEED, Ze as CRYPTO_CONTEXT, et as CRYPTO_JWT_TTL, Ar as Core, _t as Crypto, It as EXPIRER_CONTEXT, pr as EXPIRER_DEFAULT_TTL, v as EXPIRER_EVENTS, Ct as EXPIRER_STORAGE_VERSION, kt as Expirer, wt as HISTORY_CONTEXT, R as HISTORY_EVENTS, vt as HISTORY_STORAGE_VERSION, Mt as JsonRpcHistory, tt as KEYCHAIN_CONTEXT, it as KEYCHAIN_STORAGE_VERSION, Rt as KeyChain, st as MESSAGES_CONTEXT, rt as MESSAGES_STORAGE_VERSION, St as MessageTracker, ft as PAIRING_CONTEXT, gr as PAIRING_DEFAULT_TTL, B as PAIRING_EVENTS, F as PAIRING_RPC_OPTS, Et as PAIRING_STORAGE_VERSION, bt as PENDING_SUB_RESOLUTION_TIMEOUT, at as PUBLISHER_CONTEXT, nt as PUBLISHER_DEFAULT_TTL, $t as Pairing, ct as RELAYER_CONTEXT, ht as RELAYER_DEFAULT_LOGGER, ot as RELAYER_DEFAULT_PROTOCOL, de as RELAYER_DEFAULT_RELAY_URL, D as RELAYER_EVENTS, ge as RELAYER_FAILOVER_RELAY_URL, T as RELAYER_PROVIDER_EVENTS, lt as RELAYER_RECONNECT_TIMEOUT, dt as RELAYER_SDK_VERSION, lr as RELAYER_STORAGE_OPTIONS, ut as RELAYER_SUBSCRIBER_SUFFIX, gt as RELAYER_TRANSPORT_CUTOFF, zt as Relayer, pt as STORE_STORAGE_VERSION, yt as SUBSCRIBER_CONTEXT, dr as SUBSCRIBER_DEFAULT_TTL, w as SUBSCRIBER_EVENTS, mt as SUBSCRIBER_STORAGE_VERSION, Ft as Store, xt as Subscriber, Q as VERIFY_CONTEXT, pe as VERIFY_FALLBACK_SERVER, Z as VERIFY_SERVER, Kt as Verify, Dt as WALLETCONNECT_CLIENT_ID, ee as default };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import jt,{EventEmitter as N}from\"events\";import Yt from\"@walletconnect/keyvaluestorage\";import{HEARTBEAT_EVENTS as j,HeartBeat as Gt}from\"@walletconnect/heartbeat\";import{generateChildLogger as f,getLoggerContext as E,pino as ye,getDefaultLoggerOptions as me}from\"@walletconnect/logger\";import{IMessageTracker as Ht,IPublisher as Jt,ISubscriber as Wt,IRelayer as Xt,IStore as Qt,IJsonRpcHistory as Zt,IExpirer as ei,IVerify as ti,ICore as ii}from\"@walletconnect/types\";import{safeJsonStringify as si,safeJsonParse as ri}from\"@walletconnect/safe-json\";import*as Y from\"@walletconnect/relay-auth\";import{getInternalError as l,mapToObj as be,objToMap as fe,generateKeyPair as ni,generateRandomBytes32 as te,deriveSymKey as ai,hashKey as oi,validateEncoding as hi,isTypeOneEnvelope as Ee,encrypt as ci,validateDecoding as ui,decrypt as li,deserialize as we,decodeTypeByte as di,BASE16 as gi,hashMessage as ie,getRelayProtocolName as se,createExpiringPromise as M,getRelayProtocolApi as G,isUndefined as re,getSdkError as k,isValidArray as pi,isOnline as ve,formatRelayRpcUrl as Di,subscribeToNetworkChange as yi,isProposalStruct as mi,isSessionStruct as bi,TYPE_1 as fi,calcExpiry as H,formatUri as Ei,parseUri as wi,createDelayedPromise as vi,engineEvent as ne,isExpired as Ie,isValidParams as ae,isValidUrl as Ii,isValidString as Ci,parseExpirerTarget as Ri,formatTopicTarget as _i,formatIdTarget as Si,isReactNative as Pi,isBrowser as Ti,isNode as xi}from\"@walletconnect/utils\";import{toString as Oi}from\"uint8arrays\";import{ONE_DAY as L,SIX_HOURS as Ai,ONE_SECOND as Ce,THIRTY_DAYS as J,FIVE_SECONDS as Re,THIRTY_SECONDS as _e,toMiliseconds as U,TEN_SECONDS as zi,Watch as Ni,FIVE_MINUTES as Se}from\"@walletconnect/time\";import{JsonRpcProvider as Li}from\"@walletconnect/jsonrpc-provider\";import{getBigIntRpcId as Ui,isJsonRpcRequest as Pe,isJsonRpcResponse as Te,formatJsonRpcResult as xe,formatJsonRpcRequest as Oe,formatJsonRpcError as Fi,isJsonRpcResult as $i,isJsonRpcError as Ae}from\"@walletconnect/jsonrpc-utils\";import Mi from\"@walletconnect/jsonrpc-ws-connection\";import ki from\"lodash.isequal\";function Ki(r,e){if(r.length>=255)throw new TypeError(\"Alphabet too long\");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<r.length;s++){var n=r.charAt(s),a=n.charCodeAt(0);if(t[a]!==255)throw new TypeError(n+\" is ambiguous\");t[a]=s}var o=r.length,h=r.charAt(0),u=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function p(c){if(c instanceof Uint8Array||(ArrayBuffer.isView(c)?c=new Uint8Array(c.buffer,c.byteOffset,c.byteLength):Array.isArray(c)&&(c=Uint8Array.from(c))),!(c instanceof Uint8Array))throw new TypeError(\"Expected Uint8Array\");if(c.length===0)return\"\";for(var m=0,z=0,I=0,_=c.length;I!==_&&c[I]===0;)I++,m++;for(var S=(_-I)*d+1>>>0,b=new Uint8Array(S);I!==_;){for(var P=c[I],A=0,C=S-1;(P!==0||A<z)&&C!==-1;C--,A++)P+=256*b[C]>>>0,b[C]=P%o>>>0,P=P/o>>>0;if(P!==0)throw new Error(\"Non-zero carry\");z=A,I++}for(var x=S-z;x!==S&&b[x]===0;)x++;for(var q=h.repeat(m);x<S;++x)q+=r.charAt(b[x]);return q}function y(c){if(typeof c!=\"string\")throw new TypeError(\"Expected String\");if(c.length===0)return new Uint8Array;var m=0;if(c[m]!==\" \"){for(var z=0,I=0;c[m]===h;)z++,m++;for(var _=(c.length-m)*u+1>>>0,S=new Uint8Array(_);c[m];){var b=t[c.charCodeAt(m)];if(b===255)return;for(var P=0,A=_-1;(b!==0||P<I)&&A!==-1;A--,P++)b+=o*S[A]>>>0,S[A]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error(\"Non-zero carry\");I=P,m++}if(c[m]!==\" \"){for(var C=_-I;C!==_&&S[C]===0;)C++;for(var x=new Uint8Array(z+(_-C)),q=z;C!==_;)x[q++]=S[C++];return x}}}function $(c){var m=y(c);if(m)return m;throw new Error(`Non-${e} character`)}return{encode:p,decodeUnsafe:y,decode:$}}var Bi=Ki,Vi=Bi;const ze=r=>{if(r instanceof Uint8Array&&r.constructor.name===\"Uint8Array\")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error(\"Unknown type, must be binary type\")},qi=r=>new TextEncoder().encode(r),ji=r=>new TextDecoder().decode(r);class Yi{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error(\"Unknown type, must be binary type\")}}class Gi{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error(\"Invalid prefix character\");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e==\"string\"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error(\"Can only multibase decode strings\")}or(e){return Ne(this,e)}}class Hi{constructor(e){this.decoders=e}or(e){return Ne(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Ne=(r,e)=>new Hi({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class Ji{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new Yi(e,t,i),this.decoder=new Gi(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const W=({name:r,prefix:e,encode:t,decode:i})=>new Ji(r,e,t,i),K=({prefix:r,name:e,alphabet:t})=>{const{encode:i,decode:s}=Vi(t,e);return W({prefix:r,name:e,encode:i,decode:n=>ze(s(n))})},Wi=(r,e,t,i)=>{const s={};for(let d=0;d<e.length;++d)s[e[d]]=d;let n=r.length;for(;r[n-1]===\"=\";)--n;const a=new Uint8Array(n*t/8|0);let o=0,h=0,u=0;for(let d=0;d<n;++d){const p=s[r[d]];if(p===void 0)throw new SyntaxError(`Non-${i} character`);h=h<<t|p,o+=t,o>=8&&(o-=8,a[u++]=255&h>>o)}if(o>=t||255&h<<8-o)throw new SyntaxError(\"Unexpected end of data\");return a},Xi=(r,e,t)=>{const i=e[e.length-1]===\"=\",s=(1<<t)-1;let n=\"\",a=0,o=0;for(let h=0;h<r.length;++h)for(o=o<<8|r[h],a+=8;a>t;)a-=t,n+=e[s&o>>a];if(a&&(n+=e[s&o<<t-a]),i)for(;n.length*t&7;)n+=\"=\";return n},g=({name:r,prefix:e,bitsPerChar:t,alphabet:i})=>W({prefix:e,name:r,encode(s){return Xi(s,i,t)},decode(s){return Wi(s,i,t,r)}}),Qi=W({prefix:\"\\0\",name:\"identity\",encode:r=>ji(r),decode:r=>qi(r)});var Zi=Object.freeze({__proto__:null,identity:Qi});const es=g({prefix:\"0\",name:\"base2\",alphabet:\"01\",bitsPerChar:1});var ts=Object.freeze({__proto__:null,base2:es});const is=g({prefix:\"7\",name:\"base8\",alphabet:\"01234567\",bitsPerChar:3});var ss=Object.freeze({__proto__:null,base8:is});const rs=K({prefix:\"9\",name:\"base10\",alphabet:\"0123456789\"});var ns=Object.freeze({__proto__:null,base10:rs});const as=g({prefix:\"f\",name:\"base16\",alphabet:\"0123456789abcdef\",bitsPerChar:4}),os=g({prefix:\"F\",name:\"base16upper\",alphabet:\"0123456789ABCDEF\",bitsPerChar:4});var hs=Object.freeze({__proto__:null,base16:as,base16upper:os});const cs=g({prefix:\"b\",name:\"base32\",alphabet:\"abcdefghijklmnopqrstuvwxyz234567\",bitsPerChar:5}),us=g({prefix:\"B\",name:\"base32upper\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",bitsPerChar:5}),ls=g({prefix:\"c\",name:\"base32pad\",alphabet:\"abcdefghijklmnopqrstuvwxyz234567=\",bitsPerChar:5}),ds=g({prefix:\"C\",name:\"base32padupper\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",bitsPerChar:5}),gs=g({prefix:\"v\",name:\"base32hex\",alphabet:\"0123456789abcdefghijklmnopqrstuv\",bitsPerChar:5}),ps=g({prefix:\"V\",name:\"base32hexupper\",alphabet:\"0123456789ABCDEFGHIJKLMNOPQRSTUV\",bitsPerChar:5}),Ds=g({prefix:\"t\",name:\"base32hexpad\",alphabet:\"0123456789abcdefghijklmnopqrstuv=\",bitsPerChar:5}),ys=g({prefix:\"T\",name:\"base32hexpadupper\",alphabet:\"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",bitsPerChar:5}),ms=g({prefix:\"h\",name:\"base32z\",alphabet:\"ybndrfg8ejkmcpqxot1uwisza345h769\",bitsPerChar:5});var bs=Object.freeze({__proto__:null,base32:cs,base32upper:us,base32pad:ls,base32padupper:ds,base32hex:gs,base32hexupper:ps,base32hexpad:Ds,base32hexpadupper:ys,base32z:ms});const fs=K({prefix:\"k\",name:\"base36\",alphabet:\"0123456789abcdefghijklmnopqrstuvwxyz\"}),Es=K({prefix:\"K\",name:\"base36upper\",alphabet:\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"});var ws=Object.freeze({__proto__:null,base36:fs,base36upper:Es});const vs=K({name:\"base58btc\",prefix:\"z\",alphabet:\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"}),Is=K({name:\"base58flickr\",prefix:\"Z\",alphabet:\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"});var Cs=Object.freeze({__proto__:null,base58btc:vs,base58flickr:Is});const Rs=g({prefix:\"m\",name:\"base64\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",bitsPerChar:6}),_s=g({prefix:\"M\",name:\"base64pad\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",bitsPerChar:6}),Ss=g({prefix:\"u\",name:\"base64url\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",bitsPerChar:6}),Ps=g({prefix:\"U\",name:\"base64urlpad\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",bitsPerChar:6});var Ts=Object.freeze({__proto__:null,base64:Rs,base64pad:_s,base64url:Ss,base64urlpad:Ps});const Le=Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),xs=Le.reduce((r,e,t)=>(r[t]=e,r),[]),Os=Le.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function As(r){return r.reduce((e,t)=>(e+=xs[t],e),\"\")}function zs(r){const e=[];for(const t of r){const i=Os[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const Ns=W({prefix:\"\\u{1F680}\",name:\"base256emoji\",encode:As,decode:zs});var Ls=Object.freeze({__proto__:null,base256emoji:Ns}),Us=Fe,Ue=128,Fs=127,$s=~Fs,Ms=Math.pow(2,31);function Fe(r,e,t){e=e||[],t=t||0;for(var i=t;r>=Ms;)e[t++]=r&255|Ue,r/=128;for(;r&$s;)e[t++]=r&255|Ue,r>>>=7;return e[t]=r|0,Fe.bytes=t-i+1,e}var ks=oe,Ks=128,$e=127;function oe(r,i){var t=0,i=i||0,s=0,n=i,a,o=r.length;do{if(n>=o)throw oe.bytes=0,new RangeError(\"Could not decode varint\");a=r[n++],t+=s<28?(a&$e)<<s:(a&$e)*Math.pow(2,s),s+=7}while(a>=Ks);return oe.bytes=n-i,t}var Bs=Math.pow(2,7),Vs=Math.pow(2,14),qs=Math.pow(2,21),js=Math.pow(2,28),Ys=Math.pow(2,35),Gs=Math.pow(2,42),Hs=Math.pow(2,49),Js=Math.pow(2,56),Ws=Math.pow(2,63),Xs=function(r){return r<Bs?1:r<Vs?2:r<qs?3:r<js?4:r<Ys?5:r<Gs?6:r<Hs?7:r<Js?8:r<Ws?9:10},Qs={encode:Us,decode:ks,encodingLength:Xs},Me=Qs;const ke=(r,e,t=0)=>(Me.encode(r,e,t),e),Ke=r=>Me.encodingLength(r),he=(r,e)=>{const t=e.byteLength,i=Ke(r),s=i+Ke(t),n=new Uint8Array(s+t);return ke(r,n,0),ke(t,n,i),n.set(e,s),new Zs(r,t,e,n)};class Zs{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const Be=({name:r,code:e,encode:t})=>new er(r,e,t);class er{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?he(this.code,t):t.then(i=>he(this.code,i))}else throw Error(\"Unknown type, must be binary type\")}}const Ve=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),tr=Be({name:\"sha2-256\",code:18,encode:Ve(\"SHA-256\")}),ir=Be({name:\"sha2-512\",code:19,encode:Ve(\"SHA-512\")});var sr=Object.freeze({__proto__:null,sha256:tr,sha512:ir});const qe=0,rr=\"identity\",je=ze,nr=r=>he(qe,je(r)),ar={code:qe,name:rr,encode:je,digest:nr};var or=Object.freeze({__proto__:null,identity:ar});new TextEncoder,new TextDecoder;const Ye={...Zi,...ts,...ss,...ns,...hs,...bs,...ws,...Cs,...Ts,...Ls};({...sr,...or});function Ge(r){return globalThis.Buffer!=null?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r}function hr(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?Ge(globalThis.Buffer.allocUnsafe(r)):new Uint8Array(r)}function He(r,e,t,i){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:i}}}const Je=He(\"utf8\",\"u\",r=>\"u\"+new TextDecoder(\"utf8\").decode(r),r=>new TextEncoder().encode(r.substring(1))),ce=He(\"ascii\",\"a\",r=>{let e=\"a\";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=hr(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),cr={utf8:Je,\"utf-8\":Je,hex:Ye.base16,latin1:ce,ascii:ce,binary:ce,...Ye};function ur(r,e=\"utf8\"){const t=cr[e];if(!t)throw new Error(`Unsupported encoding \"${e}\"`);return(e===\"utf8\"||e===\"utf-8\")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?Ge(globalThis.Buffer.from(r,\"utf-8\")):t.decoder.decode(`${t.prefix}${r}`)}const ue=\"wc\",We=2,X=\"core\",O=`${ue}@2:${X}:`,Xe={name:X,logger:\"error\"},Qe={database:\":memory:\"},Ze=\"crypto\",le=\"client_ed25519_seed\",et=L,tt=\"keychain\",it=\"0.3\",st=\"messages\",rt=\"0.3\",nt=Ai,at=\"publisher\",ot=\"irn\",ht=\"error\",de=\"wss://relay.walletconnect.com\",ge=\"wss://relay.walletconnect.org\",ct=\"relayer\",D={message:\"relayer_message\",message_ack:\"relayer_message_ack\",connect:\"relayer_connect\",disconnect:\"relayer_disconnect\",error:\"relayer_error\",connection_stalled:\"relayer_connection_stalled\",transport_closed:\"relayer_transport_closed\",publish:\"relayer_publish\"},ut=\"_subscription\",T={payload:\"payload\",connect:\"connect\",disconnect:\"disconnect\",error:\"error\"},lt=Ce,lr={database:\":memory:\"},dt=\"2.10.2\",gt=1e4,pt=\"0.3\",Dt=\"WALLETCONNECT_CLIENT_ID\",w={created:\"subscription_created\",deleted:\"subscription_deleted\",expired:\"subscription_expired\",disabled:\"subscription_disabled\",sync:\"subscription_sync\",resubscribed:\"subscription_resubscribed\"},dr=J,yt=\"subscription\",mt=\"0.3\",bt=Re*1e3,ft=\"pairing\",Et=\"0.3\",gr=J,F={wc_pairingDelete:{req:{ttl:L,prompt:!1,tag:1e3},res:{ttl:L,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:_e,prompt:!1,tag:1002},res:{ttl:_e,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:L,prompt:!1,tag:0},res:{ttl:L,prompt:!1,tag:0}}},B={create:\"pairing_create\",expire:\"pairing_expire\",delete:\"pairing_delete\",ping:\"pairing_ping\"},R={created:\"history_created\",updated:\"history_updated\",deleted:\"history_deleted\",sync:\"history_sync\"},wt=\"history\",vt=\"0.3\",It=\"expirer\",v={created:\"expirer_created\",deleted:\"expirer_deleted\",expired:\"expirer_expired\",sync:\"expirer_sync\"},Ct=\"0.3\",pr=L,Q=\"verify-api\",Z=\"https://verify.walletconnect.com\",pe=\"https://verify.walletconnect.org\";class Rt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=tt,this.version=it,this.initialized=!1,this.storagePrefix=O,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<\"u\"&&(this.keychain=i),this.initialized=!0}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>\"u\"){const{message:n}=l(\"NO_MATCHING_KEY\",`${this.name}: ${i}`);throw new Error(n)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()},this.core=e,this.logger=f(t,this.name)}get context(){return E(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+\"//\"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,be(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<\"u\"?fe(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}}class _t{constructor(e,t,i){this.core=e,this.logger=t,this.name=Ze,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),n=Y.generateKeyPair(s);return Y.encodeIss(n.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=ni();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const n=await this.getClientSeed(),a=Y.generateKeyPair(n),o=te(),h=et;return await Y.signJWT(o,s,h,a)},this.generateSharedKey=(s,n,a)=>{this.isInitialized();const o=this.getPrivateKey(s),h=ai(o,n);return this.setSymKey(h,a)},this.setSymKey=async(s,n)=>{this.isInitialized();const a=n||oi(s);return await this.keychain.set(a,s),a},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s)},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s)},this.encode=async(s,n,a)=>{this.isInitialized();const o=hi(a),h=si(n);if(Ee(o)){const y=o.senderPublicKey,$=o.receiverPublicKey;s=await this.generateSharedKey(y,$)}const u=this.getSymKey(s),{type:d,senderPublicKey:p}=o;return ci({type:d,symKey:u,message:h,senderPublicKey:p})},this.decode=async(s,n,a)=>{this.isInitialized();const o=ui(n,a);if(Ee(o)){const h=o.receiverPublicKey,u=o.senderPublicKey;s=await this.generateSharedKey(h,u)}try{const h=this.getSymKey(s),u=li({symKey:h,encoded:n});return ri(u)}catch(h){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(h)}},this.getPayloadType=s=>{const n=we(s);return di(n.type)},this.getPayloadSenderPublicKey=s=>{const n=we(s);return n.senderPublicKey?Oi(n.senderPublicKey,gi):void 0},this.core=e,this.logger=f(t,this.name),this.keychain=i||new Rt(this.core,this.logger)}get context(){return E(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e=\"\";try{e=this.keychain.get(le)}catch{e=te(),await this.keychain.set(le,e)}return ur(e,\"base16\")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}}class St extends Ht{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=st,this.version=rt,this.initialized=!1,this.storagePrefix=O,this.init=async()=>{if(!this.initialized){this.logger.trace(\"Initialized\");try{const i=await this.getRelayerMessages();typeof i<\"u\"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:\"method\",method:\"restore\",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}},this.set=async(i,s)=>{this.isInitialized();const n=ie(s);let a=this.messages.get(i);return typeof a>\"u\"&&(a={}),typeof a[n]<\"u\"||(a[n]=s,this.messages.set(i,a),await this.persist()),n},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>\"u\"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();const n=this.get(i),a=ie(s);return typeof n[a]<\"u\"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist()},this.logger=f(e,this.name),this.core=t}get context(){return E(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+\"//\"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,be(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<\"u\"?fe(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}}class Dr extends Jt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new N,this.name=at,this.queue=new Map,this.publishTimeout=U(zi),this.needsTransportRestart=!1,this.publish=async(i,s,n)=>{var a;this.logger.debug(\"Publishing Payload\"),this.logger.trace({type:\"method\",method:\"publish\",params:{topic:i,message:s,opts:n}});try{const o=n?.ttl||nt,h=se(n),u=n?.prompt||!1,d=n?.tag||0,p=n?.id||Ui().toString(),y={topic:i,message:s,opts:{ttl:o,relay:h,prompt:u,tag:d,id:p}},$=setTimeout(()=>this.queue.set(p,y),this.publishTimeout);try{await await M(this.rpcPublish(i,s,o,h,u,d,p),this.publishTimeout,\"Failed to publish payload, please try again.\"),this.removeRequestFromQueue(p),this.relayer.events.emit(D.publish,y)}catch(c){if(this.logger.debug(\"Publishing Payload stalled\"),this.needsTransportRestart=!0,(a=n?.internal)!=null&&a.throwOnFailedPublish)throw this.removeRequestFromQueue(p),c;return}finally{clearTimeout($)}this.logger.debug(\"Successfully Published Payload\"),this.logger.trace({type:\"method\",method:\"publish\",params:{topic:i,message:s,opts:n}})}catch(o){throw this.logger.debug(\"Failed to Publish Payload\"),this.logger.error(o),o}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=f(t,this.name),this.registerEventListeners()}get context(){return E(this.logger)}rpcPublish(e,t,i,s,n,a,o){var h,u,d,p;const y={method:G(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:n,tag:a},id:o};return re((h=y.params)==null?void 0:h.prompt)&&((u=y.params)==null||delete u.prompt),re((d=y.params)==null?void 0:d.tag)&&((p=y.params)==null||delete p.tag),this.logger.debug(\"Outgoing Relay Payload\"),this.logger.trace({type:\"message\",direction:\"outgoing\",request:y}),this.relayer.request(y)}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s)})}registerEventListeners(){this.relayer.core.heartbeat.on(j.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(D.connection_stalled);return}this.checkQueue()}),this.relayer.on(D.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}class yr{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>\"u\"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(n=>n!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var mr=Object.defineProperty,br=Object.defineProperties,fr=Object.getOwnPropertyDescriptors,Pt=Object.getOwnPropertySymbols,Er=Object.prototype.hasOwnProperty,wr=Object.prototype.propertyIsEnumerable,Tt=(r,e,t)=>e in r?mr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,V=(r,e)=>{for(var t in e||(e={}))Er.call(e,t)&&Tt(r,t,e[t]);if(Pt)for(var t of Pt(e))wr.call(e,t)&&Tt(r,t,e[t]);return r},De=(r,e)=>br(r,fr(e));class xt extends Wt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new yr,this.events=new N,this.name=yt,this.version=mt,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel=\"pending_sub_watch_label\",this.pollingInterval=20,this.storagePrefix=O,this.subscribeTimeout=1e4,this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.init=async()=>{this.initialized||(this.logger.trace(\"Initialized\"),this.registerEventListeners(),this.clientId=await this.relayer.core.crypto.getClientId())},this.subscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug(\"Subscribing Topic\"),this.logger.trace({type:\"method\",method:\"subscribe\",params:{topic:i,opts:s}});try{const n=se(s),a={topic:i,relay:n};this.pending.set(i,a);const o=await this.rpcSubscribe(i,n);return this.onSubscribe(o,a),this.logger.debug(\"Successfully Subscribed Topic\"),this.logger.trace({type:\"method\",method:\"subscribe\",params:{topic:i,opts:s}}),o}catch(n){throw this.logger.debug(\"Failed to Subscribe Topic\"),this.logger.error(n),n}},this.unsubscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),typeof s?.id<\"u\"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)},this.isSubscribed=async i=>this.topics.includes(i)?!0:await new Promise((s,n)=>{const a=new Ni;a.start(this.pendingSubscriptionWatchLabel);const o=setInterval(()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),s(!0)),a.elapsed(this.pendingSubscriptionWatchLabel)>=bt&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),n(new Error(\"Subscription resolution timeout\")))},this.pollingInterval)}).catch(()=>!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=f(t,this.name),this.clientId=\"\"}get context(){return E(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+\"//\"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug(\"Unsubscribing Topic\"),this.logger.trace({type:\"method\",method:\"unsubscribe\",params:{topic:e,id:t,opts:i}});try{const s=se(i);await this.rpcUnsubscribe(e,t,s);const n=k(\"USER_DISCONNECTED\",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,n),this.logger.debug(\"Successfully Unsubscribed Topic\"),this.logger.trace({type:\"method\",method:\"unsubscribe\",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug(\"Failed to Unsubscribe Topic\"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:G(t.protocol).subscribe,params:{topic:e}};this.logger.debug(\"Outgoing Relay Payload\"),this.logger.trace({type:\"payload\",direction:\"outgoing\",request:i});try{await await M(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug(\"Outgoing Relay Subscribe Payload stalled\"),this.relayer.events.emit(D.connection_stalled)}return ie(e+this.clientId)}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:G(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug(\"Outgoing Relay Payload\"),this.logger.trace({type:\"payload\",direction:\"outgoing\",request:i});try{return await await M(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug(\"Outgoing Relay Payload stalled\"),this.relayer.events.emit(D.connection_stalled)}}rpcUnsubscribe(e,t,i){const s={method:G(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug(\"Outgoing Relay Payload\"),this.logger.trace({type:\"payload\",direction:\"outgoing\",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,De(V({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,V({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug(\"Setting subscription\"),this.logger.trace({type:\"method\",method:\"setSubscription\",id:e,subscription:t}),this.addSubscription(e,t))}addSubscription(e,t){this.subscriptions.set(e,V({},t)),this.topicMap.set(t.topic,e),this.events.emit(w.created,t)}getSubscription(e){this.logger.debug(\"Getting subscription\"),this.logger.trace({type:\"method\",method:\"getSubscription\",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=l(\"NO_MATCHING_KEY\",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug(\"Deleting subscription\"),this.logger.trace({type:\"method\",method:\"deleteSubscription\",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(w.deleted,De(V({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(w.sync)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const i=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(i)}}this.events.emit(w.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>\"u\"||!e.length)return;if(this.subscriptions.size){const{message:t}=l(\"RESTORE_WILL_OVERRIDE\",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:\"method\",method:\"restore\",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);pi(t)&&this.onBatchSubscribe(t.map((i,s)=>De(V({},e[s]),{id:i})))}async onConnect(){this.restartInProgress||(await this.restart(),this.onEnable())}onDisconnect(){this.onDisable()}async checkPending(){if(!this.initialized||this.relayer.transportExplicitlyClosed)return;const e=[];this.pending.forEach(t=>{e.push(t)}),await this.batchSubscribe(e)}registerEventListeners(){this.relayer.core.heartbeat.on(j.pulse,async()=>{await this.checkPending()}),this.relayer.on(D.connect,async()=>{await this.onConnect()}),this.relayer.on(D.disconnect,()=>{this.onDisconnect()}),this.events.on(w.created,async e=>{const t=w.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,data:e}),await this.persist()}),this.events.on(w.deleted,async e=>{const t=w.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,data:e}),await this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise(e=>{const t=setInterval(()=>{this.restartInProgress||(clearInterval(t),e())},this.pollingInterval)})}}var vr=Object.defineProperty,Ot=Object.getOwnPropertySymbols,Ir=Object.prototype.hasOwnProperty,Cr=Object.prototype.propertyIsEnumerable,At=(r,e,t)=>e in r?vr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Rr=(r,e)=>{for(var t in e||(e={}))Ir.call(e,t)&&At(r,t,e[t]);if(Ot)for(var t of Ot(e))Cr.call(e,t)&&At(r,t,e[t]);return r};class zt extends Xt{constructor(e){super(e),this.protocol=\"wc\",this.version=2,this.events=new N,this.name=ct,this.transportExplicitlyClosed=!1,this.initialized=!1,this.connectionAttemptInProgress=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=[\"socket hang up\",\"socket stalled\"],this.hasExperiencedNetworkDisruption=!1,this.request=async t=>{this.logger.debug(\"Publishing Request Payload\");try{return await this.toEstablishConnection(),await this.provider.request(t)}catch(i){throw this.logger.debug(\"Failed to Publish Request\"),this.logger.error(i),i}},this.onPayloadHandler=t=>{this.onProviderPayload(t)},this.onConnectHandler=()=>{this.events.emit(D.connect)},this.onDisconnectHandler=()=>{this.onProviderDisconnect()},this.onProviderErrorHandler=t=>{this.logger.error(t),this.events.emit(D.error,t),this.logger.info(\"Fatal socket error received, closing transport\"),this.transportClose()},this.registerProviderListeners=()=>{this.provider.on(T.payload,this.onPayloadHandler),this.provider.on(T.connect,this.onConnectHandler),this.provider.on(T.disconnect,this.onDisconnectHandler),this.provider.on(T.error,this.onProviderErrorHandler)},this.core=e.core,this.logger=typeof e.logger<\"u\"&&typeof e.logger!=\"string\"?f(e.logger,this.name):ye(me({level:e.logger||ht})),this.messages=new St(this.logger,e.core),this.subscriber=new xt(this,this.logger),this.publisher=new Dr(this,this.logger),this.relayUrl=e?.relayUrl||de,this.projectId=e.projectId,this.provider={}}async init(){this.logger.trace(\"Initialized\"),this.registerEventListeners(),await this.createProvider(),await Promise.all([this.messages.init(),this.subscriber.init()]);try{await this.transportOpen()}catch{this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${ge}...`),await this.restartTransport(ge)}this.initialized=!0,setTimeout(async()=>{this.subscriber.topics.length===0&&(this.logger.info(\"No topics subscribed to after init, closing transport\"),await this.transportClose(),this.transportExplicitlyClosed=!1)},gt)}get context(){return E(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()})}async subscribe(e,t){var i;this.isInitialized();let s=((i=this.subscriber.topicMap.get(e))==null?void 0:i[0])||\"\";if(s)return s;let n;const a=o=>{o.topic===e&&(this.subscriber.off(w.created,a),n())};return await Promise.all([new Promise(o=>{n=o,this.subscriber.on(w.created,a)}),new Promise(async o=>{s=await this.subscriber.subscribe(e,t),o()})]),s}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportClose(){this.transportExplicitlyClosed=!0,this.hasExperiencedNetworkDisruption&&this.connected?await M(this.provider.disconnect(),1e3,\"provider.disconnect()\").catch(()=>this.onProviderDisconnect()):this.connected&&await this.provider.disconnect()}async transportOpen(e){if(this.transportExplicitlyClosed=!1,await this.confirmOnlineStateOrThrow(),!this.connectionAttemptInProgress){e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportClose(),await this.createProvider()),this.connectionAttemptInProgress=!0;try{await Promise.all([new Promise(t=>{if(!this.initialized)return t();this.subscriber.once(w.resubscribed,()=>{t()})}),new Promise(async(t,i)=>{try{await M(this.provider.connect(),1e4,`Socket stalled when trying to connect to ${this.relayUrl}`)}catch(s){i(s);return}t()})])}catch(t){this.logger.error(t);const i=t;if(!this.isConnectionStalled(i.message))throw t;this.provider.events.emit(T.disconnect)}finally{this.connectionAttemptInProgress=!1,this.hasExperiencedNetworkDisruption=!1}}}async restartTransport(e){await this.confirmOnlineStateOrThrow(),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.transportClose(),await this.createProvider(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await ve())throw new Error(\"No internet connection detected. Please restart your network and try again.\")}isConnectionStalled(e){return this.staleConnectionErrors.some(t=>e.includes(t))}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new Li(new Mi(Di({sdkVersion:dt,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||i.length===0)return this.logger.debug(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isSubscribed(t))return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.debug(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug(\"Incoming Relay Payload\"),this.logger.trace({type:\"payload\",direction:\"incoming\",payload:e}),Pe(e)){if(!e.method.endsWith(ut))return;const t=e.params,{topic:i,message:s,publishedAt:n}=t.data,a={topic:i,message:s,publishedAt:n};this.logger.debug(\"Emitting Relayer Payload\"),this.logger.trace(Rr({type:\"event\",event:t.id},a)),this.events.emit(t.id,a),await this.acknowledgePayload(e),await this.onMessageEvent(a)}else Te(e)&&this.events.emit(D.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(D.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=xe(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(T.payload,this.onPayloadHandler),this.provider.off(T.connect,this.onConnectHandler),this.provider.off(T.disconnect,this.onDisconnectHandler),this.provider.off(T.error,this.onProviderErrorHandler)}async registerEventListeners(){this.events.on(D.connection_stalled,()=>{this.restartTransport().catch(t=>this.logger.error(t))});let e=await ve();yi(async t=>{this.initialized&&e!==t&&(e=t,t?await this.restartTransport().catch(i=>this.logger.error(i)):(this.hasExperiencedNetworkDisruption=!0,await this.transportClose().catch(i=>this.logger.error(i))))})}onProviderDisconnect(){this.events.emit(D.disconnect),this.attemptToReconnect()}attemptToReconnect(){this.transportExplicitlyClosed||(this.logger.info(\"attemptToReconnect called. Connecting...\"),setTimeout(async()=>{await this.restartTransport().catch(e=>this.logger.error(e))},U(lt)))}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectionAttemptInProgress)return await new Promise(e=>{const t=setInterval(()=>{this.connected&&(clearInterval(t),e())},this.connectionStatusPollingInterval)});await this.restartTransport()}}}var _r=Object.defineProperty,Nt=Object.getOwnPropertySymbols,Sr=Object.prototype.hasOwnProperty,Pr=Object.prototype.propertyIsEnumerable,Lt=(r,e,t)=>e in r?_r(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ut=(r,e)=>{for(var t in e||(e={}))Sr.call(e,t)&&Lt(r,t,e[t]);if(Nt)for(var t of Nt(e))Pr.call(e,t)&&Lt(r,t,e[t]);return r};class Ft extends Qt{constructor(e,t,i,s=O,n=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=pt,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace(\"Initialized\"),await this.restore(),this.cached.forEach(a=>{this.getKey&&a!==null&&!re(a)?this.map.set(this.getKey(a),a):mi(a)?this.map.set(a.id,a):bi(a)&&this.map.set(a.topic,a)}),this.cached=[],this.initialized=!0)},this.set=async(a,o)=>{this.isInitialized(),this.map.has(a)?await this.update(a,o):(this.logger.debug(\"Setting value\"),this.logger.trace({type:\"method\",method:\"set\",key:a,value:o}),this.map.set(a,o),await this.persist())},this.get=a=>(this.isInitialized(),this.logger.debug(\"Getting value\"),this.logger.trace({type:\"method\",method:\"get\",key:a}),this.getData(a)),this.getAll=a=>(this.isInitialized(),a?this.values.filter(o=>Object.keys(a).every(h=>ki(o[h],a[h]))):this.values),this.update=async(a,o)=>{this.isInitialized(),this.logger.debug(\"Updating value\"),this.logger.trace({type:\"method\",method:\"update\",key:a,update:o});const h=Ut(Ut({},this.getData(a)),o);this.map.set(a,h),await this.persist()},this.delete=async(a,o)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug(\"Deleting value\"),this.logger.trace({type:\"method\",method:\"delete\",key:a,reason:o}),this.map.delete(a),await this.persist())},this.logger=f(t,this.name),this.storagePrefix=s,this.getKey=n}get context(){return E(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+\"//\"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:i}=l(\"NO_MATCHING_KEY\",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>\"u\"||!e.length)return;if(this.map.size){const{message:t}=l(\"RESTORE_WILL_OVERRIDE\",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:\"method\",method:\"restore\",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}}class $t{constructor(e,t){this.core=e,this.logger=t,this.name=ft,this.version=Et,this.events=new jt,this.initialized=!1,this.storagePrefix=O,this.ignoredPayloadTypes=[fi],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace(\"Initialized\"))},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]},this.create=async()=>{this.isInitialized();const i=te(),s=await this.core.crypto.setSymKey(i),n=H(Se),a={protocol:ot},o={topic:s,expiry:n,relay:a,active:!1},h=Ei({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:a});return await this.pairings.set(s,o),await this.core.relayer.subscribe(s),this.core.expirer.set(s,n),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:n,relay:a}=wi(i.uri);let o;if(this.pairings.keys.includes(s)&&(o=this.pairings.get(s),o.active))throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);this.core.crypto.keychain.has(s)||(await this.core.crypto.setSymKey(n,s),await this.core.relayer.subscribe(s,{relay:a}));const h=H(Se),u={topic:s,relay:a,expiry:h,active:!1};return await this.pairings.set(s,u),this.core.expirer.set(s,h),i.activatePairing&&await this.activate({topic:s}),this.events.emit(B.create,u),u},this.activate=async({topic:i})=>{this.isInitialized();const s=H(J);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s)},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const n=await this.sendRequest(s,\"wc_pairingPing\",{}),{done:a,resolve:o,reject:h}=vi();this.events.once(ne(\"pairing_ping\",n),({error:u})=>{u?h(u):o()}),await a()}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,\"wc_pairingDelete\",k(\"USER_DISCONNECTED\")),await this.deletePairing(s))},this.sendRequest=async(i,s,n)=>{const a=Oe(s,n),o=await this.core.crypto.encode(i,a),h=F[s].req;return this.core.history.set(i,a),this.core.relayer.publish(i,o,h),a.id},this.sendResult=async(i,s,n)=>{const a=xe(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),u=F[h.request.method].res;await this.core.relayer.publish(s,o,u),await this.core.history.resolve(a)},this.sendError=async(i,s,n)=>{const a=Fi(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),u=F[h.request.method]?F[h.request.method].res:F.unregistered_method.res;await this.core.relayer.publish(s,o,u),await this.core.history.resolve(a)},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,k(\"USER_DISCONNECTED\")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])},this.cleanup=async()=>{const i=this.pairings.getAll().filter(s=>Ie(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))},this.onRelayEventRequest=i=>{const{topic:s,payload:n}=i;switch(n.method){case\"wc_pairingPing\":return this.onPairingPingRequest(s,n);case\"wc_pairingDelete\":return this.onPairingDeleteRequest(s,n);default:return this.onUnknownRpcMethodRequest(s,n)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:n}=i,a=(await this.core.history.get(s,n.id)).request.method;switch(a){case\"wc_pairingPing\":return this.onPairingPingResponse(s,n);default:return this.onUnknownRpcMethodResponse(a)}},this.onPairingPingRequest=async(i,s)=>{const{id:n}=s;try{this.isValidPing({topic:i}),await this.sendResult(n,i,!0),this.events.emit(B.ping,{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onPairingPingResponse=(i,s)=>{const{id:n}=s;setTimeout(()=>{$i(s)?this.events.emit(ne(\"pairing_ping\",n),{}):Ae(s)&&this.events.emit(ne(\"pairing_ping\",n),{error:s.error})},500)},this.onPairingDeleteRequest=async(i,s)=>{const{id:n}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit(B.delete,{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:n,method:a}=s;try{if(this.registeredMethods.includes(a))return;const o=k(\"WC_METHOD_UNSUPPORTED\",a);await this.sendError(n,i,o),this.logger.error(o)}catch(o){await this.sendError(n,i,o),this.logger.error(o)}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(k(\"WC_METHOD_UNSUPPORTED\",i))},this.isValidPair=i=>{if(!ae(i)){const{message:s}=l(\"MISSING_OR_INVALID\",`pair() params: ${i}`);throw new Error(s)}if(!Ii(i.uri)){const{message:s}=l(\"MISSING_OR_INVALID\",`pair() uri: ${i.uri}`);throw new Error(s)}},this.isValidPing=async i=>{if(!ae(i)){const{message:n}=l(\"MISSING_OR_INVALID\",`ping() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidDisconnect=async i=>{if(!ae(i)){const{message:n}=l(\"MISSING_OR_INVALID\",`disconnect() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidPairingTopic=async i=>{if(!Ci(i,!1)){const{message:s}=l(\"MISSING_OR_INVALID\",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=l(\"NO_MATCHING_KEY\",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(Ie(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=l(\"EXPIRED\",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=f(t,this.name),this.pairings=new Ft(this.core,this.logger,this.name,this.storagePrefix)}get context(){return E(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(D.message,async e=>{const{topic:t,message:i}=e;if(!this.pairings.keys.includes(t)||this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);try{Pe(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):Te(s)&&(await this.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.core.history.delete(t,s.id))}catch(n){this.logger.error(n)}})}registerExpirerEvents(){this.core.expirer.on(v.expired,async e=>{const{topic:t}=Ri(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(B.expire,{topic:t}))})}}class Mt extends Zt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new N,this.name=wt,this.version=vt,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace(\"Initialized\"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(i,s,n)=>{if(this.isInitialized(),this.logger.debug(\"Setting JSON-RPC request history record\"),this.logger.trace({type:\"method\",method:\"set\",topic:i,request:s,chainId:n}),this.records.has(s.id))return;const a={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:n,expiry:H(J)};this.records.set(a.id,a),this.events.emit(R.created,a)},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug(\"Updating JSON-RPC response history record\"),this.logger.trace({type:\"method\",method:\"update\",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>\"u\"&&(s.response=Ae(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(R.updated,s))},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug(\"Getting record\"),this.logger.trace({type:\"method\",method:\"get\",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug(\"Deleting record\"),this.logger.trace({type:\"method\",method:\"delete\",id:s}),this.values.forEach(n=>{if(n.topic===i){if(typeof s<\"u\"&&n.id!==s)return;this.records.delete(n.id),this.events.emit(R.deleted,n)}})},this.exists=async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=f(t,this.name)}get context(){return E(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+\"//\"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<\"u\")return;const i={topic:t.topic,request:Oe(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=l(\"NO_MATCHING_KEY\",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(R.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>\"u\"||!e.length)return;if(this.records.size){const{message:t}=l(\"RESTORE_WILL_OVERRIDE\",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:\"method\",method:\"restore\",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(R.created,e=>{const t=R.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,record:e}),this.persist()}),this.events.on(R.updated,e=>{const t=R.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,record:e}),this.persist()}),this.events.on(R.deleted,e=>{const t=R.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,record:e}),this.persist()}),this.core.heartbeat.on(j.pulse,()=>{this.cleanup()})}cleanup(){try{this.records.forEach(e=>{U(e.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${e.id}`),this.delete(e.topic,e.id))})}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}}class kt extends ei{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new N,this.name=It,this.version=Ct,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace(\"Initialized\"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<\"u\"}catch{return!1}},this.set=(i,s)=>{this.isInitialized();const n=this.formatTarget(i),a={target:n,expiry:s};this.expirations.set(n,a),this.checkExpiry(n,a),this.events.emit(v.created,{target:n,expiration:a})},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),n=this.getExpiration(s);this.expirations.delete(s),this.events.emit(v.deleted,{target:s,expiration:n})}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=f(t,this.name)}get context(){return E(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+\"//\"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e==\"string\")return _i(e);if(typeof e==\"number\")return Si(e);const{message:t}=l(\"UNKNOWN_TYPE\",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(v.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>\"u\"||!e.length)return;if(this.expirations.size){const{message:t}=l(\"RESTORE_WILL_OVERRIDE\",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:\"method\",method:\"restore\",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=l(\"NO_MATCHING_KEY\",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;U(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(v.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(j.pulse,()=>this.checkExpirations()),this.events.on(v.created,e=>{const t=v.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,data:e}),this.persist()}),this.events.on(v.expired,e=>{const t=v.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,data:e}),this.persist()}),this.events.on(v.deleted,e=>{const t=v.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:\"event\",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=l(\"NOT_INITIALIZED\",this.name);throw new Error(e)}}}class Kt extends ti{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.name=Q,this.initialized=!1,this.queue=[],this.verifyDisabled=!1,this.init=async()=>{if(this.verifyDisabled||Pi()||!Ti())return;const i=Z;this.verifyUrl!==i&&this.removeIframe(),this.verifyUrl=i;try{await this.createIframe()}catch(s){this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.info(s)}if(!this.initialized){this.removeIframe(),this.verifyUrl=pe;try{await this.createIframe()}catch(s){this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.info(s),this.verifyDisabled=!0}}},this.register=async i=>{this.initialized?this.sendPost(i.attestationId):(this.addToQueue(i.attestationId),await this.init())},this.resolve=async i=>{if(this.isDevEnv)return\"\";const s=i?.verifyUrl||Z;let n;try{n=await this.fetchAttestation(i.attestationId,s)}catch(a){this.logger.info(`failed to resolve attestation: ${i.attestationId} from url: ${s}`),this.logger.info(a),n=await this.fetchAttestation(i.attestationId,pe)}return n},this.fetchAttestation=async(i,s)=>{this.logger.info(`resolving attestation: ${i} from url: ${s}`);const n=this.startAbortTimer(Ce*2),a=await fetch(`${s}/attestation/${i}`,{signal:this.abortController.signal});return clearTimeout(n),a.status===200?await a.json():void 0},this.addToQueue=i=>{this.queue.push(i)},this.processQueue=()=>{this.queue.length!==0&&(this.queue.forEach(i=>this.sendPost(i)),this.queue=[])},this.sendPost=i=>{var s;try{if(!this.iframe)return;(s=this.iframe.contentWindow)==null||s.postMessage(i,\"*\"),this.logger.info(`postMessage sent: ${i} ${this.verifyUrl}`)}catch{}},this.createIframe=async()=>{let i;const s=n=>{n.data===\"verify_ready\"&&(this.initialized=!0,this.processQueue(),window.removeEventListener(\"message\",s),i())};await Promise.race([new Promise(n=>{if(document.getElementById(Q))return n();window.addEventListener(\"message\",s);const a=document.createElement(\"iframe\");a.id=Q,a.src=`${this.verifyUrl}/${this.projectId}`,a.style.display=\"none\",document.body.append(a),this.iframe=a,i=n}),new Promise((n,a)=>setTimeout(()=>{window.removeEventListener(\"message\",s),a(\"verify iframe load timeout\")},U(Re)))])},this.removeIframe=()=>{this.iframe&&(this.iframe.remove(),this.iframe=void 0,this.initialized=!1)},this.logger=f(t,this.name),this.verifyUrl=Z,this.abortController=new AbortController,this.isDevEnv=xi()&&process.env.IS_VITEST}get context(){return E(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),U(e))}}var Tr=Object.defineProperty,Bt=Object.getOwnPropertySymbols,xr=Object.prototype.hasOwnProperty,Or=Object.prototype.propertyIsEnumerable,Vt=(r,e,t)=>e in r?Tr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,qt=(r,e)=>{for(var t in e||(e={}))xr.call(e,t)&&Vt(r,t,e[t]);if(Bt)for(var t of Bt(e))Or.call(e,t)&&Vt(r,t,e[t]);return r};class ee extends ii{constructor(e){super(e),this.protocol=ue,this.version=We,this.name=X,this.events=new N,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||de,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:\"\";const t=typeof e?.logger<\"u\"&&typeof e?.logger!=\"string\"?e.logger:ye(me({level:e?.logger||Xe.logger}));this.logger=f(t,this.name),this.heartbeat=new Gt,this.crypto=new _t(this,this.logger,e?.keychain),this.history=new Mt(this,this.logger),this.expirer=new kt(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new Yt(qt(qt({},Qe),e?.storageOptions)),this.relayer=new zt({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new $t(this,this.logger),this.verify=new Kt(this.projectId||\"\",this.logger)}static async init(e){const t=new ee(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem(Dt,i),t}get context(){return E(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace(\"Initialized\");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info(\"Core Initialization Success\")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const Ar=ee;export{X as CORE_CONTEXT,Xe as CORE_DEFAULT,ue as CORE_PROTOCOL,Qe as CORE_STORAGE_OPTIONS,O as CORE_STORAGE_PREFIX,We as CORE_VERSION,le as CRYPTO_CLIENT_SEED,Ze as CRYPTO_CONTEXT,et as CRYPTO_JWT_TTL,Ar as Core,_t as Crypto,It as EXPIRER_CONTEXT,pr as EXPIRER_DEFAULT_TTL,v as EXPIRER_EVENTS,Ct as EXPIRER_STORAGE_VERSION,kt as Expirer,wt as HISTORY_CONTEXT,R as HISTORY_EVENTS,vt as HISTORY_STORAGE_VERSION,Mt as JsonRpcHistory,tt as KEYCHAIN_CONTEXT,it as KEYCHAIN_STORAGE_VERSION,Rt as KeyChain,st as MESSAGES_CONTEXT,rt as MESSAGES_STORAGE_VERSION,St as MessageTracker,ft as PAIRING_CONTEXT,gr as PAIRING_DEFAULT_TTL,B as PAIRING_EVENTS,F as PAIRING_RPC_OPTS,Et as PAIRING_STORAGE_VERSION,bt as PENDING_SUB_RESOLUTION_TIMEOUT,at as PUBLISHER_CONTEXT,nt as PUBLISHER_DEFAULT_TTL,$t as Pairing,ct as RELAYER_CONTEXT,ht as RELAYER_DEFAULT_LOGGER,ot as RELAYER_DEFAULT_PROTOCOL,de as RELAYER_DEFAULT_RELAY_URL,D as RELAYER_EVENTS,ge as RELAYER_FAILOVER_RELAY_URL,T as RELAYER_PROVIDER_EVENTS,lt as RELAYER_RECONNECT_TIMEOUT,dt as RELAYER_SDK_VERSION,lr as RELAYER_STORAGE_OPTIONS,ut as RELAYER_SUBSCRIBER_SUFFIX,gt as RELAYER_TRANSPORT_CUTOFF,zt as Relayer,pt as STORE_STORAGE_VERSION,yt as SUBSCRIBER_CONTEXT,dr as SUBSCRIBER_DEFAULT_TTL,w as SUBSCRIBER_EVENTS,mt as SUBSCRIBER_STORAGE_VERSION,Ft as Store,xt as Subscriber,Q as VERIFY_CONTEXT,pe as VERIFY_FALLBACK_SERVER,Z as VERIFY_SERVER,Kt as Verify,Dt as WALLETCONNECT_CLIENT_ID,ee as default};\n//# sourceMappingURL=index.es.js.map\n"]},"metadata":{},"sourceType":"module"}