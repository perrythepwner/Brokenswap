{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref;\n    return max === undefined ? (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must contain at least \", \" valid item(s)\"])), min) : (0, codegen_1.str)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"must contain at least \", \" and no more than \", \" valid item(s)\"])), min, max);\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref2;\n    return max === undefined ? (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"{minContains: \", \"}\"])), min) : (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{minContains: \", \", maxContains: \", \"}\"])), min, max);\n  }\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n    const len = gen.const(\"len\", (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n    cxt.setParams({\n      min,\n      max\n    });\n    if (max === undefined && min === 0) {\n      (0, util_1.checkStrictMode)(it, \"\\\"minContains\\\" == 0 without \\\"maxContains\\\": \\\"contains\\\" keyword ignored\");\n      return;\n    }\n    if (max !== undefined && min > max) {\n      (0, util_1.checkStrictMode)(it, \"\\\"minContains\\\" > \\\"maxContains\\\" is always invalid\");\n      cxt.fail();\n      return;\n    }\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      let cond = (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), len, min);\n      if (max !== undefined) cond = (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" && \", \" <= \", \"\"])), cond, len, max);\n      cxt.pass(cond);\n      return;\n    }\n    it.items = true;\n    const valid = gen.name(\"valid\");\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else if (min === 0) {\n      gen.let(valid, true);\n      if (max !== undefined) gen.if((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".length > 0\"])), data), validateItemsWithCount);\n    } else {\n      gen.let(valid, false);\n      validateItemsWithCount();\n    }\n    cxt.result(valid, () => cxt.reset());\n    function validateItemsWithCount() {\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n    function checkLimits(count) {\n      gen.code((0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \"++\"])), count));\n      if (max === undefined) {\n        gen.if((0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), count, min), () => gen.assign(valid, true).break());\n      } else {\n        gen.if((0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \" > \", \"\"])), count, max), () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if((0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), count, min), () => gen.assign(valid, true));\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/contains.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map"]},"metadata":{},"sourceType":"script"}