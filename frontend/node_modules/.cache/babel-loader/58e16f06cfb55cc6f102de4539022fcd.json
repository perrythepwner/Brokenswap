{"ast":null,"code":"import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo,useConnectedSigner,useProvider}from'@celo/react-celo';import{JSBI,Percent,Router}from'@ubeswap/sdk';import{MoolaRouterTrade}from'components/swap/routing/hooks/useTrade';import{useMemo}from'react';import{useTransactionAdder}from'state/transactions/hooks';import invariant from'tiny-invariant';import{BIPS_BASE,INITIAL_ALLOWED_SLIPPAGE}from'../constants';import{calculateGasMargin,getMoolaRouterContract,getRouterContract,isAddress,shortenAddress}from'../utils';import isZero from'../utils/isZero';import useENS from'./useENS';import useTransactionDeadline from'./useTransactionDeadline';export let SwapCallbackState=/*#__PURE__*/function(SwapCallbackState){SwapCallbackState[SwapCallbackState[\"INVALID\"]=0]=\"INVALID\";SwapCallbackState[SwapCallbackState[\"LOADING\"]=1]=\"LOADING\";SwapCallbackState[SwapCallbackState[\"VALID\"]=2]=\"VALID\";return SwapCallbackState;}({});/**\n * Returns the swap calls that can be used to make the trade\n * @param trade trade to execute\n * @param allowedSlippage user allowed slippage\n * @param recipientAddressOrName\n */function useSwapCallArguments(trade){let allowedSlippage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:INITIAL_ALLOWED_SLIPPAGE;let// in bips\nrecipientAddressOrName=arguments.length>2?arguments[2]:undefined;const{address:account,network}=useCelo();const library=useProvider();const chainId=network.chainId;const{address:recipientAddress}=useENS(recipientAddressOrName);const recipient=recipientAddressOrName===null?account:recipientAddress;const deadline=useTransactionDeadline();return useMemo(()=>{if(!trade||!recipient||!library||!account||!chainId||!deadline)return[];const contract=trade instanceof MoolaRouterTrade?getMoolaRouterContract(chainId,library,account):getRouterContract(chainId,library,account);const swapCallParameters=Router.swapCallParameters(trade,{feeOnTransfer:!(trade instanceof MoolaRouterTrade),allowedSlippage:new Percent(JSBI.BigInt(allowedSlippage),BIPS_BASE),recipient,deadline:deadline.toNumber()});invariant(Array.isArray(swapCallParameters.args[2]),'arg 2 not path');if(trade instanceof MoolaRouterTrade){swapCallParameters.args[2]=trade.path.map(p=>p.address);}const swapMethods=[swapCallParameters];// TODO(igm): figure out why this is failing\n// if (trade.tradeType === TradeType.EXACT_INPUT) {\n//   swapMethods.push(\n//     Router.swapCallParameters(trade, {\n//       feeOnTransfer: true,\n//       allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n//       recipient,\n//       deadline: deadline.toNumber()\n//     })\n//   )\n// }\nreturn swapMethods.map(parameters=>({parameters,contract}));},[account,allowedSlippage,chainId,deadline,library,recipient,trade]);}// returns a function that will execute a swap, if the parameters are all valid\n// and the user has approved the slippage adjusted input amount for the trade\nexport function useSwapCallback(trade){let allowedSlippage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:INITIAL_ALLOWED_SLIPPAGE;let// in bips\nrecipientAddressOrName=arguments.length>2?arguments[2]:undefined;const{network,address:account}=useCelo();const chainId=network.chainId;const swapCalls=useSwapCallArguments(trade,allowedSlippage,recipientAddressOrName);const addTransaction=useTransactionAdder();const{address:recipientAddress}=useENS(recipientAddressOrName);const recipient=recipientAddressOrName===null?account:recipientAddress;const signer=useConnectedSigner();return useMemo(()=>{if(!trade||!account||!chainId){return{state:SwapCallbackState.INVALID,callback:null,error:'Missing dependencies'};}if(!recipient){if(recipientAddressOrName!==null){return{state:SwapCallbackState.INVALID,callback:null,error:'Invalid recipient'};}else{return{state:SwapCallbackState.LOADING,callback:null,error:null};}}return{state:SwapCallbackState.VALID,callback:function(){var _onSwap=_asyncToGenerator(function*(){const estimatedCalls=yield Promise.all(swapCalls.map(call=>{const{parameters:{methodName,args,value},contract}=call;const options=!value||isZero(value)?{}:{value};return contract.estimateGas[methodName](...args,options).then(gasEstimate=>{return{call,gasEstimate};}).catch(gasError=>{console.debug('Gas estimate failed, trying eth_call to extract error',call);return contract.callStatic[methodName](...args,options).then(result=>{console.debug('Unexpected successful call after failed estimate gas',call,gasError,result);return{call,error:new Error('Unexpected issue with estimating the gas. Please try again.')};}).catch(callError=>{console.debug('Call threw error',call,callError);let errorMessage;switch(callError.reason){case'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':case'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':errorMessage='This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';break;default:errorMessage=\"The transaction cannot succeed due to error: \".concat(callError.reason,\". This is probably an issue with one of the tokens you are swapping.\");}return{call,error:new Error(errorMessage)};});});}));// a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\nconst successfulEstimation=estimatedCalls.find((el,ix,list)=>'gasEstimate'in el&&(ix===list.length-1||'gasEstimate'in list[ix+1]));if(!successfulEstimation){const errorCalls=estimatedCalls.filter(call=>'error'in call);if(errorCalls.length>0)throw errorCalls[errorCalls.length-1].error;throw new Error('Unexpected error. Please contact support: none of the calls threw an error');}const{call:{contract:disconnectedContract,parameters:{methodName,args,value}},gasEstimate}=successfulEstimation;const contract=disconnectedContract.connect(signer);return contract[methodName](...args,{gasLimit:calculateGasMargin(gasEstimate)}).then(response=>{const inputSymbol=trade instanceof MoolaRouterTrade?trade.path[0].symbol:trade.inputAmount.currency.symbol;const outputSymbol=trade instanceof MoolaRouterTrade?trade.path[trade.path.length-1].symbol:trade.outputAmount.currency.symbol;const inputAmount=trade.inputAmount.toSignificant(3);const outputAmount=trade.outputAmount.toSignificant(3);const base=\"Swap \".concat(inputAmount,\" \").concat(inputSymbol,\" for \").concat(outputAmount,\" \").concat(outputSymbol);const withRecipient=recipient===account?base:\"\".concat(base,\" to \").concat(recipientAddressOrName&&isAddress(recipientAddressOrName)?shortenAddress(recipientAddressOrName):recipientAddressOrName);addTransaction(response,{summary:withRecipient});return response.hash;}).catch(error=>{// if the user rejected the tx, pass this along\nif((error===null||error===void 0?void 0:error.code)===4001){throw new Error('Transaction rejected.');}else{// otherwise, the error was unexpected and we need to convey that\nconsole.error(\"Swap failed\",error,methodName,args,value);throw new Error(\"Swap failed: \".concat(error.message));}});});function onSwap(){return _onSwap.apply(this,arguments);}return onSwap;}(),error:null};},[trade,account,chainId,recipient,recipientAddressOrName,swapCalls,signer,addTransaction]);}","map":null,"metadata":{},"sourceType":"module"}