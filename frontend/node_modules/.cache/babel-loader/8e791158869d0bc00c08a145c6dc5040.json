{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n   */\n  constructor(index, validatorIndex, address,\n  /**\n   * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n   */\n  amount) {\n    this.index = index;\n    this.validatorIndex = validatorIndex;\n    this.address = address;\n    this.amount = amount;\n  }\n  static fromWithdrawalData(withdrawalData) {\n    const {\n      index: indexData,\n      validatorIndex: validatorIndexData,\n      address: addressData,\n      amount: amountData\n    } = withdrawalData;\n    const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n    const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n    const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n    const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n    return new Withdrawal(index, validatorIndex, address, amount);\n  }\n  static fromValuesArray(withdrawalArray) {\n    if (withdrawalArray.length !== 4) {\n      throw Error(\"Invalid withdrawalArray length expected=4 actual=\".concat(withdrawalArray.length));\n    }\n    const [index, validatorIndex, address, amount] = withdrawalArray;\n    return Withdrawal.fromWithdrawalData({\n      index,\n      validatorIndex,\n      address,\n      amount\n    });\n  }\n  /**\n   * Convert a withdrawal to a buffer array\n   * @param withdrawal the withdrawal to convert\n   * @returns buffer array of the withdrawal\n   */\n  static toBufferArray(withdrawal) {\n    const {\n      index,\n      validatorIndex,\n      address,\n      amount\n    } = withdrawal;\n    const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n    const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n    let addressBuffer;\n    if (address instanceof address_1.Address) {\n      addressBuffer = address.buf;\n    } else {\n      addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n    }\n    const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n    return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n  }\n  raw() {\n    return Withdrawal.toBufferArray(this);\n  }\n  toValue() {\n    return {\n      index: this.index,\n      validatorIndex: this.validatorIndex,\n      address: this.address.buf,\n      amount: this.amount\n    };\n  }\n  toJSON() {\n    return {\n      index: (0, bytes_1.bigIntToHex)(this.index),\n      validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n      address: '0x' + this.address.buf.toString('hex'),\n      amount: (0, bytes_1.bigIntToHex)(this.amount)\n    };\n  }\n}\nexports.Withdrawal = Withdrawal;","map":{"version":3,"sources":["../src/withdrawal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Withdrawal = void 0;\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst types_1 = require(\"./types\");\n/**\n * Representation of EIP-4895 withdrawal data\n */\nclass Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */\n    constructor(index, validatorIndex, address, \n    /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */\n    amount) {\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData, } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */\n    static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        }\n        else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0)\n            ? Buffer.alloc(0)\n            : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount,\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: '0x' + this.address.buf.toString('hex'),\n            amount: (0, bytes_1.bigIntToHex)(this.amount),\n        };\n    }\n}\nexports.Withdrawal = Withdrawal;\n//# sourceMappingURL=withdrawal.js.map"]},"metadata":{},"sourceType":"script"}