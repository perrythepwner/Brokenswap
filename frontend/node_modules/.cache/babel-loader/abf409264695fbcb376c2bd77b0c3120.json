{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction wait(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction waitRandom(min, max) {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)));\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nexport class CancelledError extends Error {\n  constructor() {\n    super('Cancelled');\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry(fn, _ref) {\n  let {\n    n,\n    minWait,\n    maxWait\n  } = _ref;\n  let completed = false;\n  let rejectCancelled;\n  const promise = new Promise((resolve, reject) => {\n    void _asyncToGenerator(function* () {\n      rejectCancelled = reject;\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        let result;\n        try {\n          result = yield fn();\n          if (!completed) {\n            resolve(result);\n            completed = true;\n          }\n          break;\n        } catch (error) {\n          if (completed) {\n            break;\n          }\n          if (n <= 0 || !(error instanceof RetryableError)) {\n            reject(error);\n            completed = true;\n            break;\n          }\n          n--;\n        }\n        yield waitRandom(minWait, maxWait);\n      }\n    })();\n  });\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return;\n      completed = true;\n      rejectCancelled(new CancelledError());\n    }\n  };\n}","map":{"version":3,"names":["wait","ms","Promise","resolve","setTimeout","waitRandom","min","max","Math","round","random","CancelledError","Error","constructor","RetryableError","retry","fn","_ref","n","minWait","maxWait","completed","rejectCancelled","promise","reject","_asyncToGenerator","result","error","cancel"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/utils/retry.ts"],"sourcesContent":["function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n\nfunction waitRandom(min: number, max: number): Promise<void> {\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)))\n}\n\n/**\n * This error is thrown if the function is cancelled before completing\n */\nexport class CancelledError extends Error {\n  constructor() {\n    super('Cancelled')\n  }\n}\n\n/**\n * Throw this error if the function should retry\n */\nexport class RetryableError extends Error {}\n\n/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */\nexport function retry<T>(\n  fn: () => Promise<T>,\n  { n, minWait, maxWait }: { n: number; minWait: number; maxWait: number }\n): { promise: Promise<T>; cancel: () => void } {\n  let completed = false\n  let rejectCancelled: (error: Error) => void\n  const promise = new Promise<T>((resolve, reject) => {\n    void (async () => {\n      rejectCancelled = reject\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        let result: T\n        try {\n          result = await fn()\n          if (!completed) {\n            resolve(result)\n            completed = true\n          }\n          break\n        } catch (error) {\n          if (completed) {\n            break\n          }\n          if (n <= 0 || !(error instanceof RetryableError)) {\n            reject(error)\n            completed = true\n            break\n          }\n          n--\n        }\n        await waitRandom(minWait, maxWait)\n      }\n    })()\n  })\n  return {\n    promise,\n    cancel: () => {\n      if (completed) return\n      completed = true\n      rejectCancelled(new CancelledError())\n    },\n  }\n}\n"],"mappings":";AAAA,SAASA,IAAIA,CAACC,EAAU,EAAiB;EACvC,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;AAC1D;AAEA,SAASI,UAAUA,CAACC,GAAW,EAAEC,GAAW,EAAiB;EAC3D,OAAOP,IAAI,CAACM,GAAG,GAAGE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGF,IAAI,CAACD,GAAG,CAAC,CAAC,EAAEA,GAAG,GAAGD,GAAG,CAAC,CAAC,CAAC;AACvE;;AAEA;AACA;AACA;AACA,OAAO,MAAMK,cAAc,SAASC,KAAK,CAAC;EACxCC,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,WAAW,CAAC;EACpB;AACF;;AAEA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,SAASF,KAAK,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,KAAKA,CACnBC,EAAoB,EAAAC,IAAA,EAEyB;EAAA,IAD7C;IAAEC,CAAC;IAAEC,OAAO;IAAEC;EAAyD,CAAC,GAAAH,IAAA;EAExE,IAAII,SAAS,GAAG,KAAK;EACrB,IAAIC,eAAuC;EAC3C,MAAMC,OAAO,GAAG,IAAIrB,OAAO,CAAI,CAACC,OAAO,EAAEqB,MAAM,KAAK;IAClD,KAAKC,iBAAA,CAAC,aAAY;MAChBH,eAAe,GAAGE,MAAM;MACxB;MACA,OAAO,IAAI,EAAE;QACX,IAAIE,MAAS;QACb,IAAI;UACFA,MAAM,SAASV,EAAE,CAAC,CAAC;UACnB,IAAI,CAACK,SAAS,EAAE;YACdlB,OAAO,CAACuB,MAAM,CAAC;YACfL,SAAS,GAAG,IAAI;UAClB;UACA;QACF,CAAC,CAAC,OAAOM,KAAK,EAAE;UACd,IAAIN,SAAS,EAAE;YACb;UACF;UACA,IAAIH,CAAC,IAAI,CAAC,IAAI,EAAES,KAAK,YAAYb,cAAc,CAAC,EAAE;YAChDU,MAAM,CAACG,KAAK,CAAC;YACbN,SAAS,GAAG,IAAI;YAChB;UACF;UACAH,CAAC,EAAE;QACL;QACA,MAAMb,UAAU,CAACc,OAAO,EAAEC,OAAO,CAAC;MACpC;IACF,CAAC,EAAE,CAAC;EACN,CAAC,CAAC;EACF,OAAO;IACLG,OAAO;IACPK,MAAM,EAAEA,CAAA,KAAM;MACZ,IAAIP,SAAS,EAAE;MACfA,SAAS,GAAG,IAAI;MAChBC,eAAe,CAAC,IAAIX,cAAc,CAAC,CAAC,CAAC;IACvC;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module"}