{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayBasicTreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayBasicTreeView extends abstract_1.TreeView {\n  constructor(type, tree) {\n    super();\n    this.type = type;\n    this.tree = tree;\n  }\n  /**\n   * Number of elements in the array. Equal to the Uint32 value of the Tree's length node\n   */\n  get length() {\n    return this.type.tree_getLength(this.tree.rootNode);\n  }\n  get node() {\n    return this.tree.rootNode;\n  }\n  /**\n   * Get element at `index`. Returns the Basic element type value directly\n   */\n  get(index) {\n    // First walk through the tree to get the root node for that index\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    const leafNode = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return this.type.elementType.tree_getFromPackedNode(leafNode, index);\n  }\n  /**\n   * Set Basic element type `value` at `index`\n   */\n  set(index, value) {\n    const length = this.length;\n    if (index >= length) {\n      throw Error(\"Error setting index over length \".concat(index, \" > \").concat(length));\n    }\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    const leafNodePrev = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);\n    // Create a new node to preserve immutability\n    const leafNode = leafNodePrev.clone();\n    this.type.elementType.tree_setToPackedNode(leafNode, index, value);\n    // Commit immediately\n    this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);\n  }\n  /**\n   * Get all values of this array as Basic element type values, from index zero to `this.length - 1`\n   */\n  getAll() {\n    const length = this.length;\n    const chunksNode = this.type.tree_getChunksNode(this.node);\n    const chunkCount = Math.ceil(length / this.type.itemsPerChunk);\n    const leafNodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);\n    const values = new Array(length);\n    const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below\n    const lenFullNodes = Math.floor(length / itemsPerChunk);\n    const remainder = length % itemsPerChunk;\n    for (let n = 0; n < lenFullNodes; n++) {\n      const leafNode = leafNodes[n];\n      // TODO: Implement add a fast bulk packed element reader in the elementType\n      // ```\n      // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;\n      // ```\n      // if performance here is a problem\n      for (let i = 0; i < itemsPerChunk; i++) {\n        values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    if (remainder > 0) {\n      const leafNode = leafNodes[lenFullNodes];\n      for (let i = 0; i < remainder; i++) {\n        values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    return values;\n  }\n}\nexports.ArrayBasicTreeView = ArrayBasicTreeView;","map":{"version":3,"sources":["../../src/view/arrayBasic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayBasicTreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayBasicTreeView extends abstract_1.TreeView {\n    constructor(type, tree) {\n        super();\n        this.type = type;\n        this.tree = tree;\n    }\n    /**\n     * Number of elements in the array. Equal to the Uint32 value of the Tree's length node\n     */\n    get length() {\n        return this.type.tree_getLength(this.tree.rootNode);\n    }\n    get node() {\n        return this.tree.rootNode;\n    }\n    /**\n     * Get element at `index`. Returns the Basic element type value directly\n     */\n    get(index) {\n        // First walk through the tree to get the root node for that index\n        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n        const leafNode = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.type.elementType.tree_getFromPackedNode(leafNode, index);\n    }\n    /**\n     * Set Basic element type `value` at `index`\n     */\n    set(index, value) {\n        const length = this.length;\n        if (index >= length) {\n            throw Error(`Error setting index over length ${index} > ${length}`);\n        }\n        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n        const leafNodePrev = this.tree.getNodeAtDepth(this.type.depth, chunkIndex);\n        // Create a new node to preserve immutability\n        const leafNode = leafNodePrev.clone();\n        this.type.elementType.tree_setToPackedNode(leafNode, index, value);\n        // Commit immediately\n        this.tree.setNodeAtDepth(this.type.depth, chunkIndex, leafNode);\n    }\n    /**\n     * Get all values of this array as Basic element type values, from index zero to `this.length - 1`\n     */\n    getAll() {\n        const length = this.length;\n        const chunksNode = this.type.tree_getChunksNode(this.node);\n        const chunkCount = Math.ceil(length / this.type.itemsPerChunk);\n        const leafNodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);\n        const values = new Array(length);\n        const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below\n        const lenFullNodes = Math.floor(length / itemsPerChunk);\n        const remainder = length % itemsPerChunk;\n        for (let n = 0; n < lenFullNodes; n++) {\n            const leafNode = leafNodes[n];\n            // TODO: Implement add a fast bulk packed element reader in the elementType\n            // ```\n            // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;\n            // ```\n            // if performance here is a problem\n            for (let i = 0; i < itemsPerChunk; i++) {\n                values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n            }\n        }\n        if (remainder > 0) {\n            const leafNode = leafNodes[lenFullNodes];\n            for (let i = 0; i < remainder; i++) {\n                values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n            }\n        }\n        return values;\n    }\n}\nexports.ArrayBasicTreeView = ArrayBasicTreeView;\n//# sourceMappingURL=arrayBasic.js.map"]},"metadata":{},"sourceType":"script"}