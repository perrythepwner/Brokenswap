{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestationBase = exports.isAccountConsideredVerified = exports.extractAttestationCodeFromMessage = exports.messageContainsAttestationCode = exports.sanitizeMessageBase64 = exports.base64ToHex = exports.hashIdentifier = exports.getIdentifierPrefix = exports.IdentifierType = void 0;\nvar phoneNumbers_1 = require(\"./phoneNumbers\");\nvar DEFAULT_NUM_ATTESTATIONS_REQUIRED = 3;\nvar DEFAULT_ATTESTATION_THRESHOLD = 0.25;\n// Supported identifer types for attestations\nvar IdentifierType;\n(function (IdentifierType) {\n  IdentifierType[IdentifierType[\"PHONE_NUMBER\"] = 0] = \"PHONE_NUMBER\";\n  // In the future, other types like usernames or emails could go here\n})(IdentifierType = exports.IdentifierType || (exports.IdentifierType = {}));\n// Each identifer type has a unique prefix to prevent unlikely but possible collisions\nfunction getIdentifierPrefix(type) {\n  switch (type) {\n    case IdentifierType.PHONE_NUMBER:\n      return 'tel://';\n    default:\n      throw new Error('Unsupported Identifier Type');\n  }\n}\nexports.getIdentifierPrefix = getIdentifierPrefix;\nfunction hashIdentifier(sha3, identifier, type, salt) {\n  switch (type) {\n    case IdentifierType.PHONE_NUMBER:\n      return (0, phoneNumbers_1.getPhoneHash)(sha3, identifier, salt);\n    default:\n      throw new Error('Unsupported Identifier Type');\n  }\n}\nexports.hashIdentifier = hashIdentifier;\nfunction base64ToHex(base64String) {\n  return '0x' + Buffer.from(base64String, 'base64').toString('hex');\n}\nexports.base64ToHex = base64ToHex;\nfunction sanitizeMessageBase64(base64String) {\n  // Replace occurrences of ¿ with _. Unsure why that is happening right now\n  return base64String.replace(/(¿|§)/gi, '_');\n}\nexports.sanitizeMessageBase64 = sanitizeMessageBase64;\nvar attestationCodeRegex = new RegExp(/(.* |^)(?:celo:\\/\\/wallet\\/v\\/)?([a-zA-Z0-9=\\+\\/_-]{87,88})($| .*)/);\nfunction messageContainsAttestationCode(message) {\n  return attestationCodeRegex.test(message);\n}\nexports.messageContainsAttestationCode = messageContainsAttestationCode;\nfunction extractAttestationCodeFromMessage(message) {\n  var sanitizedMessage = sanitizeMessageBase64(message);\n  if (!messageContainsAttestationCode(sanitizedMessage)) {\n    return null;\n  }\n  var matches = sanitizedMessage.match(attestationCodeRegex);\n  if (!matches || matches.length < 3) {\n    return null;\n  }\n  return base64ToHex(matches[2]);\n}\nexports.extractAttestationCodeFromMessage = extractAttestationCodeFromMessage;\n/**\n * Returns true if an AttestationStat is considered verified using the given factors,\n * or defaults if factors are ommited.\n * @param stats AttestationStat of the account's attestation identitifer, retrievable via lookupIdentitfiers\n * @param numAttestationsRequired Optional number of attestations required.  Will default to\n *  hardcoded value if absent.\n * @param attestationThreshold Optional threshold for fraction attestations completed. Will\n *  default to hardcoded value if absent.\n */\nfunction isAccountConsideredVerified(stats, numAttestationsRequired, attestationThreshold) {\n  if (numAttestationsRequired === void 0) {\n    numAttestationsRequired = DEFAULT_NUM_ATTESTATIONS_REQUIRED;\n  }\n  if (attestationThreshold === void 0) {\n    attestationThreshold = DEFAULT_ATTESTATION_THRESHOLD;\n  }\n  if (!stats) {\n    return {\n      isVerified: false,\n      numAttestationsRemaining: 0,\n      total: 0,\n      completed: 0\n    };\n  }\n  var numAttestationsRemaining = numAttestationsRequired - stats.completed;\n  var fractionAttestation = stats.total < 1 ? 0 : stats.completed / stats.total;\n  // 'verified' is a term of convenience to mean that the attestation stats for a\n  // given identifier are beyond a certain threshold of confidence\n  var isVerified = numAttestationsRemaining <= 0 && fractionAttestation >= attestationThreshold;\n  return {\n    isVerified: isVerified,\n    numAttestationsRemaining: numAttestationsRemaining,\n    total: stats.total,\n    completed: stats.completed\n  };\n}\nexports.isAccountConsideredVerified = isAccountConsideredVerified;\nexports.AttestationBase = {\n  IdentifierType: IdentifierType,\n  getIdentifierPrefix: getIdentifierPrefix,\n  hashIdentifier: hashIdentifier,\n  base64ToHex: base64ToHex,\n  sanitizeMessageBase64: sanitizeMessageBase64,\n  messageContainsAttestationCode: messageContainsAttestationCode,\n  extractAttestationCodeFromMessage: extractAttestationCodeFromMessage,\n  isAccountConsideredVerified: isAccountConsideredVerified\n};","map":{"version":3,"sources":["../src/attestations.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttestationBase = exports.isAccountConsideredVerified = exports.extractAttestationCodeFromMessage = exports.messageContainsAttestationCode = exports.sanitizeMessageBase64 = exports.base64ToHex = exports.hashIdentifier = exports.getIdentifierPrefix = exports.IdentifierType = void 0;\nvar phoneNumbers_1 = require(\"./phoneNumbers\");\nvar DEFAULT_NUM_ATTESTATIONS_REQUIRED = 3;\nvar DEFAULT_ATTESTATION_THRESHOLD = 0.25;\n// Supported identifer types for attestations\nvar IdentifierType;\n(function (IdentifierType) {\n    IdentifierType[IdentifierType[\"PHONE_NUMBER\"] = 0] = \"PHONE_NUMBER\";\n    // In the future, other types like usernames or emails could go here\n})(IdentifierType = exports.IdentifierType || (exports.IdentifierType = {}));\n// Each identifer type has a unique prefix to prevent unlikely but possible collisions\nfunction getIdentifierPrefix(type) {\n    switch (type) {\n        case IdentifierType.PHONE_NUMBER:\n            return 'tel://';\n        default:\n            throw new Error('Unsupported Identifier Type');\n    }\n}\nexports.getIdentifierPrefix = getIdentifierPrefix;\nfunction hashIdentifier(sha3, identifier, type, salt) {\n    switch (type) {\n        case IdentifierType.PHONE_NUMBER:\n            return (0, phoneNumbers_1.getPhoneHash)(sha3, identifier, salt);\n        default:\n            throw new Error('Unsupported Identifier Type');\n    }\n}\nexports.hashIdentifier = hashIdentifier;\nfunction base64ToHex(base64String) {\n    return '0x' + Buffer.from(base64String, 'base64').toString('hex');\n}\nexports.base64ToHex = base64ToHex;\nfunction sanitizeMessageBase64(base64String) {\n    // Replace occurrences of ¿ with _. Unsure why that is happening right now\n    return base64String.replace(/(¿|§)/gi, '_');\n}\nexports.sanitizeMessageBase64 = sanitizeMessageBase64;\nvar attestationCodeRegex = new RegExp(/(.* |^)(?:celo:\\/\\/wallet\\/v\\/)?([a-zA-Z0-9=\\+\\/_-]{87,88})($| .*)/);\nfunction messageContainsAttestationCode(message) {\n    return attestationCodeRegex.test(message);\n}\nexports.messageContainsAttestationCode = messageContainsAttestationCode;\nfunction extractAttestationCodeFromMessage(message) {\n    var sanitizedMessage = sanitizeMessageBase64(message);\n    if (!messageContainsAttestationCode(sanitizedMessage)) {\n        return null;\n    }\n    var matches = sanitizedMessage.match(attestationCodeRegex);\n    if (!matches || matches.length < 3) {\n        return null;\n    }\n    return base64ToHex(matches[2]);\n}\nexports.extractAttestationCodeFromMessage = extractAttestationCodeFromMessage;\n/**\n * Returns true if an AttestationStat is considered verified using the given factors,\n * or defaults if factors are ommited.\n * @param stats AttestationStat of the account's attestation identitifer, retrievable via lookupIdentitfiers\n * @param numAttestationsRequired Optional number of attestations required.  Will default to\n *  hardcoded value if absent.\n * @param attestationThreshold Optional threshold for fraction attestations completed. Will\n *  default to hardcoded value if absent.\n */\nfunction isAccountConsideredVerified(stats, numAttestationsRequired, attestationThreshold) {\n    if (numAttestationsRequired === void 0) { numAttestationsRequired = DEFAULT_NUM_ATTESTATIONS_REQUIRED; }\n    if (attestationThreshold === void 0) { attestationThreshold = DEFAULT_ATTESTATION_THRESHOLD; }\n    if (!stats) {\n        return {\n            isVerified: false,\n            numAttestationsRemaining: 0,\n            total: 0,\n            completed: 0,\n        };\n    }\n    var numAttestationsRemaining = numAttestationsRequired - stats.completed;\n    var fractionAttestation = stats.total < 1 ? 0 : stats.completed / stats.total;\n    // 'verified' is a term of convenience to mean that the attestation stats for a\n    // given identifier are beyond a certain threshold of confidence\n    var isVerified = numAttestationsRemaining <= 0 && fractionAttestation >= attestationThreshold;\n    return {\n        isVerified: isVerified,\n        numAttestationsRemaining: numAttestationsRemaining,\n        total: stats.total,\n        completed: stats.completed,\n    };\n}\nexports.isAccountConsideredVerified = isAccountConsideredVerified;\nexports.AttestationBase = {\n    IdentifierType: IdentifierType,\n    getIdentifierPrefix: getIdentifierPrefix,\n    hashIdentifier: hashIdentifier,\n    base64ToHex: base64ToHex,\n    sanitizeMessageBase64: sanitizeMessageBase64,\n    messageContainsAttestationCode: messageContainsAttestationCode,\n    extractAttestationCodeFromMessage: extractAttestationCodeFromMessage,\n    isAccountConsideredVerified: isAccountConsideredVerified,\n};\n//# sourceMappingURL=attestations.js.map"]},"metadata":{},"sourceType":"script"}