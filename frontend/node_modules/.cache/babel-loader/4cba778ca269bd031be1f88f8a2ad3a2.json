{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * A Tree View is a wrapper around a type and an SSZ Tree that contains:\n * - data merkleized\n * - a hook to its parent Tree to propagate changes upwards\n *\n * **View**\n * - Best for simple usage where performance is NOT important\n * - Applies changes immediately\n * - Has reference to parent tree\n * - Does NOT have caches for fast get / set ops\n */\nclass TreeView {\n  /** Serialize view to binary data */\n  serialize() {\n    const output = new Uint8Array(this.type.tree_serializedSize(this.node));\n    const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);\n    this.type.tree_serializeToBytes({\n      uint8Array: output,\n      dataView\n    }, 0, this.node);\n    return output;\n  }\n  /**\n   * Merkleize view and compute its hashTreeRoot.\n   *\n   * See spec for definition of hashTreeRoot:\n   * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n   */\n  hashTreeRoot() {\n    return this.node.root;\n  }\n  /**\n   * Create a Merkle multiproof on this view's data.\n   * A `path` is an array of 'JSON' paths into the data\n   * @example\n   * ```ts\n   * state.createProof([\n   *   [\"validators\", 1234, \"slashed\"],\n   *   [\"genesisTime\"]\n   * ])\n   * ```\n   *\n   * See spec for definition of merkle multiproofs:\n   * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n   */\n  createProof(paths) {\n    return this.type.tree_createProof(this.node, paths);\n  }\n  /**\n   * Transform the view into a value, from the current node instance.\n   * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.\n   */\n  toValue() {\n    return this.type.tree_toValue(this.node);\n  }\n  /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */\n  clone() {\n    return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));\n  }\n}\nexports.TreeView = TreeView;","map":{"version":3,"sources":["../../src/view/abstract.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AAIA;;;;;;;;;;AAUG;AACH,MAAsB,QAAQ,CAAA;EAM5B;EACA,SAAS,CAAA,EAAA;IACP,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACvE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC;IAClF,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC;MAAC,UAAU,EAAE,MAAM;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC;IAC7E,OAAO,MAAM;EACf;EAEA;;;;;AAKG;EACH,YAAY,CAAA,EAAA;IACV,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI;EACvB;EAEA;;;;;;;;;;;;;AAaG;EACH,WAAW,CAAC,KAAiB,EAAA;IAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;EACrD;EAEA;;;AAGG;EACH,OAAO,CAAA,EAAA;IACL,OAAO,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAe;EACxD;EAEA;EACA,KAAK,CAAA,EAAA;IACH,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,wBAAA,CAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAS;EACvD;AACD;AAtDD,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * A Tree View is a wrapper around a type and an SSZ Tree that contains:\n * - data merkleized\n * - a hook to its parent Tree to propagate changes upwards\n *\n * **View**\n * - Best for simple usage where performance is NOT important\n * - Applies changes immediately\n * - Has reference to parent tree\n * - Does NOT have caches for fast get / set ops\n */\nclass TreeView {\n    /** Serialize view to binary data */\n    serialize() {\n        const output = new Uint8Array(this.type.tree_serializedSize(this.node));\n        const dataView = new DataView(output.buffer, output.byteOffset, output.byteLength);\n        this.type.tree_serializeToBytes({ uint8Array: output, dataView }, 0, this.node);\n        return output;\n    }\n    /**\n     * Merkleize view and compute its hashTreeRoot.\n     *\n     * See spec for definition of hashTreeRoot:\n     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n     */\n    hashTreeRoot() {\n        return this.node.root;\n    }\n    /**\n     * Create a Merkle multiproof on this view's data.\n     * A `path` is an array of 'JSON' paths into the data\n     * @example\n     * ```ts\n     * state.createProof([\n     *   [\"validators\", 1234, \"slashed\"],\n     *   [\"genesisTime\"]\n     * ])\n     * ```\n     *\n     * See spec for definition of merkle multiproofs:\n     * https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n     */\n    createProof(paths) {\n        return this.type.tree_createProof(this.node, paths);\n    }\n    /**\n     * Transform the view into a value, from the current node instance.\n     * For ViewDU returns the value of the committed data, so call .commit() before if there are pending changes.\n     */\n    toValue() {\n        return this.type.tree_toValue(this.node);\n    }\n    /** Return a new Tree View instance referencing the same internal `Node`. Drops its existing `Tree` hook if any */\n    clone() {\n        return this.type.getView(new persistent_merkle_tree_1.Tree(this.node));\n    }\n}\nexports.TreeView = TreeView;\n//# sourceMappingURL=abstract.js.map"]},"metadata":{},"sourceType":"script"}