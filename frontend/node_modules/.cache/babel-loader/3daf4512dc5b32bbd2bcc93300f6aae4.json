{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst mini_kit_1 = require(\"@celo/contractkit/lib/mini-kit\");\nconst constants_1 = require(\"../constants\");\nconst ethereum_1 = require(\"../utils/ethereum\");\nconst logger_1 = require(\"../utils/logger\");\nconst metamask_1 = require(\"../utils/metamask\");\nconst common_1 = require(\"./common\");\nclass InjectedConnector extends common_1.AbstractConnector {\n  constructor(network, manualNetworkMode, feeCurrency) {\n    let defaultType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.WalletTypes.Injected;\n    super();\n    this.manualNetworkMode = manualNetworkMode;\n    this.feeCurrency = feeCurrency;\n    this.initialised = false;\n    this.type = constants_1.WalletTypes.Injected;\n    // wallet changes net chain\n    // emits 'chainChanged'\n    // onChainChanged called and emits WALLET_CHAIN_CHANGED if chain ids dont match\n    // networkWatcher sees that and if a suitable network can be found calls continueNetworkUpdateFromWallet()\n    // else it dies.\n    this.onChainChanged = chainIdHex => {\n      const chainId = parseInt(chainIdHex, 16);\n      // if this change was initiated by app the chainIds will already match and we can abort\n      (0, logger_1.getApplicationLogger)().log('onChainChanged', chainId);\n      if (this.network.chainId !== chainId) {\n        this.emit(common_1.ConnectorEvents.WALLET_CHAIN_CHANGED, chainId);\n      }\n    };\n    this.onAccountsChanged = accounts => {\n      if (accounts.length === 0) {\n        // wallet is locked properly close the connection.\n        this.close();\n      } else {\n        this.kit.connection.defaultAccount = accounts[0];\n        this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, accounts[0]);\n      }\n    };\n    this.type = defaultType;\n    this.kit = (0, mini_kit_1.newKit)(network.rpcUrl);\n    this.network = network;\n  }\n  initialise(lastUsedAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initialised) {\n        return this;\n      }\n      let defaultAccount = lastUsedAddress;\n      const injected = yield (0, ethereum_1.getInjectedEthereum)();\n      if (!injected) {\n        throw new Error('Ethereum wallet not installed');\n      }\n      const {\n        web3,\n        ethereum,\n        isMetaMask\n      } = injected;\n      this.type = isMetaMask ? constants_1.WalletTypes.MetaMask : constants_1.WalletTypes.Injected;\n      const metamask = ethereum._metamask;\n      const isUnlocked = isMetaMask && (yield metamask === null || metamask === void 0 ? void 0 : metamask.isUnlocked());\n      const isConnected = ethereum.isConnected && ethereum.isConnected();\n      if (isUnlocked || !isConnected || !defaultAccount) {\n        [defaultAccount] = yield ethereum.request({\n          method: 'eth_requestAccounts'\n        });\n      }\n      ethereum.removeListener('chainChanged', this.onChainChanged);\n      ethereum.removeListener('accountsChanged', this.onAccountsChanged);\n      if (!this.manualNetworkMode) {\n        yield (0, metamask_1.switchToNetwork)(this.network, ethereum, () => this.kit.connection.chainId());\n      }\n      ethereum.on('chainChanged', this.onChainChanged);\n      ethereum.on('accountsChanged', this.onAccountsChanged);\n      this.newKit(web3, defaultAccount);\n      const walletChainId = yield ethereum.request({\n        method: 'eth_chainId'\n      });\n      this.initialised = true;\n      this.emit(common_1.ConnectorEvents.CONNECTED, {\n        walletType: this.type,\n        address: defaultAccount,\n        networkName: this.network.name,\n        walletChainId: parseInt(walletChainId, 16)\n      });\n      return this;\n    });\n  }\n  newKit(web3, defaultAccount) {\n    this.kit = (0, mini_kit_1.newKitFromWeb3)(web3);\n    this.kit.connection.defaultAccount = defaultAccount;\n  }\n  startNetworkChangeFromApp(network) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ethereum = (0, ethereum_1.getEthereum)();\n      yield (0, metamask_1.switchToNetwork)(network, ethereum, this.kit.connection.chainId);\n      this.continueNetworkUpdateFromWallet(network);\n    });\n  }\n  //\n  continueNetworkUpdateFromWallet(network) {\n    this.network = network; // must set to prevent loop\n    const web3 = this.kit.connection.web3;\n    this.newKit(web3, this.account); // kit caches things so it need to be recreated\n    this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);\n  }\n  supportsFeeCurrency() {\n    return false;\n  }\n  removeListenersFromEth() {\n    const ethereum = (0, ethereum_1.getEthereum)();\n    if (ethereum) {\n      ethereum.removeListener('chainChanged', this.onChainChanged);\n      ethereum.removeListener('accountsChanged', this.onAccountsChanged);\n    }\n  }\n  close() {\n    this.removeListenersFromEth();\n    try {\n      this.kit.connection.stop();\n    } finally {\n      this.disconnect();\n    }\n  }\n}\nexports.default = InjectedConnector;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","mini_kit_1","require","constants_1","ethereum_1","logger_1","metamask_1","common_1","InjectedConnector","AbstractConnector","constructor","network","manualNetworkMode","feeCurrency","defaultType","arguments","length","undefined","WalletTypes","Injected","initialised","type","onChainChanged","chainIdHex","chainId","parseInt","getApplicationLogger","log","emit","ConnectorEvents","WALLET_CHAIN_CHANGED","onAccountsChanged","accounts","close","kit","connection","defaultAccount","ADDRESS_CHANGED","newKit","rpcUrl","initialise","lastUsedAddress","injected","getInjectedEthereum","Error","web3","ethereum","isMetaMask","MetaMask","metamask","_metamask","isUnlocked","isConnected","request","method","removeListener","switchToNetwork","on","walletChainId","CONNECTED","walletType","address","networkName","name","newKitFromWeb3","startNetworkChangeFromApp","getEthereum","continueNetworkUpdateFromWallet","account","NETWORK_CHANGED","supportsFeeCurrency","removeListenersFromEth","stop","disconnect","default"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@celo/react-celo/lib/connectors/injected.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mini_kit_1 = require(\"@celo/contractkit/lib/mini-kit\");\nconst constants_1 = require(\"../constants\");\nconst ethereum_1 = require(\"../utils/ethereum\");\nconst logger_1 = require(\"../utils/logger\");\nconst metamask_1 = require(\"../utils/metamask\");\nconst common_1 = require(\"./common\");\nclass InjectedConnector extends common_1.AbstractConnector {\n    constructor(network, manualNetworkMode, feeCurrency, defaultType = constants_1.WalletTypes.Injected) {\n        super();\n        this.manualNetworkMode = manualNetworkMode;\n        this.feeCurrency = feeCurrency;\n        this.initialised = false;\n        this.type = constants_1.WalletTypes.Injected;\n        // wallet changes net chain\n        // emits 'chainChanged'\n        // onChainChanged called and emits WALLET_CHAIN_CHANGED if chain ids dont match\n        // networkWatcher sees that and if a suitable network can be found calls continueNetworkUpdateFromWallet()\n        // else it dies.\n        this.onChainChanged = (chainIdHex) => {\n            const chainId = parseInt(chainIdHex, 16);\n            // if this change was initiated by app the chainIds will already match and we can abort\n            (0, logger_1.getApplicationLogger)().log('onChainChanged', chainId);\n            if (this.network.chainId !== chainId) {\n                this.emit(common_1.ConnectorEvents.WALLET_CHAIN_CHANGED, chainId);\n            }\n        };\n        this.onAccountsChanged = (accounts) => {\n            if (accounts.length === 0) {\n                // wallet is locked properly close the connection.\n                this.close();\n            }\n            else {\n                this.kit.connection.defaultAccount = accounts[0];\n                this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, accounts[0]);\n            }\n        };\n        this.type = defaultType;\n        this.kit = (0, mini_kit_1.newKit)(network.rpcUrl);\n        this.network = network;\n    }\n    initialise(lastUsedAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.initialised) {\n                return this;\n            }\n            let defaultAccount = lastUsedAddress;\n            const injected = yield (0, ethereum_1.getInjectedEthereum)();\n            if (!injected) {\n                throw new Error('Ethereum wallet not installed');\n            }\n            const { web3, ethereum, isMetaMask } = injected;\n            this.type = isMetaMask ? constants_1.WalletTypes.MetaMask : constants_1.WalletTypes.Injected;\n            const metamask = ethereum._metamask;\n            const isUnlocked = isMetaMask && (yield (metamask === null || metamask === void 0 ? void 0 : metamask.isUnlocked()));\n            const isConnected = ethereum.isConnected && ethereum.isConnected();\n            if (isUnlocked || !isConnected || !defaultAccount) {\n                [defaultAccount] = yield ethereum.request({\n                    method: 'eth_requestAccounts',\n                });\n            }\n            ethereum.removeListener('chainChanged', this.onChainChanged);\n            ethereum.removeListener('accountsChanged', this.onAccountsChanged);\n            if (!this.manualNetworkMode) {\n                yield (0, metamask_1.switchToNetwork)(this.network, ethereum, () => this.kit.connection.chainId());\n            }\n            ethereum.on('chainChanged', this.onChainChanged);\n            ethereum.on('accountsChanged', this.onAccountsChanged);\n            this.newKit(web3, defaultAccount);\n            const walletChainId = yield ethereum.request({ method: 'eth_chainId' });\n            this.initialised = true;\n            this.emit(common_1.ConnectorEvents.CONNECTED, {\n                walletType: this.type,\n                address: defaultAccount,\n                networkName: this.network.name,\n                walletChainId: parseInt(walletChainId, 16),\n            });\n            return this;\n        });\n    }\n    newKit(web3, defaultAccount) {\n        this.kit = (0, mini_kit_1.newKitFromWeb3)(web3);\n        this.kit.connection.defaultAccount = defaultAccount;\n    }\n    startNetworkChangeFromApp(network) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ethereum = (0, ethereum_1.getEthereum)();\n            yield (0, metamask_1.switchToNetwork)(network, ethereum, this.kit.connection.chainId);\n            this.continueNetworkUpdateFromWallet(network);\n        });\n    }\n    //\n    continueNetworkUpdateFromWallet(network) {\n        this.network = network; // must set to prevent loop\n        const web3 = this.kit.connection.web3;\n        this.newKit(web3, this.account); // kit caches things so it need to be recreated\n        this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);\n    }\n    supportsFeeCurrency() {\n        return false;\n    }\n    removeListenersFromEth() {\n        const ethereum = (0, ethereum_1.getEthereum)();\n        if (ethereum) {\n            ethereum.removeListener('chainChanged', this.onChainChanged);\n            ethereum.removeListener('accountsChanged', this.onAccountsChanged);\n        }\n    }\n    close() {\n        this.removeListenersFromEth();\n        try {\n            this.kit.connection.stop();\n        }\n        finally {\n            this.disconnect();\n        }\n    }\n}\nexports.default = InjectedConnector;\n//# sourceMappingURL=injected.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script"}