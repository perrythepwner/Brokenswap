{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst treePostProcessFromProofNode_1 = require(\"../util/proof/treePostProcessFromProofNode\");\nconst abstract_1 = require(\"./abstract\");\nexports.LENGTH_GINDEX = BigInt(3);\n/** Dedicated property to cache hashTreeRoot of immutable CompositeType values */\nconst symbolCachedPermanentRoot = Symbol(\"ssz_cached_permanent_root\");\n/* eslint-disable @typescript-eslint/member-ordering  */\n/**\n * Represents a composite type as defined in the spec:\n * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#composite-types\n */\nclass CompositeType extends abstract_1.Type {\n  constructor(\n  /**\n   * Caches `hashTreeRoot()` result for struct values.\n   *\n   * WARNING: Must only be used for immutable values. The cached root is never discarded\n   */\n  cachePermanentRootStruct) {\n    super();\n    this.cachePermanentRootStruct = cachePermanentRootStruct;\n    this.isBasic = false;\n  }\n  /** New instance of a recursive zero'ed value converted to Tree View */\n  defaultView() {\n    return this.toView(this.defaultValue());\n  }\n  /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */\n  defaultViewDU() {\n    return this.toViewDU(this.defaultValue());\n  }\n  /**\n   * Deserialize binary data to a Tree View.\n   * @see {@link CompositeType.getView}\n   */\n  deserializeToView(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const node = this.tree_deserializeFromBytes({\n      uint8Array: data,\n      dataView\n    }, 0, data.length);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Deserialize binary data to a Deferred Update Tree View.\n   * @see {@link CompositeType.getViewDU}\n   */\n  deserializeToViewDU(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    const node = this.tree_deserializeFromBytes({\n      uint8Array: data,\n      dataView\n    }, 0, data.length);\n    return this.getViewDU(node);\n  }\n  /**\n   * Transform value to a View.\n   * @see {@link CompositeType.getView}\n   */\n  toView(value) {\n    const node = this.value_toTree(value);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Transform value to a ViewDU.\n   * @see {@link CompositeType.getViewDU}\n   */\n  toViewDU(value) {\n    const node = this.value_toTree(value);\n    return this.getViewDU(node);\n  }\n  /**\n   * Transform value to a View.\n   * @see {@link CompositeType.getView}\n   */\n  toValueFromView(view) {\n    const node = this.commitView(view);\n    return this.tree_toValue(node);\n  }\n  /**\n   * Transform value to a ViewDU.\n   * @see {@link CompositeType.getViewDU}\n   */\n  toValueFromViewDU(view) {\n    const node = this.commitViewDU(view);\n    return this.tree_toValue(node);\n  }\n  /**\n   * Transform a ViewDU to a View.\n   * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n   */\n  toViewFromViewDU(view) {\n    const node = this.commitViewDU(view);\n    return this.getView(new persistent_merkle_tree_1.Tree(node));\n  }\n  /**\n   * Transform a View to a ViewDU.\n   * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n   */\n  toViewDUFromView(view) {\n    const node = this.commitView(view);\n    return this.getViewDU(node);\n  }\n  // Merkleize API\n  hashTreeRoot(value) {\n    // Return cached mutable root if any\n    if (this.cachePermanentRootStruct) {\n      const cachedRoot = value[symbolCachedPermanentRoot];\n      if (cachedRoot) {\n        return cachedRoot;\n      }\n    }\n    const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);\n    if (this.cachePermanentRootStruct) {\n      value[symbolCachedPermanentRoot] = root;\n    }\n    return root;\n  }\n  // For debugging and testing this feature\n  getCachedPermanentRoot(value) {\n    return value[symbolCachedPermanentRoot];\n  }\n  // Proofs API\n  /**\n   * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.\n   * @see {@link CompositeType.getView}\n   */\n  createFromProof(proof, root) {\n    const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;\n    const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);\n    if (root !== undefined && !byteArray_1.byteArrayEquals(rootNode.root, root)) {\n      throw new Error(\"Proof does not match trusted root\");\n    }\n    return this.getView(new persistent_merkle_tree_1.Tree(rootNode));\n  }\n  /** INTERNAL METHOD: For view's API, create proof from a tree */\n  tree_createProof(node, jsonPaths) {\n    const gindexes = this.tree_createProofGindexes(node, jsonPaths);\n    return persistent_merkle_tree_1.createProof(node, {\n      type: persistent_merkle_tree_1.ProofType.treeOffset,\n      gindices: gindexes\n    });\n  }\n  /** INTERNAL METHOD: For view's API, create proof from a tree */\n  tree_createProofGindexes(node, jsonPaths) {\n    const gindexes = [];\n    for (const jsonPath of jsonPaths) {\n      const {\n        type,\n        gindex\n      } = this.getPathInfo(jsonPath);\n      if (!isCompositeType(type)) {\n        gindexes.push(gindex);\n      } else {\n        // if the path subtype is composite, include the gindices of all the leaves\n        const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : undefined);\n        for (const gindex of leafGindexes) {\n          gindexes.push(gindex);\n        }\n      }\n    }\n    return gindexes;\n  }\n  /**\n   * Navigate to a subtype & gindex using a path\n   */\n  getPathInfo(path) {\n    const gindices = [];\n    let type = this;\n    for (const prop of path) {\n      if (type.isBasic) {\n        throw new Error(\"Invalid path: cannot navigate beyond a basic type\");\n      }\n      const gindex = type.getPropertyGindex(prop);\n      // else stop navigating\n      if (gindex !== null) {\n        gindices.push(gindex);\n        type = type.getPropertyType(prop);\n      }\n    }\n    return {\n      type,\n      gindex: persistent_merkle_tree_1.concatGindices(gindices)\n    };\n  }\n  /**\n   * INTERNAL METHOD: post process `Ç¸ode` instance created from a proof and return either the same node,\n   * and a new node representing the same data is a different `Node` instance. Currently used exclusively\n   * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.\n   */\n  tree_fromProofNode(node) {\n    return {\n      node,\n      done: false\n    };\n  }\n}\nexports.CompositeType = CompositeType;\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\nexports.isCompositeType = isCompositeType;","map":{"version":3,"sources":["../../src/type/composite.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCompositeType = exports.CompositeType = exports.LENGTH_GINDEX = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst treePostProcessFromProofNode_1 = require(\"../util/proof/treePostProcessFromProofNode\");\nconst abstract_1 = require(\"./abstract\");\nexports.LENGTH_GINDEX = BigInt(3);\n/** Dedicated property to cache hashTreeRoot of immutable CompositeType values */\nconst symbolCachedPermanentRoot = Symbol(\"ssz_cached_permanent_root\");\n/* eslint-disable @typescript-eslint/member-ordering  */\n/**\n * Represents a composite type as defined in the spec:\n * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#composite-types\n */\nclass CompositeType extends abstract_1.Type {\n    constructor(\n    /**\n     * Caches `hashTreeRoot()` result for struct values.\n     *\n     * WARNING: Must only be used for immutable values. The cached root is never discarded\n     */\n    cachePermanentRootStruct) {\n        super();\n        this.cachePermanentRootStruct = cachePermanentRootStruct;\n        this.isBasic = false;\n    }\n    /** New instance of a recursive zero'ed value converted to Tree View */\n    defaultView() {\n        return this.toView(this.defaultValue());\n    }\n    /** New instance of a recursive zero'ed value converted to Deferred Update Tree View */\n    defaultViewDU() {\n        return this.toViewDU(this.defaultValue());\n    }\n    /**\n     * Deserialize binary data to a Tree View.\n     * @see {@link CompositeType.getView}\n     */\n    deserializeToView(data) {\n        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);\n        return this.getView(new persistent_merkle_tree_1.Tree(node));\n    }\n    /**\n     * Deserialize binary data to a Deferred Update Tree View.\n     * @see {@link CompositeType.getViewDU}\n     */\n    deserializeToViewDU(data) {\n        const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        const node = this.tree_deserializeFromBytes({ uint8Array: data, dataView }, 0, data.length);\n        return this.getViewDU(node);\n    }\n    /**\n     * Transform value to a View.\n     * @see {@link CompositeType.getView}\n     */\n    toView(value) {\n        const node = this.value_toTree(value);\n        return this.getView(new persistent_merkle_tree_1.Tree(node));\n    }\n    /**\n     * Transform value to a ViewDU.\n     * @see {@link CompositeType.getViewDU}\n     */\n    toViewDU(value) {\n        const node = this.value_toTree(value);\n        return this.getViewDU(node);\n    }\n    /**\n     * Transform value to a View.\n     * @see {@link CompositeType.getView}\n     */\n    toValueFromView(view) {\n        const node = this.commitView(view);\n        return this.tree_toValue(node);\n    }\n    /**\n     * Transform value to a ViewDU.\n     * @see {@link CompositeType.getViewDU}\n     */\n    toValueFromViewDU(view) {\n        const node = this.commitViewDU(view);\n        return this.tree_toValue(node);\n    }\n    /**\n     * Transform a ViewDU to a View.\n     * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n     */\n    toViewFromViewDU(view) {\n        const node = this.commitViewDU(view);\n        return this.getView(new persistent_merkle_tree_1.Tree(node));\n    }\n    /**\n     * Transform a View to a ViewDU.\n     * @see {@link CompositeType.getView} and {@link CompositeType.getViewDU}\n     */\n    toViewDUFromView(view) {\n        const node = this.commitView(view);\n        return this.getViewDU(node);\n    }\n    // Merkleize API\n    hashTreeRoot(value) {\n        // Return cached mutable root if any\n        if (this.cachePermanentRootStruct) {\n            const cachedRoot = value[symbolCachedPermanentRoot];\n            if (cachedRoot) {\n                return cachedRoot;\n            }\n        }\n        const root = merkleize_1.merkleize(this.getRoots(value), this.maxChunkCount);\n        if (this.cachePermanentRootStruct) {\n            value[symbolCachedPermanentRoot] = root;\n        }\n        return root;\n    }\n    // For debugging and testing this feature\n    getCachedPermanentRoot(value) {\n        return value[symbolCachedPermanentRoot];\n    }\n    // Proofs API\n    /**\n     * Create a Tree View from a Proof. Verifies that the Proof is correct against `root`.\n     * @see {@link CompositeType.getView}\n     */\n    createFromProof(proof, root) {\n        const rootNodeFromProof = persistent_merkle_tree_1.Tree.createFromProof(proof).rootNode;\n        const rootNode = treePostProcessFromProofNode_1.treePostProcessFromProofNode(rootNodeFromProof, this);\n        if (root !== undefined && !byteArray_1.byteArrayEquals(rootNode.root, root)) {\n            throw new Error(\"Proof does not match trusted root\");\n        }\n        return this.getView(new persistent_merkle_tree_1.Tree(rootNode));\n    }\n    /** INTERNAL METHOD: For view's API, create proof from a tree */\n    tree_createProof(node, jsonPaths) {\n        const gindexes = this.tree_createProofGindexes(node, jsonPaths);\n        return persistent_merkle_tree_1.createProof(node, {\n            type: persistent_merkle_tree_1.ProofType.treeOffset,\n            gindices: gindexes,\n        });\n    }\n    /** INTERNAL METHOD: For view's API, create proof from a tree */\n    tree_createProofGindexes(node, jsonPaths) {\n        const gindexes = [];\n        for (const jsonPath of jsonPaths) {\n            const { type, gindex } = this.getPathInfo(jsonPath);\n            if (!isCompositeType(type)) {\n                gindexes.push(gindex);\n            }\n            else {\n                // if the path subtype is composite, include the gindices of all the leaves\n                const leafGindexes = type.tree_getLeafGindices(gindex, type.fixedSize === null ? persistent_merkle_tree_1.getNode(node, gindex) : undefined);\n                for (const gindex of leafGindexes) {\n                    gindexes.push(gindex);\n                }\n            }\n        }\n        return gindexes;\n    }\n    /**\n     * Navigate to a subtype & gindex using a path\n     */\n    getPathInfo(path) {\n        const gindices = [];\n        let type = this;\n        for (const prop of path) {\n            if (type.isBasic) {\n                throw new Error(\"Invalid path: cannot navigate beyond a basic type\");\n            }\n            const gindex = type.getPropertyGindex(prop);\n            // else stop navigating\n            if (gindex !== null) {\n                gindices.push(gindex);\n                type = type.getPropertyType(prop);\n            }\n        }\n        return {\n            type,\n            gindex: persistent_merkle_tree_1.concatGindices(gindices),\n        };\n    }\n    /**\n     * INTERNAL METHOD: post process `Ç¸ode` instance created from a proof and return either the same node,\n     * and a new node representing the same data is a different `Node` instance. Currently used exclusively\n     * by ContainerNodeStruct to convert `BranchNode` into `BranchNodeStruct`.\n     */\n    tree_fromProofNode(node) {\n        return { node, done: false };\n    }\n}\nexports.CompositeType = CompositeType;\nfunction isCompositeType(type) {\n    return !type.isBasic;\n}\nexports.isCompositeType = isCompositeType;\n//# sourceMappingURL=composite.js.map"]},"metadata":{},"sourceType":"script"}