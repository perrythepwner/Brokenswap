{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treePostProcessFromProofNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\nfunction treePostProcessFromProofNode(node, type) {\n  let bitstring = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n  if (currentDepth === 0) {\n    const nodePost = type.tree_fromProofNode(node);\n    if (nodePost.done) {\n      return nodePost.node;\n    } else {\n      node = nodePost.node;\n    }\n  }\n  const atTypeDepth = type.depth === currentDepth;\n  if (node.isLeaf()) {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      // If this type merkleized fits in a single chunk then this LeafNode includes all data\n      if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n        return childType.tree_fromProofNode(node).node;\n      }\n      // Witness node\n      else {\n        return node;\n      }\n    }\n    // LeafNode not at type depth is a witness or a length / selector nodes\n    else {\n      return node;\n    }\n  } else {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      if (!isCompositeType(childType)) {\n        throw Error(\"BranchNode does not map to CompositeType\");\n      }\n      const nodePost = childType.tree_fromProofNode(node);\n      // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n      if (nodePost.done) {\n        return nodePost.node;\n      } else {\n        return treePostProcessFromProofNode(nodePost.node, childType);\n      }\n    }\n    // BranchNode at not type depth, keep navigating\n    else {\n      const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n      const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n      if (leftNode === node.left && rightNode === node.right) {\n        return node;\n      } else {\n        return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n      }\n    }\n  }\n}\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\nfunction bitstringToIndex(bitstring) {\n  if (bitstring === \"\") return 0;\n  return parseInt(bitstring, 2);\n}","map":{"version":3,"sources":["../../../src/util/proof/treePostProcessFromProofNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.treePostProcessFromProofNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\nfunction isCompositeType(type) {\n    return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\nfunction treePostProcessFromProofNode(node, type, bitstring = \"\", currentDepth = 0) {\n    // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n    if (currentDepth === 0) {\n        const nodePost = type.tree_fromProofNode(node);\n        if (nodePost.done) {\n            return nodePost.node;\n        }\n        else {\n            node = nodePost.node;\n        }\n    }\n    const atTypeDepth = type.depth === currentDepth;\n    if (node.isLeaf()) {\n        if (atTypeDepth) {\n            const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n            if (jsonPathProp === null) {\n                // bitstring is out of bounds, witness node\n                return node;\n            }\n            const childType = type.getPropertyType(jsonPathProp);\n            // If this type merkleized fits in a single chunk then this LeafNode includes all data\n            if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n                return childType.tree_fromProofNode(node).node;\n            }\n            // Witness node\n            else {\n                return node;\n            }\n        }\n        // LeafNode not at type depth is a witness or a length / selector nodes\n        else {\n            return node;\n        }\n    }\n    else {\n        if (atTypeDepth) {\n            const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n            if (jsonPathProp === null) {\n                // bitstring is out of bounds, witness node\n                return node;\n            }\n            const childType = type.getPropertyType(jsonPathProp);\n            if (!isCompositeType(childType)) {\n                throw Error(\"BranchNode does not map to CompositeType\");\n            }\n            const nodePost = childType.tree_fromProofNode(node);\n            // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n            if (nodePost.done) {\n                return nodePost.node;\n            }\n            else {\n                return treePostProcessFromProofNode(nodePost.node, childType);\n            }\n        }\n        // BranchNode at not type depth, keep navigating\n        else {\n            const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n            const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n            if (leftNode === node.left && rightNode === node.right) {\n                return node;\n            }\n            else {\n                return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n            }\n        }\n    }\n}\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\nfunction bitstringToIndex(bitstring) {\n    if (bitstring === \"\")\n        return 0;\n    return parseInt(bitstring, 2);\n}\n//# sourceMappingURL=treePostProcessFromProofNode.js.map"]},"metadata":{},"sourceType":"script"}