{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar buffer_1 = require(\"buffer\");\nvar transaction_1 = require(\"./transaction\");\n/**\n * Creates a new transaction object that doesn't need to be signed.\n *\n * @param data - A transaction can be initialized with its rlp representation, an array containing\n * the value of its fields in order, or an object containing them by name.\n *\n * @param opts - The transaction's options, used to indicate the chain and hardfork the\n * transactions belongs to.\n *\n * @see Transaction\n */\nvar FakeTransaction = /** @class */function (_super) {\n  __extends(FakeTransaction, _super);\n  function FakeTransaction(data, opts) {\n    if (data === void 0) {\n      data = {};\n    }\n    if (opts === void 0) {\n      opts = {};\n    }\n    var _this = _super.call(this, data, opts) || this;\n    Object.defineProperty(_this, 'from', {\n      enumerable: true,\n      configurable: true,\n      get: function get() {\n        return _this.getSenderAddress();\n      },\n      set: function set(val) {\n        if (val) {\n          _this._from = ethereumjs_util_1.toBuffer(val);\n        }\n      }\n    });\n    var txData = data;\n    if (txData.from) {\n      _this.from = ethereumjs_util_1.toBuffer(txData.from);\n    }\n    return _this;\n  }\n  /**\n   * Computes a sha3-256 hash of the serialized tx, using the sender address to generate a fake\n   * signature.\n   *\n   * @param includeSignature - Whether or not to include the signature\n   */\n  FakeTransaction.prototype.hash = function (includeSignature) {\n    if (includeSignature === void 0) {\n      includeSignature = true;\n    }\n    if (includeSignature && this._from && this._from.toString('hex') !== '') {\n      // include a fake signature using the from address as a private key\n      var fakeKey = buffer_1.Buffer.concat([this._from, this._from.slice(0, 12)]);\n      this.sign(fakeKey);\n    }\n    return _super.prototype.hash.call(this, includeSignature);\n  };\n  return FakeTransaction;\n}(transaction_1.default);\nexports.default = FakeTransaction;","map":{"version":3,"sources":["../src/fake.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA;;;;;;;;;;AAUG;AACH,IAAA,eAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAA6C,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;EAO3C,SAAA,eAAA,CACE,IAAiE,EACjE,IAA6B,EAAA;IAD7B,IAAA,IAAA,KAAA,KAAA,CAAA,EAAA;MAAA,IAAA,GAAA,CAAA,CAAiE;IAAA;IACjE,IAAA,IAAA,KAAA,KAAA,CAAA,EAAA;MAAA,IAAA,GAAA,CAAA,CAA6B;IAAA;IAF/B,IAAA,KAAA,GAIE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAI,EAAE,IAAI,CAAC,IAAA,IAAA;IAEjB,MAAM,CAAC,cAAc,CAAC,KAAI,EAAE,MAAM,EAAE;MAClC,UAAU,EAAE,IAAI;MAChB,YAAY,EAAE,IAAI;MAClB,GAAG,EAAE,SAAA,IAAA,EAAA;QAAM,OAAA,KAAI,CAAC,gBAAgB,CAAA,CAAE;MAAvB,CAAuB;MAClC,GAAG,EAAE,SAAA,IAAA,GAAG,EAAA;QACN,IAAI,GAAG,EAAE;UACP,KAAI,CAAC,KAAK,GAAG,iBAAA,CAAA,QAAQ,CAAC,GAAG,CAAC;QAC3B;MACH;KACD,CAAC;IAEF,IAAM,MAAM,GAAG,IAAkB;IACjC,IAAI,MAAM,CAAC,IAAI,EAAE;MACf,KAAI,CAAC,IAAI,GAAG,iBAAA,CAAA,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC;IAClC;;EACH;EAEA;;;;;AAKG;EACH,eAAA,CAAA,SAAA,CAAA,IAAI,GAAJ,UAAK,gBAAuB,EAAA;IAAvB,IAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;MAAA,gBAAA,GAAA,IAAuB;IAAA;IAC1B,IAAI,gBAAgB,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE;MACvE;MACA,IAAM,OAAO,GAAG,QAAA,CAAA,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;MACpE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;IACnB;IAED,OAAO,MAAA,CAAA,SAAA,CAAM,IAAI,CAAA,IAAA,CAAA,IAAA,EAAC,gBAAgB,CAAC;EACrC,CAAC;EACH,OAAA,eAAC;AAAD,CAAC,CA7C4C,aAAA,CAAA,OAAW,CAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar buffer_1 = require(\"buffer\");\nvar transaction_1 = require(\"./transaction\");\n/**\n * Creates a new transaction object that doesn't need to be signed.\n *\n * @param data - A transaction can be initialized with its rlp representation, an array containing\n * the value of its fields in order, or an object containing them by name.\n *\n * @param opts - The transaction's options, used to indicate the chain and hardfork the\n * transactions belongs to.\n *\n * @see Transaction\n */\nvar FakeTransaction = /** @class */ (function (_super) {\n    __extends(FakeTransaction, _super);\n    function FakeTransaction(data, opts) {\n        if (data === void 0) { data = {}; }\n        if (opts === void 0) { opts = {}; }\n        var _this = _super.call(this, data, opts) || this;\n        Object.defineProperty(_this, 'from', {\n            enumerable: true,\n            configurable: true,\n            get: function () { return _this.getSenderAddress(); },\n            set: function (val) {\n                if (val) {\n                    _this._from = ethereumjs_util_1.toBuffer(val);\n                }\n            },\n        });\n        var txData = data;\n        if (txData.from) {\n            _this.from = ethereumjs_util_1.toBuffer(txData.from);\n        }\n        return _this;\n    }\n    /**\n     * Computes a sha3-256 hash of the serialized tx, using the sender address to generate a fake\n     * signature.\n     *\n     * @param includeSignature - Whether or not to include the signature\n     */\n    FakeTransaction.prototype.hash = function (includeSignature) {\n        if (includeSignature === void 0) { includeSignature = true; }\n        if (includeSignature && this._from && this._from.toString('hex') !== '') {\n            // include a fake signature using the from address as a private key\n            var fakeKey = buffer_1.Buffer.concat([this._from, this._from.slice(0, 12)]);\n            this.sign(fakeKey);\n        }\n        return _super.prototype.hash.call(this, includeSignature);\n    };\n    return FakeTransaction;\n}(transaction_1.default));\nexports.default = FakeTransaction;\n//# sourceMappingURL=fake.js.map"]},"metadata":{},"sourceType":"script"}