{"ast":null,"code":"import _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$(),\n  _s7 = $RefreshSig$(),\n  _s8 = $RefreshSig$(),\n  _s9 = $RefreshSig$(),\n  _s10 = $RefreshSig$(),\n  _s11 = $RefreshSig$(),\n  _s12 = $RefreshSig$();\nimport { ChainId, useCelo, useProvider } from '@celo/react-celo';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { ChainId as UbeswapChainId, JSBI, Token, TokenAmount } from '@ubeswap/sdk';\nimport { POOL_MANAGER } from 'constants/poolManager';\nimport { UBE } from 'constants/tokens';\nimport { MoolaStakingRewards__factory } from 'generated/';\nimport { useAllTokens } from 'hooks/Tokens';\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp';\nimport zip from 'lodash/zip';\n// Hooks\nimport React, { useEffect, useMemo } from 'react';\nimport ERC_20_INTERFACE from '../../constants/abis/erc20';\nimport { STAKING_REWARDS_INTERFACE } from '../../constants/abis/staking-rewards';\n// Interfaces\nimport { UNISWAP_V2_PAIR_INTERFACE } from '../../constants/abis/uniswap-v2-pair';\nimport { usePoolManagerContract, useTokenContract } from '../../hooks/useContract';\nimport { useFarmRegistry } from '../../pages/Earn/useFarmRegistry';\nimport { NEVER_RELOAD, useMultipleContractSingleData, useSingleCallResult, useSingleContractMultipleData } from '../multicall/hooks';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useMultiStakeRewards } from './useDualStakeRewards';\nimport useStakingInfo from './useStakingInfo';\nexport const STAKING_GENESIS = 1619100000;\nconst ACTIVE_CONTRACT_UPDATED_THRESHOLD = 5259492;\nconst UNPREDICTABLE_GAS_LIMIT_ERROR_CODE = 'UNPREDICTABLE_GAS_LIMIT';\nexport const useMultiRewardPools = () => {\n  _s();\n  const library = useProvider();\n  const farmSummaries = useFarmRegistry();\n  const [multiRewardPools, setMultiRewardPools] = React.useState([]);\n  const call = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {\n    const multiRwdPools = [];\n    yield Promise.all(farmSummaries.map( /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (fs) {\n        let poolContract = MoolaStakingRewards__factory.connect(fs.stakingAddress, library);\n        const rewardsTokens = [];\n        const externalStakingRwdAddresses = [];\n\n        // the first reward token at the top level\n        rewardsTokens.push(yield poolContract.rewardsToken());\n\n        // last time the contract was updated - set isActive to false if it has been longer than 2 months\n        let periodFinish = yield poolContract.periodFinish();\n        let isActive = Math.floor(Date.now() / 1000) - periodFinish.toNumber() < ACTIVE_CONTRACT_UPDATED_THRESHOLD;\n        let baseContractFound = false;\n        // recursivley find underlying and base pool contracts\n        while (!baseContractFound) {\n          try {\n            // find the underlying contract if one exists\n            const externalStakingRewardAddr = yield poolContract.externalStakingRewards();\n            externalStakingRwdAddresses.push(externalStakingRewardAddr);\n\n            // capture the contract's reward token\n            poolContract = MoolaStakingRewards__factory.connect(externalStakingRewardAddr, library);\n            rewardsTokens.push(yield poolContract.rewardsToken());\n\n            // determine if the underlying contract is active or not\n            periodFinish = yield poolContract.periodFinish();\n            isActive = Math.floor(Date.now() / 1000) - periodFinish.toNumber() < ACTIVE_CONTRACT_UPDATED_THRESHOLD || isActive;\n          } catch (e) {\n            //if the error is not what is expected - log it\n            if (e.code !== UNPREDICTABLE_GAS_LIMIT_ERROR_CODE) {\n              console.log(e);\n            }\n\n            //set true when externalStakingRewards() throws an error\n            baseContractFound = true;\n          }\n        }\n        if (externalStakingRwdAddresses.length) {\n          multiRwdPools.push({\n            address: fs.stakingAddress,\n            underlyingPool: externalStakingRwdAddresses[0],\n            basePool: externalStakingRwdAddresses[externalStakingRwdAddresses.length - 1],\n            numRewards: rewardsTokens.length,\n            active: isActive\n          });\n        }\n      });\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }()));\n    setMultiRewardPools(multiRwdPools);\n  }), [farmSummaries, library]);\n  useEffect(() => {\n    call();\n  }, [call]);\n  return multiRewardPools;\n};\n_s(useMultiRewardPools, \"e5B9kh87BHi5PzitftDFOP5J1EE=\", false, function () {\n  return [useProvider, useFarmRegistry];\n});\nexport const usePairMultiStakingInfo = (stakingInfo, stakingAddress) => {\n  _s2();\n  var _multiRewardPool$acti, _multiRewardPool$acti2;\n  const multiRewardPools = useMultiRewardPools();\n  const multiRewardPool = useMemo(() => {\n    return multiRewardPools.filter(x => x.address.toLowerCase() === stakingAddress.toLowerCase()).find(x => x.basePool.toLowerCase() === (stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.poolInfo.poolAddress.toLowerCase()));\n  }, [multiRewardPools, stakingAddress, stakingInfo === null || stakingInfo === void 0 ? void 0 : stakingInfo.poolInfo.poolAddress]);\n  const isTriple = (multiRewardPool === null || multiRewardPool === void 0 ? void 0 : multiRewardPool.numRewards) === 3;\n  const dualPool = useMultiStakeRewards(isTriple ? multiRewardPool === null || multiRewardPool === void 0 ? void 0 : multiRewardPool.underlyingPool : multiRewardPool === null || multiRewardPool === void 0 ? void 0 : multiRewardPool.address, stakingInfo, 2, isTriple ? true : (_multiRewardPool$acti = multiRewardPool === null || multiRewardPool === void 0 ? void 0 : multiRewardPool.active) !== null && _multiRewardPool$acti !== void 0 ? _multiRewardPool$acti : false);\n  const triplePool = useMultiStakeRewards(isTriple ? multiRewardPool === null || multiRewardPool === void 0 ? void 0 : multiRewardPool.address : undefined, dualPool, 3, (_multiRewardPool$acti2 = multiRewardPool === null || multiRewardPool === void 0 ? void 0 : multiRewardPool.active) !== null && _multiRewardPool$acti2 !== void 0 ? _multiRewardPool$acti2 : false);\n  return triplePool || dualPool;\n};\n_s2(usePairMultiStakingInfo, \"aV6PiiSxapaMeMUKPW2zTsbSNsM=\", false, function () {\n  return [useMultiRewardPools, useMultiStakeRewards, useMultiStakeRewards];\n});\nexport const useUnclaimedStakingRewards = () => {\n  _s3();\n  var _useSingleCallResult$, _poolsCountBigNumber$, _balances$reduce, _rewardRates$;\n  const {\n    network\n  } = useCelo();\n  const {\n    chainId\n  } = network;\n  const ube = chainId ? UBE[chainId] : undefined;\n  const ubeContract = useTokenContract(ube === null || ube === void 0 ? void 0 : ube.address);\n  const poolManagerContract = usePoolManagerContract([ChainId.Mainnet, ChainId.Alfajores].includes(chainId) ? POOL_MANAGER[chainId] : undefined);\n  const poolsCountBigNumber = (_useSingleCallResult$ = useSingleCallResult(poolManagerContract, 'poolsCount').result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n  const poolsCount = (_poolsCountBigNumber$ = poolsCountBigNumber === null || poolsCountBigNumber === void 0 ? void 0 : poolsCountBigNumber.toNumber()) !== null && _poolsCountBigNumber$ !== void 0 ? _poolsCountBigNumber$ : 0;\n  const poolAddresses = useStakingPoolAddresses(poolManagerContract, poolsCount);\n\n  // compute amount that is locked up\n  const balancesRaw = useSingleContractMultipleData(ubeContract, 'balanceOf', poolAddresses.map(addr => [addr]));\n  const balances = balancesRaw.find(b => !b.result) ? null : balancesRaw.map(b => {\n    var _b$result$, _b$result;\n    return (_b$result$ = (_b$result = b.result) === null || _b$result === void 0 ? void 0 : _b$result[0]) !== null && _b$result$ !== void 0 ? _b$result$ : BigNumber.from(0);\n  });\n  const balanceRemaining = (_balances$reduce = balances === null || balances === void 0 ? void 0 : balances.reduce((sum, b) => b.add(sum), BigNumber.from(0))) !== null && _balances$reduce !== void 0 ? _balances$reduce : null;\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(poolAddresses, STAKING_REWARDS_INTERFACE, 'rewardRate', undefined, NEVER_RELOAD);\n  const periodFinishes = useMultipleContractSingleData(poolAddresses, STAKING_REWARDS_INTERFACE, 'periodFinish', undefined, NEVER_RELOAD);\n  const now = useCurrentBlockTimestamp();\n  const amounts = now ? zip(rewardRates, periodFinishes).map(_ref3 => {\n    var _rate$result, _finish$result;\n    let [rate, finish] = _ref3;\n    const rawRate = rate === null || rate === void 0 ? void 0 : (_rate$result = rate.result) === null || _rate$result === void 0 ? void 0 : _rate$result[0];\n    const finishTime = finish === null || finish === void 0 ? void 0 : (_finish$result = finish.result) === null || _finish$result === void 0 ? void 0 : _finish$result[0];\n    if (rawRate && finishTime && finishTime.gt(now)) {\n      return rawRate.mul(finishTime.sub(now).toNumber());\n    }\n    return BigNumber.from(0);\n  }) : undefined;\n  const earned = rewardRates !== null && rewardRates !== void 0 && (_rewardRates$ = rewardRates[0]) !== null && _rewardRates$ !== void 0 && _rewardRates$.loading || !amounts ? null : amounts.reduce((sum, amt) => sum.add(amt), BigNumber.from(0));\n  return {\n    balanceRemaining,\n    earned,\n    noncirculatingSupply: balanceRemaining && earned ? balanceRemaining.sub(earned) : null\n  };\n};\n_s3(useUnclaimedStakingRewards, \"3qOCSpJTVTJPIsGKW6+DGmW+JRQ=\", false, function () {\n  return [useCelo, useTokenContract, usePoolManagerContract, useSingleCallResult, useStakingPoolAddresses, useSingleContractMultipleData, useMultipleContractSingleData, useMultipleContractSingleData, useCurrentBlockTimestamp];\n});\nexport function useStakingPools(pairToFilterBy, stakingAddress) {\n  _s4();\n  var _useSingleCallResult$2, _poolsCountBigNumber$2;\n  const {\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const ube = chainId ? UBE[chainId] : undefined;\n  const poolManagerContract = usePoolManagerContract(chainId !== UbeswapChainId.BAKLAVA ? POOL_MANAGER[chainId] : undefined);\n  const poolsCountBigNumber = (_useSingleCallResult$2 = useSingleCallResult(poolManagerContract, 'poolsCount').result) === null || _useSingleCallResult$2 === void 0 ? void 0 : _useSingleCallResult$2[0];\n  const poolsCount = (_poolsCountBigNumber$2 = poolsCountBigNumber === null || poolsCountBigNumber === void 0 ? void 0 : poolsCountBigNumber.toNumber()) !== null && _poolsCountBigNumber$2 !== void 0 ? _poolsCountBigNumber$2 : 0;\n  const poolAddresses = useStakingPoolAddresses(poolManagerContract, poolsCount);\n  const pools = useStakingPoolsInfo(poolManagerContract, poolAddresses);\n  const stakingTokens = pools.map(p => p === null || p === void 0 ? void 0 : p.stakingToken);\n  const poolPairs = usePairDataFromAddresses(stakingTokens);\n  return useMemo(() => {\n    var _pools$reduce$filter;\n    if (!ube || !pools || !poolPairs) return [];\n    return (_pools$reduce$filter = pools.reduce((memo, poolInfo, index) => {\n      return [...memo, {\n        stakingRewardAddress: poolInfo.poolAddress,\n        tokens: poolPairs[index],\n        poolInfo\n      }];\n    }, []).filter(stakingRewardInfo => {\n      if (stakingAddress) {\n        return stakingAddress.toLowerCase() === stakingRewardInfo.stakingRewardAddress.toLowerCase();\n      }\n      if (pairToFilterBy === undefined) {\n        return true;\n      }\n      if (pairToFilterBy === null) {\n        return false;\n      }\n      return stakingRewardInfo.tokens && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) && pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1]);\n    })) !== null && _pools$reduce$filter !== void 0 ? _pools$reduce$filter : [];\n  }, [ube, pools, poolPairs, pairToFilterBy, stakingAddress]);\n}\n_s4(useStakingPools, \"X4yWLGz7HUhN3EYTxPoSelDpwQw=\", false, function () {\n  return [useCelo, usePoolManagerContract, useSingleCallResult, useStakingPoolAddresses, useStakingPoolsInfo, usePairDataFromAddresses];\n});\nexport function useStakingPoolAddresses(poolManagerContract, poolsCount) {\n  _s5();\n  // Get rewards pools addresses\n  const inputs = [...Array(poolsCount).keys()].map(i => [i]);\n  const poolAddresses = useSingleContractMultipleData(poolManagerContract, 'poolsByIndex', inputs);\n  return useMemo(() => {\n    return !poolAddresses.length || !poolAddresses[0] || poolAddresses[0].loading ? [] : poolAddresses.map(p => {\n      var _p$result;\n      return p === null || p === void 0 ? void 0 : (_p$result = p.result) === null || _p$result === void 0 ? void 0 : _p$result[0];\n    }).filter(x => !!x);\n  }, [poolAddresses]);\n}\n_s5(useStakingPoolAddresses, \"dcm4D+o6JCxaiDePcIyk/L99IjM=\", false, function () {\n  return [useSingleContractMultipleData];\n});\nconst EXTERNAL_POOLS = [{\n  index: -1,\n  poolAddress: '0x33F819986FE80A4f4A9032260A24770918511849',\n  stakingToken: '0xF97E6168283e38FC42725082FC63b47B6cD16B18',\n  rewardToken: '0x18414Ce6dAece0365f935F3e78A7C1993e77d8Cd',\n  rewardTokenSymbol: 'LAPIS',\n  weight: 0\n}, {\n  index: -1,\n  poolAddress: '0xD409B7C4F67F5C845c53505b3d3B5aCD44e479AB',\n  stakingToken: '0x573bcEBD09Ff805eD32df2cb1A968418DC74DCf7',\n  rewardToken: '0x18414Ce6dAece0365f935F3e78A7C1993e77d8Cd',\n  rewardTokenSymbol: 'LAPIS',\n  weight: 0\n}, {\n  index: -1,\n  poolAddress: '0x478b8D37eE976228d17704d95B5430Cd93a31b87',\n  stakingToken: '0x12E42ccf14B283Ef0a36A791892D18BF75Da5c80',\n  rewardToken: '0x94140c2eA9D208D8476cA4E3045254169791C59e',\n  rewardTokenSymbol: 'PREMIO',\n  weight: 0\n}];\nexport function useStakingPoolsInfo(poolManagerContract, poolAddresses) {\n  _s6();\n  const pools = useSingleContractMultipleData(poolManagerContract, 'pools', poolAddresses.map(addr => [addr]));\n  const rawPools = useMemo(() => {\n    return !pools || !pools[0] || pools[0].loading ? [] : pools.map(p => p === null || p === void 0 ? void 0 : p.result).filter(x => !!x);\n  }, [pools]);\n  const nextPeriod = useSingleCallResult(poolManagerContract, 'nextPeriod');\n  const poolRewards = useSingleContractMultipleData(poolManagerContract, 'computeAmountForPool', rawPools.map(p => {\n    var _nextPeriod$result;\n    return [p.stakingToken, nextPeriod === null || nextPeriod === void 0 ? void 0 : (_nextPeriod$result = nextPeriod.result) === null || _nextPeriod$result === void 0 ? void 0 : _nextPeriod$result[0]];\n  }));\n  return rawPools.concat(EXTERNAL_POOLS).map((pool, i) => {\n    var _poolRewards$i$result, _poolRewards$i, _poolRewards$i$result2;\n    return _objectSpread(_objectSpread({}, pool), {}, {\n      nextPeriodRewards: (_poolRewards$i$result = poolRewards === null || poolRewards === void 0 ? void 0 : (_poolRewards$i = poolRewards[i]) === null || _poolRewards$i === void 0 ? void 0 : (_poolRewards$i$result2 = _poolRewards$i.result) === null || _poolRewards$i$result2 === void 0 ? void 0 : _poolRewards$i$result2[0]) !== null && _poolRewards$i$result !== void 0 ? _poolRewards$i$result : null\n    });\n  });\n}\n_s6(useStakingPoolsInfo, \"bmYSbmegZTJYRh5OF6IWLWilSe0=\", false, function () {\n  return [useSingleContractMultipleData, useSingleCallResult, useSingleContractMultipleData];\n});\nexport function usePairDataFromAddresses(pairAddresses) {\n  _s7();\n  const {\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const token0Data = useMultipleContractSingleData(pairAddresses, UNISWAP_V2_PAIR_INTERFACE, 'token0', undefined, NEVER_RELOAD);\n  const token1Data = useMultipleContractSingleData(pairAddresses, UNISWAP_V2_PAIR_INTERFACE, 'token1', undefined, NEVER_RELOAD);\n  const tokens0 = token0Data.map(t => {\n    var _t$result;\n    return t === null || t === void 0 ? void 0 : (_t$result = t.result) === null || _t$result === void 0 ? void 0 : _t$result[0];\n  });\n  const tokens1 = token1Data.map(t => {\n    var _t$result2;\n    return t === null || t === void 0 ? void 0 : (_t$result2 = t.result) === null || _t$result2 === void 0 ? void 0 : _t$result2[0];\n  });\n  const tokensDb = useAllTokens();\n\n  // Construct a set of all the unique token addresses that are not in the tokenlists.\n  const tokenAddressesNeededToFetch = useMemo(() => [...new Set([...tokens0, ...tokens1])].filter(addr => addr !== undefined && !tokensDb[addr]), [tokensDb, tokens0, tokens1]);\n  const names = useMultipleContractSingleData(tokenAddressesNeededToFetch, ERC_20_INTERFACE, 'name', undefined, NEVER_RELOAD);\n  const symbols = useMultipleContractSingleData(tokenAddressesNeededToFetch, ERC_20_INTERFACE, 'symbol', undefined, NEVER_RELOAD);\n  const tokenDecimals = useMultipleContractSingleData(tokenAddressesNeededToFetch, ERC_20_INTERFACE, 'decimals', undefined, NEVER_RELOAD);\n\n  // Construct the full token data\n  const tokensNeededToFetch = useMemo(() => {\n    if (!tokenAddressesNeededToFetch.length || !names.length || !symbols.length || !tokenDecimals.length) return null;\n    if (names[0].loading || tokenDecimals[0].loading || symbols[0].loading) return null;\n    if (!names[0].result || !tokenDecimals[0].result || !symbols[0].result) return null;\n    return tokenAddressesNeededToFetch.reduce((memo, address, index) => {\n      var _tokenDecimals$index$, _names$index$result, _names$index$result2, _symbols$index$result, _symbols$index$result2;\n      const decimals = (_tokenDecimals$index$ = tokenDecimals[index].result) === null || _tokenDecimals$index$ === void 0 ? void 0 : _tokenDecimals$index$[0];\n      const name = ((_names$index$result = names[index].result) === null || _names$index$result === void 0 ? void 0 : _names$index$result[0]) === 'Celo Gold' ? 'Celo' : (_names$index$result2 = names[index].result) === null || _names$index$result2 === void 0 ? void 0 : _names$index$result2[0];\n      const symbol = ((_symbols$index$result = symbols[index].result) === null || _symbols$index$result === void 0 ? void 0 : _symbols$index$result[0]) === 'cGLD' ? 'CELO' : (_symbols$index$result2 = symbols[index].result) === null || _symbols$index$result2 === void 0 ? void 0 : _symbols$index$result2[0]; // todo - remove hardcoded symbol swap for CELO\n\n      // Sometimes, decimals/name/symbol can be undefined, causing an error. TODO: Look into a root cause\n      if (chainId && address && decimals && symbol && name) {\n        const token = new Token(chainId, address, decimals, symbol, name);\n        return [...memo, token];\n      }\n      return memo;\n    }, []);\n  }, [chainId, tokenAddressesNeededToFetch, names, symbols, tokenDecimals]);\n  const pairsData = useMemo(() => {\n    const tokens = tokensNeededToFetch !== null && tokensNeededToFetch !== void 0 ? tokensNeededToFetch : [];\n    return tokens0.reduce((pairs, token0Address, index) => {\n      var _tokensDb$token0Addre, _tokensDb$token1Addre;\n      if (!token0Address) {\n        return [...pairs, undefined];\n      }\n      const token1Address = tokens1[index];\n      if (!token1Address) {\n        return [...pairs, undefined];\n      }\n      const token0 = (_tokensDb$token0Addre = tokensDb[token0Address]) !== null && _tokensDb$token0Addre !== void 0 ? _tokensDb$token0Addre : tokens.find(t => t.address === token0Address);\n      const token1 = (_tokensDb$token1Addre = tokensDb[token1Address]) !== null && _tokensDb$token1Addre !== void 0 ? _tokensDb$token1Addre : tokens.find(t => t.address === token1Address);\n      if (!token0 || !token1) {\n        return [...pairs, undefined];\n      }\n      return [...pairs, [token0, token1]];\n    }, []);\n  }, [tokensNeededToFetch, tokens0, tokens1, tokensDb]);\n  return pairsData;\n}\n_s7(usePairDataFromAddresses, \"nGD7rlT/51pIjgnua6uyLrIRLi0=\", false, function () {\n  return [useCelo, useMultipleContractSingleData, useMultipleContractSingleData, useAllTokens, useMultipleContractSingleData, useMultipleContractSingleData, useMultipleContractSingleData];\n});\nexport function useTotalUbeEarned() {\n  _s8();\n  const {\n    network\n  } = useCelo();\n  const {\n    chainId\n  } = network;\n  const ube = chainId ? UBE[chainId] : undefined;\n  const stakingInfos = useStakingInfo();\n  return useMemo(() => {\n    var _stakingInfos$filter$;\n    if (!ube) return undefined;\n    return (_stakingInfos$filter$ = stakingInfos === null || stakingInfos === void 0 ? void 0 : stakingInfos.filter(stakingInfo => stakingInfo.rewardTokens.includes(ube)).reduce((accumulator, stakingInfo) => {\n      var _stakingInfo$earnedAm, _stakingInfo$earnedAm2;\n      return accumulator.add((_stakingInfo$earnedAm = (_stakingInfo$earnedAm2 = stakingInfo.earnedAmounts) === null || _stakingInfo$earnedAm2 === void 0 ? void 0 : _stakingInfo$earnedAm2.find(earnedAmount => earnedAmount.token == ube)) !== null && _stakingInfo$earnedAm !== void 0 ? _stakingInfo$earnedAm : new TokenAmount(ube, '0'));\n    }, new TokenAmount(ube, '0'))) !== null && _stakingInfos$filter$ !== void 0 ? _stakingInfos$filter$ : new TokenAmount(ube, '0');\n  }, [stakingInfos, ube]);\n}\n_s8(useTotalUbeEarned, \"yuDJTFKGN55TjB6xOveJ/BehqKw=\", false, function () {\n  return [useCelo, useStakingInfo];\n});\nexport function useFilteredStakingInfo(stakingAddresses) {\n  _s9();\n  const {\n    network\n  } = useCelo();\n  const {\n    chainId\n  } = network;\n  const ube = chainId ? UBE[chainId] : undefined;\n  const stakingInfos = useStakingInfo();\n  return useMemo(() => {\n    if (!ube) return;\n    return stakingInfos.filter(stakingInfo => stakingInfo.stakingToken.address && stakingAddresses.includes(stakingInfo.stakingToken.address));\n  }, [stakingInfos, ube, stakingAddresses]);\n}\n_s9(useFilteredStakingInfo, \"yuDJTFKGN55TjB6xOveJ/BehqKw=\", false, function () {\n  return [useCelo, useStakingInfo];\n});\nexport function useFarmRewardsInfo(stakingAddresses) {\n  _s10();\n  const {\n    network\n  } = useCelo();\n  const {\n    chainId\n  } = network;\n  const ube = chainId ? UBE[chainId] : undefined;\n  const stakingInfos = useStakingInfo();\n  return useMemo(() => {\n    if (!ube) return;\n    return stakingInfos.filter(stakingInfo => stakingInfo.stakingToken.address && stakingAddresses.includes(stakingInfo.stakingToken.address));\n  }, [stakingInfos, ube, stakingAddresses]);\n}\n\n// based on typed value\n_s10(useFarmRewardsInfo, \"yuDJTFKGN55TjB6xOveJ/BehqKw=\", false, function () {\n  return [useCelo, useStakingInfo];\n});\nexport function useDerivedStakeInfo(typedValue, stakingToken, userLiquidityUnstaked) {\n  _s11();\n  const {\n    address\n  } = useCelo();\n  const parsedInput = tryParseAmount(typedValue, stakingToken !== null && stakingToken !== void 0 ? stakingToken : undefined);\n  const parsedAmount = parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw) ? parsedInput : undefined;\n  let error;\n  if (!address) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    var _error;\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Enter an amount';\n  }\n  return {\n    parsedAmount,\n    error\n  };\n}\n\n// based on typed value\n_s11(useDerivedStakeInfo, \"whDHY6H3YUZs14KHPjkPWVtD0a8=\", false, function () {\n  return [useCelo];\n});\nexport function useDerivedUnstakeInfo(typedValue, stakingAmount) {\n  _s12();\n  const {\n    address\n  } = useCelo();\n  const parsedInput = tryParseAmount(typedValue, stakingAmount.token);\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined;\n  let error;\n  if (!address) {\n    error = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    var _error2;\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n  return {\n    parsedAmount,\n    error\n  };\n}\n_s12(useDerivedUnstakeInfo, \"whDHY6H3YUZs14KHPjkPWVtD0a8=\", false, function () {\n  return [useCelo];\n});","map":{"version":3,"names":["ChainId","useCelo","useProvider","BigNumber","UbeswapChainId","JSBI","Token","TokenAmount","POOL_MANAGER","UBE","MoolaStakingRewards__factory","useAllTokens","useCurrentBlockTimestamp","zip","React","useEffect","useMemo","ERC_20_INTERFACE","STAKING_REWARDS_INTERFACE","UNISWAP_V2_PAIR_INTERFACE","usePoolManagerContract","useTokenContract","useFarmRegistry","NEVER_RELOAD","useMultipleContractSingleData","useSingleCallResult","useSingleContractMultipleData","tryParseAmount","useMultiStakeRewards","useStakingInfo","STAKING_GENESIS","ACTIVE_CONTRACT_UPDATED_THRESHOLD","UNPREDICTABLE_GAS_LIMIT_ERROR_CODE","useMultiRewardPools","_s","library","farmSummaries","multiRewardPools","setMultiRewardPools","useState","call","useCallback","_asyncToGenerator","multiRwdPools","Promise","all","map","_ref2","fs","poolContract","connect","stakingAddress","rewardsTokens","externalStakingRwdAddresses","push","rewardsToken","periodFinish","isActive","Math","floor","Date","now","toNumber","baseContractFound","externalStakingRewardAddr","externalStakingRewards","e","code","console","log","length","address","underlyingPool","basePool","numRewards","active","_x","apply","arguments","usePairMultiStakingInfo","stakingInfo","_s2","_multiRewardPool$acti","_multiRewardPool$acti2","multiRewardPool","filter","x","toLowerCase","find","poolInfo","poolAddress","isTriple","dualPool","triplePool","undefined","useUnclaimedStakingRewards","_s3","_useSingleCallResult$","_poolsCountBigNumber$","_balances$reduce","_rewardRates$","network","chainId","ube","ubeContract","poolManagerContract","Mainnet","Alfajores","includes","poolsCountBigNumber","result","poolsCount","poolAddresses","useStakingPoolAddresses","balancesRaw","addr","balances","b","_b$result$","_b$result","from","balanceRemaining","reduce","sum","add","rewardRates","periodFinishes","amounts","_ref3","_rate$result","_finish$result","rate","finish","rawRate","finishTime","gt","mul","sub","earned","loading","amt","noncirculatingSupply","useStakingPools","pairToFilterBy","_s4","_useSingleCallResult$2","_poolsCountBigNumber$2","BAKLAVA","pools","useStakingPoolsInfo","stakingTokens","p","stakingToken","poolPairs","usePairDataFromAddresses","_pools$reduce$filter","memo","index","stakingRewardAddress","tokens","stakingRewardInfo","involvesToken","_s5","inputs","Array","keys","i","_p$result","EXTERNAL_POOLS","rewardToken","rewardTokenSymbol","weight","_s6","rawPools","nextPeriod","poolRewards","_nextPeriod$result","concat","pool","_poolRewards$i$result","_poolRewards$i","_poolRewards$i$result2","_objectSpread","nextPeriodRewards","pairAddresses","_s7","token0Data","token1Data","tokens0","t","_t$result","tokens1","_t$result2","tokensDb","tokenAddressesNeededToFetch","Set","names","symbols","tokenDecimals","tokensNeededToFetch","_tokenDecimals$index$","_names$index$result","_names$index$result2","_symbols$index$result","_symbols$index$result2","decimals","name","symbol","token","pairsData","pairs","token0Address","_tokensDb$token0Addre","_tokensDb$token1Addre","token1Address","token0","token1","useTotalUbeEarned","_s8","stakingInfos","_stakingInfos$filter$","rewardTokens","accumulator","_stakingInfo$earnedAm","_stakingInfo$earnedAm2","earnedAmounts","earnedAmount","useFilteredStakingInfo","stakingAddresses","_s9","useFarmRewardsInfo","_s10","useDerivedStakeInfo","typedValue","userLiquidityUnstaked","_s11","parsedInput","parsedAmount","lessThanOrEqual","raw","error","_error","useDerivedUnstakeInfo","stakingAmount","_s12","_error2"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/stake/hooks.ts"],"sourcesContent":["import { ChainId, useCelo, useProvider } from '@celo/react-celo'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { ChainId as UbeswapChainId, JSBI, Pair, Token, TokenAmount } from '@ubeswap/sdk'\nimport { POOL_MANAGER } from 'constants/poolManager'\nimport { UBE } from 'constants/tokens'\nimport { MoolaStakingRewards__factory, PoolManager } from 'generated/'\nimport { useAllTokens } from 'hooks/Tokens'\nimport useCurrentBlockTimestamp from 'hooks/useCurrentBlockTimestamp'\nimport zip from 'lodash/zip'\n// Hooks\nimport React, { useEffect, useMemo } from 'react'\n\nimport ERC_20_INTERFACE from '../../constants/abis/erc20'\nimport { STAKING_REWARDS_INTERFACE } from '../../constants/abis/staking-rewards'\n// Interfaces\nimport { UNISWAP_V2_PAIR_INTERFACE } from '../../constants/abis/uniswap-v2-pair'\nimport { usePoolManagerContract, useTokenContract } from '../../hooks/useContract'\nimport { useFarmRegistry } from '../../pages/Earn/useFarmRegistry'\nimport {\n  NEVER_RELOAD,\n  useMultipleContractSingleData,\n  useSingleCallResult,\n  useSingleContractMultipleData,\n} from '../multicall/hooks'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useMultiStakeRewards } from './useDualStakeRewards'\nimport useStakingInfo from './useStakingInfo'\n\nexport const STAKING_GENESIS = 1619100000\nconst ACTIVE_CONTRACT_UPDATED_THRESHOLD = 5259492\nconst UNPREDICTABLE_GAS_LIMIT_ERROR_CODE = 'UNPREDICTABLE_GAS_LIMIT'\n\nexport interface StakingInfo {\n  // the address of the reward contract\n  readonly stakingRewardAddress: string | undefined\n  // the token of the liquidity pool\n  readonly stakingToken: Token\n  // the tokens involved in this pair\n  readonly tokens: readonly [Token, Token]\n  // the amount of token currently staked, or undefined if no account\n  readonly stakedAmount?: TokenAmount\n  // the total amount of token staked in the contract\n  readonly totalStakedAmount: TokenAmount\n  // the amount of reward tokens earned by the active account, or undefined if no account\n  readonly earnedAmounts?: TokenAmount[]\n  // the current amount of token distributed to the active account per second.\n  // equivalent to percent of total supply * reward rate\n  readonly rewardRates?: TokenAmount[]\n  // the amount of token distributed per second to all LPs, constant\n  readonly totalRewardRates: TokenAmount[]\n  // when the period ends\n  readonly periodFinish: Date | undefined\n  // if pool is active\n  readonly active: boolean\n  // calculates a hypothetical amount of token distributed to the active account per second.\n  readonly getHypotheticalRewardRate: (\n    stakedAmount: TokenAmount,\n    totalStakedAmount: TokenAmount,\n    totalRewardRates: TokenAmount[]\n  ) => TokenAmount[]\n  readonly nextPeriodRewards: TokenAmount\n  readonly poolInfo: IRawPool\n  readonly rewardTokens: Token[]\n}\n\ntype MultiRewardPool = {\n  address: string\n  underlyingPool: string\n  basePool: string\n  numRewards: number\n  active: boolean\n}\n\nexport const useMultiRewardPools = (): MultiRewardPool[] => {\n  const library = useProvider()\n  const farmSummaries = useFarmRegistry()\n\n  const [multiRewardPools, setMultiRewardPools] = React.useState<MultiRewardPool[]>([])\n\n  const call = React.useCallback(async () => {\n    const multiRwdPools: MultiRewardPool[] = []\n\n    await Promise.all(\n      farmSummaries.map(async (fs) => {\n        let poolContract = MoolaStakingRewards__factory.connect(fs.stakingAddress, library)\n        const rewardsTokens = []\n        const externalStakingRwdAddresses = []\n\n        // the first reward token at the top level\n        rewardsTokens.push(await poolContract.rewardsToken())\n\n        // last time the contract was updated - set isActive to false if it has been longer than 2 months\n        let periodFinish = await poolContract.periodFinish()\n        let isActive = Math.floor(Date.now() / 1000) - periodFinish.toNumber() < ACTIVE_CONTRACT_UPDATED_THRESHOLD\n\n        let baseContractFound = false\n        // recursivley find underlying and base pool contracts\n        while (!baseContractFound) {\n          try {\n            // find the underlying contract if one exists\n            const externalStakingRewardAddr = await poolContract.externalStakingRewards()\n            externalStakingRwdAddresses.push(externalStakingRewardAddr)\n\n            // capture the contract's reward token\n            poolContract = MoolaStakingRewards__factory.connect(externalStakingRewardAddr, library)\n            rewardsTokens.push(await poolContract.rewardsToken())\n\n            // determine if the underlying contract is active or not\n            periodFinish = await poolContract.periodFinish()\n            isActive =\n              Math.floor(Date.now() / 1000) - periodFinish.toNumber() < ACTIVE_CONTRACT_UPDATED_THRESHOLD || isActive\n          } catch (e: any) {\n            //if the error is not what is expected - log it\n            if (e.code !== UNPREDICTABLE_GAS_LIMIT_ERROR_CODE) {\n              console.log(e)\n            }\n\n            //set true when externalStakingRewards() throws an error\n            baseContractFound = true\n          }\n        }\n\n        if (externalStakingRwdAddresses.length) {\n          multiRwdPools.push({\n            address: fs.stakingAddress,\n            underlyingPool: externalStakingRwdAddresses[0],\n            basePool: externalStakingRwdAddresses[externalStakingRwdAddresses.length - 1],\n            numRewards: rewardsTokens.length,\n            active: isActive,\n          })\n        }\n      })\n    )\n    setMultiRewardPools(multiRwdPools)\n  }, [farmSummaries, library])\n\n  useEffect(() => {\n    call()\n  }, [call])\n\n  return multiRewardPools\n}\n\nexport const usePairMultiStakingInfo = (\n  stakingInfo: StakingInfo | undefined,\n  stakingAddress: string\n): StakingInfo | null => {\n  const multiRewardPools = useMultiRewardPools()\n\n  const multiRewardPool = useMemo(() => {\n    return multiRewardPools\n      .filter((x) => x.address.toLowerCase() === stakingAddress.toLowerCase())\n      .find((x) => x.basePool.toLowerCase() === stakingInfo?.poolInfo.poolAddress.toLowerCase())\n  }, [multiRewardPools, stakingAddress, stakingInfo?.poolInfo.poolAddress])\n\n  const isTriple = multiRewardPool?.numRewards === 3\n\n  const dualPool = useMultiStakeRewards(\n    isTriple ? multiRewardPool?.underlyingPool : multiRewardPool?.address,\n    stakingInfo,\n    2,\n    isTriple ? true : multiRewardPool?.active ?? false\n  )\n  const triplePool = useMultiStakeRewards(\n    isTriple ? multiRewardPool?.address : undefined,\n    dualPool,\n    3,\n    multiRewardPool?.active ?? false\n  )\n  return triplePool || dualPool\n}\n\ninterface UnclaimedInfo {\n  /**\n   * Total tokens left in the contract\n   */\n  balanceRemaining: BigNumber | null\n  /**\n   * Earned but unclaimed tokens\n   */\n  earned: BigNumber | null\n  /**\n   * Tokens not in the circulating supply\n   */\n  noncirculatingSupply: BigNumber | null\n}\n\nexport const useUnclaimedStakingRewards = (): UnclaimedInfo => {\n  const { network } = useCelo()\n  const { chainId } = network\n  const ube = chainId ? UBE[chainId as unknown as UbeswapChainId] : undefined\n  const ubeContract = useTokenContract(ube?.address)\n  const poolManagerContract = usePoolManagerContract(\n    [ChainId.Mainnet, ChainId.Alfajores].includes(chainId) ? POOL_MANAGER[chainId] : undefined\n  )\n  const poolsCountBigNumber = useSingleCallResult(poolManagerContract, 'poolsCount').result?.[0] as\n    | BigNumber\n    | undefined\n  const poolsCount = poolsCountBigNumber?.toNumber() ?? 0\n  const poolAddresses = useStakingPoolAddresses(poolManagerContract, poolsCount)\n\n  // compute amount that is locked up\n  const balancesRaw = useSingleContractMultipleData(\n    ubeContract,\n    'balanceOf',\n    poolAddresses.map((addr) => [addr])\n  )\n  const balances = balancesRaw.find((b) => !b.result)\n    ? null\n    : (balancesRaw.map((b) => b.result?.[0] ?? BigNumber.from(0)) as readonly BigNumber[])\n  const balanceRemaining = balances?.reduce((sum, b) => b.add(sum), BigNumber.from(0)) ?? null\n\n  // tokens per second, constants\n  const rewardRates = useMultipleContractSingleData(\n    poolAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'rewardRate',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const periodFinishes = useMultipleContractSingleData(\n    poolAddresses,\n    STAKING_REWARDS_INTERFACE,\n    'periodFinish',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const now = useCurrentBlockTimestamp()\n  const amounts = now\n    ? zip(rewardRates, periodFinishes).map(([rate, finish]): BigNumber => {\n        const rawRate = rate?.result?.[0] as BigNumber | undefined\n        const finishTime = finish?.result?.[0] as BigNumber | undefined\n        if (rawRate && finishTime && finishTime.gt(now)) {\n          return rawRate.mul(finishTime.sub(now).toNumber())\n        }\n        return BigNumber.from(0)\n      })\n    : undefined\n  const earned =\n    rewardRates?.[0]?.loading || !amounts ? null : amounts.reduce((sum, amt) => sum.add(amt), BigNumber.from(0))\n\n  return {\n    balanceRemaining,\n    earned,\n    noncirculatingSupply: balanceRemaining && earned ? balanceRemaining.sub(earned) : null,\n  }\n}\n\ninterface IStakingPool {\n  stakingRewardAddress: string\n  tokens?: readonly [Token, Token]\n  poolInfo: IRawPool\n}\n\nexport function useStakingPools(pairToFilterBy?: Pair | null, stakingAddress?: string): readonly IStakingPool[] {\n  const { network } = useCelo()\n  const chainId = network.chainId as unknown as UbeswapChainId\n  const ube = chainId ? UBE[chainId] : undefined\n\n  const poolManagerContract = usePoolManagerContract(\n    chainId !== UbeswapChainId.BAKLAVA ? POOL_MANAGER[chainId] : undefined\n  )\n  const poolsCountBigNumber = useSingleCallResult(poolManagerContract, 'poolsCount').result?.[0] as\n    | BigNumber\n    | undefined\n  const poolsCount = poolsCountBigNumber?.toNumber() ?? 0\n\n  const poolAddresses = useStakingPoolAddresses(poolManagerContract, poolsCount)\n  const pools = useStakingPoolsInfo(poolManagerContract, poolAddresses)\n\n  const stakingTokens = pools.map((p) => p?.stakingToken as string)\n  const poolPairs = usePairDataFromAddresses(stakingTokens)\n\n  return useMemo(() => {\n    if (!ube || !pools || !poolPairs) return []\n\n    return (\n      pools\n        .reduce((memo: IStakingPool[], poolInfo, index) => {\n          return [\n            ...memo,\n            {\n              stakingRewardAddress: poolInfo.poolAddress,\n              tokens: poolPairs[index],\n              poolInfo,\n            },\n          ]\n        }, [])\n        .filter((stakingRewardInfo) => {\n          if (stakingAddress) {\n            return stakingAddress.toLowerCase() === stakingRewardInfo.stakingRewardAddress.toLowerCase()\n          }\n          if (pairToFilterBy === undefined) {\n            return true\n          }\n          if (pairToFilterBy === null) {\n            return false\n          }\n          return (\n            stakingRewardInfo.tokens &&\n            pairToFilterBy.involvesToken(stakingRewardInfo.tokens[0]) &&\n            pairToFilterBy.involvesToken(stakingRewardInfo.tokens[1])\n          )\n        }) ?? []\n    )\n  }, [ube, pools, poolPairs, pairToFilterBy, stakingAddress])\n}\n\nexport function useStakingPoolAddresses(\n  poolManagerContract: PoolManager | null,\n  poolsCount: number\n): readonly string[] {\n  // Get rewards pools addresses\n  const inputs = [...Array(poolsCount).keys()].map((i) => [i])\n  const poolAddresses = useSingleContractMultipleData(poolManagerContract, 'poolsByIndex', inputs)\n\n  return useMemo(() => {\n    return !poolAddresses.length || !poolAddresses[0] || poolAddresses[0].loading\n      ? []\n      : poolAddresses.map((p) => p?.result?.[0]).filter((x): x is string => !!x)\n  }, [poolAddresses])\n}\n\ninterface IRawPool {\n  index: number\n  stakingToken: string\n  poolAddress: string\n  weight: number\n  rewardToken?: string\n  rewardTokenSymbol?: string\n  nextPeriod?: number\n  nextPeriodRewards?: BigNumber | null\n}\n\nconst EXTERNAL_POOLS: IRawPool[] = [\n  {\n    index: -1,\n    poolAddress: '0x33F819986FE80A4f4A9032260A24770918511849',\n    stakingToken: '0xF97E6168283e38FC42725082FC63b47B6cD16B18',\n    rewardToken: '0x18414Ce6dAece0365f935F3e78A7C1993e77d8Cd',\n    rewardTokenSymbol: 'LAPIS',\n    weight: 0,\n  },\n  {\n    index: -1,\n    poolAddress: '0xD409B7C4F67F5C845c53505b3d3B5aCD44e479AB',\n    stakingToken: '0x573bcEBD09Ff805eD32df2cb1A968418DC74DCf7',\n    rewardToken: '0x18414Ce6dAece0365f935F3e78A7C1993e77d8Cd',\n    rewardTokenSymbol: 'LAPIS',\n    weight: 0,\n  },\n  {\n    index: -1,\n    poolAddress: '0x478b8D37eE976228d17704d95B5430Cd93a31b87',\n    stakingToken: '0x12E42ccf14B283Ef0a36A791892D18BF75Da5c80',\n    rewardToken: '0x94140c2eA9D208D8476cA4E3045254169791C59e',\n    rewardTokenSymbol: 'PREMIO',\n    weight: 0,\n  },\n]\n\nexport function useStakingPoolsInfo(\n  poolManagerContract: PoolManager | null,\n  poolAddresses: readonly string[]\n): readonly IRawPool[] {\n  const pools = useSingleContractMultipleData(\n    poolManagerContract,\n    'pools',\n    poolAddresses.map((addr) => [addr])\n  )\n\n  const rawPools = useMemo(() => {\n    return !pools || !pools[0] || pools[0].loading\n      ? []\n      : pools.map((p) => p?.result as unknown as IRawPool | undefined).filter((x): x is IRawPool => !!x)\n  }, [pools])\n\n  const nextPeriod = useSingleCallResult(poolManagerContract, 'nextPeriod')\n  const poolRewards = useSingleContractMultipleData(\n    poolManagerContract,\n    'computeAmountForPool',\n    rawPools.map((p) => [p.stakingToken, nextPeriod?.result?.[0]])\n  )\n  return rawPools.concat(EXTERNAL_POOLS).map((pool, i) => ({\n    ...pool,\n    nextPeriodRewards: poolRewards?.[i]?.result?.[0] ?? null,\n  }))\n}\n\nexport function usePairDataFromAddresses(\n  pairAddresses: readonly string[]\n): readonly (readonly [Token, Token] | undefined)[] {\n  const { network } = useCelo()\n  const chainId = network.chainId as unknown as UbeswapChainId\n\n  const token0Data = useMultipleContractSingleData(\n    pairAddresses,\n    UNISWAP_V2_PAIR_INTERFACE,\n    'token0',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const token1Data = useMultipleContractSingleData(\n    pairAddresses,\n    UNISWAP_V2_PAIR_INTERFACE,\n    'token1',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const tokens0 = token0Data.map((t) => t?.result?.[0] as string | undefined)\n  const tokens1 = token1Data.map((t) => t?.result?.[0] as string | undefined)\n  const tokensDb = useAllTokens()\n\n  // Construct a set of all the unique token addresses that are not in the tokenlists.\n  const tokenAddressesNeededToFetch = useMemo(\n    () =>\n      [...new Set([...tokens0, ...tokens1])].filter((addr): addr is string => addr !== undefined && !tokensDb[addr]),\n    [tokensDb, tokens0, tokens1]\n  )\n\n  const names = useMultipleContractSingleData(\n    tokenAddressesNeededToFetch,\n    ERC_20_INTERFACE,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const symbols = useMultipleContractSingleData(\n    tokenAddressesNeededToFetch,\n    ERC_20_INTERFACE,\n    'symbol',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  const tokenDecimals = useMultipleContractSingleData(\n    tokenAddressesNeededToFetch,\n    ERC_20_INTERFACE,\n    'decimals',\n    undefined,\n    NEVER_RELOAD\n  )\n\n  // Construct the full token data\n  const tokensNeededToFetch: readonly Token[] | null = useMemo(() => {\n    if (!tokenAddressesNeededToFetch.length || !names.length || !symbols.length || !tokenDecimals.length) return null\n    if (names[0].loading || tokenDecimals[0].loading || symbols[0].loading) return null\n    if (!names[0].result || !tokenDecimals[0].result || !symbols[0].result) return null\n\n    return tokenAddressesNeededToFetch.reduce((memo: Token[], address, index) => {\n      const decimals = tokenDecimals[index].result?.[0]\n      const name = names[index].result?.[0] === 'Celo Gold' ? 'Celo' : names[index].result?.[0]\n      const symbol = symbols[index].result?.[0] === 'cGLD' ? 'CELO' : symbols[index].result?.[0] // todo - remove hardcoded symbol swap for CELO\n\n      // Sometimes, decimals/name/symbol can be undefined, causing an error. TODO: Look into a root cause\n      if (chainId && address && decimals && symbol && name) {\n        const token = new Token(chainId, address, decimals, symbol, name)\n        return [...memo, token]\n      }\n      return memo\n    }, [])\n  }, [chainId, tokenAddressesNeededToFetch, names, symbols, tokenDecimals])\n\n  const pairsData: readonly (readonly [Token, Token] | undefined)[] = useMemo(() => {\n    const tokens = tokensNeededToFetch ?? []\n    return tokens0.reduce((pairs: readonly (readonly [Token, Token] | undefined)[], token0Address, index) => {\n      if (!token0Address) {\n        return [...pairs, undefined]\n      }\n      const token1Address = tokens1[index]\n      if (!token1Address) {\n        return [...pairs, undefined]\n      }\n      const token0 = tokensDb[token0Address] ?? tokens.find((t) => t.address === token0Address)\n      const token1 = tokensDb[token1Address] ?? tokens.find((t) => t.address === token1Address)\n      if (!token0 || !token1) {\n        return [...pairs, undefined]\n      }\n      return [...pairs, [token0, token1]]\n    }, [])\n  }, [tokensNeededToFetch, tokens0, tokens1, tokensDb])\n\n  return pairsData\n}\n\nexport function useTotalUbeEarned(): TokenAmount | undefined {\n  const { network } = useCelo()\n  const { chainId } = network\n  const ube = chainId ? UBE[chainId as unknown as UbeswapChainId] : undefined\n  const stakingInfos = useStakingInfo()\n\n  return useMemo(() => {\n    if (!ube) return undefined\n    return (\n      stakingInfos\n        ?.filter((stakingInfo) => stakingInfo.rewardTokens.includes(ube))\n        .reduce(\n          (accumulator, stakingInfo) =>\n            accumulator.add(\n              stakingInfo.earnedAmounts?.find((earnedAmount) => earnedAmount.token == ube) ?? new TokenAmount(ube, '0')\n            ),\n          new TokenAmount(ube, '0')\n        ) ?? new TokenAmount(ube, '0')\n    )\n  }, [stakingInfos, ube])\n}\n\nexport function useFilteredStakingInfo(stakingAddresses: string[]): readonly StakingInfo[] | undefined {\n  const { network } = useCelo()\n  const { chainId } = network\n  const ube = chainId ? UBE[chainId as unknown as UbeswapChainId] : undefined\n  const stakingInfos = useStakingInfo()\n  return useMemo(() => {\n    if (!ube) return\n    return stakingInfos.filter(\n      (stakingInfo) => stakingInfo.stakingToken.address && stakingAddresses.includes(stakingInfo.stakingToken.address)\n    )\n  }, [stakingInfos, ube, stakingAddresses])\n}\n\nexport function useFarmRewardsInfo(stakingAddresses: string[]): readonly StakingInfo[] | undefined {\n  const { network } = useCelo()\n  const { chainId } = network\n  const ube = chainId ? UBE[chainId as unknown as UbeswapChainId] : undefined\n  const stakingInfos = useStakingInfo()\n  return useMemo(() => {\n    if (!ube) return\n    return stakingInfos.filter(\n      (stakingInfo) => stakingInfo.stakingToken.address && stakingAddresses.includes(stakingInfo.stakingToken.address)\n    )\n  }, [stakingInfos, ube, stakingAddresses])\n}\n\n// based on typed value\nexport function useDerivedStakeInfo(\n  typedValue: string,\n  stakingToken: Token | null | undefined,\n  userLiquidityUnstaked: TokenAmount | undefined\n): {\n  parsedAmount?: TokenAmount\n  error?: string\n} {\n  const { address } = useCelo()\n\n  const parsedInput: TokenAmount | undefined = tryParseAmount(typedValue, stakingToken ?? undefined)\n\n  const parsedAmount =\n    parsedInput && userLiquidityUnstaked && JSBI.lessThanOrEqual(parsedInput.raw, userLiquidityUnstaked.raw)\n      ? parsedInput\n      : undefined\n\n  let error: string | undefined\n  if (!address) {\n    error = 'Connect Wallet'\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount'\n  }\n\n  return {\n    parsedAmount,\n    error,\n  }\n}\n\n// based on typed value\nexport function useDerivedUnstakeInfo(\n  typedValue: string,\n  stakingAmount: TokenAmount\n): {\n  parsedAmount?: TokenAmount\n  error?: string\n} {\n  const { address } = useCelo()\n\n  const parsedInput: TokenAmount | undefined = tryParseAmount(typedValue, stakingAmount.token)\n\n  const parsedAmount = parsedInput && JSBI.lessThanOrEqual(parsedInput.raw, stakingAmount.raw) ? parsedInput : undefined\n\n  let error: string | undefined\n  if (!address) {\n    error = 'Connect Wallet'\n  }\n  if (!parsedAmount) {\n    error = error ?? 'Enter an amount'\n  }\n\n  return {\n    parsedAmount,\n    error,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}