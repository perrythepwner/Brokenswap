{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = require(\"superstruct\");\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns True or false, depending on the result.\n */\nfunction isErrorWithMessage(error) {\n  return typeof error === 'object' && error !== null && 'message' in error;\n}\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n  var _a, _b;\n  /* istanbul ignore next */\n  return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');\n}\n/**\n * Get the error message from an unknown error object. If the error object has\n * a `message` property, that property is returned. Otherwise, the stringified\n * error object is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The error message.\n */\nfunction getErrorMessage(error) {\n  const message = isErrorWithMessage(error) ? error.message : String(error);\n  // If the error ends with a period, remove it, as we'll add our own period.\n  if (message.endsWith('.')) {\n    return message.slice(0, -1);\n  }\n  return message;\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message\n    });\n  }\n  return ErrorWrapper({\n    message\n  });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n  constructor(options) {\n    super(options.message);\n    this.code = 'ERR_ASSERTION';\n  }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Assertion failed.';\n  let ErrorWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AssertionError;\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    throw getError(ErrorWrapper, message);\n  }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct) {\n  let errorPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Assertion failed';\n  let ErrorWrapper = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : AssertionError;\n  try {\n    (0, superstruct_1.assert)(value, struct);\n  } catch (error) {\n    throw getError(ErrorWrapper, \"\".concat(errorPrefix, \": \").concat(getErrorMessage(error), \".\"));\n  }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n  throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\nexports.assertExhaustive = assertExhaustive;","map":{"version":3,"sources":["../src/assert.ts"],"names":[],"mappings":"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","sourcesContent":["import { assert as assertSuperstruct, Struct } from 'superstruct';\n\nexport type AssertionErrorConstructor =\n  | (new (args: { message: string }) => Error)\n  | ((args: { message: string }) => Error);\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns True or false, depending on the result.\n */\nfunction isErrorWithMessage(error: unknown): error is { message: string } {\n  return typeof error === 'object' && error !== null && 'message' in error;\n}\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(\n  fn: AssertionErrorConstructor,\n): fn is new (args: { message: string }) => Error {\n  /* istanbul ignore next */\n  return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n\n/**\n * Get the error message from an unknown error object. If the error object has\n * a `message` property, that property is returned. Otherwise, the stringified\n * error object is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The error message.\n */\nfunction getErrorMessage(error: unknown): string {\n  const message = isErrorWithMessage(error) ? error.message : String(error);\n\n  // If the error ends with a period, remove it, as we'll add our own period.\n  if (message.endsWith('.')) {\n    return message.slice(0, -1);\n  }\n\n  return message;\n}\n\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper: AssertionErrorConstructor, message: string) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message,\n    });\n  }\n  return ErrorWrapper({\n    message,\n  });\n}\n\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n  readonly code = 'ERR_ASSERTION';\n\n  constructor(options: { message: string }) {\n    super(options.message);\n  }\n}\n\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(\n  value: any,\n  message: string | Error = 'Assertion failed.',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n\n    throw getError(ErrorWrapper, message);\n  }\n}\n\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  errorPrefix = 'Assertion failed',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value is T {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);\n  }\n}\n\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object: never): never {\n  throw new Error(\n    'Invalid branch reached. Should be detected during compilation.',\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}