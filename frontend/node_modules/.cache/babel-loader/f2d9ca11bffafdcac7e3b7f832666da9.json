{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;\nconst subtree_1 = require(\"./subtree\");\nconst node_1 = require(\"./node\");\nfunction packedRootsBytesToNode(depth, dataView, start, end) {\n  const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);\n  return subtree_1.subtreeFillToContents(leafNodes, depth);\n}\nexports.packedRootsBytesToNode = packedRootsBytesToNode;\n/**\n * Optimized deserialization of linear bytes to consecutive leaf nodes\n */\nfunction packedRootsBytesToLeafNodes(dataView, start, end) {\n  const size = end - start;\n  // If the offset in data is not a multiple of 4, Uint32Array can't be used\n  // > start offset of Uint32Array should be a multiple of 4\n  // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n  const fullNodeCount = Math.floor(size / 32);\n  const leafNodes = new Array(Math.ceil(size / 32));\n  // Efficiently construct the tree writing to hashObjects directly\n  // TODO: Optimize, with this approach each h property is written twice\n  for (let i = 0; i < fullNodeCount; i++) {\n    const offset = start + i * 32;\n    leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));\n  }\n  // Consider that the last node may only include partial data\n  const remainderBytes = size % 32;\n  // Last node\n  if (remainderBytes > 0) {\n    const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n    leafNodes[fullNodeCount] = node;\n    // Loop to dynamically copy the full h values\n    const fullHCount = Math.floor(remainderBytes / 4);\n    for (let h = 0; h < fullHCount; h++) {\n      node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));\n    }\n    const remainderUint32 = size % 4;\n    if (remainderUint32 > 0) {\n      let h = 0;\n      for (let i = 0; i < remainderUint32; i++) {\n        h |= dataView.getUint8(start + size - remainderUint32 + i) << i * 8;\n      }\n      node_1.setNodeH(node, fullHCount, h);\n    }\n  }\n  return leafNodes;\n}\nexports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;\n/**\n * Optimized serialization of consecutive leave nodes to linear bytes\n */\nfunction packedNodeRootsToBytes(dataView, start, size, nodes) {\n  // If the offset in data is not a multiple of 4, Uint32Array can't be used\n  // > start offset of Uint32Array should be a multiple of 4\n  // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n  // Consider that the last node may only include partial data\n  const remainderBytes = size % 32;\n  // Full nodes\n  // Efficiently get hashObjects data into data\n  const fullNodeCount = Math.floor(size / 32);\n  for (let i = 0; i < fullNodeCount; i++) {\n    const node = nodes[i];\n    const offset = start + i * 32;\n    dataView.setInt32(offset + 0, node.h0, true);\n    dataView.setInt32(offset + 4, node.h1, true);\n    dataView.setInt32(offset + 8, node.h2, true);\n    dataView.setInt32(offset + 12, node.h3, true);\n    dataView.setInt32(offset + 16, node.h4, true);\n    dataView.setInt32(offset + 20, node.h5, true);\n    dataView.setInt32(offset + 24, node.h6, true);\n    dataView.setInt32(offset + 28, node.h7, true);\n  }\n  // Last node\n  if (remainderBytes > 0) {\n    const node = nodes[fullNodeCount];\n    // Loop to dynamically copy the full h values\n    const fullHCount = Math.floor(remainderBytes / 4);\n    for (let h = 0; h < fullHCount; h++) {\n      dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);\n    }\n    const remainderUint32 = size % 4;\n    if (remainderUint32 > 0) {\n      const h = node_1.getNodeH(node, fullHCount);\n      for (let i = 0; i < remainderUint32; i++) {\n        dataView.setUint8(start + size - remainderUint32 + i, h >> i * 8 & 0xff);\n      }\n    }\n  }\n}\nexports.packedNodeRootsToBytes = packedNodeRootsToBytes;","map":{"version":3,"names":["Object","defineProperty","exports","value","packedNodeRootsToBytes","packedRootsBytesToLeafNodes","packedRootsBytesToNode","subtree_1","require","node_1","depth","dataView","start","end","leafNodes","subtreeFillToContents","size","fullNodeCount","Math","floor","Array","ceil","i","offset","LeafNode","getInt32","remainderBytes","node","fullHCount","h","setNodeH","remainderUint32","getUint8","nodes","setInt32","h0","h1","h2","h3","h4","h5","h6","h7","getNodeH","setUint8"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/packedNode.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;\nconst subtree_1 = require(\"./subtree\");\nconst node_1 = require(\"./node\");\nfunction packedRootsBytesToNode(depth, dataView, start, end) {\n    const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);\n    return subtree_1.subtreeFillToContents(leafNodes, depth);\n}\nexports.packedRootsBytesToNode = packedRootsBytesToNode;\n/**\n * Optimized deserialization of linear bytes to consecutive leaf nodes\n */\nfunction packedRootsBytesToLeafNodes(dataView, start, end) {\n    const size = end - start;\n    // If the offset in data is not a multiple of 4, Uint32Array can't be used\n    // > start offset of Uint32Array should be a multiple of 4\n    // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n    const fullNodeCount = Math.floor(size / 32);\n    const leafNodes = new Array(Math.ceil(size / 32));\n    // Efficiently construct the tree writing to hashObjects directly\n    // TODO: Optimize, with this approach each h property is written twice\n    for (let i = 0; i < fullNodeCount; i++) {\n        const offset = start + i * 32;\n        leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));\n    }\n    // Consider that the last node may only include partial data\n    const remainderBytes = size % 32;\n    // Last node\n    if (remainderBytes > 0) {\n        const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n        leafNodes[fullNodeCount] = node;\n        // Loop to dynamically copy the full h values\n        const fullHCount = Math.floor(remainderBytes / 4);\n        for (let h = 0; h < fullHCount; h++) {\n            node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));\n        }\n        const remainderUint32 = size % 4;\n        if (remainderUint32 > 0) {\n            let h = 0;\n            for (let i = 0; i < remainderUint32; i++) {\n                h |= dataView.getUint8(start + size - remainderUint32 + i) << (i * 8);\n            }\n            node_1.setNodeH(node, fullHCount, h);\n        }\n    }\n    return leafNodes;\n}\nexports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;\n/**\n * Optimized serialization of consecutive leave nodes to linear bytes\n */\nfunction packedNodeRootsToBytes(dataView, start, size, nodes) {\n    // If the offset in data is not a multiple of 4, Uint32Array can't be used\n    // > start offset of Uint32Array should be a multiple of 4\n    // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n    // Consider that the last node may only include partial data\n    const remainderBytes = size % 32;\n    // Full nodes\n    // Efficiently get hashObjects data into data\n    const fullNodeCount = Math.floor(size / 32);\n    for (let i = 0; i < fullNodeCount; i++) {\n        const node = nodes[i];\n        const offset = start + i * 32;\n        dataView.setInt32(offset + 0, node.h0, true);\n        dataView.setInt32(offset + 4, node.h1, true);\n        dataView.setInt32(offset + 8, node.h2, true);\n        dataView.setInt32(offset + 12, node.h3, true);\n        dataView.setInt32(offset + 16, node.h4, true);\n        dataView.setInt32(offset + 20, node.h5, true);\n        dataView.setInt32(offset + 24, node.h6, true);\n        dataView.setInt32(offset + 28, node.h7, true);\n    }\n    // Last node\n    if (remainderBytes > 0) {\n        const node = nodes[fullNodeCount];\n        // Loop to dynamically copy the full h values\n        const fullHCount = Math.floor(remainderBytes / 4);\n        for (let h = 0; h < fullHCount; h++) {\n            dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);\n        }\n        const remainderUint32 = size % 4;\n        if (remainderUint32 > 0) {\n            const h = node_1.getNodeH(node, fullHCount);\n            for (let i = 0; i < remainderUint32; i++) {\n                dataView.setUint8(start + size - remainderUint32 + i, (h >> (i * 8)) & 0xff);\n            }\n        }\n    }\n}\nexports.packedNodeRootsToBytes = packedNodeRootsToBytes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}