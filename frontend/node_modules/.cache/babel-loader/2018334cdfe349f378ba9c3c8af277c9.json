{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { useCelo } from '@celo/react-celo';\nimport { CELO, currencyEquals, cUSD, JSBI, Pair, Price } from '@ubeswap/sdk';\nimport { useTotalSupply } from 'data/TotalSupply';\nimport { useToken } from 'hooks/Tokens';\nimport { usePairContract } from 'hooks/useContract';\nimport { useMemo } from 'react';\nimport { useSingleCallResult } from 'state/multicall/hooks';\nimport { MCUSD } from '../constants/index';\nimport { usePair, usePairs } from '../data/Reserves';\n/**\n * Returns the price in cUSD of the input currency\n * @param currency currency to compute the cUSD price of\n */\nexport function useCUSDPrices(tokens) {\n  _s();\n  const {\n    network: {\n      chainId\n    }\n  } = useCelo();\n  const CUSD = cUSD[chainId];\n  const celo = CELO[chainId];\n  const tokenPairs = useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.map(token => [[token && currencyEquals(token, CUSD) ? undefined : token, CUSD], [token && currencyEquals(token, celo) ? undefined : token, celo], [celo, CUSD]]).flat(), [CUSD, celo, tokens]);\n  const thesePairs = usePairs(tokenPairs);\n  return useMemo(() => {\n    if (!tokens || !chainId) {\n      return undefined;\n    }\n    const pairs = thesePairs.map(x => x[1]);\n    return tokens.map((token, idx) => {\n      const start = idx * 3;\n      const [cUSDPair, celoPair, celoCUSDPair] = [pairs[start], pairs[start + 1], pairs[start + 2]];\n\n      // handle cUSD\n      if (token.equals(CUSD)) {\n        return new Price(CUSD, CUSD, '1', '1');\n      }\n      if (cUSDPair) {\n        return cUSDPair.priceOf(token);\n      }\n      if (celoPair && celoCUSDPair) {\n        return celoPair.priceOf(token).multiply(celoCUSDPair.priceOf(celo));\n      }\n      return undefined;\n    });\n  }, [chainId, tokens, CUSD, celo, thesePairs]);\n}\n\n/**\n * Returns the price in cUSD of the input currency\n * @param token the token to get the cUSD price of\n */\n_s(useCUSDPrices, \"9xn365YKSpEFvxqKAzlqyNmM0Cg=\", false, function () {\n  return [useCelo, usePairs];\n});\nexport function useCUSDPrice(token) {\n  _s2();\n  const {\n    network: {\n      chainId\n    }\n  } = useCelo();\n  const CUSD = cUSD[chainId];\n  const celo = CELO[chainId];\n  const mcUSD = MCUSD[chainId];\n  const tokenPairs = useMemo(() => [[token && currencyEquals(token, CUSD) ? undefined : token, CUSD], [token && currencyEquals(token, celo) ? undefined : token, celo], [token && mcUSD && currencyEquals(token, mcUSD) ? undefined : token, mcUSD ? mcUSD : undefined], [celo, CUSD]], [CUSD, celo, mcUSD, token]);\n  const [[, cUSDPair], [, celoPair], [, mcUSDPair], [, celoCUSDPair]] = usePairs(tokenPairs);\n  const cusdPairAddr = token ? currencyEquals(token, CUSD) ? undefined : Pair.getAddress(token, CUSD) : undefined;\n  const cusdPairTotalSupply = useTotalSupply(useToken(cusdPairAddr) || undefined);\n  const mcusdPairAddr = token && mcUSD && token.address !== mcUSD.address ? Pair.getAddress(token, mcUSD) : undefined;\n  const mcusdPairTotalSupply = useTotalSupply(useToken(mcusdPairAddr) || undefined);\n  return useMemo(() => {\n    if (!token || !chainId) {\n      return undefined;\n    }\n\n    // handle cUSD\n    if (token.equals(CUSD)) {\n      return new Price(CUSD, CUSD, '1', '1');\n    }\n    if (mcUSDPair && cUSDPair && cusdPairTotalSupply && mcusdPairTotalSupply) {\n      try {\n        if (JSBI.greaterThan(mcUSDPair.getLiquidityMinted(mcusdPairTotalSupply, mcUSDPair.reserve0, mcUSDPair.reserve1).raw, cUSDPair.getLiquidityMinted(cusdPairTotalSupply, cUSDPair.reserve0, cUSDPair.reserve1).raw)) {\n          return mcUSDPair.priceOf(token);\n        }\n      } catch (e) {\n        if (e.message != 'Invariant failed: LIQUIDITY') {\n          console.log(e);\n        }\n      }\n    }\n    if (cUSDPair) {\n      return cUSDPair.priceOf(token);\n    }\n    if (celoPair && celoCUSDPair) {\n      return celoPair.priceOf(token).multiply(celoCUSDPair.priceOf(celo));\n    }\n    return undefined;\n  }, [chainId, token, CUSD, cUSDPair, celo, celoCUSDPair, celoPair, mcUSDPair, cusdPairTotalSupply, mcusdPairTotalSupply]);\n}\n\n/**\n * Returns the price in cUSD of the input currency\n * @param currency currency to compute the cUSD price of\n */\n_s2(useCUSDPrice, \"avewy23yQeycla8JozvHtxZm/nE=\", false, function () {\n  return [useCelo, usePairs, useTotalSupply, useToken, useTotalSupply, useToken];\n});\nexport const useCUSDPriceOfULP = stakingToken => {\n  _s3();\n  var _useSingleCallResult, _useSingleCallResult$, _useSingleCallResult2, _useSingleCallResult3;\n  const {\n    network: {\n      chainId\n    }\n  } = useCelo();\n  const pair = usePairContract(stakingToken ? stakingToken.address : '');\n  const token0Address = (_useSingleCallResult = useSingleCallResult(pair, 'token0', [])) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n  const token1Address = (_useSingleCallResult2 = useSingleCallResult(pair, 'token1', [])) === null || _useSingleCallResult2 === void 0 ? void 0 : (_useSingleCallResult3 = _useSingleCallResult2.result) === null || _useSingleCallResult3 === void 0 ? void 0 : _useSingleCallResult3[0];\n  const totalSupplyOfStakingToken = useTotalSupply(stakingToken);\n  const token0 = useToken(token0Address) || undefined;\n  const token1 = useToken(token1Address) || undefined;\n  const [, stakingTokenPair] = usePair(token0, token1);\n  const cusdPrice0 = useCUSDPrice(stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.token0);\n  const cusdPrice1 = useCUSDPrice(stakingTokenPair === null || stakingTokenPair === void 0 ? void 0 : stakingTokenPair.token1);\n  const CUSD = cUSD[chainId];\n  return useMemo(() => {\n    if (!stakingToken || !chainId) {\n      return undefined;\n    }\n\n    // handle cUSD\n    if (stakingToken.equals(CUSD)) {\n      return new Price(CUSD, CUSD, '1', '1');\n    }\n    if (stakingToken && totalSupplyOfStakingToken && !totalSupplyOfStakingToken.equalTo('0') && cusdPrice0 && cusdPrice1 && stakingTokenPair && stakingTokenPair !== null && stakingTokenPair !== void 0 && stakingTokenPair.reserve0 && stakingTokenPair !== null && stakingTokenPair !== void 0 && stakingTokenPair.reserve1) {\n      const amount0 = cusdPrice0.quote(stakingTokenPair.reserve0);\n      const amount1 = cusdPrice1.quote(stakingTokenPair.reserve1);\n      const token1CUSDPrice = amount0.divide(totalSupplyOfStakingToken);\n      const token2CUSDPrice = amount1.divide(totalSupplyOfStakingToken);\n      const amount = token1CUSDPrice.add(token2CUSDPrice);\n      return new Price(stakingToken, CUSD, amount.denominator, amount.numerator);\n    }\n    return undefined;\n  }, [stakingToken, chainId, CUSD, totalSupplyOfStakingToken, cusdPrice0, cusdPrice1, stakingTokenPair]);\n};\n_s3(useCUSDPriceOfULP, \"sGpWADcCxWI/RiD4cyPBJ7w7hAs=\", false, function () {\n  return [useCelo, usePairContract, useSingleCallResult, useSingleCallResult, useTotalSupply, useToken, useToken, usePair, useCUSDPrice, useCUSDPrice];\n});","map":{"version":3,"names":["useCelo","CELO","currencyEquals","cUSD","JSBI","Pair","Price","useTotalSupply","useToken","usePairContract","useMemo","useSingleCallResult","MCUSD","usePair","usePairs","useCUSDPrices","tokens","_s","network","chainId","CUSD","celo","tokenPairs","map","token","undefined","flat","thesePairs","pairs","x","idx","start","cUSDPair","celoPair","celoCUSDPair","equals","priceOf","multiply","useCUSDPrice","_s2","mcUSD","mcUSDPair","cusdPairAddr","getAddress","cusdPairTotalSupply","mcusdPairAddr","address","mcusdPairTotalSupply","greaterThan","getLiquidityMinted","reserve0","reserve1","raw","e","message","console","log","useCUSDPriceOfULP","stakingToken","_s3","_useSingleCallResult","_useSingleCallResult$","_useSingleCallResult2","_useSingleCallResult3","pair","token0Address","result","token1Address","totalSupplyOfStakingToken","token0","token1","stakingTokenPair","cusdPrice0","cusdPrice1","equalTo","amount0","quote","amount1","token1CUSDPrice","divide","token2CUSDPrice","amount","add","denominator","numerator"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/utils/useCUSDPrice.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { CELO, ChainId as UbeswapChainId, currencyEquals, cUSD, JSBI, Pair, Price, Token } from '@ubeswap/sdk'\nimport { useTotalSupply } from 'data/TotalSupply'\nimport { useToken } from 'hooks/Tokens'\nimport { usePairContract } from 'hooks/useContract'\nimport { useMemo } from 'react'\nimport { useSingleCallResult } from 'state/multicall/hooks'\n\nimport { MCUSD } from '../constants/index'\nimport { usePair, usePairs } from '../data/Reserves'\n\ntype TokenPair = [Token | undefined, Token | undefined]\n\n/**\n * Returns the price in cUSD of the input currency\n * @param currency currency to compute the cUSD price of\n */\nexport function useCUSDPrices(tokens?: Token[]): (Price | undefined)[] | undefined {\n  const {\n    network: { chainId },\n  } = useCelo()\n  const CUSD = cUSD[chainId as unknown as UbeswapChainId]\n  const celo = CELO[chainId as unknown as UbeswapChainId]\n  const tokenPairs: TokenPair[] = useMemo(\n    () =>\n      tokens\n        ?.map((token) => [\n          [token && currencyEquals(token, CUSD) ? undefined : token, CUSD],\n          [token && currencyEquals(token, celo) ? undefined : token, celo],\n          [celo, CUSD],\n        ])\n        .flat() as TokenPair[],\n    [CUSD, celo, tokens]\n  )\n  const thesePairs = usePairs(tokenPairs)\n\n  return useMemo(() => {\n    if (!tokens || !chainId) {\n      return undefined\n    }\n    const pairs = thesePairs.map((x) => x[1])\n\n    return tokens.map((token, idx) => {\n      const start = idx * 3\n      const [cUSDPair, celoPair, celoCUSDPair] = [pairs[start], pairs[start + 1], pairs[start + 2]]\n\n      // handle cUSD\n      if (token.equals(CUSD)) {\n        return new Price(CUSD, CUSD, '1', '1')\n      }\n\n      if (cUSDPair) {\n        return cUSDPair.priceOf(token)\n      }\n\n      if (celoPair && celoCUSDPair) {\n        return celoPair.priceOf(token).multiply(celoCUSDPair.priceOf(celo))\n      }\n\n      return undefined\n    })\n  }, [chainId, tokens, CUSD, celo, thesePairs])\n}\n\n/**\n * Returns the price in cUSD of the input currency\n * @param token the token to get the cUSD price of\n */\nexport function useCUSDPrice(token?: Token): Price | undefined {\n  const {\n    network: { chainId },\n  } = useCelo()\n  const CUSD = cUSD[chainId as unknown as UbeswapChainId]\n  const celo = CELO[chainId as unknown as UbeswapChainId]\n  const mcUSD = MCUSD[chainId as unknown as UbeswapChainId]\n  const tokenPairs: [Token | undefined, Token | undefined][] = useMemo(\n    () => [\n      [token && currencyEquals(token, CUSD) ? undefined : token, CUSD],\n      [token && currencyEquals(token, celo) ? undefined : token, celo],\n      [token && mcUSD && currencyEquals(token, mcUSD) ? undefined : token, mcUSD ? mcUSD : undefined],\n      [celo, CUSD],\n    ],\n    [CUSD, celo, mcUSD, token]\n  )\n  const [[, cUSDPair], [, celoPair], [, mcUSDPair], [, celoCUSDPair]] = usePairs(tokenPairs)\n  const cusdPairAddr = token ? (currencyEquals(token, CUSD) ? undefined : Pair.getAddress(token, CUSD)) : undefined\n  const cusdPairTotalSupply = useTotalSupply(useToken(cusdPairAddr) || undefined)\n  const mcusdPairAddr = token && mcUSD && token.address !== mcUSD.address ? Pair.getAddress(token, mcUSD) : undefined\n  const mcusdPairTotalSupply = useTotalSupply(useToken(mcusdPairAddr) || undefined)\n\n  return useMemo(() => {\n    if (!token || !chainId) {\n      return undefined\n    }\n\n    // handle cUSD\n    if (token.equals(CUSD)) {\n      return new Price(CUSD, CUSD, '1', '1')\n    }\n\n    if (mcUSDPair && cUSDPair && cusdPairTotalSupply && mcusdPairTotalSupply) {\n      try {\n        if (\n          JSBI.greaterThan(\n            mcUSDPair.getLiquidityMinted(mcusdPairTotalSupply, mcUSDPair.reserve0, mcUSDPair.reserve1).raw,\n            cUSDPair.getLiquidityMinted(cusdPairTotalSupply, cUSDPair.reserve0, cUSDPair.reserve1).raw\n          )\n        ) {\n          return mcUSDPair.priceOf(token)\n        }\n      } catch (e: any) {\n        if (e.message != 'Invariant failed: LIQUIDITY') {\n          console.log(e)\n        }\n      }\n    }\n\n    if (cUSDPair) {\n      return cUSDPair.priceOf(token)\n    }\n\n    if (celoPair && celoCUSDPair) {\n      return celoPair.priceOf(token).multiply(celoCUSDPair.priceOf(celo))\n    }\n\n    return undefined\n  }, [\n    chainId,\n    token,\n    CUSD,\n    cUSDPair,\n    celo,\n    celoCUSDPair,\n    celoPair,\n    mcUSDPair,\n    cusdPairTotalSupply,\n    mcusdPairTotalSupply,\n  ])\n}\n\n/**\n * Returns the price in cUSD of the input currency\n * @param currency currency to compute the cUSD price of\n */\n\nexport const useCUSDPriceOfULP = (stakingToken: Token | undefined): Price | undefined => {\n  const {\n    network: { chainId },\n  } = useCelo()\n  const pair = usePairContract(stakingToken ? stakingToken.address : '')\n  const token0Address = useSingleCallResult(pair, 'token0', [])?.result?.[0]\n  const token1Address = useSingleCallResult(pair, 'token1', [])?.result?.[0]\n  const totalSupplyOfStakingToken = useTotalSupply(stakingToken)\n  const token0 = useToken(token0Address) || undefined\n  const token1 = useToken(token1Address) || undefined\n  const [, stakingTokenPair] = usePair(token0, token1)\n  const cusdPrice0 = useCUSDPrice(stakingTokenPair?.token0)\n  const cusdPrice1 = useCUSDPrice(stakingTokenPair?.token1)\n  const CUSD = cUSD[chainId as unknown as UbeswapChainId]\n\n  return useMemo(() => {\n    if (!stakingToken || !chainId) {\n      return undefined\n    }\n\n    // handle cUSD\n    if (stakingToken.equals(CUSD)) {\n      return new Price(CUSD, CUSD, '1', '1')\n    }\n\n    if (\n      stakingToken &&\n      totalSupplyOfStakingToken &&\n      !totalSupplyOfStakingToken.equalTo('0') &&\n      cusdPrice0 &&\n      cusdPrice1 &&\n      stakingTokenPair &&\n      stakingTokenPair?.reserve0 &&\n      stakingTokenPair?.reserve1\n    ) {\n      const amount0 = cusdPrice0.quote(stakingTokenPair.reserve0)\n      const amount1 = cusdPrice1.quote(stakingTokenPair.reserve1)\n      const token1CUSDPrice = amount0.divide(totalSupplyOfStakingToken)\n      const token2CUSDPrice = amount1.divide(totalSupplyOfStakingToken)\n      const amount = token1CUSDPrice.add(token2CUSDPrice)\n      return new Price(stakingToken, CUSD, amount.denominator, amount.numerator)\n    }\n\n    return undefined\n  }, [stakingToken, chainId, CUSD, totalSupplyOfStakingToken, cusdPrice0, cusdPrice1, stakingTokenPair])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}