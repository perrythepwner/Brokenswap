{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { browserPerformanceTimeOrigin, getGlobalObject, htmlTreeAsString, isNodeEnv, logger } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { msToSec } from '../utils';\nimport { getCLS } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP } from './web-vitals/getLCP';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\nvar global = getGlobalObject();\n/** Class tracking metrics  */\nvar MetricsInstrumentation = /** @class */function () {\n  function MetricsInstrumentation(_reportAllChanges) {\n    if (_reportAllChanges === void 0) {\n      _reportAllChanges = false;\n    }\n    this._reportAllChanges = _reportAllChanges;\n    this._measurements = {};\n    this._performanceCursor = 0;\n    if (!isNodeEnv() && global && global.performance && global.document) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n      this._trackCLS();\n      this._trackLCP();\n      this._trackFID();\n    }\n  }\n  /** Add performance related spans to a transaction */\n  MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {\n    var _this = this;\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n    IS_DEBUG_BUILD && logger.log('[Tracing] Adding & adjusting spans using Performance API');\n    var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    var responseStartTimestamp;\n    var requestStartTimestamp;\n    global.performance.getEntries().slice(this._performanceCursor).forEach(function (entry) {\n      var startTime = msToSec(entry.startTime);\n      var duration = msToSec(entry.duration);\n      if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n        return;\n      }\n      switch (entry.entryType) {\n        case 'navigation':\n          {\n            addNavigationSpans(transaction, entry, timeOrigin);\n            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n            break;\n          }\n        case 'mark':\n        case 'paint':\n        case 'measure':\n          {\n            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            // capture web vitals\n            var firstHidden = getVisibilityWatcher();\n            // Only report if the page wasn't hidden prior to the web vital.\n            var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n            if (entry.name === 'first-paint' && shouldRecord) {\n              IS_DEBUG_BUILD && logger.log('[Measurements] Adding FP');\n              _this._measurements['fp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fp'] = {\n                value: startTimestamp\n              };\n            }\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              IS_DEBUG_BUILD && logger.log('[Measurements] Adding FCP');\n              _this._measurements['fcp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fcp'] = {\n                value: startTimestamp\n              };\n            }\n            break;\n          }\n        case 'resource':\n          {\n            var resourceName = entry.name.replace(global.location.origin, '');\n            addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            break;\n          }\n        default:\n        // Ignore other entry types.\n      }\n    });\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n    this._trackNavigator(transaction);\n    // Measurements are only available for pageload transactions\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n      var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);\n      // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n      // start of the response in milliseconds\n      if (typeof responseStartTimestamp === 'number') {\n        IS_DEBUG_BUILD && logger.log('[Measurements] Adding TTFB');\n        this._measurements['ttfb'] = {\n          value: (responseStartTimestamp - transaction.startTimestamp) * 1000\n        };\n        if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n          // Capture the time spent making the request and receiving the first byte of the response.\n          // This is the time between the start of the request and the start of the response in milliseconds.\n          this._measurements['ttfb.requestTime'] = {\n            value: (responseStartTimestamp - requestStartTimestamp) * 1000\n          };\n        }\n      }\n      ['fcp', 'fp', 'lcp'].forEach(function (name) {\n        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {\n          return;\n        }\n        // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n        var oldValue = _this._measurements[name].value;\n        var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);\n        // normalizedValue should be in milliseconds\n        var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n        var delta = normalizedValue - oldValue;\n        IS_DEBUG_BUILD && logger.log(\"[Measurements] Normalized \" + name + \" from \" + oldValue + \" to \" + normalizedValue + \" (\" + delta + \")\");\n        _this._measurements[name].value = normalizedValue;\n      });\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value\n        });\n      }\n      // If FCP is not recorded we should not record the cls value\n      // according to the new definition of CLS.\n      if (!('fcp' in this._measurements)) {\n        delete this._measurements.cls;\n      }\n      transaction.setMeasurements(this._measurements);\n      tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);\n      transaction.setTag('sentry_reportAllChanges', this._reportAllChanges);\n    }\n  };\n  /**\n   * Capture the information of the user agent.\n   */\n  MetricsInstrumentation.prototype._trackNavigator = function (transaction) {\n    var navigator = global.navigator;\n    if (!navigator) {\n      return;\n    }\n    // track network connectivity\n    var connection = navigator.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = {\n          value: connection.rtt\n        };\n      }\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = {\n          value: connection.downlink\n        };\n      }\n    }\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  };\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n  MetricsInstrumentation.prototype._trackCLS = function () {\n    var _this = this;\n    // See:\n    // https://web.dev/evolving-cls/\n    // https://web.dev/cls-web-tooling/\n    getCLS(function (metric) {\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding CLS');\n      _this._measurements['cls'] = {\n        value: metric.value\n      };\n      _this._clsEntry = entry;\n    });\n  };\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  MetricsInstrumentation.prototype._trackLCP = function () {\n    var _this = this;\n    getLCP(function (metric) {\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n      var startTime = msToSec(entry.startTime);\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding LCP');\n      _this._measurements['lcp'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.lcp'] = {\n        value: timeOrigin + startTime\n      };\n      _this._lcpEntry = entry;\n    }, this._reportAllChanges);\n  };\n  /** Starts tracking the First Input Delay on the current page. */\n  MetricsInstrumentation.prototype._trackFID = function () {\n    var _this = this;\n    getFID(function (metric) {\n      var entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n      var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n      var startTime = msToSec(entry.startTime);\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding FID');\n      _this._measurements['fid'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.fid'] = {\n        value: timeOrigin + startTime\n      };\n    });\n  };\n  return MetricsInstrumentation;\n}();\nexport { MetricsInstrumentation };\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(function (event) {\n    addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);\n  });\n  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');\n  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');\n  addRequest(transaction, entry, timeOrigin);\n}\n/** Create measure related spans */\nfunction addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n  _startChild(transaction, {\n    description: entry.name,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType,\n    startTimestamp: measureStartTimestamp\n  });\n  return measureStartTimestamp;\n}\n/** Create resource-related spans */\nexport function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n  var data = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp: endTimestamp,\n    op: entry.initiatorType ? \"resource.\" + entry.initiatorType : 'resource',\n    startTimestamp: startTimestamp,\n    data: data\n  });\n}\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {\n  var end = eventEnd ? entry[eventEnd] : entry[event + \"End\"];\n  var start = entry[event + \"Start\"];\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: description !== null && description !== void 0 ? description : event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end)\n  });\n}\n/** Create request and response related spans */\nfunction addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n}\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction, _a) {\n  var startTimestamp = _a.startTimestamp,\n    ctx = __rest(_a, [\"startTimestamp\"]);\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n  return transaction.startChild(__assign({\n    startTimestamp: startTimestamp\n  }, ctx));\n}\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n/** Add LCP / CLS data to transaction to allow debugging */\nfunction tagMetricInfo(transaction, lcpEntry, clsEntry) {\n  if (lcpEntry) {\n    IS_DEBUG_BUILD && logger.log('[Measurements] Adding LCP Data');\n    // Capture Properties of the LCP element that contributes to the LCP.\n    if (lcpEntry.element) {\n      transaction.setTag('lcp.element', htmlTreeAsString(lcpEntry.element));\n    }\n    if (lcpEntry.id) {\n      transaction.setTag('lcp.id', lcpEntry.id);\n    }\n    if (lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      transaction.setTag('lcp.url', lcpEntry.url.trim().slice(0, 200));\n    }\n    transaction.setTag('lcp.size', lcpEntry.size);\n  }\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (clsEntry && clsEntry.sources) {\n    IS_DEBUG_BUILD && logger.log('[Measurements] Adding CLS Data');\n    clsEntry.sources.forEach(function (source, index) {\n      return transaction.setTag(\"cls.source.\" + (index + 1), htmlTreeAsString(source.node));\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}