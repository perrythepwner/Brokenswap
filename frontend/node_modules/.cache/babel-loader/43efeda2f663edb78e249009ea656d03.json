{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncIterator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n  redirect: true,\n  expectStatusCode: 200,\n  headers: {},\n  full: false,\n  keepAlive: true,\n  cors: false,\n  referrer: false,\n  sslAllowSelfSigned: false,\n  _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n  constructor(msg, fingerprint256) {\n    super(msg);\n    this.fingerprint256 = fingerprint256;\n  }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(\"Request Failed. Status Code: \".concat(statusCode));\n    this.statusCode = statusCode;\n  }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n  if (!type || type === 'text' || type === 'json') {\n    try {\n      let text = new TextDecoder('utf8', {\n        fatal: true\n      }).decode(b);\n      if (type === 'text') return text;\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        if (type === 'json') throw err;\n        return text;\n      }\n    } catch (err) {\n      if (type === 'text' || type === 'json') throw err;\n    }\n  }\n  return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n  let options = _objectSpread(_objectSpread({}, DEFAULT_OPT), _options);\n  const http = require('http');\n  const https = require('https');\n  const zlib = require('zlib');\n  const {\n    promisify\n  } = require('util');\n  const {\n    resolve: urlResolve\n  } = require('url');\n  const isSecure = !!/^https/.test(url);\n  let opts = {\n    method: options.method || 'GET',\n    headers: {\n      'Accept-Encoding': 'gzip, deflate, br'\n    }\n  };\n  const compactFP = s => s.replace(/:| /g, '').toLowerCase();\n  if (options.keepAlive) {\n    var _options$sslPinnedCer;\n    const agentOpt = {\n      keepAlive: true,\n      keepAliveMsecs: 30 * 1000,\n      maxFreeSockets: 1024,\n      maxCachedSessions: 1024\n    };\n    const agentKey = [isSecure, isSecure && ((_options$sslPinnedCer = options.sslPinnedCertificates) === null || _options$sslPinnedCer === void 0 ? void 0 : _options$sslPinnedCer.map(i => compactFP(i)).sort())].join();\n    opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n  }\n  if (options.type === 'json') opts.headers['Content-Type'] = 'application/json';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  opts.headers = _objectSpread(_objectSpread({}, opts.headers), options.headers);\n  if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n  const handleRes = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (res) {\n      const status = res.statusCode;\n      if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n        if (options._redirectCount == 10) throw new Error('Request failed. Too much redirects.');\n        options._redirectCount += 1;\n        return yield fetchNode(urlResolve(url, res.headers['location']), options);\n      }\n      if (options.expectStatusCode && status !== options.expectStatusCode) {\n        res.resume();\n        throw new InvalidStatusCodeError(status);\n      }\n      let buf = [];\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(res), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          {\n            buf.push(chunk);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      let bytes = Buffer.concat(buf);\n      const encoding = res.headers['content-encoding'];\n      if (encoding === 'br') bytes = yield promisify(zlib.brotliDecompress)(bytes);\n      if (encoding === 'gzip' || encoding === 'deflate') bytes = yield promisify(zlib.unzip)(bytes);\n      const body = detectType(bytes, options.type);\n      if (options.full) return {\n        headers: res.headers,\n        status,\n        body\n      };\n      return body;\n    });\n    return function handleRes(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return new Promise((resolve, reject) => {\n    var _options$sslPinnedCer2;\n    const handleError = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (err) {\n        if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n          try {\n            yield fetchNode(url, _objectSpread(_objectSpread({}, options), {}, {\n              sslAllowSelfSigned: true,\n              sslPinnedCertificates: []\n            }));\n          } catch (e) {\n            if (e && e.fingerprint256) {\n              err = new InvalidCertError(\"Self-signed SSL certificate: \".concat(e.fingerprint256), e.fingerprint256);\n            }\n          }\n        }\n        reject(err);\n      });\n      return function handleError(_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    const req = (isSecure ? https : http).request(url, opts, res => {\n      res.on('error', handleError);\n      _asyncToGenerator(function* () {\n        try {\n          resolve(yield handleRes(res));\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n    req.on('error', handleError);\n    const pinned = (_options$sslPinnedCer2 = options.sslPinnedCertificates) === null || _options$sslPinnedCer2 === void 0 ? void 0 : _options$sslPinnedCer2.map(i => compactFP(i));\n    const mfetchSecureConnect = socket => {\n      var _socket$getPeerCertif;\n      const fp256 = compactFP(((_socket$getPeerCertif = socket.getPeerCertificate()) === null || _socket$getPeerCertif === void 0 ? void 0 : _socket$getPeerCertif.fingerprint256) || '');\n      if (!fp256 && socket.isSessionReused()) return;\n      if (pinned.includes(fp256)) return;\n      req.emit('error', new InvalidCertError(\"Invalid SSL certificate: \".concat(fp256, \" Expected: \").concat(pinned), fp256));\n      return req.abort();\n    };\n    if (options.sslPinnedCertificates) {\n      req.on('socket', socket => {\n        const hasListeners = socket.listeners('secureConnect').map(i => (i.name || '').replace('bound ', '')).includes('mfetchSecureConnect');\n        if (hasListeners) return;\n        socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n      });\n    }\n    if (options.keepAlive) req.setNoDelay(true);\n    if (opts.body) req.write(opts.body);\n    req.end();\n  });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map(i => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method', 'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer', 'Transfer-Encoding', 'Upgrade', 'Via'].map(i => i.toLowerCase()));\nfunction fetchBrowser(_x3, _x4) {\n  return _fetchBrowser.apply(this, arguments);\n}\nfunction _fetchBrowser() {\n  _fetchBrowser = _asyncToGenerator(function* (url, _options) {\n    let options = _objectSpread(_objectSpread({}, DEFAULT_OPT), _options);\n    const headers = new Headers();\n    if (options.type === 'json') headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n      const auth = btoa(\"\".concat(parsed.username, \":\").concat(parsed.password));\n      headers.set('Authorization', \"Basic \".concat(auth));\n      parsed.username = '';\n      parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n      const name = k.toLowerCase();\n      if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n    }\n    let opts = {\n      headers,\n      redirect: options.redirect ? 'follow' : 'manual'\n    };\n    if (!options.referrer) opts.referrerPolicy = 'no-referrer';\n    if (options.cors) opts.mode = 'cors';\n    if (options.data) {\n      if (!options.method) opts.method = 'POST';\n      opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = yield fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(yield res.arrayBuffer()), options.type);\n    if (options.full) return {\n      headers: Object.fromEntries(res.headers.entries()),\n      status: res.status,\n      body\n    };\n    return body;\n  });\n  return _fetchBrowser.apply(this, arguments);\n}\nconst IS_NODE = !!(typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n  const fn = IS_NODE ? fetchNode : fetchBrowser;\n  return fn(url, options);\n}\nexports.default = fetchUrl;","map":{"version":3,"names":["_asyncToGenerator","require","default","_objectSpread","_asyncIterator","Object","defineProperty","exports","value","InvalidStatusCodeError","InvalidCertError","DEFAULT_OPT","freeze","redirect","expectStatusCode","headers","full","keepAlive","cors","referrer","sslAllowSelfSigned","_redirectCount","Error","constructor","msg","fingerprint256","statusCode","concat","detectType","b","type","text","TextDecoder","fatal","decode","JSON","parse","err","agents","fetchNode","url","_options","options","http","https","zlib","promisify","resolve","urlResolve","isSecure","test","opts","method","compactFP","s","replace","toLowerCase","_options$sslPinnedCer","agentOpt","keepAliveMsecs","maxFreeSockets","maxCachedSessions","agentKey","sslPinnedCertificates","map","i","sort","join","agent","Agent","data","body","stringify","rejectUnauthorized","handleRes","_ref","res","status","resume","buf","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","chunk","push","return","bytes","Buffer","encoding","brotliDecompress","unzip","_x","apply","arguments","Promise","reject","_options$sslPinnedCer2","handleError","_ref2","code","e","_x2","req","request","on","error","pinned","mfetchSecureConnect","socket","_socket$getPeerCertif","fp256","getPeerCertificate","isSessionReused","includes","emit","abort","hasListeners","listeners","name","bind","setNoDelay","write","end","SAFE_HEADERS","Set","FORBIDDEN_HEADERS","fetchBrowser","_x3","_x4","_fetchBrowser","Headers","set","parsed","URL","username","auth","btoa","password","k","has","referrerPolicy","mode","fetch","Uint8Array","arrayBuffer","fromEntries","entries","IS_NODE","process","versions","node","v8","fetchUrl","fn"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/micro-ftch/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0,\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256) {\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode) {\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === 'text' || type === 'json') {\n        try {\n            let text = new TextDecoder('utf8', { fatal: true }).decode(b);\n            if (type === 'text')\n                return text;\n            try {\n                return JSON.parse(text);\n            }\n            catch (err) {\n                if (type === 'json')\n                    throw err;\n                return text;\n            }\n        }\n        catch (err) {\n            if (type === 'text' || type === 'json')\n                throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const http = require('http');\n    const https = require('https');\n    const zlib = require('zlib');\n    const { promisify } = require('util');\n    const { resolve: urlResolve } = require('url');\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || 'GET',\n        headers: { 'Accept-Encoding': 'gzip, deflate, br' },\n    };\n    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024,\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),\n        ].join();\n        opts.agent =\n            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === 'json')\n        opts.headers['Content-Type'] = 'application/json';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = { ...opts.headers, ...options.headers };\n    if (options.sslAllowSelfSigned)\n        opts.rejectUnauthorized = false;\n    const handleRes = async (res) => {\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n            if (options._redirectCount == 10)\n                throw new Error('Request failed. Too much redirects.');\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers['location']), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)\n            buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'br')\n            bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === 'gzip' || encoding === 'deflate')\n            bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full)\n            return { headers: res.headers, status, body };\n        return body;\n    };\n    return new Promise((resolve, reject) => {\n        const handleError = async (err) => {\n            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n                try {\n                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });\n                }\n                catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res) => {\n            res.on('error', handleError);\n            (async () => {\n                try {\n                    resolve(await handleRes(res));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on('error', handleError);\n        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));\n        const mfetchSecureConnect = (socket) => {\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n            if (!fp256 && socket.isSessionReused())\n                return;\n            if (pinned.includes(fp256))\n                return;\n            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on('socket', (socket) => {\n                const hasListeners = socket\n                    .listeners('secureConnect')\n                    .map((i) => (i.name || '').replace('bound ', ''))\n                    .includes('mfetchSecureConnect');\n                if (hasListeners)\n                    return;\n                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive)\n            req.setNoDelay(true);\n        if (opts.body)\n            req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',\n    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',\n    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const headers = new Headers();\n    if (options.type === 'json')\n        headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set('Authorization', `Basic ${auth}`);\n        parsed.username = '';\n        parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))\n            headers.set(k, options.headers[k]);\n    }\n    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };\n    if (!options.referrer)\n        opts.referrerPolicy = 'no-referrer';\n    if (options.cors)\n        opts.mode = 'cors';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode)\n        throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full)\n        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };\n    return body;\n}\nconst IS_NODE = !!(typeof process == 'object' &&\n    process.versions &&\n    process.versions.node &&\n    process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports.default = fetchUrl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}