{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nconst search = /[#.]/g;\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name.\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector.\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || '';\n  /** @type {Properties} */\n  const props = {};\n  let start = 0;\n  /** @type {string | undefined} */\n  let previous;\n  /** @type {string | undefined} */\n  let tagName;\n  while (start < value.length) {\n    search.lastIndex = start;\n    const match = search.exec(value);\n    const subvalue = value.slice(start, match ? match.index : value.length);\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n      start += subvalue.length;\n    }\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n  return {\n    type: 'element',\n    // @ts-expect-error: fine.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  };\n}","map":null,"metadata":{},"sourceType":"module"}