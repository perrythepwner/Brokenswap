{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.digest64HashObjects = exports.digest2Bytes32 = exports.digest64 = exports.digest = exports.SHA256 = exports.hashObjectToByteArray = exports.byteArrayToHashObject = void 0;\nconst wasm_1 = require(\"./wasm\");\nconst hashObject_1 = require(\"./hashObject\");\nObject.defineProperty(exports, \"byteArrayToHashObject\", {\n  enumerable: true,\n  get: function get() {\n    return hashObject_1.byteArrayToHashObject;\n  }\n});\nObject.defineProperty(exports, \"hashObjectToByteArray\", {\n  enumerable: true,\n  get: function get() {\n    return hashObject_1.hashObjectToByteArray;\n  }\n});\nconst sha256_1 = __importDefault(require(\"./sha256\"));\nexports.SHA256 = sha256_1.default;\nconst ctx = wasm_1.newInstance();\nconst wasmInputValue = ctx.input.value;\nconst wasmOutputValue = ctx.output.value;\nconst inputUint8Array = new Uint8Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nconst outputUint8Array = new Uint8Array(ctx.memory.buffer, wasmOutputValue, 32);\nconst inputUint32Array = new Uint32Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nfunction digest(data) {\n  if (data.length === 64) {\n    return digest64(data);\n  }\n  if (data.length <= ctx.INPUT_LENGTH) {\n    inputUint8Array.set(data);\n    ctx.digest(data.length);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n  ctx.init();\n  update(data);\n  return final();\n}\nexports.digest = digest;\nfunction digest64(data) {\n  if (data.length === 64) {\n    inputUint8Array.set(data);\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n  throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest64 = digest64;\nfunction digest2Bytes32(bytes1, bytes2) {\n  if (bytes1.length === 32 && bytes2.length === 32) {\n    inputUint8Array.set(bytes1);\n    inputUint8Array.set(bytes2, 32);\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n  throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest2Bytes32 = digest2Bytes32;\n/**\n * Digest 2 objects, each has 8 properties from h0 to h7.\n * The performance is a little bit better than digest64 due to the use of Uint32Array\n * and the memory is a little bit better than digest64 due to no temporary Uint8Array.\n * @returns\n */\nfunction digest64HashObjects(obj1, obj2) {\n  // TODO: expect obj1 and obj2 as HashObject\n  inputUint32Array[0] = obj1.h0;\n  inputUint32Array[1] = obj1.h1;\n  inputUint32Array[2] = obj1.h2;\n  inputUint32Array[3] = obj1.h3;\n  inputUint32Array[4] = obj1.h4;\n  inputUint32Array[5] = obj1.h5;\n  inputUint32Array[6] = obj1.h6;\n  inputUint32Array[7] = obj1.h7;\n  inputUint32Array[8] = obj2.h0;\n  inputUint32Array[9] = obj2.h1;\n  inputUint32Array[10] = obj2.h2;\n  inputUint32Array[11] = obj2.h3;\n  inputUint32Array[12] = obj2.h4;\n  inputUint32Array[13] = obj2.h5;\n  inputUint32Array[14] = obj2.h6;\n  inputUint32Array[15] = obj2.h7;\n  ctx.digest64(wasmInputValue, wasmOutputValue);\n  // extracting numbers from Uint32Array causes more memory\n  return hashObject_1.byteArrayToHashObject(outputUint8Array);\n}\nexports.digest64HashObjects = digest64HashObjects;\nfunction update(data) {\n  const INPUT_LENGTH = ctx.INPUT_LENGTH;\n  if (data.length > INPUT_LENGTH) {\n    for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n      const sliced = data.slice(i, i + INPUT_LENGTH);\n      inputUint8Array.set(sliced);\n      ctx.update(wasmInputValue, sliced.length);\n    }\n  } else {\n    inputUint8Array.set(data);\n    ctx.update(wasmInputValue, data.length);\n  }\n}\nfunction final() {\n  ctx.final(wasmOutputValue);\n  const output = new Uint8Array(32);\n  output.set(outputUint8Array);\n  return output;\n}","map":null,"metadata":{},"sourceType":"script"}