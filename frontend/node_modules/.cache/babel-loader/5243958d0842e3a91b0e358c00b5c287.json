{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcEngine = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nclass JsonRpcEngine extends safe_event_emitter_1.default {\n  constructor() {\n    super();\n    this._middleware = [];\n  }\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n  handle(req, cb) {\n    if (cb && typeof cb !== 'function') {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n      return this._handleBatch(req);\n    }\n    if (cb) {\n      return this._handle(req, cb);\n    }\n    return this._promiseHandle(req);\n  }\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware() {\n    var _this = this;\n    return /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next, end) {\n        try {\n          const [middlewareError, isComplete, returnHandlers] = yield JsonRpcEngine._runAllMiddleware(req, res, _this._middleware);\n          if (isComplete) {\n            yield JsonRpcEngine._runReturnHandlers(returnHandlers);\n            return end(middlewareError);\n          }\n          return next( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (handlerCallback) {\n              try {\n                yield JsonRpcEngine._runReturnHandlers(returnHandlers);\n              } catch (error) {\n                return handlerCallback(error);\n              }\n              return handlerCallback();\n            });\n            return function (_x5) {\n              return _ref2.apply(this, arguments);\n            };\n          }());\n        } catch (error) {\n          return end(error);\n        }\n      });\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  _handleBatch(reqs, cb) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // The order here is important\n      try {\n        // 2. Wait for all requests to finish, or throw on some kind of fatal\n        // error\n        const responses = yield Promise.all(\n        // 1. Begin executing each request in the order received\n        reqs.map(_this2._promiseHandle.bind(_this2)));\n        // 3. Return batch response\n        if (cb) {\n          return cb(null, responses);\n        }\n        return responses;\n      } catch (error) {\n        if (cb) {\n          return cb(error);\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * A promise-wrapped _handle.\n   */\n  _promiseHandle(req) {\n    return new Promise(resolve => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n  _handle(callerReq, cb) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== 'object') {\n        const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, \"Requests must be plain objects. Received: \".concat(typeof callerReq), {\n          request: callerReq\n        });\n        return cb(error, {\n          id: undefined,\n          jsonrpc: '2.0',\n          error\n        });\n      }\n      if (typeof callerReq.method !== 'string') {\n        const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, \"Must specify a string method. Received: \".concat(typeof callerReq.method), {\n          request: callerReq\n        });\n        return cb(error, {\n          id: callerReq.id,\n          jsonrpc: '2.0',\n          error\n        });\n      }\n      const req = Object.assign({}, callerReq);\n      const res = {\n        id: req.id,\n        jsonrpc: req.jsonrpc\n      };\n      let error = null;\n      try {\n        yield _this3._processRequest(req, res);\n      } catch (_error) {\n        // A request handler error, a re-thrown middleware error, or something\n        // unexpected.\n        error = _error;\n      }\n      if (error) {\n        // Ensure no result is present on an errored response\n        delete res.result;\n        if (!res.error) {\n          res.error = eth_rpc_errors_1.serializeError(error);\n        }\n      }\n      return cb(error, res);\n    })();\n  }\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n  _processRequest(req, res) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const [error, isComplete, returnHandlers] = yield JsonRpcEngine._runAllMiddleware(req, res, _this4._middleware);\n      // Throw if \"end\" was not called, or if the response has neither a result\n      // nor an error.\n      JsonRpcEngine._checkForCompletion(req, res, isComplete);\n      // The return handlers should run even if an error was encountered during\n      // middleware processing.\n      yield JsonRpcEngine._runReturnHandlers(returnHandlers);\n      // Now we re-throw the middleware processing error, if any, to catch it\n      // further up the call chain.\n      if (error) {\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  static _runAllMiddleware(req, res, middlewareStack) {\n    return _asyncToGenerator(function* () {\n      const returnHandlers = [];\n      let error = null;\n      let isComplete = false;\n      // Go down stack of middleware, call and collect optional returnHandlers\n      for (const middleware of middlewareStack) {\n        [error, isComplete] = yield JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);\n        if (isComplete) {\n          break;\n        }\n      }\n      return [error, isComplete, returnHandlers.reverse()];\n    })();\n  }\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n        if (error) {\n          res.error = eth_rpc_errors_1.serializeError(error);\n        }\n        // True indicates that the request should end\n        resolve([error, true]);\n      };\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== 'function') {\n              end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, \"JsonRpcEngine: \\\"next\\\" return handlers must be functions. \" + \"Received \\\"\".concat(typeof returnHandler, \"\\\" for request:\\n\").concat(jsonify(req)), {\n                request: req\n              }));\n            }\n            returnHandlers.push(returnHandler);\n          }\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n  static _runReturnHandlers(handlers) {\n    return _asyncToGenerator(function* () {\n      for (const handler of handlers) {\n        yield new Promise((resolve, reject) => {\n          handler(err => err ? reject(err) : resolve());\n        });\n      }\n    })();\n  }\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n  static _checkForCompletion(req, res, isComplete) {\n    if (!('result' in res) && !('error' in res)) {\n      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, \"JsonRpcEngine: Response has no error or result for request:\\n\".concat(jsonify(req)), {\n        request: req\n      });\n    }\n    if (!isComplete) {\n      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, \"JsonRpcEngine: Nothing ended request:\\n\".concat(jsonify(req)), {\n        request: req\n      });\n    }\n  }\n}\nexports.JsonRpcEngine = JsonRpcEngine;\nfunction jsonify(request) {\n  return JSON.stringify(request, null, 2);\n}","map":null,"metadata":{},"sourceType":"script"}