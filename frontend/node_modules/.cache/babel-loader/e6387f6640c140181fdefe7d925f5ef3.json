{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT } from \"./utils\";\nexport function generateKeyPair() {\n  let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : randomBytes(KEY_PAIR_SEED_LENGTH);\n  return ed25519.generateKeyPairFromSeed(seed);\n}\nexport function signJWT(_x, _x2, _x3, _x4) {\n  return _signJWT.apply(this, arguments);\n}\nfunction _signJWT() {\n  _signJWT = _asyncToGenerator(function* (sub, aud, ttl, keyPair) {\n    let iat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : fromMiliseconds(Date.now());\n    const header = {\n      alg: JWT_IRIDIUM_ALG,\n      typ: JWT_IRIDIUM_TYP\n    };\n    const iss = encodeIss(keyPair.publicKey);\n    const exp = iat + ttl;\n    const payload = {\n      iss,\n      sub,\n      aud,\n      iat,\n      exp\n    };\n    const data = encodeData({\n      header,\n      payload\n    });\n    const signature = ed25519.sign(keyPair.secretKey, data);\n    return encodeJWT({\n      header,\n      payload,\n      signature\n    });\n  });\n  return _signJWT.apply(this, arguments);\n}\nexport function verifyJWT(_x5) {\n  return _verifyJWT.apply(this, arguments);\n}\nfunction _verifyJWT() {\n  _verifyJWT = _asyncToGenerator(function* (jwt) {\n    const {\n      header,\n      payload,\n      data,\n      signature\n    } = decodeJWT(jwt);\n    if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {\n      throw new Error(\"JWT must use EdDSA algorithm\");\n    }\n    const publicKey = decodeIss(payload.iss);\n    return ed25519.verify(publicKey, data, signature);\n  });\n  return _verifyJWT.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/api.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,OAAO,MAAM,oBAAoB;AAC7C,SAAS,WAAW,QAAQ,mBAAmB;AAC/C,SAAS,eAAe,QAAQ,qBAAqB;AACrD,SACE,eAAe,EACf,eAAe,EACf,oBAAoB,QACf,aAAa;AAEpB,SACE,SAAS,EACT,SAAS,EACT,UAAU,EACV,SAAS,EACT,SAAS,QACJ,SAAS;AAEhB,OAAM,SAAU,eAAe,CAAA,EACuB;EAAA,IAApD,IAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAmB,WAAW,CAAC,oBAAoB,CAAC;EAEpD,OAAO,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC;AAC9C;AAEA,gBAAsB,OAAO,CAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA;EAAA,OAAA,QAAA,CAAA,KAAA,OAAA,SAAA;AAAA;AAc5B,SAAA,SAAA;EAAA,QAAA,GAAA,iBAAA,CAdM,WACL,GAAW,EACX,GAAW,EACX,GAAW,EACX,OAAwB,EACiB;IAAA,IAAzC,GAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAc,eAAe,CAAC,IAAI,CAAC,GAAG,CAAA,CAAE,CAAC;IAEzC,MAAM,MAAM,GAAG;MAAE,GAAG,EAAE,eAAe;MAAE,GAAG,EAAE;IAAe,CAAE;IAC7D,MAAM,GAAG,GAAG,SAAS,CAAC,OAAO,CAAC,SAAS,CAAC;IACxC,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG;IACrB,MAAM,OAAO,GAAG;MAAE,GAAG;MAAE,GAAG;MAAE,GAAG;MAAE,GAAG;MAAE;IAAG,CAAE;IAC3C,MAAM,IAAI,GAAG,UAAU,CAAC;MAAE,MAAM;MAAE;IAAO,CAAE,CAAC;IAC5C,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC;IACvD,OAAO,SAAS,CAAC;MAAE,MAAM;MAAE,OAAO;MAAE;IAAS,CAAE,CAAC;EAClD,CAAC;EAAA,OAAA,QAAA,CAAA,KAAA,OAAA,SAAA;AAAA;AAED,gBAAsB,SAAS,CAAA,GAAA;EAAA,OAAA,UAAA,CAAA,KAAA,OAAA,SAAA;AAAA;AAO9B,SAAA,WAAA;EAAA,UAAA,GAAA,iBAAA,CAPM,WAAyB,GAAW,EAAA;IACzC,MAAM;MAAE,MAAM;MAAE,OAAO;MAAE,IAAI;MAAE;IAAS,CAAE,GAAG,SAAS,CAAC,GAAG,CAAC;IAC3D,IAAI,MAAM,CAAC,GAAG,KAAK,eAAe,IAAI,MAAM,CAAC,GAAG,KAAK,eAAe,EAAE;MACpE,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC;IAChD;IACD,MAAM,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC;IACxC,OAAO,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC;EACnD,CAAC;EAAA,OAAA,UAAA,CAAA,KAAA,OAAA,SAAA;AAAA","sourceRoot":"","sourcesContent":["import * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH, } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT, } from \"./utils\";\nexport function generateKeyPair(seed = randomBytes(KEY_PAIR_SEED_LENGTH)) {\n    return ed25519.generateKeyPairFromSeed(seed);\n}\nexport async function signJWT(sub, aud, ttl, keyPair, iat = fromMiliseconds(Date.now())) {\n    const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };\n    const iss = encodeIss(keyPair.publicKey);\n    const exp = iat + ttl;\n    const payload = { iss, sub, aud, iat, exp };\n    const data = encodeData({ header, payload });\n    const signature = ed25519.sign(keyPair.secretKey, data);\n    return encodeJWT({ header, payload, signature });\n}\nexport async function verifyJWT(jwt) {\n    const { header, payload, data, signature } = decodeJWT(jwt);\n    if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {\n        throw new Error(\"JWT must use EdDSA algorithm\");\n    }\n    const publicKey = decodeIss(payload.iss);\n    return ed25519.verify(publicKey, data, signature);\n}\n//# sourceMappingURL=api.js.map"]},"metadata":{},"sourceType":"module"}