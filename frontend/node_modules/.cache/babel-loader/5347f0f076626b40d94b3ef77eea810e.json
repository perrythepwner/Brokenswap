{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst mini_kit_1 = require(\"@celo/contractkit/lib/mini-kit\");\nconst constants_1 = require(\"../constants\");\nconst ethereum_1 = require(\"../utils/ethereum\");\nconst logger_1 = require(\"../utils/logger\");\nconst metamask_1 = require(\"../utils/metamask\");\nconst common_1 = require(\"./common\");\nclass InjectedConnector extends common_1.AbstractConnector {\n  constructor(network, manualNetworkMode, feeCurrency) {\n    let defaultType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.WalletTypes.Injected;\n    super();\n    this.manualNetworkMode = manualNetworkMode;\n    this.feeCurrency = feeCurrency;\n    this.initialised = false;\n    this.type = constants_1.WalletTypes.Injected;\n    // wallet changes net chain\n    // emits 'chainChanged'\n    // onChainChanged called and emits WALLET_CHAIN_CHANGED if chain ids dont match\n    // networkWatcher sees that and if a suitable network can be found calls continueNetworkUpdateFromWallet()\n    // else it dies.\n    this.onChainChanged = chainIdHex => {\n      const chainId = parseInt(chainIdHex, 16);\n      // if this change was initiated by app the chainIds will already match and we can abort\n      (0, logger_1.getApplicationLogger)().log('onChainChanged', chainId);\n      if (this.network.chainId !== chainId) {\n        this.emit(common_1.ConnectorEvents.WALLET_CHAIN_CHANGED, chainId);\n      }\n    };\n    this.onAccountsChanged = accounts => {\n      if (accounts.length === 0) {\n        // wallet is locked properly close the connection.\n        this.close();\n      } else {\n        this.kit.connection.defaultAccount = accounts[0];\n        this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, accounts[0]);\n      }\n    };\n    this.type = defaultType;\n    this.kit = (0, mini_kit_1.newKit)(network.rpcUrl);\n    this.network = network;\n  }\n  initialise(lastUsedAddress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initialised) {\n        return this;\n      }\n      let defaultAccount = lastUsedAddress;\n      const injected = yield (0, ethereum_1.getInjectedEthereum)();\n      if (!injected) {\n        throw new Error('Ethereum wallet not installed');\n      }\n      const {\n        web3,\n        ethereum,\n        isMetaMask\n      } = injected;\n      this.type = isMetaMask ? constants_1.WalletTypes.MetaMask : constants_1.WalletTypes.Injected;\n      const metamask = ethereum._metamask;\n      const isUnlocked = isMetaMask && (yield metamask === null || metamask === void 0 ? void 0 : metamask.isUnlocked());\n      const isConnected = ethereum.isConnected && ethereum.isConnected();\n      if (isUnlocked || !isConnected || !defaultAccount) {\n        [defaultAccount] = yield ethereum.request({\n          method: 'eth_requestAccounts'\n        });\n      }\n      ethereum.removeListener('chainChanged', this.onChainChanged);\n      ethereum.removeListener('accountsChanged', this.onAccountsChanged);\n      if (!this.manualNetworkMode) {\n        yield (0, metamask_1.switchToNetwork)(this.network, ethereum, () => this.kit.connection.chainId());\n      }\n      ethereum.on('chainChanged', this.onChainChanged);\n      ethereum.on('accountsChanged', this.onAccountsChanged);\n      this.newKit(web3, defaultAccount);\n      const walletChainId = yield ethereum.request({\n        method: 'eth_chainId'\n      });\n      this.initialised = true;\n      this.emit(common_1.ConnectorEvents.CONNECTED, {\n        walletType: this.type,\n        address: defaultAccount,\n        networkName: this.network.name,\n        walletChainId: parseInt(walletChainId, 16)\n      });\n      return this;\n    });\n  }\n  newKit(web3, defaultAccount) {\n    this.kit = (0, mini_kit_1.newKitFromWeb3)(web3);\n    this.kit.connection.defaultAccount = defaultAccount;\n  }\n  startNetworkChangeFromApp(network) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ethereum = (0, ethereum_1.getEthereum)();\n      yield (0, metamask_1.switchToNetwork)(network, ethereum, this.kit.connection.chainId);\n      this.continueNetworkUpdateFromWallet(network);\n    });\n  }\n  //\n  continueNetworkUpdateFromWallet(network) {\n    this.network = network; // must set to prevent loop\n    const web3 = this.kit.connection.web3;\n    this.newKit(web3, this.account); // kit caches things so it need to be recreated\n    this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);\n  }\n  supportsFeeCurrency() {\n    return false;\n  }\n  removeListenersFromEth() {\n    const ethereum = (0, ethereum_1.getEthereum)();\n    if (ethereum) {\n      ethereum.removeListener('chainChanged', this.onChainChanged);\n      ethereum.removeListener('accountsChanged', this.onAccountsChanged);\n    }\n  }\n  close() {\n    this.removeListenersFromEth();\n    try {\n      this.kit.connection.stop();\n    } finally {\n      this.disconnect();\n    }\n  }\n}\nexports.default = InjectedConnector;","map":null,"metadata":{},"sourceType":"script"}