{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Type = void 0;\n/**\n * An SSZ type provides the following operations:\n * - Serialization from/to bytes to either a value or a tree\n * - Merkelization to compute the hashTreeRoot of both a value and a tree\n * - Proof creation from trees\n * - Create a View and a ViewDU instance from a tree\n * - Manipulate views\n */\nclass Type {\n  /** INTERNAL METHOD: Merkleize value to tree */\n  value_toTree(value) {\n    // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return this.tree_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n  /** INTERNAL METHOD: Un-merkleize tree to value */\n  tree_toValue(node) {\n    // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important\n    const uint8Array = new Uint8Array(this.tree_serializedSize(node));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.tree_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, node);\n    return this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n  /** Serialize a value to binary data */\n  serialize(value) {\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return uint8Array;\n  }\n  /** Deserialize binary data to value */\n  deserialize(uint8Array) {\n    // Buffer.prototype.slice does not copy memory, force use Uint8Array.prototype.slice https://github.com/nodejs/node/issues/28087\n    // - Uint8Array.prototype.slice: Copy memory, safe to mutate\n    // - Buffer.prototype.slice: Does NOT copy memory, mutation affects both views\n    // We could ensure that all Buffer instances are converted to Uint8Array before calling value_deserializeFromBytes\n    // However doing that in a browser friendly way is not easy. Downstream code uses `Uint8Array.prototype.slice.call`\n    // to ensure Buffer.prototype.slice is never used. Unit tests also test non-mutability.\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    return this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n}\nexports.Type = Type;","map":null,"metadata":{},"sourceType":"script"}