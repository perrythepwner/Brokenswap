{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar hmac_1 = require(\"@stablelib/hmac\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nvar HKDF = /** @class */function () {\n  /**\n   * Create a new HKDF instance for the given hash function\n   * with the master key, optional salt, and info.\n   *\n   * - Master key is a high-entropy secret key (not a password).\n   * - Salt is a non-secret random value.\n   * - Info is application- and/or context-specific information.\n   */\n  function HKDF(hash, key, salt, info) {\n    if (salt === void 0) {\n      salt = new Uint8Array(0);\n    }\n    this._counter = new Uint8Array(1); // starts with zero\n    this._hash = hash;\n    this._info = info;\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac_1.hmac(this._hash, salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    this._hmac = new hmac_1.HMAC(hash, okm);\n    // Allocate buffer.\n    this._buffer = new Uint8Array(this._hmac.digestLength);\n    this._bufpos = this._buffer.length;\n  }\n  // Fill buffer with new block of HKDF-Extract output.\n  HKDF.prototype._fillBuffer = function () {\n    // Increment counter.\n    this._counter[0]++;\n    var ctr = this._counter[0];\n    // Check if counter overflowed.\n    if (ctr === 0) {\n      throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    this._hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (ctr > 1) {\n      this._hmac.update(this._buffer);\n    }\n    // Hash in info if it exists.\n    if (this._info) {\n      this._hmac.update(this._info);\n    }\n    // Hash in the counter.\n    this._hmac.update(this._counter);\n    // Output result to buffer and clean HMAC instance.\n    this._hmac.finish(this._buffer);\n    // Reset buffer position.\n    this._bufpos = 0;\n  };\n  /**\n   * Expand returns next key material of the given length.\n   *\n   * It throws if expansion limit is reached (which is\n   * 254 digests of the underlying HMAC function).\n   */\n  HKDF.prototype.expand = function (length) {\n    var out = new Uint8Array(length);\n    for (var i = 0; i < out.length; i++) {\n      if (this._bufpos === this._buffer.length) {\n        this._fillBuffer();\n      }\n      out[i] = this._buffer[this._bufpos++];\n    }\n    return out;\n  };\n  HKDF.prototype.clean = function () {\n    this._hmac.clean();\n    wipe_1.wipe(this._buffer);\n    wipe_1.wipe(this._counter);\n    this._bufpos = 0;\n  };\n  return HKDF;\n}();\nexports.HKDF = HKDF;\n// TODO(dchest): maybe implement deriveKey?","map":{"version":3,"sources":["../hkdf.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hmac_1 = require(\"@stablelib/hmac\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nvar HKDF = /** @class */ (function () {\n    /**\n     * Create a new HKDF instance for the given hash function\n     * with the master key, optional salt, and info.\n     *\n     * - Master key is a high-entropy secret key (not a password).\n     * - Salt is a non-secret random value.\n     * - Info is application- and/or context-specific information.\n     */\n    function HKDF(hash, key, salt, info) {\n        if (salt === void 0) { salt = new Uint8Array(0); }\n        this._counter = new Uint8Array(1); // starts with zero\n        this._hash = hash;\n        this._info = info;\n        // HKDF-Extract uses salt as HMAC key, and key as data.\n        var okm = hmac_1.hmac(this._hash, salt, key);\n        // Initialize HMAC for expanding with extracted key.\n        this._hmac = new hmac_1.HMAC(hash, okm);\n        // Allocate buffer.\n        this._buffer = new Uint8Array(this._hmac.digestLength);\n        this._bufpos = this._buffer.length;\n    }\n    // Fill buffer with new block of HKDF-Extract output.\n    HKDF.prototype._fillBuffer = function () {\n        // Increment counter.\n        this._counter[0]++;\n        var ctr = this._counter[0];\n        // Check if counter overflowed.\n        if (ctr === 0) {\n            throw new Error(\"hkdf: cannot expand more\");\n        }\n        // Prepare HMAC instance for new data with old key.\n        this._hmac.reset();\n        // Hash in previous output if it was generated\n        // (i.e. counter is greater than 1).\n        if (ctr > 1) {\n            this._hmac.update(this._buffer);\n        }\n        // Hash in info if it exists.\n        if (this._info) {\n            this._hmac.update(this._info);\n        }\n        // Hash in the counter.\n        this._hmac.update(this._counter);\n        // Output result to buffer and clean HMAC instance.\n        this._hmac.finish(this._buffer);\n        // Reset buffer position.\n        this._bufpos = 0;\n    };\n    /**\n     * Expand returns next key material of the given length.\n     *\n     * It throws if expansion limit is reached (which is\n     * 254 digests of the underlying HMAC function).\n     */\n    HKDF.prototype.expand = function (length) {\n        var out = new Uint8Array(length);\n        for (var i = 0; i < out.length; i++) {\n            if (this._bufpos === this._buffer.length) {\n                this._fillBuffer();\n            }\n            out[i] = this._buffer[this._bufpos++];\n        }\n        return out;\n    };\n    HKDF.prototype.clean = function () {\n        this._hmac.clean();\n        wipe_1.wipe(this._buffer);\n        wipe_1.wipe(this._counter);\n        this._bufpos = 0;\n    };\n    return HKDF;\n}());\nexports.HKDF = HKDF;\n// TODO(dchest): maybe implement deriveKey?\n//# sourceMappingURL=hkdf.js.map"]},"metadata":{},"sourceType":"script"}