{"ast":null,"code":"import { concat } from \"uint8arrays/concat\";\nimport { toString } from \"uint8arrays/to-string\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { DATA_ENCODING, DID_DELIMITER, DID_METHOD, DID_PREFIX, JSON_ENCODING, JWT_DELIMITER, JWT_ENCODING, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_LENGTH } from \"./constants\";\nexport function decodeJSON(str) {\n  return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));\n}\nexport function encodeJSON(val) {\n  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);\n}\nexport function encodeIss(publicKey) {\n  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);\n  const multicodec = MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);\n  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);\n}\nexport function decodeIss(issuer) {\n  const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);\n  if (prefix !== DID_PREFIX || method !== DID_METHOD) {\n    throw new Error(\"Issuer must be a DID with method \\\"key\\\"\");\n  }\n  const base = multicodec.slice(0, 1);\n  if (base !== MULTICODEC_ED25519_BASE) {\n    throw new Error(\"Issuer must be a key in mulicodec format\");\n  }\n  const bytes = fromString(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);\n  const type = toString(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);\n  if (type !== MULTICODEC_ED25519_HEADER) {\n    throw new Error(\"Issuer must be a public key with type \\\"Ed25519\\\"\");\n  }\n  const publicKey = bytes.slice(2);\n  if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {\n    throw new Error(\"Issuer must be a public key with length 32 bytes\");\n  }\n  return publicKey;\n}\nexport function encodeSig(bytes) {\n  return toString(bytes, JWT_ENCODING);\n}\nexport function decodeSig(encoded) {\n  return fromString(encoded, JWT_ENCODING);\n}\nexport function encodeData(params) {\n  return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);\n}\nexport function decodeData(data) {\n  const params = toString(data, DATA_ENCODING).split(JWT_DELIMITER);\n  const header = decodeJSON(params[0]);\n  const payload = decodeJSON(params[1]);\n  return {\n    header,\n    payload\n  };\n}\nexport function encodeJWT(params) {\n  return [encodeJSON(params.header), encodeJSON(params.payload), encodeSig(params.signature)].join(JWT_DELIMITER);\n}\nexport function decodeJWT(jwt) {\n  const params = jwt.split(JWT_DELIMITER);\n  const header = decodeJSON(params[0]);\n  const payload = decodeJSON(params[1]);\n  const signature = decodeSig(params[2]);\n  const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);\n  return {\n    header,\n    payload,\n    signature,\n    data\n  };\n}","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { concat } from \"uint8arrays/concat\";\nimport { toString } from \"uint8arrays/to-string\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { DATA_ENCODING, DID_DELIMITER, DID_METHOD, DID_PREFIX, JSON_ENCODING, JWT_DELIMITER, JWT_ENCODING, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_LENGTH, } from \"./constants\";\nexport function decodeJSON(str) {\n    return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));\n}\nexport function encodeJSON(val) {\n    return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);\n}\nexport function encodeIss(publicKey) {\n    const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);\n    const multicodec = MULTICODEC_ED25519_BASE +\n        toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);\n    return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);\n}\nexport function decodeIss(issuer) {\n    const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);\n    if (prefix !== DID_PREFIX || method !== DID_METHOD) {\n        throw new Error(`Issuer must be a DID with method \"key\"`);\n    }\n    const base = multicodec.slice(0, 1);\n    if (base !== MULTICODEC_ED25519_BASE) {\n        throw new Error(`Issuer must be a key in mulicodec format`);\n    }\n    const bytes = fromString(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);\n    const type = toString(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);\n    if (type !== MULTICODEC_ED25519_HEADER) {\n        throw new Error(`Issuer must be a public key with type \"Ed25519\"`);\n    }\n    const publicKey = bytes.slice(2);\n    if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {\n        throw new Error(`Issuer must be a public key with length 32 bytes`);\n    }\n    return publicKey;\n}\nexport function encodeSig(bytes) {\n    return toString(bytes, JWT_ENCODING);\n}\nexport function decodeSig(encoded) {\n    return fromString(encoded, JWT_ENCODING);\n}\nexport function encodeData(params) {\n    return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);\n}\nexport function decodeData(data) {\n    const params = toString(data, DATA_ENCODING).split(JWT_DELIMITER);\n    const header = decodeJSON(params[0]);\n    const payload = decodeJSON(params[1]);\n    return { header, payload };\n}\nexport function encodeJWT(params) {\n    return [\n        encodeJSON(params.header),\n        encodeJSON(params.payload),\n        encodeSig(params.signature),\n    ].join(JWT_DELIMITER);\n}\nexport function decodeJWT(jwt) {\n    const params = jwt.split(JWT_DELIMITER);\n    const header = decodeJSON(params[0]);\n    const payload = decodeJSON(params[1]);\n    const signature = decodeSig(params[2]);\n    const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);\n    return { header, payload, signature, data };\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}