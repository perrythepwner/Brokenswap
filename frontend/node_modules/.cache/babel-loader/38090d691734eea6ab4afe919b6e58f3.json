{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0;\nvar events_1 = require(\"events\");\nvar LockEvent;\n(function (LockEvent) {\n  LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {}));\n// Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\nvar Lock = /** @class */function () {\n  function Lock() {\n    this.locked = false;\n    this.emitter = new events_1.EventEmitter();\n  }\n  // Attempt to acquire the lock without blocking.\n  // @returns {boolean} True if the lock was acquired.\n  Lock.prototype.tryAcquire = function () {\n    if (!this.locked) {\n      this.locked = true;\n      return true;\n    }\n    return false;\n  };\n  // Acquire the lock, blocking until the lock is available.\n  Lock.prototype.acquire = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // Attempt to grab the lock without waiting.\n      if (_this.tryAcquire()) {\n        resolve();\n        return;\n      }\n      // Wait for an event emitted when releasing the lock.\n      var callback = function callback() {\n        try {\n          if (_this.tryAcquire()) {\n            _this.emitter.removeListener(LockEvent.Unlock, callback);\n            resolve();\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n      _this.emitter.on(LockEvent.Unlock, callback);\n    });\n  };\n  // Release the lock such that another caller can acquire it.\n  // If not locked, calling this method has no effect.\n  Lock.prototype.release = function () {\n    if (this.locked) {\n      this.locked = false;\n      this.emitter.emit(LockEvent.Unlock);\n    }\n  };\n  return Lock;\n}();\nexports.Lock = Lock;","map":{"version":3,"sources":["../src/lock.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEA,IAAK,SAEJ;AAFD,CAAA,UAAK,SAAS,EAAA;EACZ,SAAA,CAAA,QAAA,CAAA,GAAA,QAAiB;AACnB,CAAC,EAFI,SAAS,KAAT,SAAS,GAAA,CAAA,CAAA,CAAA,CAAA;AAId;AACA;AACA;AACA,IAAA,IAAA,GAAA,aAAA,YAAA;EAIE,SAAA,IAAA,CAAA,EAAA;IAHQ,IAAA,CAAA,MAAM,GAAY,KAAK;IAI7B,IAAI,CAAC,OAAO,GAAG,IAAI,QAAA,CAAA,YAAY,CAAA,CAAE;EACnC;EAEA;EACA;EACA,IAAA,CAAA,SAAA,CAAA,UAAU,GAAV,YAAA;IACE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;MAChB,IAAI,CAAC,MAAM,GAAG,IAAI;MAClB,OAAO,IAAI;IACZ;IACD,OAAO,KAAK;EACd,CAAC;EAED;EACA,IAAA,CAAA,SAAA,CAAA,OAAO,GAAP,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;IACE,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM,EAAA;MACjC;MACA,IAAI,KAAI,CAAC,UAAU,CAAA,CAAE,EAAE;QACrB,OAAO,CAAA,CAAE;QACT;MACD;MAED;MACA,IAAM,QAAQ,GAAG,SAAX,QAAQ,CAAA,EAAG;QACf,IAAI;UACF,IAAI,KAAI,CAAC,UAAU,CAAA,CAAE,EAAE;YACrB,KAAI,CAAC,OAAO,CAAC,cAAc,CAAC,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC;YACvD,OAAO,CAAA,CAAE;UACV;SACF,CAAC,OAAO,KAAK,EAAE;UACd,MAAM,CAAC,KAAK,CAAC;QACd;MACH,CAAC;MACD,KAAI,CAAC,OAAO,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC;IAC7C,CAAC,CAAC;EACJ,CAAC;EAED;EACA;EACA,IAAA,CAAA,SAAA,CAAA,OAAO,GAAP,YAAA;IACE,IAAI,IAAI,CAAC,MAAM,EAAE;MACf,IAAI,CAAC,MAAM,GAAG,KAAK;MACnB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;IACpC;EACH,CAAC;EACH,OAAA,IAAC;AAAD,CAAC,CAAA,CAAA;AAlDY,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\nvar events_1 = require(\"events\");\nvar LockEvent;\n(function (LockEvent) {\n    LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {}));\n// Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\nvar Lock = /** @class */ (function () {\n    function Lock() {\n        this.locked = false;\n        this.emitter = new events_1.EventEmitter();\n    }\n    // Attempt to acquire the lock without blocking.\n    // @returns {boolean} True if the lock was acquired.\n    Lock.prototype.tryAcquire = function () {\n        if (!this.locked) {\n            this.locked = true;\n            return true;\n        }\n        return false;\n    };\n    // Acquire the lock, blocking until the lock is available.\n    Lock.prototype.acquire = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // Attempt to grab the lock without waiting.\n            if (_this.tryAcquire()) {\n                resolve();\n                return;\n            }\n            // Wait for an event emitted when releasing the lock.\n            var callback = function () {\n                try {\n                    if (_this.tryAcquire()) {\n                        _this.emitter.removeListener(LockEvent.Unlock, callback);\n                        resolve();\n                    }\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            _this.emitter.on(LockEvent.Unlock, callback);\n        });\n    };\n    // Release the lock such that another caller can acquire it.\n    // If not locked, calling this method has no effect.\n    Lock.prototype.release = function () {\n        if (this.locked) {\n            this.locked = false;\n            this.emitter.emit(LockEvent.Unlock);\n        }\n    };\n    return Lock;\n}());\nexports.Lock = Lock;\n//# sourceMappingURL=lock.js.map"]},"metadata":{},"sourceType":"script"}