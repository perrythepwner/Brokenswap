{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$();\nimport { JSBI, Token, TokenAmount } from '@ubeswap/sdk';\nimport { useMemo } from 'react';\nimport ERC20_INTERFACE from '../../constants/abis/erc20';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { isAddress } from '../../utils';\nimport { useMultipleContractSingleData } from '../multicall/hooks';\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  _s();\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address]);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return [useMemo(() => address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n    if (amount) {\n      memo[token.address] = new TokenAmount(token, amount);\n    }\n    return memo;\n  }, {}) : {}, [address, validatedTokens, balances]), anyLoading];\n}\n_s(useTokenBalancesWithLoadingIndicator, \"SCK9OM08RM+gVw11exo8N+EChV4=\", false, function () {\n  return [useMultipleContractSingleData];\n});\nexport function useTokenBalances(address, tokens) {\n  _s2();\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n}\n\n// get the balance for a single token/account combo\n_s2(useTokenBalances, \"mWHFhmTyaoodDeiE1Op0b2ODA8c=\", false, function () {\n  return [useTokenBalancesWithLoadingIndicator];\n});\nexport function useTokenBalance(account, token) {\n  _s3();\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\n_s3(useTokenBalance, \"Bs7OvuixKI6epyl0XTe28FcYl68=\", false, function () {\n  return [useTokenBalances];\n});\nexport function useCurrencyBalances(account, currencies) {\n  _s4();\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => currency instanceof Token)) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const tokenBalances = useTokenBalances(account, tokens);\n  return useMemo(() => {\n    var _currencies$map;\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency) return undefined;\n      if (currency instanceof Token) return tokenBalances[currency.address];\n      return undefined;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, currencies, tokenBalances]);\n}\n_s4(useCurrencyBalances, \"3/eeD2Vj5+BIpwvbkEPQGHwX4Hk=\", false, function () {\n  return [useTokenBalances];\n});\nexport function useCurrencyBalance(account, currency) {\n  _s5();\n  return useCurrencyBalances(account, [currency])[0];\n}\n\n// mimics useAllBalances\n_s5(useCurrencyBalance, \"ujXQyrriKnCrImnzvRCr5xp5xyc=\", false, function () {\n  return [useCurrencyBalances];\n});\nexport function useAllTokenBalances() {\n  _s6();\n  const allTokens = useAllTokens();\n  const allTokensArray = useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);\n  const balances = useTokenBalances(undefined, allTokensArray);\n  return balances !== null && balances !== void 0 ? balances : {};\n}\n_s6(useAllTokenBalances, \"iDduHbrLiNYlYRJvdiCyi9V+s8g=\", false, function () {\n  return [useAllTokens, useTokenBalances];\n});","map":{"version":3,"names":["JSBI","Token","TokenAmount","useMemo","ERC20_INTERFACE","useAllTokens","isAddress","useMultipleContractSingleData","useTokenBalancesWithLoadingIndicator","address","tokens","_s","validatedTokens","_tokens$filter","filter","t","validatedTokenAddresses","map","vt","balances","anyLoading","some","callState","loading","length","reduce","memo","token","i","_balances$i","_balances$i$result","value","result","amount","BigInt","toString","undefined","useTokenBalances","_s2","useTokenBalance","account","_s3","tokenBalances","useCurrencyBalances","currencies","_s4","_currencies$filter","currency","_currencies$map","useCurrencyBalance","_s5","useAllTokenBalances","_s6","allTokens","allTokensArray","Object","values"],"sources":["/app/src/state/wallet/hooks.ts"],"sourcesContent":["import { JSBI, Token, TokenAmount } from '@ubeswap/sdk'\nimport { useMemo } from 'react'\n\nimport ERC20_INTERFACE from '../../constants/abis/erc20'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { isAddress } from '../../utils'\nimport { useMultipleContractSingleData } from '../multicall/hooks'\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: TokenAmount | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false) ?? [],\n    [tokens]\n  )\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map((vt) => vt.address), [validatedTokens])\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address])\n  const anyLoading: boolean = useMemo(() => balances.some((callState) => callState.loading), [balances])\n\n  return [\n    useMemo(\n      () =>\n        address && validatedTokens.length > 0\n          ? validatedTokens.reduce<{ [tokenAddress: string]: TokenAmount | undefined }>((memo, token, i) => {\n              const value = balances?.[i]?.result?.[0]\n              const amount = value ? JSBI.BigInt(value.toString()) : undefined\n              if (amount) {\n                memo[token.address] = new TokenAmount(token, amount)\n              }\n              return memo\n            }, {})\n          : {},\n      [address, validatedTokens, balances]\n    ),\n    anyLoading,\n  ]\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: TokenAmount | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): TokenAmount | undefined {\n  const tokenBalances = useTokenBalances(account, [token])\n  if (!token) return undefined\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(account?: string, currencies?: (Token | undefined)[]): (TokenAmount | undefined)[] {\n  const tokens = useMemo(\n    () => currencies?.filter((currency): currency is Token => currency instanceof Token) ?? [],\n    [currencies]\n  )\n\n  const tokenBalances = useTokenBalances(account, tokens)\n\n  return useMemo(\n    () =>\n      currencies?.map((currency) => {\n        if (!account || !currency) return undefined\n        if (currency instanceof Token) return tokenBalances[currency.address]\n        return undefined\n      }) ?? [],\n    [account, currencies, tokenBalances]\n  )\n}\n\nexport function useCurrencyBalance(account?: string, currency?: Token): TokenAmount | undefined {\n  return useCurrencyBalances(account, [currency])[0]\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): { [tokenAddress: string]: TokenAmount | undefined } {\n  const allTokens = useAllTokens()\n  const allTokensArray = useMemo(() => Object.values(allTokens ?? {}), [allTokens])\n  const balances = useTokenBalances(undefined, allTokensArray)\n  return balances ?? {}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}