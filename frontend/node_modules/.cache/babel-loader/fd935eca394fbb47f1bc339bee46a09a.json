{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{parseUnits}from'@ethersproject/units';import{CELO,cEUR,cUSD,JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{useMinimaTrade,useUbeswapTradeExactIn,useUbeswapTradeExactOut}from'components/swap/routing/hooks/useTrade';import{useCallback,useEffect,useState}from'react';import{useDispatch,useSelector}from'react-redux';import{ROUTER_ADDRESS}from'../../constants';import{useCurrency}from'../../hooks/Tokens';import useENS from'../../hooks/useENS';import useParsedQueryString from'../../hooks/useParsedQueryString';import{isAddress}from'../../utils';import{computeSlippageAdjustedAmounts}from'../../utils/prices';import{useUserSlippageTolerance}from'../user/hooks';import{useCurrencyBalances}from'../wallet/hooks';import{Field,replaceSwapState,selectCurrency,setRecipient,switchCurrencies,typeInput}from'./actions';export function useSwapState(){return useSelector(state=>state.swap);}export function useSwapActionHandlers(){const dispatch=useDispatch();const onCurrencySelection=useCallback((field,currency)=>{dispatch(selectCurrency({field,currencyId:currency instanceof Token?currency.address:''}));},[dispatch]);const onSwitchTokens=useCallback(()=>{dispatch(switchCurrencies());},[dispatch]);const onUserInput=useCallback((field,typedValue)=>{dispatch(typeInput({field,typedValue}));},[dispatch]);const onChangeRecipient=useCallback(recipient=>{dispatch(setRecipient({recipient}));},[dispatch]);return{onSwitchTokens,onCurrencySelection,onUserInput,onChangeRecipient};}// try to parse a user entered amount for a given token\nexport function tryParseAmount(value,currency){if(!value||!currency){return undefined;}try{const typedValueParsed=parseUnits(value,currency.decimals).toString();if(typedValueParsed!=='0'){return new TokenAmount(currency,JSBI.BigInt(typedValueParsed));}}catch(error){// should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\nconsole.debug(\"Failed to parse input amount: \\\"\".concat(value,\"\\\"\"),error);}// necessary for all paths to return a value\nreturn new TokenAmount(currency,JSBI.BigInt(0));}const BAD_RECIPIENT_ADDRESSES=['',ROUTER_ADDRESS];/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */function involvesAddress(trade,checksummedAddress){return trade.route.path.some(token=>token.address===checksummedAddress)||trade.route.pairs.some(pair=>pair.liquidityToken.address===checksummedAddress);}// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(){var _ref,_ref2;const{address:account,network}=useCelo();const{independentField,typedValue,[Field.INPUT]:{currencyId:inputCurrencyId},[Field.OUTPUT]:{currencyId:outputCurrencyId},recipient}=useSwapState();const inputCurrency=useCurrency(inputCurrencyId);const outputCurrency=useCurrency(outputCurrencyId);const recipientLookup=useENS(recipient!==null&&recipient!==void 0?recipient:undefined);const to=(_ref=recipient===null?account:recipientLookup.address)!==null&&_ref!==void 0?_ref:null;const relevantTokenBalances=useCurrencyBalances(account!==null&&account!==void 0?account:undefined,[inputCurrency!==null&&inputCurrency!==void 0?inputCurrency:undefined,outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined]);const isExactIn=independentField===Field.INPUT;const parsedAmount=tryParseAmount(typedValue,(_ref2=isExactIn?inputCurrency:outputCurrency)!==null&&_ref2!==void 0?_ref2:undefined);const minimaBestTradeExactIn=useMinimaTrade(isExactIn?parsedAmount:undefined,outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined);const ubeBestTradeExactIn=useUbeswapTradeExactIn(isExactIn?parsedAmount:undefined,outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined);const bestTradeExactIn=minimaBestTradeExactIn===undefined?undefined:minimaBestTradeExactIn!==null&&minimaBestTradeExactIn!==void 0?minimaBestTradeExactIn:ubeBestTradeExactIn;const bestTradeExactOut=useUbeswapTradeExactOut(inputCurrency!==null&&inputCurrency!==void 0?inputCurrency:undefined,!isExactIn?parsedAmount:undefined);const v2Trade=isExactIn?bestTradeExactIn:bestTradeExactOut;const currencyBalances={[Field.INPUT]:relevantTokenBalances[0],[Field.OUTPUT]:relevantTokenBalances[1]};const currencies={[Field.INPUT]:inputCurrency!==null&&inputCurrency!==void 0?inputCurrency:undefined,[Field.OUTPUT]:outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined};let inputError;if(!account){inputError='Connect Wallet';}if(!parsedAmount){var _inputError;inputError=(_inputError=inputError)!==null&&_inputError!==void 0?_inputError:'Enter an amount';}if(!currencies[Field.INPUT]||!currencies[Field.OUTPUT]){var _inputError2;inputError=(_inputError2=inputError)!==null&&_inputError2!==void 0?_inputError2:'Select a token';}const formattedTo=isAddress(to);if(!to||!formattedTo){var _inputError3;inputError=(_inputError3=inputError)!==null&&_inputError3!==void 0?_inputError3:'Enter a recipient';}else{if(BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo)!==-1||bestTradeExactIn&&involvesAddress(bestTradeExactIn,formattedTo)||bestTradeExactOut&&involvesAddress(bestTradeExactOut,formattedTo)){var _inputError4;inputError=(_inputError4=inputError)!==null&&_inputError4!==void 0?_inputError4:'Invalid recipient';}}const[allowedSlippage]=useUserSlippageTolerance();const slippageAdjustedAmounts=v2Trade&&allowedSlippage&&computeSlippageAdjustedAmounts(v2Trade,allowedSlippage);// compare input balance to max input based on version\nconst[balanceIn,amountIn]=[currencyBalances[Field.INPUT],slippageAdjustedAmounts?slippageAdjustedAmounts[Field.INPUT]:null];let showRamp=false;if(balanceIn&&amountIn&&balanceIn.lessThan(amountIn)){if(amountIn.currency.address===cUSD[network.chainId].address||amountIn.currency.address===CELO[network.chainId].address||amountIn.currency.address===cEUR[network.chainId].address){showRamp=true;}inputError='Insufficient '+amountIn.currency.symbol+' balance';}return{currencies,currencyBalances,parsedAmount,v2Trade:v2Trade!==null&&v2Trade!==void 0?v2Trade:undefined,showRamp,inputError};}function parseCurrencyFromURLParameter(urlParam,chainId){var _cUSD$chainId$address;if(typeof urlParam==='string'){const valid=isAddress(urlParam);if(valid)return valid;if(urlParam.toUpperCase()==='CUSD')return cUSD[chainId].address;if(valid===false)return cUSD[chainId].address;}return(_cUSD$chainId$address=cUSD[chainId].address)!==null&&_cUSD$chainId$address!==void 0?_cUSD$chainId$address:'';}function parseTokenAmountURLParameter(urlParam){return typeof urlParam==='string'&&!isNaN(parseFloat(urlParam))?urlParam:'';}function parseIndependentFieldURLParameter(urlParam){return typeof urlParam==='string'&&urlParam.toLowerCase()==='output'?Field.OUTPUT:Field.INPUT;}const ENS_NAME_REGEX=/^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;const ADDRESS_REGEX=/^0x[a-fA-F0-9]{40}$/;function validatedRecipient(recipient){if(typeof recipient!=='string')return null;const address=isAddress(recipient);if(address)return address;if(ENS_NAME_REGEX.test(recipient))return recipient;if(ADDRESS_REGEX.test(recipient))return recipient;return null;}export function queryParametersToSwapState(parsedQs,chainId){let inputCurrency=parseCurrencyFromURLParameter(parsedQs.inputCurrency,chainId);let outputCurrency=parseCurrencyFromURLParameter(parsedQs.outputCurrency,chainId);if(inputCurrency===outputCurrency){if(typeof parsedQs.outputCurrency==='string'){inputCurrency='';}else{outputCurrency='';}}const recipient=validatedRecipient(parsedQs.recipient);return{[Field.INPUT]:{currencyId:inputCurrency},[Field.OUTPUT]:{currencyId:outputCurrency},typedValue:parseTokenAmountURLParameter(parsedQs.exactAmount),independentField:parseIndependentFieldURLParameter(parsedQs.exactField),recipient};}// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch(){const{network}=useCelo();const chainId=network.chainId;const dispatch=useDispatch();const parsedQs=useParsedQueryString();const[result,setResult]=useState();useEffect(()=>{if(!chainId)return;const parsed=queryParametersToSwapState(parsedQs,chainId);dispatch(replaceSwapState({typedValue:parsed.typedValue,field:parsed.independentField,inputCurrencyId:parsed[Field.INPUT].currencyId,outputCurrencyId:parsed[Field.OUTPUT].currencyId,recipient:parsed.recipient}));setResult({inputCurrencyId:parsed[Field.INPUT].currencyId,outputCurrencyId:parsed[Field.OUTPUT].currencyId});// eslint-disable-next-line react-hooks/exhaustive-deps\n},[dispatch,chainId]);return result;}","map":{"version":3,"names":["useCelo","parseUnits","CELO","cEUR","cUSD","JSBI","Token","TokenAmount","useMinimaTrade","useUbeswapTradeExactIn","useUbeswapTradeExactOut","useCallback","useEffect","useState","useDispatch","useSelector","ROUTER_ADDRESS","useCurrency","useENS","useParsedQueryString","isAddress","computeSlippageAdjustedAmounts","useUserSlippageTolerance","useCurrencyBalances","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useSwapState","state","swap","useSwapActionHandlers","dispatch","onCurrencySelection","field","currency","currencyId","address","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","BigInt","error","console","debug","concat","BAD_RECIPIENT_ADDRESSES","involvesAddress","trade","checksummedAddress","route","path","some","token","pairs","pair","liquidityToken","useDerivedSwapInfo","_ref","_ref2","account","network","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","recipientLookup","to","relevantTokenBalances","isExactIn","parsedAmount","minimaBestTradeExactIn","ubeBestTradeExactIn","bestTradeExactIn","bestTradeExactOut","v2Trade","currencyBalances","currencies","inputError","_inputError","_inputError2","formattedTo","_inputError3","indexOf","_inputError4","allowedSlippage","slippageAdjustedAmounts","balanceIn","amountIn","showRamp","lessThan","chainId","symbol","parseCurrencyFromURLParameter","urlParam","_cUSD$chainId$address","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField","useDefaultsFromURLSearch","result","setResult","parsed"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/swap/hooks.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { parseUnits } from '@ethersproject/units'\nimport { CELO, cEUR, ChainId as UbeswapChainId, cUSD, JSBI, Token, TokenAmount, Trade } from '@ubeswap/sdk'\nimport { useMinimaTrade, useUbeswapTradeExactIn, useUbeswapTradeExactOut } from 'components/swap/routing/hooks/useTrade'\nimport { MinimaRouterTrade, UbeswapTrade } from 'components/swap/routing/trade'\nimport { ParsedQs } from 'qs'\nimport { useCallback, useEffect, useState } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { ROUTER_ADDRESS } from '../../constants'\nimport { useCurrency } from '../../hooks/Tokens'\nimport useENS from '../../hooks/useENS'\nimport useParsedQueryString from '../../hooks/useParsedQueryString'\nimport { isAddress } from '../../utils'\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices'\nimport { AppDispatch, AppState } from '../index'\nimport { useUserSlippageTolerance } from '../user/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions'\nimport { SwapState } from './reducer'\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>((state) => state.swap)\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Token) => void\n  onSwitchTokens: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Token) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency instanceof Token ? currency.address : '',\n        })\n      )\n    },\n    [dispatch]\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  }\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount(value?: string, currency?: Token): TokenAmount | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString()\n    if (typedValueParsed !== '0') {\n      return new TokenAmount(currency as Token, JSBI.BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return new TokenAmount(currency as Token, JSBI.BigInt(0))\n}\n\nconst BAD_RECIPIENT_ADDRESSES: string[] = [\n  '',\n  ROUTER_ADDRESS\n]\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some((token) => token.address === checksummedAddress) ||\n    trade.route.pairs.some((pair) => pair.liquidityToken.address === checksummedAddress)\n  )\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Token }\n  currencyBalances: { [field in Field]?: TokenAmount }\n  parsedAmount: TokenAmount | undefined\n  v2Trade: MinimaRouterTrade | UbeswapTrade | undefined\n  inputError?: string\n  showRamp: boolean\n} {\n  const { address: account, network } = useCelo()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientLookup = useENS(recipient ?? undefined)\n  const to: string | null = (recipient === null ? account : recipientLookup.address) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(account ?? undefined, [\n    inputCurrency ?? undefined,\n    outputCurrency ?? undefined,\n  ])\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined)\n\n  const minimaBestTradeExactIn = useMinimaTrade(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined)\n  const ubeBestTradeExactIn = useUbeswapTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined)\n  const bestTradeExactIn =\n    minimaBestTradeExactIn === undefined ? undefined : minimaBestTradeExactIn ?? ubeBestTradeExactIn\n  const bestTradeExactOut = useUbeswapTradeExactOut(inputCurrency ?? undefined, !isExactIn ? parsedAmount : undefined)\n\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1],\n  }\n\n  const currencies: { [field in Field]?: Token } = {\n    [Field.INPUT]: inputCurrency ?? undefined,\n    [Field.OUTPUT]: outputCurrency ?? undefined,\n  }\n\n  let inputError: string | undefined\n  if (!account) {\n    inputError = 'Connect Wallet'\n  }\n\n  if (!parsedAmount) {\n    inputError = inputError ?? 'Enter an amount'\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? 'Select a token'\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? 'Enter a recipient'\n  } else {\n    if (\n      BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||\n      (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||\n      (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))\n    ) {\n      inputError = inputError ?? 'Invalid recipient'\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null,\n  ]\n\n  let showRamp = false\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    if (\n      amountIn.currency.address === cUSD[network.chainId as unknown as UbeswapChainId].address ||\n      amountIn.currency.address === CELO[network.chainId as unknown as UbeswapChainId].address ||\n      amountIn.currency.address === cEUR[network.chainId as unknown as UbeswapChainId].address\n    ) {\n      showRamp = true\n    }\n    inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance'\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade ?? undefined,\n    showRamp,\n    inputError,\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any, chainId: UbeswapChainId): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    if (urlParam.toUpperCase() === 'CUSD') return cUSD[chainId].address\n    if (valid === false) return cUSD[chainId].address\n  }\n  return cUSD[chainId].address ?? ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs, chainId: UbeswapChainId): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId)\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = ''\n    } else {\n      outputCurrency = ''\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n  }\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined }\n  | undefined {\n  const { network } = useCelo()\n  const chainId = network.chainId as unknown as UbeswapChainId\n  const dispatch = useDispatch<AppDispatch>()\n  const parsedQs = useParsedQueryString()\n  const [result, setResult] = useState<\n    { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined } | undefined\n  >()\n\n  useEffect(() => {\n    if (!chainId) return\n    const parsed = queryParametersToSwapState(parsedQs, chainId)\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId: parsed[Field.INPUT].currencyId,\n        outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n        recipient: parsed.recipient,\n      })\n    )\n\n    setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId })\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId])\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}