{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { useCelo } from '@celo/react-celo';\nimport { parseUnits } from '@ethersproject/units';\nimport { CELO, cEUR, cUSD, JSBI, Token, TokenAmount } from '@ubeswap/sdk';\nimport { useMinimaTrade, useUbeswapTradeExactIn, useUbeswapTradeExactOut } from 'components/swap/routing/hooks/useTrade';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { ROUTER_ADDRESS } from '../../constants';\nimport { useCurrency } from '../../hooks/Tokens';\nimport useENS from '../../hooks/useENS';\nimport useParsedQueryString from '../../hooks/useParsedQueryString';\nimport { isAddress } from '../../utils';\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices';\nimport { useUserSlippageTolerance } from '../user/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nexport function useSwapState() {\n  _s();\n  return useSelector(state => state.swap);\n}\n_s(useSwapState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\nexport function useSwapActionHandlers() {\n  _s2();\n  const dispatch = useDispatch();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency instanceof Token ? currency.address : ''\n    }));\n  }, [dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n}\n\n// try to parse a user entered amount for a given token\n_s2(useSwapActionHandlers, \"oIW3xZhV8GZLW5UVB2t9AN9x/ck=\", false, function () {\n  return [useDispatch];\n});\nexport function tryParseAmount(value, currency) {\n  if (!value || !currency) {\n    return undefined;\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n    if (typedValueParsed !== '0') {\n      return new TokenAmount(currency, JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(\"Failed to parse input amount: \\\"\".concat(value, \"\\\"\"), error);\n  }\n  // necessary for all paths to return a value\n  return new TokenAmount(currency, JSBI.BigInt(0));\n}\nconst BAD_RECIPIENT_ADDRESSES = ['', ROUTER_ADDRESS];\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade, checksummedAddress) {\n  return trade.route.path.some(token => token.address === checksummedAddress) || trade.route.pairs.some(pair => pair.liquidityToken.address === checksummedAddress);\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo() {\n  _s3();\n  var _ref, _ref2;\n  const {\n    address: account,\n    network\n  } = useCelo();\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: {\n      currencyId: inputCurrencyId\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrencyId\n    },\n    recipient\n  } = useSwapState();\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const recipientLookup = useENS(recipient !== null && recipient !== void 0 ? recipient : undefined);\n  const to = (_ref = recipient === null ? account : recipientLookup.address) !== null && _ref !== void 0 ? _ref : null;\n  const relevantTokenBalances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined]);\n  const isExactIn = independentField === Field.INPUT;\n  const parsedAmount = tryParseAmount(typedValue, (_ref2 = isExactIn ? inputCurrency : outputCurrency) !== null && _ref2 !== void 0 ? _ref2 : undefined);\n  const minimaBestTradeExactIn = useMinimaTrade(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined);\n  const ubeBestTradeExactIn = useUbeswapTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined);\n  const bestTradeExactIn = minimaBestTradeExactIn === undefined ? undefined : minimaBestTradeExactIn !== null && minimaBestTradeExactIn !== void 0 ? minimaBestTradeExactIn : ubeBestTradeExactIn;\n  const bestTradeExactOut = useUbeswapTradeExactOut(inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, !isExactIn ? parsedAmount : undefined);\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut;\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1]\n  };\n  const currencies = {\n    [Field.INPUT]: inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,\n    [Field.OUTPUT]: outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined\n  };\n  let inputError;\n  if (!account) {\n    inputError = 'Connect Wallet';\n  }\n  if (!parsedAmount) {\n    var _inputError;\n    inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError : 'Enter an amount';\n  }\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    var _inputError2;\n    inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 : 'Select a token';\n  }\n  const formattedTo = isAddress(to);\n  if (!to || !formattedTo) {\n    var _inputError3;\n    inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 : 'Enter a recipient';\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 || bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo) || bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo)) {\n      var _inputError4;\n      inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 : 'Invalid recipient';\n    }\n  }\n  const [allowedSlippage] = useUserSlippageTolerance();\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage);\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null];\n  let showRamp = false;\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    if (amountIn.currency.address === cUSD[network.chainId].address || amountIn.currency.address === CELO[network.chainId].address || amountIn.currency.address === cEUR[network.chainId].address) {\n      showRamp = true;\n    }\n    inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance';\n  }\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,\n    showRamp,\n    inputError\n  };\n}\n_s3(useDerivedSwapInfo, \"ThkhTregQSUnpXJH8wAH2jiC0yw=\", false, function () {\n  return [useCelo, useSwapState, useCurrency, useCurrency, useENS, useCurrencyBalances, useMinimaTrade, useUbeswapTradeExactIn, useUbeswapTradeExactOut, useUserSlippageTolerance];\n});\nfunction parseCurrencyFromURLParameter(urlParam, chainId) {\n  var _cUSD$chainId$address;\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === 'CUSD') return cUSD[chainId].address;\n    if (valid === false) return cUSD[chainId].address;\n  }\n  return (_cUSD$chainId$address = cUSD[chainId].address) !== null && _cUSD$chainId$address !== void 0 ? _cUSD$chainId$address : '';\n}\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\nexport function queryParametersToSwapState(parsedQs, chainId) {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId);\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = '';\n    } else {\n      outputCurrency = '';\n    }\n  }\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  };\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch() {\n  _s4();\n  const {\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const dispatch = useDispatch();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] = useState();\n  useEffect(() => {\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs, chainId);\n    dispatch(replaceSwapState({\n      typedValue: parsed.typedValue,\n      field: parsed.independentField,\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n      recipient: parsed.recipient\n    }));\n    setResult({\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n  return result;\n}\n_s4(useDefaultsFromURLSearch, \"fuC+tCsG1YuAwTvuDre9z46Xsj0=\", false, function () {\n  return [useCelo, useDispatch, useParsedQueryString];\n});","map":{"version":3,"names":["useCelo","parseUnits","CELO","cEUR","cUSD","JSBI","Token","TokenAmount","useMinimaTrade","useUbeswapTradeExactIn","useUbeswapTradeExactOut","useCallback","useEffect","useState","useDispatch","useSelector","ROUTER_ADDRESS","useCurrency","useENS","useParsedQueryString","isAddress","computeSlippageAdjustedAmounts","useUserSlippageTolerance","useCurrencyBalances","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useSwapState","_s","state","swap","useSwapActionHandlers","_s2","dispatch","onCurrencySelection","field","currency","currencyId","address","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","BigInt","error","console","debug","concat","BAD_RECIPIENT_ADDRESSES","involvesAddress","trade","checksummedAddress","route","path","some","token","pairs","pair","liquidityToken","useDerivedSwapInfo","_s3","_ref","_ref2","account","network","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","recipientLookup","to","relevantTokenBalances","isExactIn","parsedAmount","minimaBestTradeExactIn","ubeBestTradeExactIn","bestTradeExactIn","bestTradeExactOut","v2Trade","currencyBalances","currencies","inputError","_inputError","_inputError2","formattedTo","_inputError3","indexOf","_inputError4","allowedSlippage","slippageAdjustedAmounts","balanceIn","amountIn","showRamp","lessThan","chainId","symbol","parseCurrencyFromURLParameter","urlParam","_cUSD$chainId$address","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField","useDefaultsFromURLSearch","_s4","result","setResult","parsed"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/swap/hooks.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { parseUnits } from '@ethersproject/units'\nimport { CELO, cEUR, ChainId as UbeswapChainId, cUSD, JSBI, Token, TokenAmount, Trade } from '@ubeswap/sdk'\nimport { useMinimaTrade, useUbeswapTradeExactIn, useUbeswapTradeExactOut } from 'components/swap/routing/hooks/useTrade'\nimport { MinimaRouterTrade, UbeswapTrade } from 'components/swap/routing/trade'\nimport { ParsedQs } from 'qs'\nimport { useCallback, useEffect, useState } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { ROUTER_ADDRESS } from '../../constants'\nimport { useCurrency } from '../../hooks/Tokens'\nimport useENS from '../../hooks/useENS'\nimport useParsedQueryString from '../../hooks/useParsedQueryString'\nimport { isAddress } from '../../utils'\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices'\nimport { AppDispatch, AppState } from '../index'\nimport { useUserSlippageTolerance } from '../user/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions'\nimport { SwapState } from './reducer'\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>((state) => state.swap)\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Token) => void\n  onSwitchTokens: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Token) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency instanceof Token ? currency.address : '',\n        })\n      )\n    },\n    [dispatch]\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  }\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount(value?: string, currency?: Token): TokenAmount | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString()\n    if (typedValueParsed !== '0') {\n      return new TokenAmount(currency as Token, JSBI.BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return new TokenAmount(currency as Token, JSBI.BigInt(0))\n}\n\nconst BAD_RECIPIENT_ADDRESSES: string[] = [\n  '',\n  ROUTER_ADDRESS\n]\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some((token) => token.address === checksummedAddress) ||\n    trade.route.pairs.some((pair) => pair.liquidityToken.address === checksummedAddress)\n  )\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Token }\n  currencyBalances: { [field in Field]?: TokenAmount }\n  parsedAmount: TokenAmount | undefined\n  v2Trade: MinimaRouterTrade | UbeswapTrade | undefined\n  inputError?: string\n  showRamp: boolean\n} {\n  const { address: account, network } = useCelo()\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n  const recipientLookup = useENS(recipient ?? undefined)\n  const to: string | null = (recipient === null ? account : recipientLookup.address) ?? null\n\n  const relevantTokenBalances = useCurrencyBalances(account ?? undefined, [\n    inputCurrency ?? undefined,\n    outputCurrency ?? undefined,\n  ])\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined)\n\n  const minimaBestTradeExactIn = useMinimaTrade(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined)\n  const ubeBestTradeExactIn = useUbeswapTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined)\n  const bestTradeExactIn =\n    minimaBestTradeExactIn === undefined ? undefined : minimaBestTradeExactIn ?? ubeBestTradeExactIn\n  const bestTradeExactOut = useUbeswapTradeExactOut(inputCurrency ?? undefined, !isExactIn ? parsedAmount : undefined)\n\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1],\n  }\n\n  const currencies: { [field in Field]?: Token } = {\n    [Field.INPUT]: inputCurrency ?? undefined,\n    [Field.OUTPUT]: outputCurrency ?? undefined,\n  }\n\n  let inputError: string | undefined\n  if (!account) {\n    inputError = 'Connect Wallet'\n  }\n\n  if (!parsedAmount) {\n    inputError = inputError ?? 'Enter an amount'\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? 'Select a token'\n  }\n\n  const formattedTo = isAddress(to)\n  if (!to || !formattedTo) {\n    inputError = inputError ?? 'Enter a recipient'\n  } else {\n    if (\n      BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||\n      (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||\n      (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))\n    ) {\n      inputError = inputError ?? 'Invalid recipient'\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance()\n\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage)\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null,\n  ]\n\n  let showRamp = false\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    if (\n      amountIn.currency.address === cUSD[network.chainId as unknown as UbeswapChainId].address ||\n      amountIn.currency.address === CELO[network.chainId as unknown as UbeswapChainId].address ||\n      amountIn.currency.address === cEUR[network.chainId as unknown as UbeswapChainId].address\n    ) {\n      showRamp = true\n    }\n    inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance'\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade ?? undefined,\n    showRamp,\n    inputError,\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any, chainId: UbeswapChainId): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    if (urlParam.toUpperCase() === 'CUSD') return cUSD[chainId].address\n    if (valid === false) return cUSD[chainId].address\n  }\n  return cUSD[chainId].address ?? ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs, chainId: UbeswapChainId): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId)\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = ''\n    } else {\n      outputCurrency = ''\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n  }\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined }\n  | undefined {\n  const { network } = useCelo()\n  const chainId = network.chainId as unknown as UbeswapChainId\n  const dispatch = useDispatch<AppDispatch>()\n  const parsedQs = useParsedQueryString()\n  const [result, setResult] = useState<\n    { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined } | undefined\n  >()\n\n  useEffect(() => {\n    if (!chainId) return\n    const parsed = queryParametersToSwapState(parsedQs, chainId)\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId: parsed[Field.INPUT].currencyId,\n        outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n        recipient: parsed.recipient,\n      })\n    )\n\n    setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId })\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId])\n\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}