{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/** @file httpprovider.js\n * @authors:\n *   Marek Kotewicz <marek@parity.io>\n *   Marian Oancea\n *   Fabian Vogelsteller <fabian@ethereum.org>\n *   AyanamiTech <ayanami0330@protonmail.com>\n * @date 2015\n */\nvar errors = require('web3-core-helpers').errors;\nvar fetch = require('cross-fetch');\nvar http = require('http');\nvar https = require('https');\n// Apply missing polyfill for IE\nrequire('es6-promise').polyfill();\n// import abortController if abortController is not included in node\nif (typeof global !== \"undefined\" && !global.AbortController) {\n  require('abortcontroller-polyfill/dist/polyfill-patch-fetch');\n}\n/**\n * HttpProvider should be used to send rpc calls over http\n */\nvar HttpProvider = function HttpProvider(host, options) {\n  options = options || {};\n  this.withCredentials = options.withCredentials;\n  this.timeout = options.timeout || 0;\n  this.headers = options.headers;\n  this.agent = options.agent;\n  this.forceGlobalFetch = options.forceGlobalFetch || false;\n  this.connected = false;\n  // keepAlive is true unless explicitly set to false\n  const keepAlive = options.keepAlive !== false;\n  this.host = host || 'http://localhost:8545';\n  if (!this.agent) {\n    if (this.host.substring(0, 5) === \"https\") {\n      this.httpsAgent = new https.Agent({\n        keepAlive\n      });\n    } else {\n      this.httpAgent = new http.Agent({\n        keepAlive\n      });\n    }\n  }\n};\n/**\n * Should be used to make async request\n *\n * @method send\n * @param {Object} payload\n * @param {Function} callback triggered on end with (err, result)\n */\nHttpProvider.prototype.send = function (payload, callback) {\n  var options = {\n    method: 'POST',\n    body: JSON.stringify(payload)\n  };\n  var headers = {};\n  var controller;\n  var fetchFunc = this.forceGlobalFetch ? globalThis.fetch : fetch;\n  if (typeof AbortController !== 'undefined') {\n    controller = new AbortController();\n  } else if (typeof window !== 'undefined' && typeof window.AbortController !== 'undefined') {\n    // Some chrome version doesn't recognize new AbortController(); so we are using it from window instead\n    // https://stackoverflow.com/questions/55718778/why-abortcontroller-is-not-defined\n    controller = new window.AbortController();\n  }\n  if (typeof controller !== 'undefined') {\n    options.signal = controller.signal;\n  }\n  // the current runtime is node\n  if (typeof XMLHttpRequest === 'undefined') {\n    // https://github.com/node-fetch/node-fetch#custom-agent\n    var agents = {\n      httpsAgent: this.httpsAgent,\n      httpAgent: this.httpAgent\n    };\n    if (this.agent) {\n      agents.httpsAgent = this.agent.https;\n      agents.httpAgent = this.agent.http;\n    }\n    if (this.host.substring(0, 5) === \"https\") {\n      options.agent = agents.httpsAgent;\n    } else {\n      options.agent = agents.httpAgent;\n    }\n  }\n  if (this.headers) {\n    this.headers.forEach(function (header) {\n      headers[header.name] = header.value;\n    });\n  }\n  // Default headers\n  if (!headers['Content-Type']) {\n    headers['Content-Type'] = 'application/json';\n  }\n  // As the Fetch API supports the credentials as following options 'include', 'omit', 'same-origin'\n  // https://developer.mozilla.org/en-US/docs/Web/API/fetch#credentials\n  // To avoid breaking change in 1.x we override this value based on boolean option.\n  if (this.withCredentials) {\n    options.credentials = 'include';\n  } else {\n    options.credentials = 'omit';\n  }\n  options.headers = headers;\n  if (this.timeout > 0 && typeof controller !== 'undefined') {\n    this.timeoutId = setTimeout(function () {\n      controller.abort();\n    }, this.timeout);\n  }\n  var success = function success(response) {\n    if (this.timeoutId !== undefined) {\n      clearTimeout(this.timeoutId);\n    }\n    // Response is a stream data so should be awaited for json response\n    response.json().then(function (data) {\n      callback(null, data);\n    }, function () {\n      response.text().then(function (text) {\n        callback(errors.InvalidResponse(text));\n      }, function () {\n        callback(errors.InvalidResponse(\"\"));\n      });\n    });\n  };\n  var failed = function failed(error) {\n    if (this.timeoutId !== undefined) {\n      clearTimeout(this.timeoutId);\n    }\n    if (error.name === 'AbortError') {\n      callback(errors.ConnectionTimeout(this.timeout));\n      return;\n    }\n    callback(errors.InvalidConnection(this.host, error));\n  };\n  fetchFunc(this.host, options).then(success.bind(this), failed.bind(this));\n};\nHttpProvider.prototype.disconnect = function () {\n  //NO OP\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n * @returns {boolean}\n */\nHttpProvider.prototype.supportsSubscriptions = function () {\n  return false;\n};\nmodule.exports = HttpProvider;","map":null,"metadata":{},"sourceType":"script"}