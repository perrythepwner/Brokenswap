{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".validate\"])), rootName), root, root.$async);\n    }\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: (0, codegen_1.stringify)(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n};\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \".validate\"])), gen.scopeValue(\"wrapper\", {\n    ref: sch\n  }));\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"await \", \"\"])), (0, code_1.callValidateCode)(cxt, v, passCxt)));\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"!(\", \" instanceof \", \")\"])), e, it.ValidationError), () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n  function callSyncRef() {\n    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n  }\n  function addErrorsFrom(source) {\n    const errs = (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".errors\"])), source);\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" === null ? \", \" : \", \".concat(\", \")\"])), names_1.default.vErrors, errs, names_1.default.vErrors, errs)); // TODO tagged\n    gen.assign(names_1.default.errors, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".length\"])), names_1.default.vErrors));\n  }\n  function addEvaluatedFrom(source) {\n    var _a;\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".evaluated.props\"])), source));\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".evaluated.items\"])), source));\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\nexports.callRef = callRef;\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}