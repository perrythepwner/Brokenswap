{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractKit = exports.newKitFromWeb3 = exports.newKitWithApiKey = exports.newKit = exports.API_KEY_HEADER_KEY = void 0;\nvar connect_1 = require(\"@celo/connect\");\nvar wallet_local_1 = require(\"@celo/wallet-local\");\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar address_registry_1 = require(\"./address-registry\");\nvar base_1 = require(\"./base\");\nvar celo_tokens_1 = require(\"./celo-tokens\");\nvar contract_cache_1 = require(\"./contract-cache\");\nvar setupForKits_1 = require(\"./setupForKits\");\nvar web3_contract_cache_1 = require(\"./web3-contract-cache\");\nvar setupForKits_2 = require(\"./setupForKits\");\nObject.defineProperty(exports, \"API_KEY_HEADER_KEY\", {\n  enumerable: true,\n  get: function get() {\n    return setupForKits_2.API_KEY_HEADER_KEY;\n  }\n});\n/**\n * Creates a new instance of `ContractKit` given a nodeUrl\n * @param url CeloBlockchain node url\n * @optional wallet to reuse or add a wallet different than the default (example ledger-wallet)\n * @optional options to pass to the Web3 HttpProvider constructor\n */\nfunction newKit(url, wallet, options) {\n  var web3 = (0, setupForKits_1.getWeb3ForKit)(url, options);\n  return newKitFromWeb3(web3, wallet);\n}\nexports.newKit = newKit;\n/**\n * Creates a new instance of `ContractKit` given a nodeUrl and apiKey\n * @param url CeloBlockchain node url\n * @param apiKey to include in the http request header\n * @optional wallet to reuse or add a wallet different than the default (example ledger-wallet)\n */\nfunction newKitWithApiKey(url, apiKey, wallet) {\n  var options = (0, setupForKits_1.setupAPIKey)(apiKey);\n  return newKit(url, wallet, options);\n}\nexports.newKitWithApiKey = newKitWithApiKey;\n/**\n * Creates a new instance of the `ContractKit` with a web3 instance\n * @param web3 Web3 instance\n */\nfunction newKitFromWeb3(web3, wallet) {\n  if (wallet === void 0) {\n    wallet = new wallet_local_1.LocalWallet();\n  }\n  (0, setupForKits_1.ensureCurrentProvider)(web3);\n  return new ContractKit(new connect_1.Connection(web3, wallet));\n}\nexports.newKitFromWeb3 = newKitFromWeb3;\n/*\n * ContractKit provides a convenient interface for All Celo Contracts\n *\n * @remarks\n *\n * For most use cases this ContractKit class might be more than you need.\n * Consider {@link MiniContractKit} for a scaled down subset of contract Wrappers,\n * or {@link Connection} for a lighter package without contract Wrappers\n *\n * @param connection â€“ an instance of @celo/connect {@link Connection}\n */\nvar ContractKit = /** @class */function () {\n  function ContractKit(connection) {\n    var _this = this;\n    this.connection = connection;\n    /** @deprecated no longer needed since gasPrice is available on minimumClientVersion node rpc */\n    this.gasPriceSuggestionMultiplier = 5;\n    this.getHumanReadableNetworkConfig = function () {\n      return _this.getNetworkConfig(true);\n    };\n    this.registry = new address_registry_1.AddressRegistry(connection);\n    this._web3Contracts = new web3_contract_cache_1.Web3ContractCache(this.registry);\n    this.contracts = new contract_cache_1.WrapperCache(connection, this._web3Contracts, this.registry);\n    this.celoTokens = new celo_tokens_1.CeloTokens(this.contracts, this.registry);\n  }\n  ContractKit.prototype.getWallet = function () {\n    return this.connection.wallet;\n  };\n  ContractKit.prototype.getTotalBalance = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var lockedCelo, lockedBalance, pending, err_1, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getLockedGold()];\n          case 1:\n            lockedCelo = _b.sent();\n            return [4 /*yield*/, lockedCelo.getAccountTotalLockedGold(address)];\n          case 2:\n            lockedBalance = _b.sent();\n            pending = new bignumber_js_1.BigNumber(0);\n            _b.label = 3;\n          case 3:\n            _b.trys.push([3, 5,, 6]);\n            return [4 /*yield*/, lockedCelo.getPendingWithdrawalsTotalValue(address)];\n          case 4:\n            pending = _b.sent();\n            return [3 /*break*/, 6];\n          case 5:\n            err_1 = _b.sent();\n            return [3 /*break*/, 6];\n          case 6:\n            _a = [{\n              lockedCELO: lockedBalance,\n              pending: pending\n            }];\n            return [4 /*yield*/, this.celoTokens.balancesOf(address)];\n          case 7:\n            return [2 /*return*/, __assign.apply(void 0, _a.concat([_b.sent()]))];\n        }\n      });\n    });\n  };\n  ContractKit.prototype.getNetworkConfig = function (humanReadable) {\n    if (humanReadable === void 0) {\n      humanReadable = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var configContracts, configMethod, configArray, configMap;\n      var _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            configContracts = [base_1.CeloContract.Election, base_1.CeloContract.Attestations,\n            // TODO ASv2\n            // CeloContract.FederatedAttestations,\n            base_1.CeloContract.Governance, base_1.CeloContract.LockedGold, base_1.CeloContract.SortedOracles, base_1.CeloContract.GasPriceMinimum, base_1.CeloContract.Reserve, base_1.CeloContract.Validators, base_1.CeloContract.DowntimeSlasher, base_1.CeloContract.BlockchainParameters, base_1.CeloContract.EpochRewards, base_1.CeloContract.GrandaMento];\n            configMethod = function configMethod(contract) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var eachTokenAddress, addresses, configContractWrapper, e_1;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      _a.trys.push([0, 3,, 4]);\n                      return [4 /*yield*/, this.celoTokens.getAddresses()];\n                    case 1:\n                      eachTokenAddress = _a.sent();\n                      addresses = Object.values(eachTokenAddress);\n                      return [4 /*yield*/, this.contracts.getContract(contract)];\n                    case 2:\n                      configContractWrapper = _a.sent();\n                      if (humanReadable && 'getHumanReadableConfig' in configContractWrapper) {\n                        return [2 /*return*/, configContractWrapper.getHumanReadableConfig(addresses)];\n                      } else if ('getConfig' in configContractWrapper) {\n                        return [2 /*return*/, configContractWrapper.getConfig(addresses)];\n                      } else {\n                        throw new Error('No config endpoint found');\n                      }\n                      return [3 /*break*/, 4];\n                    case 3:\n                      e_1 = _a.sent();\n                      return [2 /*return*/, new Error(\"Failed to fetch config for contract \".concat(contract, \": \\n\").concat(e_1))];\n                    case 4:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            };\n\n            return [4 /*yield*/, Promise.all(configContracts.map(configMethod))];\n          case 1:\n            configArray = _b.sent();\n            configMap = {};\n            configArray.forEach(function (config, index) {\n              return configMap[configContracts[index]] = config;\n            });\n            _a = {};\n            return [4 /*yield*/, this.celoTokens.getExchangesConfigs(humanReadable)];\n          case 2:\n            _a.exchanges = _b.sent();\n            return [4 /*yield*/, this.celoTokens.getStablesConfigs(humanReadable)];\n          case 3:\n            return [2 /*return*/, __assign.apply(void 0, [(_a.stableTokens = _b.sent(), _a), configMap])];\n        }\n      });\n    });\n  };\n  /**\n   * Set CeloToken to use to pay for gas fees\n   * @param tokenContract CELO (GoldToken) or a supported StableToken contract\n   */\n  ContractKit.prototype.setFeeCurrency = function (tokenContract) {\n    return __awaiter(this, void 0, void 0, function () {\n      var address, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(tokenContract === base_1.CeloContract.GoldToken)) return [3 /*break*/, 1];\n            _a = undefined;\n            return [3 /*break*/, 3];\n          case 1:\n            return [4 /*yield*/, this.registry.addressFor(tokenContract)];\n          case 2:\n            _a = _b.sent();\n            _b.label = 3;\n          case 3:\n            address = _a;\n            if (!address) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.updateGasPriceInConnectionLayer(address)];\n          case 4:\n            _b.sent();\n            _b.label = 5;\n          case 5:\n            this.connection.defaultFeeCurrency = address;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /** @deprecated no longer needed since gasPrice is available on minimumClientVersion node rpc */\n  ContractKit.prototype.updateGasPriceInConnectionLayer = function (currency) {\n    return __awaiter(this, void 0, void 0, function () {\n      var gasPriceMinimum, rawGasPrice, gasPrice;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getGasPriceMinimum()];\n          case 1:\n            gasPriceMinimum = _a.sent();\n            return [4 /*yield*/, gasPriceMinimum.getGasPriceMinimum(currency)];\n          case 2:\n            rawGasPrice = _a.sent();\n            gasPrice = rawGasPrice.multipliedBy(this.gasPriceSuggestionMultiplier).toFixed();\n            return [4 /*yield*/, this.connection.setGasPriceForCurrency(currency, gasPrice)];\n          case 3:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  ContractKit.prototype.getEpochSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockchainParamsWrapper;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getBlockchainParameters()];\n          case 1:\n            blockchainParamsWrapper = _a.sent();\n            return [2 /*return*/, blockchainParamsWrapper.getEpochSizeNumber()];\n        }\n      });\n    });\n  };\n  ContractKit.prototype.getFirstBlockNumberForEpoch = function (epochNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockchainParamsWrapper;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getBlockchainParameters()];\n          case 1:\n            blockchainParamsWrapper = _a.sent();\n            return [2 /*return*/, blockchainParamsWrapper.getFirstBlockNumberForEpoch(epochNumber)];\n        }\n      });\n    });\n  };\n  ContractKit.prototype.getLastBlockNumberForEpoch = function (epochNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockchainParamsWrapper;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getBlockchainParameters()];\n          case 1:\n            blockchainParamsWrapper = _a.sent();\n            return [2 /*return*/, blockchainParamsWrapper.getLastBlockNumberForEpoch(epochNumber)];\n        }\n      });\n    });\n  };\n  ContractKit.prototype.getEpochNumberOfBlock = function (blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockchainParamsWrapper;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getBlockchainParameters()];\n          case 1:\n            blockchainParamsWrapper = _a.sent();\n            return [2 /*return*/, blockchainParamsWrapper.getEpochNumberOfBlock(blockNumber)];\n        }\n      });\n    });\n  };\n  // *** NOTICE ***\n  // Next functions exists for backwards compatibility\n  // These should be consumed via connection to avoid future deprecation issues\n  ContractKit.prototype.addAccount = function (privateKey) {\n    this.connection.addAccount(privateKey);\n  };\n  Object.defineProperty(ContractKit.prototype, \"defaultAccount\", {\n    get: function get() {\n      return this.connection.defaultAccount;\n    },\n    set: function set(address) {\n      this.connection.defaultAccount = address;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ContractKit.prototype, \"gasInflationFactor\", {\n    get: function get() {\n      return this.connection.defaultGasInflationFactor;\n    },\n    set: function set(factor) {\n      this.connection.defaultGasInflationFactor = factor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ContractKit.prototype, \"gasPrice\", {\n    get: function get() {\n      return this.connection.defaultGasPrice;\n    },\n    set: function set(price) {\n      this.connection.defaultGasPrice = price;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ContractKit.prototype, \"defaultFeeCurrency\", {\n    get: function get() {\n      return this.connection.defaultFeeCurrency;\n    },\n    set: function set(address) {\n      this.connection.defaultFeeCurrency = address;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ContractKit.prototype.isListening = function () {\n    return this.connection.isListening();\n  };\n  ContractKit.prototype.isSyncing = function () {\n    return this.connection.isSyncing();\n  };\n  /** @deprecated no longer needed since gasPrice is available on minimumClientVersion node rpc */\n  ContractKit.prototype.fillGasPrice = function (tx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(tx.feeCurrency && tx.gasPrice === '0')) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.updateGasPriceInConnectionLayer(tx.feeCurrency)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/, this.connection.fillGasPrice(tx)];\n        }\n      });\n    });\n  };\n  ContractKit.prototype.sendTransaction = function (tx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.connection.sendTransaction(tx)];\n      });\n    });\n  };\n  ContractKit.prototype.sendTransactionObject = function (txObj, tx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.connection.sendTransactionObject(txObj, tx)];\n      });\n    });\n  };\n  ContractKit.prototype.signTypedData = function (signer, typedData) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.connection.signTypedData(signer, typedData)];\n      });\n    });\n  };\n  ContractKit.prototype.stop = function () {\n    this.connection.stop();\n  };\n  Object.defineProperty(ContractKit.prototype, \"web3\", {\n    get: function get() {\n      return this.connection.web3;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ContractKit;\n}();\nexports.ContractKit = ContractKit;","map":null,"metadata":{},"sourceType":"script"}