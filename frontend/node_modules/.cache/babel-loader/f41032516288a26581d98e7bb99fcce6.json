{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * Array: ordered homogeneous collection\n */\nclass ArrayType extends composite_1.CompositeType {\n  constructor(elementType) {\n    super();\n    this.elementType = elementType;\n  }\n  defaultValue() {\n    return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);\n  }\n  // Proofs\n  getPropertyType() {\n    return this.elementType;\n  }\n  getPropertyGindex(prop) {\n    if (typeof prop !== \"number\") {\n      throw Error(\"Invalid array index: \".concat(prop));\n    }\n    const chunkIdx = Math.floor(prop / this.itemsPerChunk);\n    return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));\n  }\n  getIndexProperty(index) {\n    return index;\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    let length;\n    if (this.isList) {\n      if (!rootNode) {\n        throw new Error(\"List type requires tree argument to get leaves\");\n      }\n      length = this.tree_getLength(rootNode);\n    } else {\n      // Vectors don't need a rootNode to return length\n      length = this.tree_getLength(null);\n    }\n    const gindices = [];\n    if (composite_1.isCompositeType(this.elementType)) {\n      // Underlying elements exist one per chunk\n      // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n      const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));\n      const endGindex = startIndex + BigInt(length);\n      const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);\n      if (this.elementType.fixedSize === null) {\n        if (!rootNode) {\n          /* istanbul ignore next - unreachable code */\n          throw new Error(\"Array of variable size requires tree argument to get leaves\");\n        }\n        // variable-length elements must pass the underlying subtrees to determine the length\n        for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));\n        }\n      } else {\n        for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));\n        }\n      }\n    }\n    // Basic\n    else {\n      const chunkCount = Math.ceil(length / this.itemsPerChunk);\n      const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n      const endGindex = startIndex + BigInt(chunkCount);\n      for (let gindex = startIndex; gindex < endGindex; gindex++) {\n        gindices.push(gindex);\n      }\n    }\n    // include the length chunk\n    if (this.isList) {\n      gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps\n    // There are multiple tests that cover this path for all clases\n    return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);\n  }\n  toJson(value) {\n    return arrayBasic_1.value_toJsonArray(this.elementType, value, this);\n  }\n  clone(value) {\n    return arrayBasic_1.value_cloneArray(this.elementType, value);\n  }\n  equals(a, b) {\n    return arrayBasic_1.value_equals(this.elementType, a, b);\n  }\n}\nexports.ArrayType = ArrayType;","map":null,"metadata":{},"sourceType":"script"}