{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollingBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(require(\"json-rpc-random-id\"));\nconst pify_1 = __importDefault(require(\"pify\"));\nconst BaseBlockTracker_1 = require(\"./BaseBlockTracker\");\nconst logging_utils_1 = require(\"./logging-utils\");\nconst log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'polling-block-tracker');\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nconst sec = 1000;\nclass PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a;\n    // parse + validate args\n    if (!opts.provider) {\n      throw new Error('PollingBlockTracker - no provider specified.');\n    }\n    super({\n      blockResetDuration: (_a = opts.blockResetDuration) !== null && _a !== void 0 ? _a : opts.pollingInterval\n    });\n    // config\n    this._provider = opts.provider;\n    this._pollingInterval = opts.pollingInterval || 20 * sec;\n    this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;\n    this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;\n    this._setSkipCacheFlag = opts.setSkipCacheFlag || false;\n  }\n  // trigger block polling\n  checkForLatestBlock() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this._updateLatestBlock();\n      return yield _this.getLatestBlock();\n    })();\n  }\n  _start() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2._synchronize();\n    })();\n  }\n  _end() {\n    return _asyncToGenerator(function* () {})();\n  } // No-op\n\n  _synchronize() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      while (_this3._isRunning) {\n        try {\n          yield _this3._updateLatestBlock();\n          const promise = timeout(_this3._pollingInterval, !_this3._keepEventLoopActive);\n          _this3.emit('_waitingForNextIteration');\n          yield promise;\n        } catch (err) {\n          const newErr = new Error(\"PollingBlockTracker - encountered an error while attempting to update latest block:\\n\".concat((_a = err.stack) !== null && _a !== void 0 ? _a : err));\n          try {\n            _this3.emit('error', newErr);\n          } catch (emitErr) {\n            console.error(newErr);\n          }\n          const promise = timeout(_this3._retryTimeout, !_this3._keepEventLoopActive);\n          _this3.emit('_waitingForNextIteration');\n          yield promise;\n        }\n      }\n    })();\n  }\n  _updateLatestBlock() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // fetch + set latest block\n      const latestBlock = yield _this4._fetchLatestBlock();\n      _this4._newPotentialLatest(latestBlock);\n    })();\n  }\n  _fetchLatestBlock() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const req = {\n        jsonrpc: '2.0',\n        id: createRandomId(),\n        method: 'eth_blockNumber',\n        params: []\n      };\n      if (_this5._setSkipCacheFlag) {\n        req.skipCache = true;\n      }\n      log('Making request', req);\n      const res = yield (0, pify_1.default)(cb => _this5._provider.sendAsync(req, cb))();\n      log('Got response', res);\n      if (res.error) {\n        throw new Error(\"PollingBlockTracker - encountered error fetching block:\\n\".concat(res.error.message));\n      }\n      return res.result;\n    })();\n  }\n}\nexports.PollingBlockTracker = PollingBlockTracker;\n/**\n * Waits for the specified amount of time.\n *\n * @param duration - The amount of time in milliseconds.\n * @param unref - Assuming this function is run in a Node context, governs\n * whether Node should wait before the `setTimeout` has completed before ending\n * the process (true for no, false for yes). Defaults to false.\n * @returns A promise that can be used to wait.\n */\nfunction timeout(duration, unref) {\n  return new Promise(resolve => {\n    const timeoutRef = setTimeout(resolve, duration);\n    // don't keep process open\n    if (timeoutRef.unref && unref) {\n      timeoutRef.unref();\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}