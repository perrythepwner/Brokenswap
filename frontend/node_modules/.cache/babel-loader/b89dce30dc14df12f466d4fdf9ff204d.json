{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n  TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n  TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n  TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n  TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n  if (input === null) {\n    return null;\n  }\n  if (input === undefined) {\n    return undefined;\n  }\n  if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n    throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n  const output = (0, bytes_1.toBuffer)(input);\n  switch (outputType) {\n    case TypeOutput.Buffer:\n      return output;\n    case TypeOutput.BigInt:\n      return (0, bytes_1.bufferToBigInt)(output);\n    case TypeOutput.Number:\n      {\n        const bigInt = (0, bytes_1.bufferToBigInt)(output);\n        if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n          throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return Number(bigInt);\n      }\n    case TypeOutput.PrefixedHexString:\n      return (0, bytes_1.bufferToHex)(output);\n    default:\n      throw new Error('unknown outputType');\n  }\n}\nexports.toType = toType;","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAmDA;;AAEG;AACH,IAAY,UAKX;AALD,CAAA,UAAY,UAAU,EAAA;EACpB,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAM;EACN,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAM;EACN,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAM;EACN,UAAA,CAAA,UAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mBAAiB;AACnB,CAAC,EALW,UAAU,GAAV,OAAA,CAAA,UAAU,KAAV,OAAA,CAAA,UAAU,GAAA,CAAA,CAAA,CAAA,CAAA;AA0BtB,SAAgB,MAAM,CACpB,KAAyB,EACzB,UAAa,EAAA;EAEb,IAAI,KAAK,KAAK,IAAI,EAAE;IAClB,OAAO,IAAI;EACZ;EACD,IAAI,KAAK,KAAK,SAAS,EAAE;IACvB,OAAO,SAAS;EACjB;EAED,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,CAAA,CAAA,EAAA,UAAA,CAAA,WAAW,EAAC,KAAK,CAAC,EAAE;IACpD,MAAM,IAAI,KAAK,uDAAA,MAAA,CAAuD,KAAK,CAAE,CAAC;GAC/E,MAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;IACpE,MAAM,IAAI,KAAK,CACb,6FAA6F,CAC9F;EACF;EAED,MAAM,MAAM,GAAG,CAAA,CAAA,EAAA,OAAA,CAAA,QAAQ,EAAC,KAAK,CAAC;EAE9B,QAAQ,UAAU;IAChB,KAAK,UAAU,CAAC,MAAM;MACpB,OAAO,MAAiC;IAC1C,KAAK,UAAU,CAAC,MAAM;MACpB,OAAO,CAAA,CAAA,EAAA,OAAA,CAAA,cAAc,EAAC,MAAM,CAA4B;IAC1D,KAAK,UAAU,CAAC,MAAM;MAAE;QACtB,MAAM,MAAM,GAAG,CAAA,CAAA,EAAA,OAAA,CAAA,cAAc,EAAC,MAAM,CAAC;QACrC,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,EAAE;UAC5C,MAAM,IAAI,KAAK,CACb,8FAA8F,CAC/F;QACF;QACD,OAAO,MAAM,CAAC,MAAM,CAA4B;MACjD;IACD,KAAK,UAAU,CAAC,iBAAiB;MAC/B,OAAO,CAAA,CAAA,EAAA,OAAA,CAAA,WAAW,EAAC,MAAM,CAA4B;IACvD;MACE,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC;EACxC;AACH;AAxCA,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = require(\"./bytes\");\nconst internal_1 = require(\"./internal\");\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch (outputType) {\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number: {\n            const bigInt = (0, bytes_1.bufferToBigInt)(output);\n            if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n            }\n            return Number(bigInt);\n        }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error('unknown outputType');\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}