{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo,useConnectedSigner}from'@celo/react-celo';import{ChainId}from'@ubeswap/sdk';import useENS from'hooks/useENS';import{SwapCallbackState,useSwapCallback}from'hooks/useSwapCallback';import{useMemo}from'react';import{INITIAL_ALLOWED_SLIPPAGE}from'../../../constants';import{isAddress,shortenAddress}from'../../../utils';import{useDoTransaction}from'.';import{executeMinimaTrade}from'./minima/executeMinimaTrade';import{executeMoolaDirectTrade}from'./moola/executeMoolaDirectTrade';import{MoolaDirectTrade}from'./moola/MoolaDirectTrade';import{MinimaRouterTrade}from'./trade';/**\n * Use callback to allow trading\n * @param trade\n * @param allowedSlippage\n * @param recipientAddressOrName\n * @returns\n */export const useTradeCallback=function useTradeCallback(trade){let allowedSlippage=arguments.length>1&&arguments[1]!==undefined?arguments[1]:INITIAL_ALLOWED_SLIPPAGE;let recipientAddressOrName=arguments.length>2?arguments[2]:undefined;const{address:account,network}=useCelo();const signer=useConnectedSigner();const chainId=network.chainId;const doTransaction=useDoTransaction();const{address:recipientAddress}=useENS(recipientAddressOrName);const recipient=recipientAddressOrName===null?account:recipientAddress;const withRecipient=recipient===account?'':\" to \".concat(recipientAddressOrName&&isAddress(recipientAddressOrName)?shortenAddress(recipientAddressOrName):recipientAddressOrName);const{state:swapState,callback:swapCallback,error}=useSwapCallback(trade,allowedSlippage,recipientAddressOrName);return useMemo(()=>{if(error){return{state:swapState,callback:null,error};}if(!trade||!account){return{state:SwapCallbackState.INVALID,callback:null,error:'Missing dependencies'};}if(chainId===ChainId.BAKLAVA){return{state:SwapCallbackState.INVALID,callback:null,error:'Baklava is not supported'};}const env={signer,chainId,doTransaction};if(trade instanceof MinimaRouterTrade){return{state:SwapCallbackState.VALID,callback:function(){var _callback=_asyncToGenerator(function*(){return(yield executeMinimaTrade(_objectSpread(_objectSpread({},env),{},{trade,recipient,withRecipient}))).hash;});function callback(){return _callback.apply(this,arguments);}return callback;}(),error:null};}else if(trade instanceof MoolaDirectTrade){return{state:SwapCallbackState.VALID,callback:function(){var _callback2=_asyncToGenerator(function*(){return(yield executeMoolaDirectTrade(_objectSpread(_objectSpread({},env),{},{trade}))).hash;});function callback(){return _callback2.apply(this,arguments);}return callback;}(),error:null};}else if(swapCallback){return{state:SwapCallbackState.VALID,callback:swapCallback,error:null};}else{return{state:SwapCallbackState.INVALID,callback:null,error:'Unknown trade type'};}},[error,signer,trade,account,chainId,doTransaction,swapCallback,swapState,recipient,withRecipient]);};","map":null,"metadata":{},"sourceType":"module"}