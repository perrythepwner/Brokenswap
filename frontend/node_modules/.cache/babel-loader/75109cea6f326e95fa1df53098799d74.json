{"ast":null,"code":"/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\"Please enable Contract data on the Ethereum app Settings\");\n  }\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\nexport default class Eth {\n  constructor(transport) {\n    let scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"w0w\";\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\"], scrambleKey);\n  }\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n  getAddress(path, boolDisplay, boolChaincode) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(response => {\n      let result = {};\n      let publicKeyLength = response[0];\n      let addressLength = response[1 + publicKeyLength];\n      result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      result.address = \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n      if (boolChaincode) {\n        result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n      }\n      return result;\n    });\n  }\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n  provideERC20TokenInformation(_ref) {\n    let {\n      data\n    } = _ref;\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n      throw e;\n    });\n  }\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n\n  signTransaction(path, rawTxHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response.slice(0, 1).toString(\"hex\");\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    }, e => {\n      throw remapTransactionRelatedErrors(e);\n    });\n  }\n  /**\n   */\n\n  getAppConfiguration() {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n  signPersonalMessage(path, messageHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n}","map":{"version":3,"sources":["../src/Eth.js"],"names":["splitPath","foreach","EthAppPleaseEnableContractData","remapTransactionRelatedErrors","e","statusCode","Eth","transport","constructor","scrambleKey","decorateAppAPIMethods","getAddress","path","boolDisplay","boolChaincode","paths","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE","send","then","response","result","publicKeyLength","addressLength","publicKey","slice","toString","address","chainCode","provideERC20TokenInformation","data","signTransaction","rawTxHex","offset","rawTx","from","toSend","maxChunkSize","chunkSize","copy","push","i","apduResponse","v","r","s","getAppConfiguration","arbitraryDataEnabled","version","signPersonalMessage","messageHex","message"],"mappings":"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","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\"\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      e => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    version: string\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}