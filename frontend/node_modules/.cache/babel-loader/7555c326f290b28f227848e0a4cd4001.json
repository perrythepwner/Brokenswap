{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayCompositeTreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayCompositeTreeView extends abstract_1.TreeView {\n  constructor(type, tree) {\n    super();\n    this.type = type;\n    this.tree = tree;\n  }\n  /**\n   * Number of elements in the array. Equal to the Uint32 value of the Tree's length node\n   */\n  get length() {\n    return this.type.tree_getLength(this.tree.rootNode);\n  }\n  /**\n   * Returns the View's Tree rootNode\n   */\n  get node() {\n    return this.tree.rootNode;\n  }\n  /**\n   * Get element at `index`. Returns a view of the Composite element type\n   */\n  get(index) {\n    // TODO: Optimize without bitstring\n    const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);\n    const subtree = this.tree.getSubtree(gindex);\n    return this.type.elementType.getView(subtree);\n  }\n  /**\n   * Get element at `index`. Returns a view of the Composite element type.\n   * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.\n   */\n  getReadonly(index) {\n    // TODO: Optimize without bitstring\n    const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);\n    // tree.getSubtree but without the hook\n    const subtree = new persistent_merkle_tree_1.Tree(this.tree.getNode(gindex));\n    return this.type.elementType.getView(subtree);\n  }\n  /**\n   * Set Composite element type `view` at `index`\n   */\n  set(index, view) {\n    const length = this.length;\n    if (index >= length) {\n      throw Error(\"Error setting index over length \".concat(index, \" > \").concat(length));\n    }\n    const node = this.type.elementType.commitView(view);\n    this.tree.setNodeAtDepth(this.type.depth, index, node);\n  }\n  /**\n   * Returns an array of views of all elements in the array, from index zero to `this.length - 1`.\n   * The returned views don't have a parent hook to this View's Tree, so changes in the returned views won't be\n   * propagated upwards. To get linked element Views use `this.get()`\n   */\n  getAllReadonly() {\n    const length = this.length;\n    const chunksNode = this.type.tree_getChunksNode(this.node);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);\n    const views = new Array(length);\n    for (let i = 0; i < length; i++) {\n      // TODO: Optimize\n      views[i] = this.type.elementType.getView(new persistent_merkle_tree_1.Tree(nodes[i]));\n    }\n    return views;\n  }\n  /**\n   * Returns an array of values of all elements in the array, from index zero to `this.length - 1`.\n   * The returned values are not Views so any changes won't be propagated upwards.\n   * To get linked element Views use `this.get()`\n   */\n  getAllReadonlyValues() {\n    const length = this.length;\n    const chunksNode = this.type.tree_getChunksNode(this.node);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      values[i] = this.type.elementType.tree_toValue(nodes[i]);\n    }\n    return values;\n  }\n}\nexports.ArrayCompositeTreeView = ArrayCompositeTreeView;","map":{"version":3,"sources":["../../src/view/arrayComposite.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AAGA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAmBA,MAAa,sBAEX,SAAQ,UAAA,CAAA,QAAyC,CAAA;EACjD,WAAA,CAAqB,IAAqC,EAAY,IAAU,EAAA;IAC9E,KAAK,CAAA,CAAE;IADY,IAAA,CAAA,IAAI,GAAJ,IAAI;IAA6C,IAAA,CAAA,IAAI,GAAJ,IAAI;EAE1E;EAEA;;AAEG;EACH,IAAI,MAAM,CAAA,EAAA;IACR,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;EACrD;EAEA;;AAEG;EACH,IAAI,IAAI,CAAA,EAAA;IACN,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ;EAC3B;EAEA;;AAEG;EACH,GAAG,CAAC,KAAa,EAAA;IACf;IACA,MAAM,MAAM,GAAG,wBAAA,CAAA,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC;IACxD,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;IAC5C,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC;EAC/C;EAEA;;;AAGG;EACH,WAAW,CAAC,KAAa,EAAA;IACvB;IACA,MAAM,MAAM,GAAG,wBAAA,CAAA,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC;IACxD;IACA,MAAM,OAAO,GAAG,IAAI,wBAAA,CAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACnD,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC;EAC/C;EAEA;;AAEG;EACH,GAAG,CAAC,KAAa,EAAE,IAAgC,EAAA;IACjD,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM;IAC1B,IAAI,KAAK,IAAI,MAAM,EAAE;MACnB,MAAM,KAAK,oCAAA,MAAA,CAAoC,KAAK,SAAA,MAAA,CAAM,MAAM,CAAE,CAAC;IACpE;IAED,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC;IACnD,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC;EACxD;EAEA;;;;AAIG;EACH,cAAc,CAAA,EAAA;IACZ,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM;IAC1B,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;IAC1D,MAAM,KAAK,GAAG,wBAAA,CAAA,eAAe,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,EAAE,MAAM,CAAC;IAC1E,MAAM,KAAK,GAAG,IAAI,KAAK,CAA6B,MAAM,CAAC;IAC3D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;MAC/B;MACA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,wBAAA,CAAA,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7D;IACD,OAAO,KAAK;EACd;EAEA;;;;AAIG;EACH,oBAAoB,CAAA,EAAA;IAClB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM;IAC1B,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;IAC1D,MAAM,KAAK,GAAG,wBAAA,CAAA,eAAe,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,EAAE,MAAM,CAAC;IAC1E,MAAM,MAAM,GAAG,IAAI,KAAK,CAAuB,MAAM,CAAC;IACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;MAC/B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACzD;IACD,OAAO,MAAM;EACf;AACD;AAxFD,OAAA,CAAA,sBAAA,GAAA,sBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayCompositeTreeView = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayCompositeTreeView extends abstract_1.TreeView {\n    constructor(type, tree) {\n        super();\n        this.type = type;\n        this.tree = tree;\n    }\n    /**\n     * Number of elements in the array. Equal to the Uint32 value of the Tree's length node\n     */\n    get length() {\n        return this.type.tree_getLength(this.tree.rootNode);\n    }\n    /**\n     * Returns the View's Tree rootNode\n     */\n    get node() {\n        return this.tree.rootNode;\n    }\n    /**\n     * Get element at `index`. Returns a view of the Composite element type\n     */\n    get(index) {\n        // TODO: Optimize without bitstring\n        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);\n        const subtree = this.tree.getSubtree(gindex);\n        return this.type.elementType.getView(subtree);\n    }\n    /**\n     * Get element at `index`. Returns a view of the Composite element type.\n     * DOES NOT PROPAGATE CHANGES: use only for reads and to skip parent references.\n     */\n    getReadonly(index) {\n        // TODO: Optimize without bitstring\n        const gindex = persistent_merkle_tree_1.toGindexBitstring(this.type.depth, index);\n        // tree.getSubtree but without the hook\n        const subtree = new persistent_merkle_tree_1.Tree(this.tree.getNode(gindex));\n        return this.type.elementType.getView(subtree);\n    }\n    /**\n     * Set Composite element type `view` at `index`\n     */\n    set(index, view) {\n        const length = this.length;\n        if (index >= length) {\n            throw Error(`Error setting index over length ${index} > ${length}`);\n        }\n        const node = this.type.elementType.commitView(view);\n        this.tree.setNodeAtDepth(this.type.depth, index, node);\n    }\n    /**\n     * Returns an array of views of all elements in the array, from index zero to `this.length - 1`.\n     * The returned views don't have a parent hook to this View's Tree, so changes in the returned views won't be\n     * propagated upwards. To get linked element Views use `this.get()`\n     */\n    getAllReadonly() {\n        const length = this.length;\n        const chunksNode = this.type.tree_getChunksNode(this.node);\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);\n        const views = new Array(length);\n        for (let i = 0; i < length; i++) {\n            // TODO: Optimize\n            views[i] = this.type.elementType.getView(new persistent_merkle_tree_1.Tree(nodes[i]));\n        }\n        return views;\n    }\n    /**\n     * Returns an array of values of all elements in the array, from index zero to `this.length - 1`.\n     * The returned values are not Views so any changes won't be propagated upwards.\n     * To get linked element Views use `this.get()`\n     */\n    getAllReadonlyValues() {\n        const length = this.length;\n        const chunksNode = this.type.tree_getChunksNode(this.node);\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, length);\n        const values = new Array(length);\n        for (let i = 0; i < length; i++) {\n            values[i] = this.type.elementType.tree_toValue(nodes[i]);\n        }\n        return values;\n    }\n}\nexports.ArrayCompositeTreeView = ArrayCompositeTreeView;\n//# sourceMappingURL=arrayComposite.js.map"]},"metadata":{},"sourceType":"script"}