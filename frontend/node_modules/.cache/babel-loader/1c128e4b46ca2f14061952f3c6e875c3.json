{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectWallet = void 0;\nconst base_1 = require(\"@celo/base\");\nconst wallet_remote_1 = require(\"@celo/wallet-remote\");\nconst sign_client_1 = __importDefault(require(\"@walletconnect/sign-client\"));\nconst utils_1 = require(\"@walletconnect/utils\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst events_1 = __importDefault(require(\"events\"));\nconst constants_1 = require(\"./constants\");\nconst types_1 = require(\"./types\");\nconst utils_2 = require(\"./utils\");\nconst canceler_1 = __importDefault(require(\"./utils/canceler\"));\nconst wc_signer_1 = require(\"./wc-signer\");\nconst debug = (0, debug_1.default)('kit:wallet:wallet-connect-wallet');\n/**\n * Session establishment happens out of band so after somehow\n * communicating the connection URI (often via QR code) we can\n * continue with the setup process\n */\nfunction waitForTruthy(getValue, signal) {\n  let waitDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n  return __awaiter(this, void 0, void 0, function* () {\n    if (signal.canceled || getValue()) {\n      return;\n    }\n    yield (0, base_1.sleep)(waitDuration);\n    return waitForTruthy(getValue, signal, waitDuration);\n  });\n}\nconst defaultInitOptions = {\n  logger: process.env.NODE_ENV === 'production' ? 'error' : 'debug',\n  metadata: {\n    name: 'react-celo',\n    description: \"Celo's react-celo is a library to help developers and validators to interact with the celo-blockchain.\",\n    url: 'https://github.com/celo-org/celo-monorepo/tree/master/packages/sdk/contractkit',\n    icons: ['https://avatars.githubusercontent.com/u/37552875?s=200&v=4']\n  }\n};\nconst requiredNamespaces = {\n  eip155: {\n    chains: [],\n    methods: [types_1.SupportedMethods.signTransaction],\n    events: ['accountsChanged']\n  }\n};\nconst optionalNamespaces = {\n  eip155: {\n    chains: ['eip155:44787', 'eip155:42220', 'eip155:17323', 'eip155:62320' // baklava\n    ],\n\n    methods: Object.values(types_1.SupportedMethods),\n    events: ['chainChanged', 'accountsChanged']\n  }\n};\nclass WalletConnectWallet extends wallet_remote_1.RemoteWallet {\n  constructor(_ref) {\n    let {\n      init,\n      projectId,\n      chainId\n    } = _ref;\n    super();\n    this.emitter = new events_1.default();\n    this.signers = new Map();\n    this.on = (event, fn) => {\n      this.emitter.on(event, fn);\n    };\n    this.emit = (event, error, data) => {\n      console.info('emit', event, error, data);\n      this.emitter.emit(event, error, data);\n    };\n    this.onSessionProposal = session => {\n      this.emit('session_proposal', null, session);\n    };\n    this.onSessionUpdated = session => {\n      var _a;\n      const {\n        topic,\n        params: {\n          namespaces\n        }\n      } = session;\n      const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);\n      this.session = Object.assign(Object.assign({}, _session), {\n        namespaces\n      });\n      this.emit('session_update', null, session);\n    };\n    this.onSessionExtended = session => {\n      var _a;\n      const {\n        topic\n      } = session;\n      const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);\n      this.session = Object.assign({}, _session);\n      this.emit('session_extend', null, session);\n    };\n    this.onSessionExpire = _ref2 => {\n      let {\n        topic\n      } = _ref2;\n      var _a, _b, _c;\n      // can you be connected to a topic that isnt the main topic? how to just disconnect that topic?\n      if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {\n        void this.close();\n      } else if ((_b = this.client) === null || _b === void 0 ? void 0 : _b.pairing.values) {\n        const sessionForTopic = this.client.pairing.values.find(connection => connection.topic === topic);\n        console.warn('received session expired for topic', topic, 'which is not the topic of session', (_c = this.session) === null || _c === void 0 ? void 0 : _c.topic, 'session with such topic in storage', sessionForTopic || 'false');\n      }\n    };\n    this.onSessionDeleted = session => {\n      this.emit('session_delete', null, session);\n      void this.close().catch(e => {\n        console.error('error closing session', e);\n      });\n    };\n    this.onSessionEvent = event => {\n      this.emit('session_event', null, event);\n    };\n    this.onSessionPing = ping => {\n      this.emit('session_ping', null, ping);\n    };\n    this.onSessionRequest = request => {\n      this.emit('session_request', null, request);\n    };\n    this.close = () => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b, _c;\n      if (!this.client) {\n        throw new Error('Wallet must be initialized before calling close()');\n      }\n      this.canceler.cancel();\n      const reason = (0, utils_1.getSdkError)('USER_DISCONNECTED');\n      const connections = this.client.pairing.values;\n      this.session && this.client.session.delete((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic, reason);\n      yield Promise.all(connections.map(connection => {\n        try {\n          console.info('closing wc connection', connection, reason);\n          return this.client.disconnect({\n            topic: connection.topic,\n            reason\n          });\n        } catch (e) {\n          console.error('Error closing wc connection', connection, reason, e);\n        }\n      }));\n      // ensures pairing is deleted so wallet doesnt have a lingering one.\n      if (((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) && this.client.pairing) {\n        yield (_c = this.client.pairing) === null || _c === void 0 ? void 0 : _c.delete(this.session.topic, reason);\n      }\n      this.client = undefined;\n      this.session = undefined;\n    });\n    this.canceler = new canceler_1.default();\n    this.initOptions = Object.assign(Object.assign(Object.assign({}, defaultInitOptions), init), {\n      projectId\n    });\n    this.chainId = chainId;\n    void this.getWalletConnectClient().then(client => __awaiter(this, void 0, void 0, function* () {\n      this.client = client;\n      this.setupListeners();\n      // when we're in certain environments (like the browser) the\n      // WalletConnect client will handle retrieving old sessions.\n      if (client.session) {\n        const session = client.session.getAll().sort((a, b) => b.expiry - a.expiry).find(x => x.acknowledged && x.expiry * 1000 > Date.now());\n        if (session) {\n          try {\n            yield client.extend({\n              topic: session.topic\n            });\n          } catch (e) {\n            debug('session resurrection, extend failed, wallet most likely refuses session extensions', e);\n          }\n          this.session = session;\n          // It might be better not to emit an event here. after all this is a fake event anyway.\n          this.emit('session_update', null, {\n            id: 0,\n            topic: session.topic,\n            params: {\n              namespaces: session.namespaces\n            }\n          });\n        }\n      }\n    })).catch(e => {\n      debug('session resurrection failed', e);\n      this.emit('session_update', e);\n    });\n  }\n  hasSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield waitForTruthy(() => !!this.session, this.canceler.status);\n    });\n  }\n  setupListeners() {\n    if (!this.client) return;\n    this.client.on('session_proposal', this.onSessionProposal);\n    this.client.on('session_update', this.onSessionUpdated);\n    this.client.on('session_delete', this.onSessionDeleted);\n    // currently when disconnecting the pairing from the offical wc w implementation\n    // https://react-wallet.walletconnect.com/pairings our dapp does not disconnect.\n    this.client.pairing.core.events.on('wc_pairingDeleted', this.onSessionDeleted);\n    this.client.core.on('subscription_deleted', this.onSessionDeleted);\n    this.client.pairing.core.on('wc_pairingDeleted', this.onSessionDeleted);\n    this.client.on('session_extend', this.onSessionExtended);\n    this.client.on('session_event', this.onSessionEvent);\n    this.client.on('session_expire', this.onSessionExpire);\n    this.client.on('session_ping', this.onSessionPing);\n    this.client.on('session_request', this.onSessionRequest);\n  }\n  /**\n   * Pulled out to allow mocking\n   */\n  getWalletConnectClient() {\n    return sign_client_1.default.init(this.initOptions);\n  }\n  switchToChain(params) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.client) {\n        return true;\n      }\n      // check if session already has the desired chain in it by checking accounts and chains\n      const accountSessions = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces) === null || _b === void 0 ? void 0 : _b.eip155) === null || _c === void 0 ? void 0 : _c.accounts) === null || _d === void 0 ? void 0 : _d.filter(eip155ChainAccount => this.chainId.toString() === (0, utils_2.parseAddress)(eip155ChainAccount).networkId);\n      const chainSessions = (_f = (_e = this.session) === null || _e === void 0 ? void 0 : _e.namespaces.eip155.chains) === null || _f === void 0 ? void 0 : _f.filter(prefixedChain => prefixedChain === \"eip155:\".concat(params.chainId));\n      if (!(accountSessions === null || accountSessions === void 0 ? void 0 : accountSessions.length) && !(chainSessions === null || chainSessions === void 0 ? void 0 : chainSessions.length)) {\n        const accounts = this.session.namespaces.eip155.accounts;\n        // update the chain data in the session.\n        // this is necessary since we only require the current chain when connecting and some wallets\n        //  might not notice the optional namespace chains and thus not include them on the namespaces when connecting even if they do in fact support them\n        try {\n          const updatingSession = {\n            topic: this.session.topic,\n            namespaces: {\n              eip155: {\n                accounts: accounts.concat(accounts.map(account => {\n                  return \"eip155:\".concat(params.chainId, \":\").concat((0, utils_2.parseAddress)(account).address);\n                })),\n                chains: (((_g = this.session) === null || _g === void 0 ? void 0 : _g.namespaces.eip155.chains) || []).concat([\"eip155:\".concat(params.chainId)]),\n                methods: this.session.namespaces.eip155.methods,\n                events: this.session.namespaces.eip155.events\n              }\n            }\n          };\n          const resp = yield (_h = this.client) === null || _h === void 0 ? void 0 : _h.update(updatingSession);\n          yield resp === null || resp === void 0 ? void 0 : resp.acknowledged();\n          // ensure we have the new data on the local session.\n          this.onSessionUpdated({\n            id: 0,\n            topic: updatingSession.topic,\n            params: {\n              namespaces: updatingSession.namespaces\n            }\n          });\n          return true;\n        } catch (e) {\n          console.error(\"switchToChain failed, wallet likely does not support \".concat(params.chainId), e);\n          return false;\n        }\n      }\n      this.chainId = params.chainId;\n      yield this.loadAccountSigners();\n      return true;\n    });\n  }\n  /**\n   * Get the URI needed for out of band session establishment\n   */\n  getUri() {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.client = this.client || (yield this.getWalletConnectClient());\n      if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.acknowledged) && ((_b = this.session) === null || _b === void 0 ? void 0 : _b.expiry) && ((_c = this.session) === null || _c === void 0 ? void 0 : _c.expiry) * 1000 > Date.now()) {\n        return;\n      }\n      this.setupListeners();\n      // wallets will literally fail if they don't support a chainId in the required namespaces\n      // likewise wallets return an error if they dont support a method in the required namespaces\n      // therefore required really is required and we add new chain to namespaces when switching chains. see switchToChain\n      const {\n        uri,\n        approval\n      } = yield this.client.connect({\n        requiredNamespaces: {\n          eip155: Object.assign(Object.assign({}, requiredNamespaces.eip155), {\n            chains: [\"eip155:\".concat(this.chainId)]\n          })\n        },\n        optionalNamespaces\n      });\n      void approval().then(session => {\n        console.info('approved session', session);\n        this.session = session;\n        this.emit('session_update', null, {\n          id: 1,\n          topic: session.topic,\n          params: {\n            namespaces: session.namespaces\n          }\n        });\n      }).catch(err => {\n        this.emit('session_update', err);\n      });\n      return uri;\n    });\n  }\n  loadAccountSigners() {\n    return __awaiter(this, void 0, void 0, function* () {\n      /**\n       * Session establishment happens out of band so after somehow\n       * communicating the connection URI (often via QR code) we can\n       * continue with the setup process\n       */\n      yield waitForTruthy(() => !!this.session, this.canceler.status);\n      if (this.canceler.status.canceled) {\n        // This will be true if this.canceler.cancel() was called earlier\n        throw constants_1.CANCELED;\n      }\n      const addressToSigner = new Map();\n      const allNamespaceAccounts = Object.values(this.session.namespaces).map(namespace => namespace.accounts).flat();\n      // namespace.accounts is an array of chain prefixed addresses,\n      // we should not be assuming that every address can work for every chain. but instead filtering based on chain prefix.\n      allNamespaceAccounts.filter(addressLike => {\n        const {\n          networkId\n        } = (0, utils_2.parseAddress)(addressLike);\n        return networkId === String(this.chainId); // chain id matches this.chainId\n      }).forEach(addressLike => {\n        const {\n          address\n        } = (0, utils_2.parseAddress)(addressLike);\n        const signer = new wc_signer_1.WalletConnectSigner(this.client, this.session, address, String(this.chainId));\n        addressToSigner.set(address, signer);\n        this.addSigner(address, signer);\n      });\n      // note the parent of this class has  a private signers map at addressSigners. which is what addSigner and GetSigner access\n      this.signers = addressToSigner;\n      return addressToSigner;\n    });\n  }\n  /**\n   * Gets the signer based on the 'from' field in the tx body\n   * @param txParams Transaction to sign\n   * @dev overrides WalletBase.signTransaction\n   */\n  signTransaction(txParams) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const fromAddress = txParams.from.toString();\n      const signer = this.getSigner(fromAddress);\n      return signer.signRawTransaction(txParams);\n    });\n  }\n}\nexports.WalletConnectWallet = WalletConnectWallet;","map":{"version":3,"sources":["../src/wc-wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletConnectWallet = void 0;\nconst base_1 = require(\"@celo/base\");\nconst wallet_remote_1 = require(\"@celo/wallet-remote\");\nconst sign_client_1 = __importDefault(require(\"@walletconnect/sign-client\"));\nconst utils_1 = require(\"@walletconnect/utils\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst events_1 = __importDefault(require(\"events\"));\nconst constants_1 = require(\"./constants\");\nconst types_1 = require(\"./types\");\nconst utils_2 = require(\"./utils\");\nconst canceler_1 = __importDefault(require(\"./utils/canceler\"));\nconst wc_signer_1 = require(\"./wc-signer\");\nconst debug = (0, debug_1.default)('kit:wallet:wallet-connect-wallet');\n/**\n * Session establishment happens out of band so after somehow\n * communicating the connection URI (often via QR code) we can\n * continue with the setup process\n */\nfunction waitForTruthy(getValue, signal, waitDuration = 500) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (signal.canceled || getValue()) {\n            return;\n        }\n        yield (0, base_1.sleep)(waitDuration);\n        return waitForTruthy(getValue, signal, waitDuration);\n    });\n}\nconst defaultInitOptions = {\n    logger: process.env.NODE_ENV === 'production' ? 'error' : 'debug',\n    metadata: {\n        name: 'react-celo',\n        description: \"Celo's react-celo is a library to help developers and validators to interact with the celo-blockchain.\",\n        url: 'https://github.com/celo-org/celo-monorepo/tree/master/packages/sdk/contractkit',\n        icons: ['https://avatars.githubusercontent.com/u/37552875?s=200&v=4'],\n    },\n};\nconst requiredNamespaces = {\n    eip155: {\n        chains: [],\n        methods: [types_1.SupportedMethods.signTransaction],\n        events: ['accountsChanged'],\n    },\n};\nconst optionalNamespaces = {\n    eip155: {\n        chains: [\n            'eip155:44787',\n            'eip155:42220',\n            'eip155:17323',\n            'eip155:62320', // baklava\n        ],\n        methods: Object.values(types_1.SupportedMethods),\n        events: ['chainChanged', 'accountsChanged'],\n    },\n};\nclass WalletConnectWallet extends wallet_remote_1.RemoteWallet {\n    constructor({ init, projectId, chainId }) {\n        super();\n        this.emitter = new events_1.default();\n        this.signers = new Map();\n        this.on = (event, fn) => {\n            this.emitter.on(event, fn);\n        };\n        this.emit = (event, error, data) => {\n            console.info('emit', event, error, data);\n            this.emitter.emit(event, error, data);\n        };\n        this.onSessionProposal = (session) => {\n            this.emit('session_proposal', null, session);\n        };\n        this.onSessionUpdated = (session) => {\n            var _a;\n            const { topic, params: { namespaces }, } = session;\n            const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);\n            this.session = Object.assign(Object.assign({}, _session), { namespaces });\n            this.emit('session_update', null, session);\n        };\n        this.onSessionExtended = (session) => {\n            var _a;\n            const { topic } = session;\n            const _session = (_a = this.client) === null || _a === void 0 ? void 0 : _a.session.get(topic);\n            this.session = Object.assign({}, _session);\n            this.emit('session_extend', null, session);\n        };\n        this.onSessionExpire = ({ topic }) => {\n            var _a, _b, _c;\n            // can you be connected to a topic that isnt the main topic? how to just disconnect that topic?\n            if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {\n                void this.close();\n            }\n            else if ((_b = this.client) === null || _b === void 0 ? void 0 : _b.pairing.values) {\n                const sessionForTopic = this.client.pairing.values.find((connection) => connection.topic === topic);\n                console.warn('received session expired for topic', topic, 'which is not the topic of session', (_c = this.session) === null || _c === void 0 ? void 0 : _c.topic, 'session with such topic in storage', sessionForTopic || 'false');\n            }\n        };\n        this.onSessionDeleted = (session) => {\n            this.emit('session_delete', null, session);\n            void this.close().catch((e) => {\n                console.error('error closing session', e);\n            });\n        };\n        this.onSessionEvent = (event) => {\n            this.emit('session_event', null, event);\n        };\n        this.onSessionPing = (ping) => {\n            this.emit('session_ping', null, ping);\n        };\n        this.onSessionRequest = (request) => {\n            this.emit('session_request', null, request);\n        };\n        this.close = () => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            if (!this.client) {\n                throw new Error('Wallet must be initialized before calling close()');\n            }\n            this.canceler.cancel();\n            const reason = (0, utils_1.getSdkError)('USER_DISCONNECTED');\n            const connections = this.client.pairing.values;\n            this.session && this.client.session.delete((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic, reason);\n            yield Promise.all(connections.map((connection) => {\n                try {\n                    console.info('closing wc connection', connection, reason);\n                    return this.client.disconnect({\n                        topic: connection.topic,\n                        reason,\n                    });\n                }\n                catch (e) {\n                    console.error('Error closing wc connection', connection, reason, e);\n                }\n            }));\n            // ensures pairing is deleted so wallet doesnt have a lingering one.\n            if (((_b = this.session) === null || _b === void 0 ? void 0 : _b.topic) && this.client.pairing) {\n                yield ((_c = this.client.pairing) === null || _c === void 0 ? void 0 : _c.delete(this.session.topic, reason));\n            }\n            this.client = undefined;\n            this.session = undefined;\n        });\n        this.canceler = new canceler_1.default();\n        this.initOptions = Object.assign(Object.assign(Object.assign({}, defaultInitOptions), init), { projectId });\n        this.chainId = chainId;\n        void this.getWalletConnectClient()\n            .then((client) => __awaiter(this, void 0, void 0, function* () {\n            this.client = client;\n            this.setupListeners();\n            // when we're in certain environments (like the browser) the\n            // WalletConnect client will handle retrieving old sessions.\n            if (client.session) {\n                const session = client.session\n                    .getAll()\n                    .sort((a, b) => b.expiry - a.expiry)\n                    .find((x) => x.acknowledged && x.expiry * 1000 > Date.now());\n                if (session) {\n                    try {\n                        yield client.extend({\n                            topic: session.topic,\n                        });\n                    }\n                    catch (e) {\n                        debug('session resurrection, extend failed, wallet most likely refuses session extensions', e);\n                    }\n                    this.session = session;\n                    // It might be better not to emit an event here. after all this is a fake event anyway.\n                    this.emit('session_update', null, {\n                        id: 0,\n                        topic: session.topic,\n                        params: { namespaces: session.namespaces },\n                    });\n                }\n            }\n        }))\n            .catch((e) => {\n            debug('session resurrection failed', e);\n            this.emit('session_update', e);\n        });\n    }\n    hasSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield waitForTruthy(() => !!this.session, this.canceler.status);\n        });\n    }\n    setupListeners() {\n        if (!this.client)\n            return;\n        this.client.on('session_proposal', this.onSessionProposal);\n        this.client.on('session_update', this.onSessionUpdated);\n        this.client.on('session_delete', this.onSessionDeleted);\n        // currently when disconnecting the pairing from the offical wc w implementation\n        // https://react-wallet.walletconnect.com/pairings our dapp does not disconnect.\n        this.client.pairing.core.events.on('wc_pairingDeleted', this.onSessionDeleted);\n        this.client.core.on('subscription_deleted', this.onSessionDeleted);\n        this.client.pairing.core.on('wc_pairingDeleted', this.onSessionDeleted);\n        this.client.on('session_extend', this.onSessionExtended);\n        this.client.on('session_event', this.onSessionEvent);\n        this.client.on('session_expire', this.onSessionExpire);\n        this.client.on('session_ping', this.onSessionPing);\n        this.client.on('session_request', this.onSessionRequest);\n    }\n    /**\n     * Pulled out to allow mocking\n     */\n    getWalletConnectClient() {\n        return sign_client_1.default.init(this.initOptions);\n    }\n    switchToChain(params) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.client) {\n                return true;\n            }\n            // check if session already has the desired chain in it by checking accounts and chains\n            const accountSessions = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces) === null || _b === void 0 ? void 0 : _b.eip155) === null || _c === void 0 ? void 0 : _c.accounts) === null || _d === void 0 ? void 0 : _d.filter((eip155ChainAccount) => this.chainId.toString() === (0, utils_2.parseAddress)(eip155ChainAccount).networkId);\n            const chainSessions = (_f = (_e = this.session) === null || _e === void 0 ? void 0 : _e.namespaces.eip155.chains) === null || _f === void 0 ? void 0 : _f.filter((prefixedChain) => prefixedChain === `eip155:${params.chainId}`);\n            if (!(accountSessions === null || accountSessions === void 0 ? void 0 : accountSessions.length) && !(chainSessions === null || chainSessions === void 0 ? void 0 : chainSessions.length)) {\n                const accounts = this.session.namespaces.eip155.accounts;\n                // update the chain data in the session.\n                // this is necessary since we only require the current chain when connecting and some wallets\n                //  might not notice the optional namespace chains and thus not include them on the namespaces when connecting even if they do in fact support them\n                try {\n                    const updatingSession = {\n                        topic: this.session.topic,\n                        namespaces: {\n                            eip155: {\n                                accounts: accounts.concat(accounts.map((account) => {\n                                    return `eip155:${params.chainId}:${(0, utils_2.parseAddress)(account).address}`;\n                                })),\n                                chains: (((_g = this.session) === null || _g === void 0 ? void 0 : _g.namespaces.eip155.chains) || []).concat([\n                                    `eip155:${params.chainId}`,\n                                ]),\n                                methods: this.session.namespaces.eip155.methods,\n                                events: this.session.namespaces.eip155.events,\n                            },\n                        },\n                    };\n                    const resp = yield ((_h = this.client) === null || _h === void 0 ? void 0 : _h.update(updatingSession));\n                    yield (resp === null || resp === void 0 ? void 0 : resp.acknowledged());\n                    // ensure we have the new data on the local session.\n                    this.onSessionUpdated({\n                        id: 0,\n                        topic: updatingSession.topic,\n                        params: { namespaces: updatingSession.namespaces },\n                    });\n                    return true;\n                }\n                catch (e) {\n                    console.error(`switchToChain failed, wallet likely does not support ${params.chainId}`, e);\n                    return false;\n                }\n            }\n            this.chainId = params.chainId;\n            yield this.loadAccountSigners();\n            return true;\n        });\n    }\n    /**\n     * Get the URI needed for out of band session establishment\n     */\n    getUri() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.client = this.client || (yield this.getWalletConnectClient());\n            if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.acknowledged) &&\n                ((_b = this.session) === null || _b === void 0 ? void 0 : _b.expiry) &&\n                ((_c = this.session) === null || _c === void 0 ? void 0 : _c.expiry) * 1000 > Date.now()) {\n                return;\n            }\n            this.setupListeners();\n            // wallets will literally fail if they don't support a chainId in the required namespaces\n            // likewise wallets return an error if they dont support a method in the required namespaces\n            // therefore required really is required and we add new chain to namespaces when switching chains. see switchToChain\n            const { uri, approval } = yield this.client.connect({\n                requiredNamespaces: {\n                    eip155: Object.assign(Object.assign({}, requiredNamespaces.eip155), { chains: [`eip155:${this.chainId}`] }),\n                },\n                optionalNamespaces,\n            });\n            void approval()\n                .then((session) => {\n                console.info('approved session', session);\n                this.session = session;\n                this.emit('session_update', null, {\n                    id: 1,\n                    topic: session.topic,\n                    params: { namespaces: session.namespaces },\n                });\n            })\n                .catch((err) => {\n                this.emit('session_update', err);\n            });\n            return uri;\n        });\n    }\n    loadAccountSigners() {\n        return __awaiter(this, void 0, void 0, function* () {\n            /**\n             * Session establishment happens out of band so after somehow\n             * communicating the connection URI (often via QR code) we can\n             * continue with the setup process\n             */\n            yield waitForTruthy(() => !!this.session, this.canceler.status);\n            if (this.canceler.status.canceled) {\n                // This will be true if this.canceler.cancel() was called earlier\n                throw constants_1.CANCELED;\n            }\n            const addressToSigner = new Map();\n            const allNamespaceAccounts = Object.values(this.session.namespaces)\n                .map((namespace) => namespace.accounts)\n                .flat();\n            // namespace.accounts is an array of chain prefixed addresses,\n            // we should not be assuming that every address can work for every chain. but instead filtering based on chain prefix.\n            allNamespaceAccounts\n                .filter((addressLike) => {\n                const { networkId } = (0, utils_2.parseAddress)(addressLike);\n                return networkId === String(this.chainId); // chain id matches this.chainId\n            })\n                .forEach((addressLike) => {\n                const { address } = (0, utils_2.parseAddress)(addressLike);\n                const signer = new wc_signer_1.WalletConnectSigner(this.client, this.session, address, String(this.chainId));\n                addressToSigner.set(address, signer);\n                this.addSigner(address, signer);\n            });\n            // note the parent of this class has  a private signers map at addressSigners. which is what addSigner and GetSigner access\n            this.signers = addressToSigner;\n            return addressToSigner;\n        });\n    }\n    /**\n     * Gets the signer based on the 'from' field in the tx body\n     * @param txParams Transaction to sign\n     * @dev overrides WalletBase.signTransaction\n     */\n    signTransaction(txParams) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const fromAddress = txParams.from.toString();\n            const signer = this.getSigner(fromAddress);\n            return signer.signRawTransaction(txParams);\n        });\n    }\n}\nexports.WalletConnectWallet = WalletConnectWallet;\n//# sourceMappingURL=wc-wallet.js.map"]},"metadata":{},"sourceType":"script"}