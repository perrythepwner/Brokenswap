{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n  const constTimeNegate = (condition, item) => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = W => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n      windows,\n      windowSize\n    };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm, n) {\n      let p = c.ZERO;\n      let d = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm, W) {\n      const {\n        windows,\n        windowSize\n      } = opts(W);\n      const points = [];\n      let p = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const {\n        windows,\n        windowSize\n      } = opts(W);\n      let p = c.ZERO;\n      let f = c.BASE;\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return {\n        p,\n        f\n      };\n    },\n    wNAFCached(P, precomputesMap, n, transform) {\n      // @ts-ignore\n      const W = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W);\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    }\n  };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n  (0, modular_js_1.validateField)(curve.Fp);\n  (0, utils_js_1.validateObject)(curve, {\n    n: 'bigint',\n    h: 'bigint',\n    Gx: 'field',\n    Gy: 'field'\n  }, {\n    nBitLength: 'isSafeInteger',\n    nByteLength: 'isSafeInteger'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread(_objectSpread(_objectSpread({}, (0, modular_js_1.nLength)(curve.n, curve.nBitLength)), curve), {\n    p: curve.Fp.ORDER\n  }));\n}\nexports.validateBasic = validateBasic;","map":{"version":3,"sources":["../src/abstract/curve.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nexports.validateBasic = validateBasic;\n//# sourceMappingURL=curve.js.map"]},"metadata":{},"sourceType":"script"}