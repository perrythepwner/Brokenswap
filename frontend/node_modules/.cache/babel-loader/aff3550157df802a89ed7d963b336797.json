{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BranchNodeStruct = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * BranchNode whose children's data is represented as a struct, not a tree.\n *\n * This approach is usefull for memory efficiency of data that is not modified often, for example the validators\n * registry in Ethereum consensus `state.validators`. The tradeoff is that getting the hash, are proofs is more\n * expensive because the tree has to be recreated every time.\n */\nclass BranchNodeStruct extends persistent_merkle_tree_1.Node {\n  constructor(valueToNode, value) {\n    // First null value is to save an extra variable to check if a node has a root or not\n    super(null, 0, 0, 0, 0, 0, 0, 0);\n    this.valueToNode = valueToNode;\n    this.value = value;\n  }\n  get rootHashObject() {\n    if (this.h0 === null) {\n      const node = this.valueToNode(this.value);\n      super.applyHash(node.rootHashObject);\n    }\n    return this;\n  }\n  get root() {\n    return persistent_merkle_tree_1.hashObjectToUint8Array(this.rootHashObject);\n  }\n  isLeaf() {\n    return false;\n  }\n  get left() {\n    return this.valueToNode(this.value).left;\n  }\n  get right() {\n    return this.valueToNode(this.value).right;\n  }\n}\nexports.BranchNodeStruct = BranchNodeStruct;","map":null,"metadata":{},"sourceType":"script"}