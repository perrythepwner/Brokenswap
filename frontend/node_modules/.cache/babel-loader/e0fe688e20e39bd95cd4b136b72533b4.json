{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = require(\"superstruct\");\nconst assert_1 = require(\"./assert\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/i);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/i);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n  return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n  return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n  (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n  (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal;\n  }\n  if (hexadecimal.startsWith('0X')) {\n    return \"0x\".concat(hexadecimal.substring(2));\n  }\n  return \"0x\".concat(hexadecimal);\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n  return hexadecimal;\n}\nexports.remove0x = remove0x;","map":{"version":3,"sources":["../src/hex.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,aAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAIa,OAAA,CAAA,SAAS,GAAG,CAAA,CAAA,EAAA,aAAA,CAAA,OAAO,EAAC,CAAA,CAAA,EAAA,aAAA,CAAA,MAAM,EAAA,CAAE,EAAE,qBAAsB,CAAC;AACrD,OAAA,CAAA,eAAe,GAAG,CAAA,CAAA,EAAA,aAAA,CAAA,OAAO,EAAC,CAAA,CAAA,EAAA,aAAA,CAAA,MAAM,EAAA,CAAE,EAAE,gBAAiB,CAGjE;AAED;;;;;AAKG;AACH,SAAgB,WAAW,CAAC,KAAc,EAAA;EACxC,OAAO,CAAA,CAAA,EAAA,aAAA,CAAA,EAAE,EAAC,KAAK,EAAE,OAAA,CAAA,SAAS,CAAC;AAC7B;AAFA,OAAA,CAAA,WAAA,GAAA,WAAA;AAIA;;;;;;AAMG;AACH,SAAgB,iBAAiB,CAAC,KAAc,EAAA;EAC9C,OAAO,CAAA,CAAA,EAAA,aAAA,CAAA,EAAE,EAAC,KAAK,EAAE,OAAA,CAAA,eAAe,CAAC;AACnC;AAFA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAIA;;;;;AAKG;AACH,SAAgB,iBAAiB,CAAC,KAAc,EAAA;EAC9C,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,WAAW,CAAC,KAAK,CAAC,EAAE,qCAAqC,CAAC;AACnE;AAFA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAIA;;;;;;AAMG;AACH,SAAgB,uBAAuB,CAAC,KAAc,EAAA;EACpD,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EACJ,iBAAiB,CAAC,KAAK,CAAC,EACxB,yDAAyD,CAC1D;AACH;AALA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAOA;;;;;;AAMG;AACH,SAAgB,KAAK,CAAC,WAAmB,EAAA;EACvC,IAAI,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;IAChC,OAAO,WAAkB;EAC1B;EAED,IAAI,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;IAChC,YAAA,MAAA,CAAY,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC;EACrC;EAED,YAAA,MAAA,CAAY,WAAW;AACzB;AAVA,OAAA,CAAA,KAAA,GAAA,KAAA;AAYA;;;;;;AAMG;AACH,SAAgB,QAAQ,CAAC,WAAmB,EAAA;EAC1C,IAAI,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;IAChE,OAAO,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC;EAChC;EAED,OAAO,WAAW;AACpB;AANA,OAAA,CAAA,QAAA,GAAA,QAAA","sourcesContent":["import { is, pattern, string, Struct } from 'superstruct';\n\nimport { assert } from './assert';\n\nexport type Hex = `0x${string}`;\n\nexport const HexStruct = pattern(string(), /^(?:0x)?[0-9a-f]+$/iu);\nexport const StrictHexStruct = pattern(string(), /^0x[0-9a-f]+$/iu) as Struct<\n  Hex,\n  null\n>;\n\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value: unknown): value is string {\n  return is(value, HexStruct);\n}\n\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value: unknown): value is Hex {\n  return is(value, StrictHexStruct);\n}\n\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value: unknown): asserts value is string {\n  assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value: unknown): asserts value is Hex {\n  assert(\n    isStrictHexString(value),\n    'Value must be a hexadecimal string, starting with \"0x\".',\n  );\n}\n\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal: string): Hex {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal as Hex;\n  }\n\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n\n  return `0x${hexadecimal}`;\n}\n\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal: string): string {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n\n  return hexadecimal;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}