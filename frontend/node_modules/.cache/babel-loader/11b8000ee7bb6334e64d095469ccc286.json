{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BranchNodeStruct = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * BranchNode whose children's data is represented as a struct, not a tree.\n *\n * This approach is usefull for memory efficiency of data that is not modified often, for example the validators\n * registry in Ethereum consensus `state.validators`. The tradeoff is that getting the hash, are proofs is more\n * expensive because the tree has to be recreated every time.\n */\nclass BranchNodeStruct extends persistent_merkle_tree_1.Node {\n  constructor(valueToNode, value) {\n    // First null value is to save an extra variable to check if a node has a root or not\n    super(null, 0, 0, 0, 0, 0, 0, 0);\n    this.valueToNode = valueToNode;\n    this.value = value;\n  }\n  get rootHashObject() {\n    if (this.h0 === null) {\n      const node = this.valueToNode(this.value);\n      super.applyHash(node.rootHashObject);\n    }\n    return this;\n  }\n  get root() {\n    return persistent_merkle_tree_1.hashObjectToUint8Array(this.rootHashObject);\n  }\n  isLeaf() {\n    return false;\n  }\n  get left() {\n    return this.valueToNode(this.value).left;\n  }\n  get right() {\n    return this.valueToNode(this.value).right;\n  }\n}\nexports.BranchNodeStruct = BranchNodeStruct;","map":{"version":3,"sources":["../src/branchNodeStruct.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AAEA;;;;;;AAMG;AACH,MAAa,gBAAoB,SAAQ,wBAAA,CAAA,IAAI,CAAA;EAC3C,WAAA,CAA6B,WAA+B,EAAW,KAAQ,EAAA;IAC7E;IACA,KAAK,CAAC,IAAyB,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAF1B,IAAA,CAAA,WAAW,GAAX,WAAW;IAA+B,IAAA,CAAA,KAAK,GAAL,KAAK;EAG5E;EAEA,IAAI,cAAc,CAAA,EAAA;IAChB,IAAI,IAAI,CAAC,EAAE,KAAK,IAAI,EAAE;MACpB,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;MACzC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC;IACrC;IACD,OAAO,IAAI;EACb;EAEA,IAAI,IAAI,CAAA,EAAA;IACN,OAAO,wBAAA,CAAA,sBAAsB,CAAC,IAAI,CAAC,cAAc,CAAC;EACpD;EAEA,MAAM,CAAA,EAAA;IACJ,OAAO,KAAK;EACd;EAEA,IAAI,IAAI,CAAA,EAAA;IACN,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI;EAC1C;EAEA,IAAI,KAAK,CAAA,EAAA;IACP,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK;EAC3C;AACD;AA7BD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BranchNodeStruct = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/**\n * BranchNode whose children's data is represented as a struct, not a tree.\n *\n * This approach is usefull for memory efficiency of data that is not modified often, for example the validators\n * registry in Ethereum consensus `state.validators`. The tradeoff is that getting the hash, are proofs is more\n * expensive because the tree has to be recreated every time.\n */\nclass BranchNodeStruct extends persistent_merkle_tree_1.Node {\n    constructor(valueToNode, value) {\n        // First null value is to save an extra variable to check if a node has a root or not\n        super(null, 0, 0, 0, 0, 0, 0, 0);\n        this.valueToNode = valueToNode;\n        this.value = value;\n    }\n    get rootHashObject() {\n        if (this.h0 === null) {\n            const node = this.valueToNode(this.value);\n            super.applyHash(node.rootHashObject);\n        }\n        return this;\n    }\n    get root() {\n        return persistent_merkle_tree_1.hashObjectToUint8Array(this.rootHashObject);\n    }\n    isLeaf() {\n        return false;\n    }\n    get left() {\n        return this.valueToNode(this.value).left;\n    }\n    get right() {\n        return this.valueToNode(this.value).right;\n    }\n}\nexports.BranchNodeStruct = BranchNodeStruct;\n//# sourceMappingURL=branchNodeStruct.js.map"]},"metadata":{},"sourceType":"script"}