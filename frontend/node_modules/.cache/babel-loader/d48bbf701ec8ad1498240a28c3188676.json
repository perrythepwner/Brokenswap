{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isReactNative, isWsUrl, isLocalhostUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nimport { truncateQuery, resolveWebSocketImplementation, hasBuiltInWebSocket } from \"./utils\";\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nconst WS = resolveWebSocketImplementation();\nexport class WsConnection {\n  constructor(url) {\n    this.url = url;\n    this.events = new EventEmitter();\n    this.registering = false;\n    if (!isWsUrl(url)) {\n      throw new Error(\"Provided URL is not compatible with WebSocket connection: \".concat(url));\n    }\n    this.url = url;\n  }\n  get connected() {\n    return typeof this.socket !== \"undefined\";\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n  open() {\n    var _arguments = arguments,\n      _this = this;\n    return _asyncToGenerator(function* () {\n      let url = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : _this.url;\n      yield _this.register(url);\n    })();\n  }\n  close() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        if (typeof _this2.socket === \"undefined\") {\n          reject(new Error(\"Connection already closed\"));\n          return;\n        }\n        _this2.socket.onclose = event => {\n          _this2.onClose(event);\n          resolve();\n        };\n        _this2.socket.close();\n      });\n    })();\n  }\n  send(payload, context) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof _this3.socket === \"undefined\") {\n        _this3.socket = yield _this3.register();\n      }\n      try {\n        _this3.socket.send(safeJsonStringify(payload));\n      } catch (e) {\n        _this3.onError(payload.id, e);\n      }\n    })();\n  }\n  register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    if (!isWsUrl(url)) {\n      throw new Error(\"Provided URL is not compatible with WebSocket connection: \".concat(url));\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (this.events.listenerCount(\"register_error\") >= currentMaxListeners || this.events.listenerCount(\"open\") >= currentMaxListeners) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.socket === \"undefined\") {\n            return reject(new Error(\"WebSocket connection is missing or invalid\"));\n          }\n          resolve(this.socket);\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n    return new Promise((resolve, reject) => {\n      const opts = !isReactNative() ? {\n        rejectUnauthorized: !isLocalhostUrl(url)\n      } : undefined;\n      const socket = new WS(url, [], opts);\n      if (hasBuiltInWebSocket()) {\n        socket.onerror = event => {\n          const errorEvent = event;\n          reject(this.emitError(errorEvent.error));\n        };\n      } else {\n        socket.on(\"error\", errorEvent => {\n          reject(this.emitError(errorEvent));\n        });\n      }\n      socket.onopen = () => {\n        this.onOpen(socket);\n        resolve(socket);\n      };\n    });\n  }\n  onOpen(socket) {\n    socket.onmessage = event => this.onPayload(event);\n    socket.onclose = event => this.onClose(event);\n    this.socket = socket;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n  onClose(event) {\n    this.socket = undefined;\n    this.registering = false;\n    this.events.emit(\"close\", event);\n  }\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, truncateQuery(url), \"WS\");\n  }\n  resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n  emitError(errorEvent) {\n    const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || \"WebSocket connection failed for host: \".concat(truncateQuery(this.url))));\n    this.events.emit(\"register_error\", error);\n    return error;\n  }\n}\nexport default WsConnection;","map":{"version":3,"sources":["../../src/ws.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isReactNative, isWsUrl, isLocalhostUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nimport { truncateQuery, resolveWebSocketImplementation, hasBuiltInWebSocket } from \"./utils\";\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nconst WS = resolveWebSocketImplementation();\nexport class WsConnection {\n    constructor(url) {\n        this.url = url;\n        this.events = new EventEmitter();\n        this.registering = false;\n        if (!isWsUrl(url)) {\n            throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n        }\n        this.url = url;\n    }\n    get connected() {\n        return typeof this.socket !== \"undefined\";\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        return new Promise((resolve, reject) => {\n            if (typeof this.socket === \"undefined\") {\n                reject(new Error(\"Connection already closed\"));\n                return;\n            }\n            this.socket.onclose = event => {\n                this.onClose(event);\n                resolve();\n            };\n            this.socket.close();\n        });\n    }\n    async send(payload, context) {\n        if (typeof this.socket === \"undefined\") {\n            this.socket = await this.register();\n        }\n        try {\n            this.socket.send(safeJsonStringify(payload));\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    register(url = this.url) {\n        if (!isWsUrl(url)) {\n            throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n        }\n        if (this.registering) {\n            const currentMaxListeners = this.events.getMaxListeners();\n            if (this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n                this.events.listenerCount(\"open\") >= currentMaxListeners) {\n                this.events.setMaxListeners(currentMaxListeners + 1);\n            }\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    this.resetMaxListeners();\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    this.resetMaxListeners();\n                    if (typeof this.socket === \"undefined\") {\n                        return reject(new Error(\"WebSocket connection is missing or invalid\"));\n                    }\n                    resolve(this.socket);\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        return new Promise((resolve, reject) => {\n            const opts = !isReactNative() ? { rejectUnauthorized: !isLocalhostUrl(url) } : undefined;\n            const socket = new WS(url, [], opts);\n            if (hasBuiltInWebSocket()) {\n                socket.onerror = (event) => {\n                    const errorEvent = event;\n                    reject(this.emitError(errorEvent.error));\n                };\n            }\n            else {\n                socket.on(\"error\", (errorEvent) => {\n                    reject(this.emitError(errorEvent));\n                });\n            }\n            socket.onopen = () => {\n                this.onOpen(socket);\n                resolve(socket);\n            };\n        });\n    }\n    onOpen(socket) {\n        socket.onmessage = (event) => this.onPayload(event);\n        socket.onclose = event => this.onClose(event);\n        this.socket = socket;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose(event) {\n        this.socket = undefined;\n        this.registering = false;\n        this.events.emit(\"close\", event);\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, truncateQuery(url), \"WS\");\n    }\n    resetMaxListeners() {\n        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n            this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n        }\n    }\n    emitError(errorEvent) {\n        const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for host: ${truncateQuery(this.url)}`));\n        this.events.emit(\"register_error\", error);\n        return error;\n    }\n}\nexport default WsConnection;\n//# sourceMappingURL=ws.js.map"]},"metadata":{},"sourceType":"module"}