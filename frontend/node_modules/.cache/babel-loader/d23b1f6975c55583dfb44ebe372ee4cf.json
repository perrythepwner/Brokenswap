{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst utils_1 = require(\"ethereum-cryptography/utils\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\nconst _0n = BigInt(0);\nclass Account {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  constructor() {\n    let nonce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _0n;\n    let balance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _0n;\n    let storageRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.KECCAK256_RLP;\n    let codeHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.KECCAK256_NULL;\n    this.nonce = nonce;\n    this.balance = balance;\n    this.storageRoot = storageRoot;\n    this.codeHash = codeHash;\n    this._validate();\n  }\n  static fromAccountData(accountData) {\n    const {\n      nonce,\n      balance,\n      storageRoot,\n      codeHash\n    } = accountData;\n    return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  }\n  static fromRlpSerializedAccount(serialized) {\n    const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n    return this.fromValuesArray(values);\n  }\n  static fromValuesArray(values) {\n    const [nonce, balance, storageRoot, codeHash] = values;\n    return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n  }\n  _validate() {\n    if (this.nonce < _0n) {\n      throw new Error('nonce must be greater than zero');\n    }\n    if (this.balance < _0n) {\n      throw new Error('balance must be greater than zero');\n    }\n    if (this.storageRoot.length !== 32) {\n      throw new Error('storageRoot must have a length of 32');\n    }\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  }\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n  raw() {\n    return [(0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce), (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance), this.storageRoot, this.codeHash];\n  }\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n  serialize() {\n    return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n  }\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract() {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty() {\n    return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function isValidAddress(hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function toChecksumAddress(hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  let prefix = '';\n  if (eip1191ChainId !== undefined) {\n    const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n    prefix = chainId.toString() + '0x';\n  }\n  const buf = Buffer.from(prefix + address, 'utf8');\n  const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n  let ret = '0x';\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function isValidChecksumAddress(hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function generateAddress(from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n  if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function generateAddress2(from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n  if (from.length !== 20) {\n    throw new Error('Expected from to be of length 20');\n  }\n  if (salt.length !== 32) {\n    throw new Error('Expected salt to be of length 32');\n  }\n  const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n  return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function isValidPrivate(privateKey) {\n  return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function isValidPublic(publicKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  if (!sanitize) {\n    return false;\n  }\n  try {\n    secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function pubToAddress(pubKey) {\n  let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  (0, helpers_1.assertIsBuffer)(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n  }\n  if (pubKey.length !== 64) {\n    throw new Error('Expected pubKey to be of length 64');\n  }\n  // Only take the lower 160bits of the hash\n  return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function privateToPublic(privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey);\n  // skip the type flag and use the X, Y points\n  return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function privateToAddress(privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function importPublic(publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n  }\n  return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function zeroAddress() {\n  const addressLength = 20;\n  const addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function isZeroAddress(hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n  const zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n  const [nonce, balance, storageRoot, codeHash] = body;\n  return [nonce, balance, (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot, (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body) {\n  let couldBeSlim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n  return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = require(\"@ethereumjs/rlp\");\nconst keccak_1 = require(\"ethereum-cryptography/keccak\");\nconst secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nconst utils_1 = require(\"ethereum-cryptography/utils\");\nconst bytes_1 = require(\"./bytes\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nconst internal_1 = require(\"./internal\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance < _0n) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error('storageRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash,\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nconst isValidAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nconst toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = '';\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + '0x';\n    }\n    const buf = Buffer.from(prefix + address, 'utf8');\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = '0x';\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nconst isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nconst generateAddress = function (from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nconst generateAddress2 = function (from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error('Expected from to be of length 20');\n    }\n    if (salt.length !== 32) {\n        throw new Error('Expected salt to be of length 32');\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, keccak_1.keccak256)(initCode)]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nconst isValidPrivate = function (privateKey) {\n    return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst isValidPublic = function (publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nconst pubToAddress = function (pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error('Expected pubKey to be of length 64');\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToPublic = function (privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nconst privateToAddress = function (privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\nconst importPublic = function (publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\nconst zeroAddress = function () {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\nconst isZeroAddress = function (hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash,\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */\nfunction accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP;\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}