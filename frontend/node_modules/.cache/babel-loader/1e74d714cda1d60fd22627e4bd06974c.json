{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BooleanType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/**\n * Boolean: True or False\n * - Notation: `boolean`\n */\nclass BooleanType extends basic_1.BasicType {\n  constructor(opts) {\n    var _opts$typeName;\n    super();\n    this.byteLength = 1;\n    this.itemsPerChunk = 32;\n    this.fixedSize = 1;\n    this.minSize = 1;\n    this.maxSize = 1;\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"boolean\";\n  }\n  static named(opts) {\n    return new (named_1.namedClass(BooleanType, opts.typeName))(opts);\n  }\n  defaultValue() {\n    return false;\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value ? 1 : 0;\n    return offset + 1;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    switch (data.uint8Array[start]) {\n      case 1:\n        return true;\n      case 0:\n        return false;\n      default:\n        throw new Error(\"Boolean: invalid value: \".concat(data.uint8Array[start]));\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    // TODO: Assumes LeafNode has 4 byte uints are primary unit\n    output.uint8Array[offset] = node.getUint(4, 0);\n    return offset + 1;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = data.uint8Array[start];\n    if (value > 1) {\n      throw Error(\"Boolean: invalid value \".concat(value));\n    }\n    return persistent_merkle_tree_1.LeafNode.fromUint32(value);\n  }\n  // Fast tree opts\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(4, 0) === 1;\n  }\n  tree_setToNode(leafNode, value) {\n    leafNode.setUint(4, 0, value ? 1 : 0);\n  }\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = index % this.itemsPerChunk;\n    return leafNode.getUint(1, offsetBytes) !== 0;\n  }\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = index % this.itemsPerChunk;\n    leafNode.setUint(1, offsetBytes, value ? 1 : 0);\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"boolean\") {\n      throw Error(\"JSON invalid type \".concat(typeof json, \" expected boolean\"));\n    }\n    return json;\n  }\n  toJson(value) {\n    return value;\n  }\n}\nexports.BooleanType = BooleanType;","map":{"version":3,"sources":["../../src/type/boolean.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BooleanType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/**\n * Boolean: True or False\n * - Notation: `boolean`\n */\nclass BooleanType extends basic_1.BasicType {\n    constructor(opts) {\n        super();\n        this.byteLength = 1;\n        this.itemsPerChunk = 32;\n        this.fixedSize = 1;\n        this.minSize = 1;\n        this.maxSize = 1;\n        this.typeName = opts?.typeName ?? \"boolean\";\n    }\n    static named(opts) {\n        return new (named_1.namedClass(BooleanType, opts.typeName))(opts);\n    }\n    defaultValue() {\n        return false;\n    }\n    // Serialization + deserialization\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array[offset] = value ? 1 : 0;\n        return offset + 1;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        switch (data.uint8Array[start]) {\n            case 1:\n                return true;\n            case 0:\n                return false;\n            default:\n                throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);\n        }\n    }\n    tree_serializeToBytes(output, offset, node) {\n        // TODO: Assumes LeafNode has 4 byte uints are primary unit\n        output.uint8Array[offset] = node.getUint(4, 0);\n        return offset + 1;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        const value = data.uint8Array[start];\n        if (value > 1) {\n            throw Error(`Boolean: invalid value ${value}`);\n        }\n        return persistent_merkle_tree_1.LeafNode.fromUint32(value);\n    }\n    // Fast tree opts\n    tree_getFromNode(leafNode) {\n        return leafNode.getUint(4, 0) === 1;\n    }\n    tree_setToNode(leafNode, value) {\n        leafNode.setUint(4, 0, value ? 1 : 0);\n    }\n    tree_getFromPackedNode(leafNode, index) {\n        const offsetBytes = index % this.itemsPerChunk;\n        return leafNode.getUint(1, offsetBytes) !== 0;\n    }\n    tree_setToPackedNode(leafNode, index, value) {\n        const offsetBytes = index % this.itemsPerChunk;\n        leafNode.setUint(1, offsetBytes, value ? 1 : 0);\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json !== \"boolean\") {\n            throw Error(`JSON invalid type ${typeof json} expected boolean`);\n        }\n        return json;\n    }\n    toJson(value) {\n        return value;\n    }\n}\nexports.BooleanType = BooleanType;\n//# sourceMappingURL=boolean.js.map"]},"metadata":{},"sourceType":"script"}