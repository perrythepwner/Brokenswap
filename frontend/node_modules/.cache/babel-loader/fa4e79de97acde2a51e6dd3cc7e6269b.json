{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Either_1 = require(\"fp-ts/lib/Either\");\nvar map = Either_1.either.map;\nvar chain = Either_1.either.chain;\n/**\n * @since 1.0.0\n */\nvar Type = /** @class */function () {\n  function Type( /** a unique name for this codec */\n  name, /** a custom type guard */\n  is, /** succeeds if a value of type I can be decoded to a value of type A */\n  validate, /** converts a value of type A to a value of type O */\n  encode) {\n    this.name = name;\n    this.is = is;\n    this.validate = validate;\n    this.encode = encode;\n    this.decode = this.decode.bind(this);\n  }\n  /**\n   * @since 1.0.0\n   */\n  Type.prototype.pipe = function (ab, name) {\n    var _this = this;\n    if (name === void 0) {\n      name = \"pipe(\" + this.name + \", \" + ab.name + \")\";\n    }\n    return new Type(name, ab.is, function (i, c) {\n      return chain(_this.validate(i, c), function (a) {\n        return ab.validate(a, c);\n      });\n    }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function (b) {\n      return _this.encode(ab.encode(b));\n    });\n  };\n  /**\n   * @since 1.0.0\n   */\n  Type.prototype.asDecoder = function () {\n    return this;\n  };\n  /**\n   * @since 1.0.0\n   */\n  Type.prototype.asEncoder = function () {\n    return this;\n  };\n  /**\n   * a version of `validate` with a default context\n   * @since 1.0.0\n   */\n  Type.prototype.decode = function (i) {\n    return this.validate(i, [{\n      key: '',\n      type: this,\n      actual: i\n    }]);\n  };\n  return Type;\n}();\nexports.Type = Type;\n/**\n * @since 1.0.0\n */\nexports.identity = function (a) {\n  return a;\n};\n/**\n * @since 1.0.0\n */\nexports.getFunctionName = function (f) {\n  return f.displayName || f.name || \"<function\" + f.length + \">\";\n};\n/**\n * @since 1.0.0\n */\nexports.getContextEntry = function (key, decoder) {\n  return {\n    key: key,\n    type: decoder\n  };\n};\n/**\n * @since 1.0.0\n */\nexports.appendContext = function (c, key, decoder, actual) {\n  var len = c.length;\n  var r = Array(len + 1);\n  for (var i = 0; i < len; i++) {\n    r[i] = c[i];\n  }\n  r[len] = {\n    key: key,\n    type: decoder,\n    actual: actual\n  };\n  return r;\n};\n/**\n * @since 1.0.0\n */\nexports.failures = Either_1.left;\n/**\n * @since 1.0.0\n */\nexports.failure = function (value, context, message) {\n  return exports.failures([{\n    value: value,\n    context: context,\n    message: message\n  }]);\n};\n/**\n * @since 1.0.0\n */\nexports.success = Either_1.right;\nvar pushAll = function pushAll(xs, ys) {\n  var l = ys.length;\n  for (var i = 0; i < l; i++) {\n    xs.push(ys[i]);\n  }\n};\nvar getIsCodec = function getIsCodec(tag) {\n  return function (codec) {\n    return codec._tag === tag;\n  };\n};\nvar isUnknownCodec = getIsCodec('UnknownType');\n// tslint:disable-next-line: deprecation\nvar isAnyCodec = getIsCodec('AnyType');\nvar isInterfaceCodec = getIsCodec('InterfaceType');\nvar isPartialCodec = getIsCodec('PartialType');\n//\n// basic types\n//\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */function (_super) {\n  __extends(NullType, _super);\n  function NullType() {\n    var _this = _super.call(this, 'null', function (u) {\n      return u === null;\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'NullType';\n    return _this;\n  }\n  return NullType;\n}(Type);\nexports.NullType = NullType;\n/**\n * @since 1.0.0\n */\nexports.nullType = new NullType();\nexports.null = exports.nullType;\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */function (_super) {\n  __extends(UndefinedType, _super);\n  function UndefinedType() {\n    var _this = _super.call(this, 'undefined', function (u) {\n      return u === void 0;\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'UndefinedType';\n    return _this;\n  }\n  return UndefinedType;\n}(Type);\nexports.UndefinedType = UndefinedType;\nvar undefinedType = new UndefinedType();\nexports.undefined = undefinedType;\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */function (_super) {\n  __extends(VoidType, _super);\n  function VoidType() {\n    var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, exports.identity) || this;\n    _this._tag = 'VoidType';\n    return _this;\n  }\n  return VoidType;\n}(Type);\nexports.VoidType = VoidType;\n/**\n * @since 1.2.0\n */\nexports.voidType = new VoidType();\nexports.void = exports.voidType;\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */function (_super) {\n  __extends(UnknownType, _super);\n  function UnknownType() {\n    var _this = _super.call(this, 'unknown', function (_) {\n      return true;\n    }, exports.success, exports.identity) || this;\n    _this._tag = 'UnknownType';\n    return _this;\n  }\n  return UnknownType;\n}(Type);\nexports.UnknownType = UnknownType;\n/**\n * @since 1.5.0\n */\nexports.unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */function (_super) {\n  __extends(StringType, _super);\n  function StringType() {\n    var _this = _super.call(this, 'string', function (u) {\n      return typeof u === 'string';\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'StringType';\n    return _this;\n  }\n  return StringType;\n}(Type);\nexports.StringType = StringType;\n/**\n * @since 1.0.0\n */\nexports.string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */function (_super) {\n  __extends(NumberType, _super);\n  function NumberType() {\n    var _this = _super.call(this, 'number', function (u) {\n      return typeof u === 'number';\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'NumberType';\n    return _this;\n  }\n  return NumberType;\n}(Type);\nexports.NumberType = NumberType;\n/**\n * @since 1.0.0\n */\nexports.number = new NumberType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */function (_super) {\n  __extends(BooleanType, _super);\n  function BooleanType() {\n    var _this = _super.call(this, 'boolean', function (u) {\n      return typeof u === 'boolean';\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'BooleanType';\n    return _this;\n  }\n  return BooleanType;\n}(Type);\nexports.BooleanType = BooleanType;\n/**\n * @since 1.0.0\n */\nexports.boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */function (_super) {\n  __extends(AnyArrayType, _super);\n  function AnyArrayType() {\n    var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'AnyArrayType';\n    return _this;\n  }\n  return AnyArrayType;\n}(Type);\nexports.AnyArrayType = AnyArrayType;\n/**\n * @since 1.7.1\n */\nexports.UnknownArray = new AnyArrayType();\nexports.Array = exports.UnknownArray;\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */function (_super) {\n  __extends(AnyDictionaryType, _super);\n  function AnyDictionaryType() {\n    var _this = _super.call(this, 'UnknownRecord', function (u) {\n      return u !== null && typeof u === 'object';\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'AnyDictionaryType';\n    return _this;\n  }\n  return AnyDictionaryType;\n}(Type);\nexports.AnyDictionaryType = AnyDictionaryType;\n/**\n * @since 1.7.1\n */\nexports.UnknownRecord = new AnyDictionaryType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar FunctionType = /** @class */function (_super) {\n  __extends(FunctionType, _super);\n  function FunctionType() {\n    var _this = _super.call(this, 'Function',\n    // tslint:disable-next-line:strict-type-predicates\n    function (u) {\n      return typeof u === 'function';\n    }, function (u, c) {\n      return _this.is(u) ? exports.success(u) : exports.failure(u, c);\n    }, exports.identity) || this;\n    _this._tag = 'FunctionType';\n    return _this;\n  }\n  return FunctionType;\n}(Type);\nexports.FunctionType = FunctionType;\n/**\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */function (_super) {\n  __extends(RefinementType, _super);\n  function RefinementType(name, is, validate, encode, type, predicate) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.type = type;\n    _this.predicate = predicate;\n    _this._tag = 'RefinementType';\n    return _this;\n  }\n  return RefinementType;\n}(Type);\nexports.RefinementType = RefinementType;\n/**\n * @since 1.8.1\n */\nexports.brand = function (codec, predicate, name) {\n  // tslint:disable-next-line: deprecation\n  return refinement(codec, predicate, name);\n};\n/**\n * A branded codec representing an integer\n * @since 1.8.1\n */\nexports.Int = exports.brand(exports.number, function (n) {\n  return Number.isInteger(n);\n}, 'Int');\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */function (_super) {\n  __extends(LiteralType, _super);\n  function LiteralType(name, is, validate, encode, value) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.value = value;\n    _this._tag = 'LiteralType';\n    return _this;\n  }\n  return LiteralType;\n}(Type);\nexports.LiteralType = LiteralType;\n/**\n * @since 1.0.0\n */\nexports.literal = function (value, name) {\n  if (name === void 0) {\n    name = JSON.stringify(value);\n  }\n  var is = function is(u) {\n    return u === value;\n  };\n  return new LiteralType(name, is, function (u, c) {\n    return is(u) ? exports.success(value) : exports.failure(u, c);\n  }, exports.identity, value);\n};\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */function (_super) {\n  __extends(KeyofType, _super);\n  function KeyofType(name, is, validate, encode, keys) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.keys = keys;\n    _this._tag = 'KeyofType';\n    return _this;\n  }\n  return KeyofType;\n}(Type);\nexports.KeyofType = KeyofType;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @since 1.0.0\n */\nexports.keyof = function (keys, name) {\n  if (name === void 0) {\n    name = Object.keys(keys).map(function (k) {\n      return JSON.stringify(k);\n    }).join(' | ');\n  }\n  var is = function is(u) {\n    return exports.string.is(u) && hasOwnProperty.call(keys, u);\n  };\n  return new KeyofType(name, is, function (u, c) {\n    return is(u) ? exports.success(u) : exports.failure(u, c);\n  }, exports.identity, keys);\n};\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */function (_super) {\n  __extends(RecursiveType, _super);\n  function RecursiveType(name, is, validate, encode, runDefinition) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.runDefinition = runDefinition;\n    _this._tag = 'RecursiveType';\n    return _this;\n  }\n  Object.defineProperty(RecursiveType.prototype, \"type\", {\n    get: function get() {\n      return this.runDefinition();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RecursiveType;\n}(Type);\nexports.RecursiveType = RecursiveType;\n/**\n * @since 1.0.0\n */\nexports.recursion = function (name, definition) {\n  var cache;\n  var runDefinition = function runDefinition() {\n    if (!cache) {\n      cache = definition(Self);\n      cache.name = name;\n    }\n    return cache;\n  };\n  var Self = new RecursiveType(name, function (u) {\n    return runDefinition().is(u);\n  }, function (u, c) {\n    return runDefinition().validate(u, c);\n  }, function (a) {\n    return runDefinition().encode(a);\n  }, runDefinition);\n  return Self;\n};\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */function (_super) {\n  __extends(ArrayType, _super);\n  function ArrayType(name, is, validate, encode, type) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.type = type;\n    _this._tag = 'ArrayType';\n    return _this;\n  }\n  return ArrayType;\n}(Type);\nexports.ArrayType = ArrayType;\n/**\n * @since 1.0.0\n */\nexports.array = function (codec, name) {\n  if (name === void 0) {\n    name = \"Array<\" + codec.name + \">\";\n  }\n  return new ArrayType(name, function (u) {\n    return exports.UnknownArray.is(u) && u.every(codec.is);\n  }, function (u, c) {\n    return chain(exports.UnknownArray.validate(u, c), function (us) {\n      var len = us.length;\n      var as = us;\n      var errors = [];\n      for (var i = 0; i < len; i++) {\n        var ui = us[i];\n        var result = codec.validate(ui, exports.appendContext(c, String(i), codec, ui));\n        if (Either_1.isLeft(result)) {\n          pushAll(errors, result.left);\n        } else {\n          var ai = result.right;\n          if (ai !== ui) {\n            if (as === us) {\n              as = us.slice();\n            }\n            as[i] = ai;\n          }\n        }\n      }\n      return errors.length > 0 ? exports.failures(errors) : exports.success(as);\n    });\n  }, codec.encode === exports.identity ? exports.identity : function (a) {\n    return a.map(codec.encode);\n  }, codec);\n};\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */function (_super) {\n  __extends(InterfaceType, _super);\n  function InterfaceType(name, is, validate, encode, props) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.props = props;\n    _this._tag = 'InterfaceType';\n    return _this;\n  }\n  return InterfaceType;\n}(Type);\nexports.InterfaceType = InterfaceType;\nvar getNameFromProps = function getNameFromProps(props) {\n  return Object.keys(props).map(function (k) {\n    return k + \": \" + props[k].name;\n  }).join(', ');\n};\nvar useIdentity = function useIdentity(codecs) {\n  for (var i = 0; i < codecs.length; i++) {\n    if (codecs[i].encode !== exports.identity) {\n      return false;\n    }\n  }\n  return true;\n};\nvar getInterfaceTypeName = function getInterfaceTypeName(props) {\n  return \"{ \" + getNameFromProps(props) + \" }\";\n};\n/**\n * @since 1.0.0\n */\nexports.type = function (props, name) {\n  if (name === void 0) {\n    name = getInterfaceTypeName(props);\n  }\n  var keys = Object.keys(props);\n  var types = keys.map(function (key) {\n    return props[key];\n  });\n  var len = keys.length;\n  return new InterfaceType(name, function (u) {\n    if (!exports.UnknownRecord.is(u)) {\n      return false;\n    }\n    for (var i = 0; i < len; i++) {\n      var k = keys[i];\n      if (!hasOwnProperty.call(u, k) || !types[i].is(u[k])) {\n        return false;\n      }\n    }\n    return true;\n  }, function (u, c) {\n    return chain(exports.UnknownRecord.validate(u, c), function (o) {\n      var a = o;\n      var errors = [];\n      for (var i = 0; i < len; i++) {\n        var k = keys[i];\n        if (!hasOwnProperty.call(a, k)) {\n          if (a === o) {\n            a = __assign({}, o);\n          }\n          a[k] = a[k];\n        }\n        var ak = a[k];\n        var type_1 = types[i];\n        var result = type_1.validate(ak, exports.appendContext(c, k, type_1, ak));\n        if (Either_1.isLeft(result)) {\n          pushAll(errors, result.left);\n        } else {\n          var vak = result.right;\n          if (vak !== ak) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = __assign({}, o);\n            }\n            a[k] = vak;\n          }\n        }\n      }\n      return errors.length > 0 ? exports.failures(errors) : exports.success(a);\n    });\n  }, useIdentity(types) ? exports.identity : function (a) {\n    var s = __assign({}, a);\n    for (var i = 0; i < len; i++) {\n      var k = keys[i];\n      var encode = types[i].encode;\n      if (encode !== exports.identity) {\n        s[k] = encode(a[k]);\n      }\n    }\n    return s;\n  }, props);\n};\nexports.interface = exports.type;\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */function (_super) {\n  __extends(PartialType, _super);\n  function PartialType(name, is, validate, encode, props) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.props = props;\n    _this._tag = 'PartialType';\n    return _this;\n  }\n  return PartialType;\n}(Type);\nexports.PartialType = PartialType;\nvar getPartialTypeName = function getPartialTypeName(inner) {\n  return \"Partial<\" + inner + \">\";\n};\n/**\n * @since 1.0.0\n */\nexports.partial = function (props, name) {\n  if (name === void 0) {\n    name = getPartialTypeName(getInterfaceTypeName(props));\n  }\n  var keys = Object.keys(props);\n  var types = keys.map(function (key) {\n    return props[key];\n  });\n  var len = keys.length;\n  return new PartialType(name, function (u) {\n    if (!exports.UnknownRecord.is(u)) {\n      return false;\n    }\n    for (var i = 0; i < len; i++) {\n      var k = keys[i];\n      var uk = u[k];\n      if (uk !== undefined && !props[k].is(uk)) {\n        return false;\n      }\n    }\n    return true;\n  }, function (u, c) {\n    return chain(exports.UnknownRecord.validate(u, c), function (o) {\n      var a = o;\n      var errors = [];\n      for (var i = 0; i < len; i++) {\n        var k = keys[i];\n        var ak = a[k];\n        var type_2 = props[k];\n        var result = type_2.validate(ak, exports.appendContext(c, k, type_2, ak));\n        if (Either_1.isLeft(result)) {\n          if (ak !== undefined) {\n            pushAll(errors, result.left);\n          }\n        } else {\n          var vak = result.right;\n          if (vak !== ak) {\n            /* istanbul ignore next */\n            if (a === o) {\n              a = __assign({}, o);\n            }\n            a[k] = vak;\n          }\n        }\n      }\n      return errors.length > 0 ? exports.failures(errors) : exports.success(a);\n    });\n  }, useIdentity(types) ? exports.identity : function (a) {\n    var s = __assign({}, a);\n    for (var i = 0; i < len; i++) {\n      var k = keys[i];\n      var ak = a[k];\n      if (ak !== undefined) {\n        s[k] = types[i].encode(ak);\n      }\n    }\n    return s;\n  }, props);\n};\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */function (_super) {\n  __extends(DictionaryType, _super);\n  function DictionaryType(name, is, validate, encode, domain, codomain) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.domain = domain;\n    _this.codomain = codomain;\n    _this._tag = 'DictionaryType';\n    return _this;\n  }\n  return DictionaryType;\n}(Type);\nexports.DictionaryType = DictionaryType;\nvar isObject = function isObject(r) {\n  return Object.prototype.toString.call(r) === '[object Object]';\n};\n/**\n * @since 1.7.1\n */\nexports.record = function (domain, codomain, name) {\n  if (name === void 0) {\n    name = \"{ [K in \" + domain.name + \"]: \" + codomain.name + \" }\";\n  }\n  return new DictionaryType(name, function (u) {\n    if (!exports.UnknownRecord.is(u)) {\n      return false;\n    }\n    if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(u)) {\n      return false;\n    }\n    return Object.keys(u).every(function (k) {\n      return domain.is(k) && codomain.is(u[k]);\n    });\n  }, function (u, c) {\n    return chain(exports.UnknownRecord.validate(u, c), function (o) {\n      if (!isUnknownCodec(codomain) && !isAnyCodec(codomain) && !isObject(o)) {\n        return exports.failure(u, c);\n      }\n      var a = {};\n      var errors = [];\n      var keys = Object.keys(o);\n      var len = keys.length;\n      var changed = false;\n      for (var i = 0; i < len; i++) {\n        var k = keys[i];\n        var ok = o[k];\n        var domainResult = domain.validate(k, exports.appendContext(c, k, domain, k));\n        if (Either_1.isLeft(domainResult)) {\n          pushAll(errors, domainResult.left);\n        } else {\n          var vk = domainResult.right;\n          changed = changed || vk !== k;\n          k = vk;\n          var codomainResult = codomain.validate(ok, exports.appendContext(c, k, codomain, ok));\n          if (Either_1.isLeft(codomainResult)) {\n            pushAll(errors, codomainResult.left);\n          } else {\n            var vok = codomainResult.right;\n            changed = changed || vok !== ok;\n            a[k] = vok;\n          }\n        }\n      }\n      return errors.length > 0 ? exports.failures(errors) : exports.success(changed ? a : o);\n    });\n  }, domain.encode === exports.identity && codomain.encode === exports.identity ? exports.identity : function (a) {\n    var s = {};\n    var keys = Object.keys(a);\n    var len = keys.length;\n    for (var i = 0; i < len; i++) {\n      var k = keys[i];\n      s[String(domain.encode(k))] = codomain.encode(a[k]);\n    }\n    return s;\n  }, domain, codomain);\n};\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */function (_super) {\n  __extends(UnionType, _super);\n  function UnionType(name, is, validate, encode, types) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.types = types;\n    _this._tag = 'UnionType';\n    return _this;\n  }\n  return UnionType;\n}(Type);\nexports.UnionType = UnionType;\nvar getUnionName = function getUnionName(codecs) {\n  return '(' + codecs.map(function (type) {\n    return type.name;\n  }).join(' | ') + ')';\n};\n/**\n * @since 1.0.0\n */\nexports.union = function (codecs, name) {\n  if (name === void 0) {\n    name = getUnionName(codecs);\n  }\n  var index = getIndex(codecs);\n  if (index !== undefined && codecs.length > 0) {\n    var tag_1 = index[0],\n      groups_1 = index[1];\n    var len_1 = groups_1.length;\n    var find_1 = function find_1(value) {\n      for (var i = 0; i < len_1; i++) {\n        if (groups_1[i].indexOf(value) !== -1) {\n          return i;\n        }\n      }\n      return undefined;\n    };\n    // tslint:disable-next-line: deprecation\n    return new TaggedUnionType(name, function (u) {\n      if (!exports.UnknownRecord.is(u)) {\n        return false;\n      }\n      var i = find_1(u[tag_1]);\n      return i !== undefined ? codecs[i].is(u) : false;\n    }, function (u, c) {\n      return chain(exports.UnknownRecord.validate(u, c), function (r) {\n        var i = find_1(r[tag_1]);\n        if (i === undefined) {\n          return exports.failure(u, c);\n        }\n        var codec = codecs[i];\n        return codec.validate(r, exports.appendContext(c, String(i), codec, r));\n      });\n    }, useIdentity(codecs) ? exports.identity : function (a) {\n      var i = find_1(a[tag_1]);\n      if (i === undefined) {\n        // https://github.com/gcanti/io-ts/pull/305\n        throw new Error(\"no codec found to encode value in union codec \" + name);\n      } else {\n        return codecs[i].encode(a);\n      }\n    }, codecs, tag_1);\n  } else {\n    return new UnionType(name, function (u) {\n      return codecs.some(function (type) {\n        return type.is(u);\n      });\n    }, function (u, c) {\n      var errors = [];\n      for (var i = 0; i < codecs.length; i++) {\n        var codec = codecs[i];\n        var result = codec.validate(u, exports.appendContext(c, String(i), codec, u));\n        if (Either_1.isLeft(result)) {\n          pushAll(errors, result.left);\n        } else {\n          return exports.success(result.right);\n        }\n      }\n      return exports.failures(errors);\n    }, useIdentity(codecs) ? exports.identity : function (a) {\n      for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {\n        var codec = codecs_1[_i];\n        if (codec.is(a)) {\n          return codec.encode(a);\n        }\n      }\n      // https://github.com/gcanti/io-ts/pull/305\n      throw new Error(\"no codec found to encode value in union type \" + name);\n    }, codecs);\n  }\n};\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */function (_super) {\n  __extends(IntersectionType, _super);\n  function IntersectionType(name, is, validate, encode, types) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.types = types;\n    _this._tag = 'IntersectionType';\n    return _this;\n  }\n  return IntersectionType;\n}(Type);\nexports.IntersectionType = IntersectionType;\nvar mergeAll = function mergeAll(base, us) {\n  var r = base;\n  for (var i = 0; i < us.length; i++) {\n    var u = us[i];\n    if (u !== base) {\n      // `u` contains a prismatic value or is the result of a stripping combinator\n      if (r === base) {\n        r = Object.assign({}, u);\n        continue;\n      }\n      for (var k in u) {\n        if (u[k] !== base[k] || !r.hasOwnProperty(k)) {\n          r[k] = u[k];\n        }\n      }\n    }\n  }\n  return r;\n};\nfunction intersection(codecs, name) {\n  if (name === void 0) {\n    name = \"(\" + codecs.map(function (type) {\n      return type.name;\n    }).join(' & ') + \")\";\n  }\n  var len = codecs.length;\n  return new IntersectionType(name, function (u) {\n    return codecs.every(function (type) {\n      return type.is(u);\n    });\n  }, codecs.length === 0 ? exports.success : function (u, c) {\n    var us = [];\n    var errors = [];\n    for (var i = 0; i < len; i++) {\n      var codec = codecs[i];\n      var result = codec.validate(u, exports.appendContext(c, String(i), codec, u));\n      if (Either_1.isLeft(result)) {\n        pushAll(errors, result.left);\n      } else {\n        us.push(result.right);\n      }\n    }\n    return errors.length > 0 ? exports.failures(errors) : exports.success(mergeAll(u, us));\n  }, codecs.length === 0 ? exports.identity : function (a) {\n    return mergeAll(a, codecs.map(function (codec) {\n      return codec.encode(a);\n    }));\n  }, codecs);\n}\nexports.intersection = intersection;\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */function (_super) {\n  __extends(TupleType, _super);\n  function TupleType(name, is, validate, encode, types) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.types = types;\n    _this._tag = 'TupleType';\n    return _this;\n  }\n  return TupleType;\n}(Type);\nexports.TupleType = TupleType;\nfunction tuple(codecs, name) {\n  if (name === void 0) {\n    name = \"[\" + codecs.map(function (type) {\n      return type.name;\n    }).join(', ') + \"]\";\n  }\n  var len = codecs.length;\n  return new TupleType(name, function (u) {\n    return exports.UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) {\n      return type.is(u[i]);\n    });\n  }, function (u, c) {\n    return chain(exports.UnknownArray.validate(u, c), function (us) {\n      var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n      var errors = [];\n      for (var i = 0; i < len; i++) {\n        var a = us[i];\n        var type_3 = codecs[i];\n        var result = type_3.validate(a, exports.appendContext(c, String(i), type_3, a));\n        if (Either_1.isLeft(result)) {\n          pushAll(errors, result.left);\n        } else {\n          var va = result.right;\n          if (va !== a) {\n            /* istanbul ignore next */\n            if (as === us) {\n              as = us.slice();\n            }\n            as[i] = va;\n          }\n        }\n      }\n      return errors.length > 0 ? exports.failures(errors) : exports.success(as);\n    });\n  }, useIdentity(codecs) ? exports.identity : function (a) {\n    return codecs.map(function (type, i) {\n      return type.encode(a[i]);\n    });\n  }, codecs);\n}\nexports.tuple = tuple;\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */function (_super) {\n  __extends(ReadonlyType, _super);\n  function ReadonlyType(name, is, validate, encode, type) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.type = type;\n    _this._tag = 'ReadonlyType';\n    return _this;\n  }\n  return ReadonlyType;\n}(Type);\nexports.ReadonlyType = ReadonlyType;\n/**\n * @since 1.0.0\n */\nexports.readonly = function (codec, name) {\n  if (name === void 0) {\n    name = \"Readonly<\" + codec.name + \">\";\n  }\n  return new ReadonlyType(name, codec.is, function (u, c) {\n    return map(codec.validate(u, c), function (x) {\n      if (process.env.NODE_ENV !== 'production') {\n        return Object.freeze(x);\n      }\n      return x;\n    });\n  }, codec.encode === exports.identity ? exports.identity : codec.encode, codec);\n};\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */function (_super) {\n  __extends(ReadonlyArrayType, _super);\n  function ReadonlyArrayType(name, is, validate, encode, type) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.type = type;\n    _this._tag = 'ReadonlyArrayType';\n    return _this;\n  }\n  return ReadonlyArrayType;\n}(Type);\nexports.ReadonlyArrayType = ReadonlyArrayType;\n/**\n * @since 1.0.0\n */\nexports.readonlyArray = function (codec, name) {\n  if (name === void 0) {\n    name = \"ReadonlyArray<\" + codec.name + \">\";\n  }\n  var arrayType = exports.array(codec);\n  return new ReadonlyArrayType(name, arrayType.is, function (u, c) {\n    return map(arrayType.validate(u, c), function (x) {\n      if (process.env.NODE_ENV !== 'production') {\n        return Object.freeze(x);\n      }\n      return x;\n    });\n  }, arrayType.encode, codec);\n};\n/**\n * Strips additional properties\n * @since 1.0.0\n */\nexports.strict = function (props, name) {\n  return exports.exact(exports.type(props), name);\n};\n/**\n * @since 1.3.0\n * @deprecated\n */\nvar TaggedUnionType = /** @class */function (_super) {\n  __extends(TaggedUnionType, _super);\n  function TaggedUnionType(name,\n  // tslint:disable-next-line: deprecation\n  is,\n  // tslint:disable-next-line: deprecation\n  validate,\n  // tslint:disable-next-line: deprecation\n  encode, codecs, tag) {\n    var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n    || this;\n    _this.tag = tag;\n    return _this;\n  }\n  return TaggedUnionType;\n}(UnionType);\nexports.TaggedUnionType = TaggedUnionType;\n/**\n * Use `union` instead\n *\n * @since 1.3.0\n * @deprecated\n */\nexports.taggedUnion = function (tag, codecs, name\n// tslint:disable-next-line: deprecation\n) {\n  if (name === void 0) {\n    name = getUnionName(codecs);\n  }\n  var U = exports.union(codecs, name);\n  // tslint:disable-next-line: deprecation\n  if (U instanceof TaggedUnionType) {\n    return U;\n  } else {\n    console.warn(\"[io-ts] Cannot build a tagged union for \" + name + \", returning a de-optimized union\");\n    // tslint:disable-next-line: deprecation\n    return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n  }\n};\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */function (_super) {\n  __extends(ExactType, _super);\n  function ExactType(name, is, validate, encode, type) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.type = type;\n    _this._tag = 'ExactType';\n    return _this;\n  }\n  return ExactType;\n}(Type);\nexports.ExactType = ExactType;\nvar getProps = function getProps(codec) {\n  switch (codec._tag) {\n    case 'RefinementType':\n    case 'ReadonlyType':\n      return getProps(codec.type);\n    case 'InterfaceType':\n    case 'StrictType':\n    case 'PartialType':\n      return codec.props;\n    case 'IntersectionType':\n      return codec.types.reduce(function (props, type) {\n        return Object.assign(props, getProps(type));\n      }, {});\n  }\n};\nvar stripKeys = function stripKeys(o, props) {\n  var keys = Object.getOwnPropertyNames(o);\n  var shouldStrip = false;\n  var r = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwnProperty.call(props, key)) {\n      shouldStrip = true;\n    } else {\n      r[key] = o[key];\n    }\n  }\n  return shouldStrip ? r : o;\n};\nvar getExactTypeName = function getExactTypeName(codec) {\n  if (isInterfaceCodec(codec)) {\n    return \"{| \" + getNameFromProps(codec.props) + \" |}\";\n  } else if (isPartialCodec(codec)) {\n    return getPartialTypeName(\"{| \" + getNameFromProps(codec.props) + \" |}\");\n  }\n  return \"Exact<\" + codec.name + \">\";\n};\n/**\n * Strips additional properties\n * @since 1.1.0\n */\nexports.exact = function (codec, name) {\n  if (name === void 0) {\n    name = getExactTypeName(codec);\n  }\n  var props = getProps(codec);\n  return new ExactType(name, codec.is, function (u, c) {\n    return chain(exports.UnknownRecord.validate(u, c), function () {\n      return map(codec.validate(u, c), function (a) {\n        return stripKeys(a, props);\n      });\n    });\n  }, function (a) {\n    return codec.encode(stripKeys(a, props));\n  }, codec);\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.getValidationError /* istanbul ignore next */ = function (value, context) {\n  return {\n    value: value,\n    context: context\n  };\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nexports.getDefaultContext /* istanbul ignore next */ = function (decoder) {\n  return [{\n    key: '',\n    type: decoder\n  }];\n};\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar NeverType = /** @class */function (_super) {\n  __extends(NeverType, _super);\n  function NeverType() {\n    var _this = _super.call(this, 'never', function (_) {\n      return false;\n    }, function (u, c) {\n      return exports.failure(u, c);\n    }, /* istanbul ignore next */\n    function () {\n      throw new Error('cannot encode never');\n    }) || this;\n    _this._tag = 'NeverType';\n    return _this;\n  }\n  return NeverType;\n}(Type);\nexports.NeverType = NeverType;\n/**\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.never = new NeverType();\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar AnyType = /** @class */function (_super) {\n  __extends(AnyType, _super);\n  function AnyType() {\n    var _this = _super.call(this, 'any', function (_) {\n      return true;\n    }, exports.success, exports.identity) || this;\n    _this._tag = 'AnyType';\n    return _this;\n  }\n  return AnyType;\n}(Type);\nexports.AnyType = AnyType;\n/**\n * Use `unknown` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.any = new AnyType();\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.Dictionary = exports.UnknownRecord;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */function (_super) {\n  __extends(ObjectType, _super);\n  function ObjectType() {\n    var _this = _super.call(this, 'object', exports.UnknownRecord.is, exports.UnknownRecord.validate, exports.identity) || this;\n    _this._tag = 'ObjectType';\n    return _this;\n  }\n  return ObjectType;\n}(Type);\nexports.ObjectType = ObjectType;\n/**\n * Use `UnknownRecord` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.object = new ObjectType();\n/**\n * Use `brand` instead\n * @since 1.0.0\n * @deprecated\n */\nfunction refinement(codec, predicate, name) {\n  if (name === void 0) {\n    name = \"(\" + codec.name + \" | \" + exports.getFunctionName(predicate) + \")\";\n  }\n  return new RefinementType(name, function (u) {\n    return codec.is(u) && predicate(u);\n  }, function (i, c) {\n    return chain(codec.validate(i, c), function (a) {\n      return predicate(a) ? exports.success(a) : exports.failure(a, c);\n    });\n  }, codec.encode, codec, predicate);\n}\nexports.refinement = refinement;\n/**\n * Use `Int` instead\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexports.Integer = refinement(exports.number, Number.isInteger, 'Integer');\n/**\n * Use `record` instead\n * @since 1.0.0\n * @deprecated\n */\nexports.dictionary = exports.record;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */function (_super) {\n  __extends(StrictType, _super);\n  function StrictType(name,\n  // tslint:disable-next-line: deprecation\n  is,\n  // tslint:disable-next-line: deprecation\n  validate,\n  // tslint:disable-next-line: deprecation\n  encode, props) {\n    var _this = _super.call(this, name, is, validate, encode) || this;\n    _this.props = props;\n    _this._tag = 'StrictType';\n    return _this;\n  }\n  return StrictType;\n}(Type);\nexports.StrictType = StrictType;\n/**\n * Drops the codec \"kind\"\n * @since 1.1.0\n * @deprecated\n */\nfunction clean(codec) {\n  return codec;\n}\nexports.clean = clean;\nfunction alias(codec) {\n  return function () {\n    return codec;\n  };\n}\nexports.alias = alias;\nvar isNonEmpty = function isNonEmpty(as) {\n  return as.length > 0;\n};\n/**\n * @internal\n */\nexports.emptyTags = {};\nfunction intersect(a, b) {\n  var r = [];\n  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n    var v = a_1[_i];\n    if (b.indexOf(v) !== -1) {\n      r.push(v);\n    }\n  }\n  return r;\n}\nfunction mergeTags(a, b) {\n  if (a === exports.emptyTags) {\n    return b;\n  }\n  if (b === exports.emptyTags) {\n    return a;\n  }\n  var r = Object.assign({}, a);\n  for (var k in b) {\n    if (a.hasOwnProperty(k)) {\n      var intersection_1 = intersect(a[k], b[k]);\n      if (isNonEmpty(intersection_1)) {\n        r[k] = intersection_1;\n      } else {\n        r = exports.emptyTags;\n        break;\n      }\n    } else {\n      r[k] = b[k];\n    }\n  }\n  return r;\n}\nfunction intersectTags(a, b) {\n  if (a === exports.emptyTags || b === exports.emptyTags) {\n    return exports.emptyTags;\n  }\n  var r = exports.emptyTags;\n  for (var k in a) {\n    if (b.hasOwnProperty(k)) {\n      var intersection_2 = intersect(a[k], b[k]);\n      if (intersection_2.length === 0) {\n        if (r === exports.emptyTags) {\n          r = {};\n        }\n        r[k] = a[k].concat(b[k]);\n      }\n    }\n  }\n  return r;\n}\nfunction isLiteralC(codec) {\n  return codec._tag === 'LiteralType';\n}\nfunction isTypeC(codec) {\n  return codec._tag === 'InterfaceType';\n}\n// tslint:disable-next-line: deprecation\nfunction isStrictC(codec) {\n  return codec._tag === 'StrictType';\n}\nfunction isExactC(codec) {\n  return codec._tag === 'ExactType';\n}\n// tslint:disable-next-line: deprecation\nfunction isRefinementC(codec) {\n  return codec._tag === 'RefinementType';\n}\nfunction isIntersectionC(codec) {\n  return codec._tag === 'IntersectionType';\n}\nfunction isUnionC(codec) {\n  return codec._tag === 'UnionType';\n}\nfunction isRecursiveC(codec) {\n  return codec._tag === 'RecursiveType';\n}\nvar lazyCodecs = [];\n/**\n * @internal\n */\nfunction getTags(codec) {\n  if (lazyCodecs.indexOf(codec) !== -1) {\n    return exports.emptyTags;\n  }\n  if (isTypeC(codec) || isStrictC(codec)) {\n    var index = exports.emptyTags;\n    // tslint:disable-next-line: forin\n    for (var k in codec.props) {\n      var prop = codec.props[k];\n      if (isLiteralC(prop)) {\n        if (index === exports.emptyTags) {\n          index = {};\n        }\n        index[k] = [prop.value];\n      }\n    }\n    return index;\n  } else if (isExactC(codec) || isRefinementC(codec)) {\n    return getTags(codec.type);\n  } else if (isIntersectionC(codec)) {\n    return codec.types.reduce(function (tags, codec) {\n      return mergeTags(tags, getTags(codec));\n    }, exports.emptyTags);\n  } else if (isUnionC(codec)) {\n    return codec.types.slice(1).reduce(function (tags, codec) {\n      return intersectTags(tags, getTags(codec));\n    }, getTags(codec.types[0]));\n  } else if (isRecursiveC(codec)) {\n    lazyCodecs.push(codec);\n    var tags = getTags(codec.type);\n    lazyCodecs.pop();\n    return tags;\n  }\n  return exports.emptyTags;\n}\nexports.getTags = getTags;\n/**\n * @internal\n */\nfunction getIndex(codecs) {\n  var tags = getTags(codecs[0]);\n  var keys = Object.keys(tags);\n  var len = codecs.length;\n  var _loop_1 = function _loop_1(k) {\n    var all = tags[k].slice();\n    var index = [tags[k]];\n    for (var i = 1; i < len; i++) {\n      var codec = codecs[i];\n      var ctags = getTags(codec);\n      var values = ctags[k];\n      // tslint:disable-next-line: strict-type-predicates\n      if (values === undefined) {\n        return \"continue-keys\";\n      } else {\n        if (values.some(function (v) {\n          return all.indexOf(v) !== -1;\n        })) {\n          return \"continue-keys\";\n        } else {\n          all.push.apply(all, values);\n          index.push(values);\n        }\n      }\n    }\n    return {\n      value: [k, index]\n    };\n  };\n  keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n    var k = keys_1[_i];\n    var state_1 = _loop_1(k);\n    if (typeof state_1 === \"object\") return state_1.value;\n    switch (state_1) {\n      case \"continue-keys\":\n        continue keys;\n    }\n  }\n  return undefined;\n}\nexports.getIndex = getIndex;","map":null,"metadata":{},"sourceType":"script"}