{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Type = void 0;\n/**\n * An SSZ type provides the following operations:\n * - Serialization from/to bytes to either a value or a tree\n * - Merkelization to compute the hashTreeRoot of both a value and a tree\n * - Proof creation from trees\n * - Create a View and a ViewDU instance from a tree\n * - Manipulate views\n */\nclass Type {\n  /** INTERNAL METHOD: Merkleize value to tree */\n  value_toTree(value) {\n    // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return this.tree_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n  /** INTERNAL METHOD: Un-merkleize tree to value */\n  tree_toValue(node) {\n    // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important\n    const uint8Array = new Uint8Array(this.tree_serializedSize(node));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.tree_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, node);\n    return this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n  /** Serialize a value to binary data */\n  serialize(value) {\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return uint8Array;\n  }\n  /** Deserialize binary data to value */\n  deserialize(uint8Array) {\n    // Buffer.prototype.slice does not copy memory, force use Uint8Array.prototype.slice https://github.com/nodejs/node/issues/28087\n    // - Uint8Array.prototype.slice: Copy memory, safe to mutate\n    // - Buffer.prototype.slice: Does NOT copy memory, mutation affects both views\n    // We could ensure that all Buffer instances are converted to Uint8Array before calling value_deserializeFromBytes\n    // However doing that in a browser friendly way is not easy. Downstream code uses `Uint8Array.prototype.slice.call`\n    // to ensure Buffer.prototype.slice is never used. Unit tests also test non-mutability.\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    return this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n}\nexports.Type = Type;","map":{"version":3,"sources":["../../src/type/abstract.ts"],"names":[],"mappings":";;;;;;AAwCA;;;;;;;AAOG;AACH,MAAsB,IAAI,CAAA;EA6CxB;EACA,YAAY,CAAC,KAAQ,EAAA;IACnB;IACA,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;IACnE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,CAAC;IAC9F,IAAI,CAAC,sBAAsB,CAAC;MAAC,UAAU;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC;IAC7D,OAAO,IAAI,CAAC,yBAAyB,CAAC;MAAC,UAAU;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,MAAM,CAAC;EACrF;EAEA;EACA,YAAY,CAAC,IAAU,EAAA;IACrB;IACA,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACjE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,CAAC;IAC9F,IAAI,CAAC,qBAAqB,CAAC;MAAC,UAAU;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC;IAC3D,OAAO,IAAI,CAAC,0BAA0B,CAAC;MAAC,UAAU;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,MAAM,CAAC;EACtF;EAOA;EACA,SAAS,CAAC,KAAQ,EAAA;IAChB,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC;IACnE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,CAAC;IAC9F,IAAI,CAAC,sBAAsB,CAAC;MAAC,UAAU;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC;IAC7D,OAAO,UAAU;EACnB;EAEA;EACA,WAAW,CAAC,UAAsB,EAAA;IAChC;IACA;IACA;IACA;IACA;IACA;IAEA,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,CAAC;IAC9F,OAAO,IAAI,CAAC,0BAA0B,CAAC;MAAC,UAAU;MAAE;IAAQ,CAAC,EAAE,CAAC,EAAE,UAAU,CAAC,MAAM,CAAC;EACtF;AAkCD;AAzHD,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = void 0;\n/**\n * An SSZ type provides the following operations:\n * - Serialization from/to bytes to either a value or a tree\n * - Merkelization to compute the hashTreeRoot of both a value and a tree\n * - Proof creation from trees\n * - Create a View and a ViewDU instance from a tree\n * - Manipulate views\n */\nclass Type {\n    /** INTERNAL METHOD: Merkleize value to tree */\n    value_toTree(value) {\n        // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important\n        const uint8Array = new Uint8Array(this.value_serializedSize(value));\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);\n        return this.tree_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n    }\n    /** INTERNAL METHOD: Un-merkleize tree to value */\n    tree_toValue(node) {\n        // TODO: Un-performant path but useful for prototyping. Overwrite in Type if performance is important\n        const uint8Array = new Uint8Array(this.tree_serializedSize(node));\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        this.tree_serializeToBytes({ uint8Array, dataView }, 0, node);\n        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n    }\n    /** Serialize a value to binary data */\n    serialize(value) {\n        const uint8Array = new Uint8Array(this.value_serializedSize(value));\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        this.value_serializeToBytes({ uint8Array, dataView }, 0, value);\n        return uint8Array;\n    }\n    /** Deserialize binary data to value */\n    deserialize(uint8Array) {\n        // Buffer.prototype.slice does not copy memory, force use Uint8Array.prototype.slice https://github.com/nodejs/node/issues/28087\n        // - Uint8Array.prototype.slice: Copy memory, safe to mutate\n        // - Buffer.prototype.slice: Does NOT copy memory, mutation affects both views\n        // We could ensure that all Buffer instances are converted to Uint8Array before calling value_deserializeFromBytes\n        // However doing that in a browser friendly way is not easy. Downstream code uses `Uint8Array.prototype.slice.call`\n        // to ensure Buffer.prototype.slice is never used. Unit tests also test non-mutability.\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n    }\n}\nexports.Type = Type;\n//# sourceMappingURL=abstract.js.map"]},"metadata":{},"sourceType":"script"}