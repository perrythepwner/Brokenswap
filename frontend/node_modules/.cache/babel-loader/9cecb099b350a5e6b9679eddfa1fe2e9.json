{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0;\nvar events_1 = require(\"events\");\nvar LockEvent;\n(function (LockEvent) {\n  LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {}));\n// Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\nvar Lock = /** @class */function () {\n  function Lock() {\n    this.locked = false;\n    this.emitter = new events_1.EventEmitter();\n  }\n  // Attempt to acquire the lock without blocking.\n  // @returns {boolean} True if the lock was acquired.\n  Lock.prototype.tryAcquire = function () {\n    if (!this.locked) {\n      this.locked = true;\n      return true;\n    }\n    return false;\n  };\n  // Acquire the lock, blocking until the lock is available.\n  Lock.prototype.acquire = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      // Attempt to grab the lock without waiting.\n      if (_this.tryAcquire()) {\n        resolve();\n        return;\n      }\n      // Wait for an event emitted when releasing the lock.\n      var callback = function callback() {\n        try {\n          if (_this.tryAcquire()) {\n            _this.emitter.removeListener(LockEvent.Unlock, callback);\n            resolve();\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n      _this.emitter.on(LockEvent.Unlock, callback);\n    });\n  };\n  // Release the lock such that another caller can acquire it.\n  // If not locked, calling this method has no effect.\n  Lock.prototype.release = function () {\n    if (this.locked) {\n      this.locked = false;\n      this.emitter.emit(LockEvent.Unlock);\n    }\n  };\n  return Lock;\n}();\nexports.Lock = Lock;","map":null,"metadata":{},"sourceType":"script"}