{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inputSignFormatter = exports.inputAddressFormatter = exports.inputAccessListFormatter = exports.parseAccessList = exports.outputBigNumberFormatter = exports.outputLogFormatter = exports.hexToNumber = exports.outputBlockFormatter = exports.outputBlockHeaderFormatter = exports.inputBlockNumberFormatter = exports.inputDefaultBlockNumberFormatter = exports.outputCeloTxReceiptFormatter = exports.outputCeloTxFormatter = exports.inputCeloTxFormatter = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar address_2 = require(\"@celo/utils/lib/address\");\nvar solidity_1 = require(\"@celo/utils/lib/solidity\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar utf8_1 = require(\"utf8\");\n/**\n * Formats the input of a transaction and converts all values to HEX\n */\nfunction inputCeloTxFormatter(tx) {\n  var from = tx.from,\n    chainId = tx.chainId,\n    nonce = tx.nonce,\n    to = tx.to,\n    gas = tx.gas,\n    gasPrice = tx.gasPrice,\n    maxFeePerGas = tx.maxFeePerGas,\n    maxPriorityFeePerGas = tx.maxPriorityFeePerGas,\n    feeCurrency = tx.feeCurrency,\n    gatewayFee = tx.gatewayFee,\n    gatewayFeeRecipient = tx.gatewayFeeRecipient,\n    data = tx.data,\n    value = tx.value,\n    accessList = tx.accessList,\n    common = tx.common,\n    chain = tx.chain,\n    hardfork = tx.hardfork,\n    rest = __rest(tx, [\"from\", \"chainId\", \"nonce\", \"to\", \"gas\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"feeCurrency\", \"gatewayFee\", \"gatewayFeeRecipient\", \"data\", \"value\", \"accessList\", \"common\", \"chain\", \"hardfork\"]);\n  var formattedTX = rest;\n  formattedTX.from = inputAddressFormatter(from === null || from === void 0 ? void 0 : from.toString());\n  formattedTX.to = inputAddressFormatter(to);\n  formattedTX.gas = numberToHex(gas);\n  formattedTX.value = numberToHex(value === null || value === void 0 ? void 0 : value.toString());\n  formattedTX.nonce = numberToHex(nonce === null || nonce === void 0 ? void 0 : nonce.toString());\n  if (feeCurrency) {\n    formattedTX.feeCurrency = inputAddressFormatter(feeCurrency);\n  }\n  if (gatewayFeeRecipient) {\n    formattedTX.gatewayFeeRecipient = inputAddressFormatter(gatewayFeeRecipient);\n  }\n  if (gatewayFee) {\n    formattedTX.gatewayFee = numberToHex(gatewayFee);\n  }\n  if (data && !isHex(data)) {\n    throw new Error('The data field must be HEX encoded data.');\n  } else if (data) {\n    formattedTX.data = (0, address_1.ensureLeading0x)(data);\n  }\n  if (gasPrice) {\n    formattedTX.gasPrice = numberToHex(gasPrice.toString());\n  }\n  if (maxFeePerGas) {\n    formattedTX.maxFeePerGas = numberToHex(maxFeePerGas.toString());\n  }\n  if (maxPriorityFeePerGas) {\n    formattedTX.maxPriorityFeePerGas = numberToHex(maxPriorityFeePerGas.toString());\n  }\n  if (accessList) {\n    formattedTX.accessList = inputAccessListFormatter(accessList);\n  }\n  return formattedTX;\n}\nexports.inputCeloTxFormatter = inputCeloTxFormatter;\nfunction outputCeloTxFormatter(tx) {\n  if (tx.blockNumber !== null) {\n    tx.blockNumber = hexToNumber(tx.blockNumber);\n  }\n  if (tx.transactionIndex !== null) {\n    tx.transactionIndex = hexToNumber(tx.transactionIndex);\n  }\n  tx.nonce = hexToNumber(tx.nonce);\n  tx.gas = hexToNumber(tx.gas);\n  tx.value = outputBigNumberFormatter(tx.value);\n  if (tx.gatewayFee) {\n    tx.gatewayFee = outputBigNumberFormatter(tx.gatewayFee);\n  }\n  if (tx.gasPrice) {\n    tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n  }\n  if (tx.maxFeePerGas) {\n    tx.maxFeePerGas = outputBigNumberFormatter(tx.maxFeePerGas);\n  }\n  if (tx.maxPriorityFeePerGas) {\n    tx.maxPriorityFeePerGas = outputBigNumberFormatter(tx.maxPriorityFeePerGas);\n  }\n  tx.to = tx.to && (0, address_2.isValidAddress)(tx.to) ?\n  // tx.to could be `0x0` or `null` while contract creation\n  tx.to = (0, address_2.toChecksumAddress)(tx.to) : null; // set to `null` if invalid address\n  if (tx.from) {\n    tx.from = (0, address_2.toChecksumAddress)(tx.from);\n  }\n  if (tx.feeCurrency) {\n    tx.feeCurrency = (0, address_2.toChecksumAddress)(tx.feeCurrency);\n  }\n  if (tx.gatewayFeeRecipient) {\n    tx.gatewayFeeRecipient = (0, address_2.toChecksumAddress)(tx.gatewayFeeRecipient);\n  }\n  return tx;\n}\nexports.outputCeloTxFormatter = outputCeloTxFormatter;\nfunction outputCeloTxReceiptFormatter(receipt) {\n  if (typeof receipt !== 'object') {\n    throw new Error('Received receipt is invalid: ' + receipt);\n  }\n  if (receipt.blockNumber !== null) {\n    receipt.blockNumber = hexToNumber(receipt.blockNumber);\n  }\n  if (receipt.transactionIndex !== null) {\n    receipt.transactionIndex = hexToNumber(receipt.transactionIndex);\n  }\n  receipt.cumulativeGasUsed = hexToNumber(receipt.cumulativeGasUsed);\n  receipt.gasUsed = hexToNumber(receipt.gasUsed);\n  if (Array.isArray(receipt.logs)) {\n    receipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n  if (receipt.contractAddress) {\n    receipt.contractAddress = (0, address_2.toChecksumAddress)(receipt.contractAddress);\n  }\n  if (typeof receipt.status !== 'undefined' && receipt.status !== null) {\n    receipt.status = Boolean(parseInt((0, address_1.trimLeading0x)(receipt.status), 10));\n  }\n  return receipt;\n}\nexports.outputCeloTxReceiptFormatter = outputCeloTxReceiptFormatter;\nfunction inputDefaultBlockNumberFormatter(blockNumber) {\n  if (blockNumber == null) {\n    blockNumber = 'latest';\n  }\n  return inputBlockNumberFormatter(blockNumber);\n}\nexports.inputDefaultBlockNumberFormatter = inputDefaultBlockNumberFormatter;\nfunction inputBlockNumberFormatter(blockNumber) {\n  if (blockNumber == null) {\n    return undefined;\n  }\n  if (isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n  if (blockNumber === 'genesis') {\n    return '0x0';\n  }\n  return isHexStrict(blockNumber.toString()) ? blockNumber.toString().toLocaleLowerCase() : numberToHex(blockNumber.toString());\n}\nexports.inputBlockNumberFormatter = inputBlockNumberFormatter;\n// TODO prune after gingerbread hardfork\nfunction outputBlockHeaderFormatter(blockHeader) {\n  // transform to number\n  blockHeader.gasLimit = hexToNumber(blockHeader.gasLimit);\n  blockHeader.gasUsed = hexToNumber(blockHeader.gasUsed);\n  blockHeader.size = hexToNumber(blockHeader.size);\n  blockHeader.timestamp = hexToNumber(blockHeader.timestamp);\n  if (blockHeader.number !== null) {\n    blockHeader.number = hexToNumber(blockHeader.number);\n  }\n  if (blockHeader.miner) {\n    blockHeader.miner = (0, address_2.toChecksumAddress)(blockHeader.miner);\n  }\n  return blockHeader;\n}\nexports.outputBlockHeaderFormatter = outputBlockHeaderFormatter;\nfunction outputBlockFormatter(block) {\n  block = outputBlockHeaderFormatter(block);\n  if (block.difficulty) {\n    block.difficulty = outputBigNumberFormatter(block.difficulty);\n  }\n  if (block.totalDifficulty) {\n    block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n  }\n  if (Array.isArray(block.transactions)) {\n    block.transactions.forEach(function (item) {\n      if (typeof item !== 'string' && !(item instanceof String)) {\n        return outputCeloTxFormatter(item);\n      }\n    });\n  }\n  return block;\n}\nexports.outputBlockFormatter = outputBlockFormatter;\nfunction hexToNumber(hex) {\n  if (hex) {\n    return new bignumber_js_1.default(hex).toNumber();\n  }\n  return undefined;\n}\nexports.hexToNumber = hexToNumber;\nfunction outputLogFormatter(log) {\n  // generate a custom log id\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    var shaId = (0, solidity_1.sha3)((0, address_1.trimLeading0x)(log.blockHash) + (0, address_1.trimLeading0x)(log.transactionHash) + (0, address_1.trimLeading0x)(log.logIndex));\n    log.id = 'log_' + (0, address_1.trimLeading0x)(shaId).substring(0, 8);\n  } else if (!log.id) {\n    log.id = null;\n  }\n  if (log.blockNumber !== null) {\n    log.blockNumber = hexToNumber(log.blockNumber);\n  }\n  if (log.transactionIndex !== null) {\n    log.transactionIndex = hexToNumber(log.transactionIndex);\n  }\n  if (log.logIndex !== null) {\n    log.logIndex = hexToNumber(log.logIndex);\n  }\n  if (log.address) {\n    log.address = (0, address_2.toChecksumAddress)(log.address);\n  }\n  return log;\n}\nexports.outputLogFormatter = outputLogFormatter;\nfunction outputBigNumberFormatter(hex) {\n  return new bignumber_js_1.default(hex).toString(10);\n}\nexports.outputBigNumberFormatter = outputBigNumberFormatter;\nfunction isHash(value) {\n  return isHex(value) && value.length === 32;\n}\nfunction parseAccessList(accessListRaw) {\n  var accessList = [];\n  if (!accessListRaw) {\n    return accessList;\n  }\n  for (var _i = 0, accessListRaw_1 = accessListRaw; _i < accessListRaw_1.length; _i++) {\n    var entry = accessListRaw_1[_i];\n    var address = entry[0],\n      storageKeys = entry[1];\n    throwIfInvalidAddress(address);\n    accessList.push({\n      address: address,\n      storageKeys: storageKeys.map(function (key) {\n        if (isHash(key)) {\n          return key;\n        } else {\n          // same behavior as web3\n          throw new Error(\"Invalid storage key: \".concat(key));\n        }\n      })\n    });\n  }\n  return accessList;\n}\nexports.parseAccessList = parseAccessList;\nfunction throwIfInvalidAddress(address) {\n  if (!(0, address_2.isValidAddress)(address)) {\n    throw new Error(\"Invalid address: \".concat(address));\n  }\n}\nfunction inputAccessListFormatter(accessList) {\n  if (!accessList || accessList.length === 0) {\n    return [];\n  }\n  return accessList.reduce(function (acc, _a) {\n    var address = _a.address,\n      storageKeys = _a.storageKeys;\n    throwIfInvalidAddress(address);\n    storageKeys.forEach(function (storageKey) {\n      if (storageKey.length - 2 !== 64) {\n        throw new Error(\"Invalid storage key: \".concat(storageKey));\n      }\n    });\n    acc.push([address, storageKeys]);\n    return acc;\n  }, []);\n}\nexports.inputAccessListFormatter = inputAccessListFormatter;\nfunction inputAddressFormatter(address) {\n  if (!address || address === '0x') {\n    return undefined;\n  }\n  if ((0, address_2.isValidAddress)(address)) {\n    return (0, address_1.ensureLeading0x)(address).toLocaleLowerCase();\n  }\n  throw new Error(\"Provided address \".concat(address, \" is invalid, the capitalization checksum test failed\"));\n}\nexports.inputAddressFormatter = inputAddressFormatter;\nfunction inputSignFormatter(data) {\n  return isHexStrict(data) ? data : utf8ToHex(data);\n}\nexports.inputSignFormatter = inputSignFormatter;\nfunction utf8ToHex(str) {\n  str = (0, utf8_1.encode)(str);\n  var hex = '';\n  // remove \\u0000 padding from either side\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  for (var i = 0; i < str.length; i++) {\n    var code = str.charCodeAt(i);\n    // if (code !== 0) {\n    var n = code.toString(16);\n    hex += n.length < 2 ? '0' + n : n;\n    // }\n  }\n\n  return (0, address_1.ensureLeading0x)(hex);\n}\nfunction isHex(hex) {\n  return /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n}\nfunction isHexStrict(hex) {\n  return /^(-)?0x[0-9a-f]*$/i.test(hex);\n}\nfunction numberToHex(value) {\n  if (value) {\n    var numberValue = new bignumber_js_1.default(value);\n    var result = (0, address_1.ensureLeading0x)(new bignumber_js_1.default(value).toString(16));\n    // Seen in web3, copied just in case\n    return numberValue.lt(new bignumber_js_1.default(0)) ? \"-\".concat(result) : result;\n  }\n  return undefined;\n}\nfunction isPredefinedBlockNumber(blockNumber) {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n}","map":null,"metadata":{},"sourceType":"script"}