{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayBasicTreeViewDU = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayBasicTreeViewDU extends abstract_1.TreeViewDU {\n  constructor(type, _rootNode, cache) {\n    super();\n    this.type = type;\n    this._rootNode = _rootNode;\n    this.nodesChanged = new Set();\n    this.dirtyLength = false;\n    if (cache) {\n      this.nodes = cache.nodes;\n      this._length = cache.length;\n      this.nodesPopulated = cache.nodesPopulated;\n    } else {\n      this.nodes = [];\n      this._length = this.type.tree_getLength(_rootNode);\n      this.nodesPopulated = false;\n    }\n  }\n  /**\n   * Number of elements in the array. Equal to un-commited length of the array\n   */\n  get length() {\n    return this._length;\n  }\n  get node() {\n    return this._rootNode;\n  }\n  get cache() {\n    return {\n      nodes: this.nodes,\n      length: this._length,\n      nodesPopulated: this.nodesPopulated\n    };\n  }\n  /**\n   * Get element at `index`. Returns the Basic element type value directly\n   */\n  get(index) {\n    // First walk through the tree to get the root node for that index\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    let node = this.nodes[chunkIndex];\n    if (node === undefined) {\n      node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n      this.nodes[chunkIndex] = node;\n    }\n    return this.type.elementType.tree_getFromPackedNode(node, index);\n  }\n  /**\n   * Set Basic element type `value` at `index`\n   */\n  set(index, value) {\n    if (index >= this._length) {\n      throw Error(\"Error setting index over length \".concat(index, \" > \").concat(this._length));\n    }\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    // Create new node if current leafNode is not dirty\n    let nodeChanged;\n    if (this.nodesChanged.has(chunkIndex)) {\n      // TODO: This assumes that node has already been populated\n      nodeChanged = this.nodes[chunkIndex];\n    } else {\n      var _this$nodes$chunkInde;\n      const nodePrev = (_this$nodes$chunkInde = this.nodes[chunkIndex]) !== null && _this$nodes$chunkInde !== void 0 ? _this$nodes$chunkInde : persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n      nodeChanged = nodePrev.clone();\n      // Store the changed node in the nodes cache\n      this.nodes[chunkIndex] = nodeChanged;\n      this.nodesChanged.add(chunkIndex);\n    }\n    this.type.elementType.tree_setToPackedNode(nodeChanged, index, value);\n  }\n  /**\n   * Get all values of this array as Basic element type values, from index zero to `this.length - 1`\n   */\n  getAll() {\n    if (!this.nodesPopulated) {\n      const nodesPrev = this.nodes;\n      const chunksNode = this.type.tree_getChunksNode(this.node);\n      const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);\n      this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);\n      // Re-apply changed nodes\n      for (const index of this.nodesChanged) {\n        this.nodes[index] = nodesPrev[index];\n      }\n      this.nodesPopulated = true;\n    }\n    const values = new Array(this._length);\n    const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below\n    const lenFullNodes = Math.floor(this._length / itemsPerChunk);\n    const remainder = this._length % itemsPerChunk;\n    // TODO Optimize: caching the variables used in the loop above it\n    for (let n = 0; n < lenFullNodes; n++) {\n      const leafNode = this.nodes[n];\n      // TODO: Implement add a fast bulk packed element reader in the elementType\n      // ```\n      // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;\n      // ```\n      // if performance here is a problem\n      for (let i = 0; i < itemsPerChunk; i++) {\n        values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    if (remainder > 0) {\n      const leafNode = this.nodes[lenFullNodes];\n      for (let i = 0; i < remainder; i++) {\n        values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    return values;\n  }\n  commit() {\n    if (this.nodesChanged.size === 0) {\n      return;\n    }\n    // Numerical sort ascending\n    const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);\n    const nodes = new Array(indexes.length);\n    for (let i = 0; i < indexes.length; i++) {\n      nodes[i] = this.nodes[indexes[i]];\n    }\n    const chunksNode = this.type.tree_getChunksNode(this._rootNode);\n    // TODO: Ensure fast setNodesAtDepth() method is correct\n    const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);\n    this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : undefined);\n    this.nodesChanged.clear();\n    this.dirtyLength = false;\n  }\n  clearCache() {\n    this.nodes = [];\n    this.nodesPopulated = false;\n    // Must clear nodesChanged, otherwise a subsequent commit call will break, because it assumes a node is there\n    this.nodesChanged.clear();\n    // Reset cached length only if it has been mutated\n    if (this.dirtyLength) {\n      this._length = this.type.tree_getLength(this._rootNode);\n      this.dirtyLength = false;\n    }\n  }\n}\nexports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;","map":{"version":3,"sources":["../../src/viewDU/arrayBasic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayBasicTreeViewDU = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayBasicTreeViewDU extends abstract_1.TreeViewDU {\n    constructor(type, _rootNode, cache) {\n        super();\n        this.type = type;\n        this._rootNode = _rootNode;\n        this.nodesChanged = new Set();\n        this.dirtyLength = false;\n        if (cache) {\n            this.nodes = cache.nodes;\n            this._length = cache.length;\n            this.nodesPopulated = cache.nodesPopulated;\n        }\n        else {\n            this.nodes = [];\n            this._length = this.type.tree_getLength(_rootNode);\n            this.nodesPopulated = false;\n        }\n    }\n    /**\n     * Number of elements in the array. Equal to un-commited length of the array\n     */\n    get length() {\n        return this._length;\n    }\n    get node() {\n        return this._rootNode;\n    }\n    get cache() {\n        return {\n            nodes: this.nodes,\n            length: this._length,\n            nodesPopulated: this.nodesPopulated,\n        };\n    }\n    /**\n     * Get element at `index`. Returns the Basic element type value directly\n     */\n    get(index) {\n        // First walk through the tree to get the root node for that index\n        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n        let node = this.nodes[chunkIndex];\n        if (node === undefined) {\n            node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n            this.nodes[chunkIndex] = node;\n        }\n        return this.type.elementType.tree_getFromPackedNode(node, index);\n    }\n    /**\n     * Set Basic element type `value` at `index`\n     */\n    set(index, value) {\n        if (index >= this._length) {\n            throw Error(`Error setting index over length ${index} > ${this._length}`);\n        }\n        const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n        // Create new node if current leafNode is not dirty\n        let nodeChanged;\n        if (this.nodesChanged.has(chunkIndex)) {\n            // TODO: This assumes that node has already been populated\n            nodeChanged = this.nodes[chunkIndex];\n        }\n        else {\n            const nodePrev = (this.nodes[chunkIndex] ??\n                persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex));\n            nodeChanged = nodePrev.clone();\n            // Store the changed node in the nodes cache\n            this.nodes[chunkIndex] = nodeChanged;\n            this.nodesChanged.add(chunkIndex);\n        }\n        this.type.elementType.tree_setToPackedNode(nodeChanged, index, value);\n    }\n    /**\n     * Get all values of this array as Basic element type values, from index zero to `this.length - 1`\n     */\n    getAll() {\n        if (!this.nodesPopulated) {\n            const nodesPrev = this.nodes;\n            const chunksNode = this.type.tree_getChunksNode(this.node);\n            const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);\n            this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);\n            // Re-apply changed nodes\n            for (const index of this.nodesChanged) {\n                this.nodes[index] = nodesPrev[index];\n            }\n            this.nodesPopulated = true;\n        }\n        const values = new Array(this._length);\n        const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below\n        const lenFullNodes = Math.floor(this._length / itemsPerChunk);\n        const remainder = this._length % itemsPerChunk;\n        // TODO Optimize: caching the variables used in the loop above it\n        for (let n = 0; n < lenFullNodes; n++) {\n            const leafNode = this.nodes[n];\n            // TODO: Implement add a fast bulk packed element reader in the elementType\n            // ```\n            // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;\n            // ```\n            // if performance here is a problem\n            for (let i = 0; i < itemsPerChunk; i++) {\n                values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n            }\n        }\n        if (remainder > 0) {\n            const leafNode = this.nodes[lenFullNodes];\n            for (let i = 0; i < remainder; i++) {\n                values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n            }\n        }\n        return values;\n    }\n    commit() {\n        if (this.nodesChanged.size === 0) {\n            return;\n        }\n        // Numerical sort ascending\n        const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);\n        const nodes = new Array(indexes.length);\n        for (let i = 0; i < indexes.length; i++) {\n            nodes[i] = this.nodes[indexes[i]];\n        }\n        const chunksNode = this.type.tree_getChunksNode(this._rootNode);\n        // TODO: Ensure fast setNodesAtDepth() method is correct\n        const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);\n        this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : undefined);\n        this.nodesChanged.clear();\n        this.dirtyLength = false;\n    }\n    clearCache() {\n        this.nodes = [];\n        this.nodesPopulated = false;\n        // Must clear nodesChanged, otherwise a subsequent commit call will break, because it assumes a node is there\n        this.nodesChanged.clear();\n        // Reset cached length only if it has been mutated\n        if (this.dirtyLength) {\n            this._length = this.type.tree_getLength(this._rootNode);\n            this.dirtyLength = false;\n        }\n    }\n}\nexports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;\n//# sourceMappingURL=arrayBasic.js.map"]},"metadata":{},"sourceType":"script"}