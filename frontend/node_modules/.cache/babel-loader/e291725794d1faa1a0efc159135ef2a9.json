{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;\nfunction bitIndexBigInt(v) {\n  return v.toString(2).length - 1;\n}\nexports.bitIndexBigInt = bitIndexBigInt;\nfunction toGindex(depth, index) {\n  const anchor = BigInt(1) << BigInt(depth);\n  if (index >= anchor) {\n    throw new Error(\"index \".concat(index, \" too large for depth \").concat(depth));\n  }\n  return anchor | index;\n}\nexports.toGindex = toGindex;\nfunction toGindexBitstring(depth, index) {\n  const str = index ? Number(index).toString(2) : \"\";\n  if (str.length > depth) {\n    throw new Error(\"index too large for depth\");\n  } else {\n    return \"1\" + str.padStart(depth, \"0\");\n  }\n}\nexports.toGindexBitstring = toGindexBitstring;\nfunction convertGindexToBitstring(gindex) {\n  if (typeof gindex === \"string\") {\n    if (gindex.length === 0) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    return gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    return gindex.toString(2);\n  }\n}\nexports.convertGindexToBitstring = convertGindexToBitstring;\n// Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.\n// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)\nfunction countToDepth(count) {\n  if (count <= 1) {\n    return 0;\n  }\n  return (count - BigInt(1)).toString(2).length;\n}\nexports.countToDepth = countToDepth;\n/**\n * Iterate through Gindexes at a certain depth\n */\nfunction iterateAtDepth(depth, startIndex, count) {\n  const anchor = BigInt(1) << BigInt(depth);\n  if (startIndex + count > anchor) {\n    throw new Error(\"Too large for depth\");\n  }\n  let i = toGindex(depth, startIndex);\n  const last = i + count;\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          if (i < last) {\n            const value = i;\n            i++;\n            return {\n              done: false,\n              value\n            };\n          } else {\n            return {\n              done: true,\n              value: undefined\n            };\n          }\n        }\n      };\n    }\n  };\n}\nexports.iterateAtDepth = iterateAtDepth;\n/**\n * Return Gindexes at a certain depth\n */\nfunction getGindicesAtDepth(depth, startIndex, count) {\n  const anchor = BigInt(1) << BigInt(depth);\n  if (startIndex + count > anchor) {\n    throw new Error(\"Too large for depth\");\n  }\n  let gindex = toGindex(depth, BigInt(startIndex));\n  const gindices = [];\n  for (let i = 0; i < count; i++) {\n    gindices.push(gindex++);\n  }\n  return gindices;\n}\nexports.getGindicesAtDepth = getGindicesAtDepth;\nconst ERR_INVALID_GINDEX = \"Invalid gindex\";\nfunction gindexIterator(gindex) {\n  let bitstring;\n  if (typeof gindex === \"string\") {\n    if (!gindex.length) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex.toString(2);\n  }\n  let i = 1;\n  const next = () => {\n    if (i === bitstring.length) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const bit = Number(bitstring[i]);\n    i++;\n    return {\n      done: false,\n      value: bit\n    };\n  };\n  return {\n    [Symbol.iterator]() {\n      return {\n        next\n      };\n    },\n    remainingBitLength() {\n      return bitstring.length - i;\n    }\n  };\n}\nexports.gindexIterator = gindexIterator;\nfunction getGindexBits(gindex) {\n  let bitstring;\n  if (typeof gindex === \"string\") {\n    if (!gindex.length) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex.toString(2);\n  }\n  const bits = [];\n  for (let i = 1; i < bitstring.length; i++) {\n    bits.push(Number(bitstring[i]));\n  }\n  return bits;\n}\nexports.getGindexBits = getGindexBits;\n/**\n * Concatenate Generalized Indices\n * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns\n * the generalized index for A -> Z.\n */\nfunction concatGindices(gindices) {\n  return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), \"0b1\"));\n}\nexports.concatGindices = concatGindices;\nfunction gindexSibling(gindex) {\n  return gindex ^ BigInt(1);\n}\nexports.gindexSibling = gindexSibling;\nfunction gindexParent(gindex) {\n  return gindex / BigInt(2);\n}\nexports.gindexParent = gindexParent;\nfunction gindexChild(gindex, rightChild) {\n  return gindex * BigInt(2) + BigInt(rightChild);\n}\nexports.gindexChild = gindexChild;","map":null,"metadata":{},"sourceType":"script"}