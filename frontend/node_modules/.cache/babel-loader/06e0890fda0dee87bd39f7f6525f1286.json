{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{UBE}from'constants/tokens';import{useMemo}from'react';import ERC20_INTERFACE from'../../constants/abis/erc20';import{useAllTokens}from'../../hooks/Tokens';import{isAddress}from'../../utils';import{useMultipleContractSingleData}from'../multicall/hooks';/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */export function useTokenBalancesWithLoadingIndicator(address,tokens){const validatedTokens=useMemo(()=>{var _tokens$filter;return(_tokens$filter=tokens===null||tokens===void 0?void 0:tokens.filter(t=>isAddress(t===null||t===void 0?void 0:t.address)!==false))!==null&&_tokens$filter!==void 0?_tokens$filter:[];},[tokens]);const validatedTokenAddresses=useMemo(()=>validatedTokens.map(vt=>vt.address),[validatedTokens]);const balances=useMultipleContractSingleData(validatedTokenAddresses,ERC20_INTERFACE,'balanceOf',[address]);const anyLoading=useMemo(()=>balances.some(callState=>callState.loading),[balances]);return[useMemo(()=>address&&validatedTokens.length>0?validatedTokens.reduce((memo,token,i)=>{var _balances$i,_balances$i$result;const value=balances===null||balances===void 0?void 0:(_balances$i=balances[i])===null||_balances$i===void 0?void 0:(_balances$i$result=_balances$i.result)===null||_balances$i$result===void 0?void 0:_balances$i$result[0];const amount=value?JSBI.BigInt(value.toString()):undefined;if(amount){memo[token.address]=new TokenAmount(token,amount);}return memo;},{}):{},[address,validatedTokens,balances]),anyLoading];}export function useTokenBalances(address,tokens){return useTokenBalancesWithLoadingIndicator(address,tokens)[0];}// get the balance for a single token/account combo\nexport function useTokenBalance(account,token){const tokenBalances=useTokenBalances(account,[token]);if(!token)return undefined;return tokenBalances[token.address];}export function useCurrencyBalances(account,currencies){const tokens=useMemo(()=>{var _currencies$filter;return(_currencies$filter=currencies===null||currencies===void 0?void 0:currencies.filter(currency=>currency instanceof Token))!==null&&_currencies$filter!==void 0?_currencies$filter:[];},[currencies]);const tokenBalances=useTokenBalances(account,tokens);return useMemo(()=>{var _currencies$map;return(_currencies$map=currencies===null||currencies===void 0?void 0:currencies.map(currency=>{if(!account||!currency)return undefined;if(currency instanceof Token)return tokenBalances[currency.address];return undefined;}))!==null&&_currencies$map!==void 0?_currencies$map:[];},[account,currencies,tokenBalances]);}export function useCurrencyBalance(account,currency){return useCurrencyBalances(account,[currency])[0];}// mimics useAllBalances\nexport function useAllTokenBalances(){const{address:account}=useCelo();const allTokens=useAllTokens();const allTokensArray=useMemo(()=>Object.values(allTokens!==null&&allTokens!==void 0?allTokens:{}),[allTokens]);const balances=useTokenBalances(account!==null&&account!==void 0?account:undefined,allTokensArray);return balances!==null&&balances!==void 0?balances:{};}// get the total owned, unclaimed, and unharvested UBE for account\nexport function useAggregateUbeBalance(){const{address,network:{chainId}}=useCelo();const ube=chainId?UBE[chainId]:undefined;const ubeBalance=useTokenBalance(address!==null&&address!==void 0?address:undefined,ube);if(!ube)return undefined;return ubeBalance;}","map":null,"metadata":{},"sourceType":"module"}