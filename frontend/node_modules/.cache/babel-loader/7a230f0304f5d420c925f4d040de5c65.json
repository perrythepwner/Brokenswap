{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _taggedTemplateLiteral = require(\"/app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n  constructor(name) {\n    super(\"CodeGen: \\\"code\\\" for \".concat(name, \" not defined\"));\n    this.value = name.value;\n  }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\nclass Scope {\n  constructor() {\n    let {\n      prefixes,\n      parent\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n    return \"\".concat(prefix).concat(ng.index++);\n  }\n  _nameGroup(prefix) {\n    var _a, _b;\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(\"CodeGen: prefix \\\"\".concat(prefix, \"\\\" is not allowed in this scope\"));\n    }\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n  setValue(value, _ref) {\n    let {\n      property,\n      itemIndex\n    } = _ref;\n    this.value = value;\n    this.scopePath = (0, code_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\".\", \"[\", \"]\"])), new code_1.Name(property), itemIndex);\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n\"], [\"\\\\n\"])));\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = _objectSpread(_objectSpread({}, opts), {}, {\n      _n: opts.lines ? line : code_1.nil\n    });\n  }\n  get() {\n    return this._scope;\n  }\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n  value(nameOrPrefix, value) {\n    var _a;\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n    if (vs) {\n      const _name = vs.get(valueKey);\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n  scopeRefs(scopeName) {\n    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._values;\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(\"CodeGen: name \\\"\".concat(name, \"\\\" has no value\"));\n      return (0, code_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"\", \"\"])), scopeName, name.scopePath);\n    });\n  }\n  scopeCode() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._values;\n    let usedValues = arguments.length > 1 ? arguments[1] : undefined;\n    let getCode = arguments.length > 2 ? arguments[2] : undefined;\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(\"CodeGen: name \\\"\".concat(name, \"\\\" has no value\"));\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n  _reduceValues(values, valueCode) {\n    let usedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let getCode = arguments.length > 3 ? arguments[3] : undefined;\n    let code = code_1.nil;\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \"\", \" \", \" = \", \";\", \"\"])), code, def, name, c, this.opts._n);\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \"\", \"\", \"\"])), code, c, this.opts._n);\n        } else {\n          throw new ValueError(name);\n        }\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n    return code;\n  }\n}\nexports.ValueScope = ValueScope;","map":null,"metadata":{},"sourceType":"script"}