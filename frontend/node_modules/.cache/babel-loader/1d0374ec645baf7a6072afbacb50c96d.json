{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useProvider } from '@celo/react-celo';\nimport { useAllInactiveTokens } from 'hooks/Tokens';\nimport { useCallback, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { useAllLists } from 'state/lists/hooks';\nimport { useFetchListCallback } from '../../hooks/useFetchListCallback';\nimport useInterval from '../../hooks/useInterval';\nimport useIsWindowVisible from '../../hooks/useIsWindowVisible';\nimport { acceptListUpdate } from './actions';\n// import { useActiveListUrls } from './hooks'\n\nexport default function Updater() {\n  _s();\n  const library = useProvider();\n  const dispatch = useDispatch();\n  const isWindowVisible = useIsWindowVisible();\n\n  // get all loaded lists, and the active urls\n  const lists = useAllLists();\n  // const activeListUrls = useActiveListUrls()\n\n  // initiate loading\n  useAllInactiveTokens();\n  const fetchList = useFetchListCallback();\n  const fetchAllListsCallback = useCallback(() => {\n    if (!isWindowVisible) return;\n    Object.keys(lists).forEach(url => fetchList(url).catch(error => console.debug('interval list fetching error', error)));\n  }, [fetchList, isWindowVisible, lists]);\n\n  // fetch all lists every 10 minutes, but only after we initialize library\n  useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null);\n\n  // whenever a list is not loaded and not loading, try again to load it\n  useEffect(() => {\n    Object.keys(lists).forEach(listUrl => {\n      const list = lists[listUrl];\n      if (!list.current && !list.loadingRequestId && !list.error) {\n        fetchList(listUrl).catch(error => console.debug('list added fetching error', error));\n      }\n    });\n  }, [dispatch, fetchList, library, lists]);\n\n  // automatically update lists if versions are minor/patch\n  useEffect(() => {\n    Object.keys(lists).forEach(listUrl => {\n      const list = lists[listUrl];\n      if (list.pendingUpdate) {\n        dispatch(acceptListUpdate(listUrl));\n      }\n      // TODO (bl): Figure out why this keeps breaking\n      // if (list.current && list.pendingUpdate) {\n      //   const bump = getVersionUpgrade(list.current.version, list.pendingUpdate.version)\n      //   switch (bump) {\n      //     case VersionUpgrade.NONE:\n      //       throw new Error('unexpected no version bump')\n      //     case VersionUpgrade.PATCH:\n      //     case VersionUpgrade.MINOR: {\n      //       const min = minVersionBump(list.current.tokens, list.pendingUpdate.tokens)\n      //       // automatically update minor/patch as long as bump matches the min update\n      //       if (bump >= min) {\n      //         dispatch(acceptListUpdate(listUrl))\n      //       } else {\n      //         console.error(\n      //           `List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`\n      //         )\n      //       }\n      //       break\n      //     }\n      //     // update any active or inactive lists\n      //     case VersionUpgrade.MAJOR:\n      //       dispatch(acceptListUpdate(listUrl))\n      //   }\n      // }\n    });\n  }, [dispatch, lists]);\n  return null;\n}\n_s(Updater, \"zUb0a+rSOgxM/g5yH/JgeljuCEk=\", false, function () {\n  return [useProvider, useDispatch, useIsWindowVisible, useAllLists, useAllInactiveTokens, useFetchListCallback, useInterval];\n});\n_c = Updater;\nvar _c;\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"names":["useProvider","useAllInactiveTokens","useCallback","useEffect","useDispatch","useAllLists","useFetchListCallback","useInterval","useIsWindowVisible","acceptListUpdate","Updater","_s","library","dispatch","isWindowVisible","lists","fetchList","fetchAllListsCallback","Object","keys","forEach","url","catch","error","console","debug","listUrl","list","current","loadingRequestId","pendingUpdate","_c","$RefreshReg$"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/lists/updater.ts"],"sourcesContent":["import { useProvider } from '@celo/react-celo'\nimport { useAllInactiveTokens } from 'hooks/Tokens'\nimport { useCallback, useEffect } from 'react'\nimport { useDispatch } from 'react-redux'\nimport { useAllLists } from 'state/lists/hooks'\n\nimport { useFetchListCallback } from '../../hooks/useFetchListCallback'\nimport useInterval from '../../hooks/useInterval'\nimport useIsWindowVisible from '../../hooks/useIsWindowVisible'\nimport { AppDispatch } from '../index'\nimport { acceptListUpdate } from './actions'\n// import { useActiveListUrls } from './hooks'\n\nexport default function Updater(): null {\n  const library = useProvider()\n  const dispatch = useDispatch<AppDispatch>()\n  const isWindowVisible = useIsWindowVisible()\n\n  // get all loaded lists, and the active urls\n  const lists = useAllLists()\n  // const activeListUrls = useActiveListUrls()\n\n  // initiate loading\n  useAllInactiveTokens()\n\n  const fetchList = useFetchListCallback()\n  const fetchAllListsCallback = useCallback(() => {\n    if (!isWindowVisible) return\n    Object.keys(lists).forEach((url) =>\n      fetchList(url).catch((error) => console.debug('interval list fetching error', error))\n    )\n  }, [fetchList, isWindowVisible, lists])\n\n  // fetch all lists every 10 minutes, but only after we initialize library\n  useInterval(fetchAllListsCallback, library ? 1000 * 60 * 10 : null)\n\n  // whenever a list is not loaded and not loading, try again to load it\n  useEffect(() => {\n    Object.keys(lists).forEach((listUrl) => {\n      const list = lists[listUrl]\n      if (!list.current && !list.loadingRequestId && !list.error) {\n        fetchList(listUrl).catch((error) => console.debug('list added fetching error', error))\n      }\n    })\n  }, [dispatch, fetchList, library, lists])\n\n  // automatically update lists if versions are minor/patch\n  useEffect(() => {\n    Object.keys(lists).forEach((listUrl) => {\n      const list = lists[listUrl]\n      if (list.pendingUpdate) {\n        dispatch(acceptListUpdate(listUrl))\n      }\n      // TODO (bl): Figure out why this keeps breaking\n      // if (list.current && list.pendingUpdate) {\n      //   const bump = getVersionUpgrade(list.current.version, list.pendingUpdate.version)\n      //   switch (bump) {\n      //     case VersionUpgrade.NONE:\n      //       throw new Error('unexpected no version bump')\n      //     case VersionUpgrade.PATCH:\n      //     case VersionUpgrade.MINOR: {\n      //       const min = minVersionBump(list.current.tokens, list.pendingUpdate.tokens)\n      //       // automatically update minor/patch as long as bump matches the min update\n      //       if (bump >= min) {\n      //         dispatch(acceptListUpdate(listUrl))\n      //       } else {\n      //         console.error(\n      //           `List at url ${listUrl} could not automatically update because the version bump was only PATCH/MINOR while the update had breaking changes and should have been MAJOR`\n      //         )\n      //       }\n      //       break\n      //     }\n      //     // update any active or inactive lists\n      //     case VersionUpgrade.MAJOR:\n      //       dispatch(acceptListUpdate(listUrl))\n      //   }\n      // }\n    })\n  }, [dispatch, lists])\n\n  return null\n}\n"],"mappings":";AAAA,SAASA,WAAW,QAAQ,kBAAkB;AAC9C,SAASC,oBAAoB,QAAQ,cAAc;AACnD,SAASC,WAAW,EAAEC,SAAS,QAAQ,OAAO;AAC9C,SAASC,WAAW,QAAQ,aAAa;AACzC,SAASC,WAAW,QAAQ,mBAAmB;AAE/C,SAASC,oBAAoB,QAAQ,kCAAkC;AACvE,OAAOC,WAAW,MAAM,yBAAyB;AACjD,OAAOC,kBAAkB,MAAM,gCAAgC;AAE/D,SAASC,gBAAgB,QAAQ,WAAW;AAC5C;;AAEA,eAAe,SAASC,OAAOA,CAAA,EAAS;EAAAC,EAAA;EACtC,MAAMC,OAAO,GAAGZ,WAAW,CAAC,CAAC;EAC7B,MAAMa,QAAQ,GAAGT,WAAW,CAAc,CAAC;EAC3C,MAAMU,eAAe,GAAGN,kBAAkB,CAAC,CAAC;;EAE5C;EACA,MAAMO,KAAK,GAAGV,WAAW,CAAC,CAAC;EAC3B;;EAEA;EACAJ,oBAAoB,CAAC,CAAC;EAEtB,MAAMe,SAAS,GAAGV,oBAAoB,CAAC,CAAC;EACxC,MAAMW,qBAAqB,GAAGf,WAAW,CAAC,MAAM;IAC9C,IAAI,CAACY,eAAe,EAAE;IACtBI,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC,CAACK,OAAO,CAAEC,GAAG,IAC7BL,SAAS,CAACK,GAAG,CAAC,CAACC,KAAK,CAAEC,KAAK,IAAKC,OAAO,CAACC,KAAK,CAAC,8BAA8B,EAAEF,KAAK,CAAC,CACtF,CAAC;EACH,CAAC,EAAE,CAACP,SAAS,EAAEF,eAAe,EAAEC,KAAK,CAAC,CAAC;;EAEvC;EACAR,WAAW,CAACU,qBAAqB,EAAEL,OAAO,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;;EAEnE;EACAT,SAAS,CAAC,MAAM;IACde,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC,CAACK,OAAO,CAAEM,OAAO,IAAK;MACtC,MAAMC,IAAI,GAAGZ,KAAK,CAACW,OAAO,CAAC;MAC3B,IAAI,CAACC,IAAI,CAACC,OAAO,IAAI,CAACD,IAAI,CAACE,gBAAgB,IAAI,CAACF,IAAI,CAACJ,KAAK,EAAE;QAC1DP,SAAS,CAACU,OAAO,CAAC,CAACJ,KAAK,CAAEC,KAAK,IAAKC,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEF,KAAK,CAAC,CAAC;MACxF;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAACV,QAAQ,EAAEG,SAAS,EAAEJ,OAAO,EAAEG,KAAK,CAAC,CAAC;;EAEzC;EACAZ,SAAS,CAAC,MAAM;IACde,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC,CAACK,OAAO,CAAEM,OAAO,IAAK;MACtC,MAAMC,IAAI,GAAGZ,KAAK,CAACW,OAAO,CAAC;MAC3B,IAAIC,IAAI,CAACG,aAAa,EAAE;QACtBjB,QAAQ,CAACJ,gBAAgB,CAACiB,OAAO,CAAC,CAAC;MACrC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAACb,QAAQ,EAAEE,KAAK,CAAC,CAAC;EAErB,OAAO,IAAI;AACb;AAACJ,EAAA,CApEuBD,OAAO;EAAA,QACbV,WAAW,EACVI,WAAW,EACJI,kBAAkB,EAG5BH,WAAW,EAIzBJ,oBAAoB,EAEFK,oBAAoB,EAStCC,WAAW;AAAA;AAAAwB,EAAA,GArBWrB,OAAO;AAAA,IAAAqB,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module"}