{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.base64 = void 0;\nconst superstruct_1 = require(\"superstruct\");\nconst assert_1 = require(\"./assert\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nconst base64 = function base64(struct) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b;\n  const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;\n  const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';\n  let letters;\n  if (characterSet === 'base64') {\n    letters = String.raw(_templateObject || (_templateObject = _taggedTemplateLiteral([\"[A-Za-z0-9+/]\"], [\"[A-Za-z0-9+\\\\/]\"])));\n  } else {\n    (0, assert_1.assert)(characterSet === 'base64url');\n    letters = String.raw(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"[-_A-Za-z0-9]\"])));\n  }\n  let re;\n  if (paddingRequired) {\n    re = new RegExp(\"^(?:\".concat(letters, \"{4})*(?:\").concat(letters, \"{3}=|\").concat(letters, \"{2}==)?$\"), 'u');\n  } else {\n    re = new RegExp(\"^(?:\".concat(letters, \"{4})*(?:\").concat(letters, \"{2,3}|\").concat(letters, \"{3}=|\").concat(letters, \"{2}==)?$\"), 'u');\n  }\n  return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64;","map":{"version":3,"sources":["../src/base64.ts"],"names":[],"mappings":";;;;;;;;AAAA,MAAA,aAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAmBA;;;;;;AAMG;AACI,MAAM,MAAM,GAAG,SAAT,MAAM,CACjB,MAAoB,EAElB;EAAA,IADF,OAAA,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAyB,CAAA,CAAE;;EAE3B,MAAM,eAAe,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,KAAK;EACxD,MAAM,YAAY,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,YAAY,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,QAAQ;EAErD,IAAI,OAAe;EACnB,IAAI,YAAY,KAAK,QAAQ,EAAE;IAC7B,OAAO,GAAG,MAAM,CAAC,GAAG,CAAA,eAAA,KAAA,eAAA,GAAA,sBAAA,0CAAgB;GACrC,MAAM;IACL,CAAA,CAAA,EAAA,QAAA,CAAA,MAAM,EAAC,YAAY,KAAK,WAAW,CAAC;IACpC,OAAO,GAAG,MAAM,CAAC,GAAG,CAAA,gBAAA,KAAA,gBAAA,GAAA,sBAAA,qBAAe;EACpC;EAED,IAAI,EAAU;EACd,IAAI,eAAe,EAAE;IACnB,EAAE,GAAG,IAAI,MAAM,QAAA,MAAA,CACN,OAAO,cAAA,MAAA,CAAW,OAAO,WAAA,MAAA,CAAQ,OAAO,eAC/C,GAAG,CACJ;GACF,MAAM;IACL,EAAE,GAAG,IAAI,MAAM,QAAA,MAAA,CACN,OAAO,cAAA,MAAA,CAAW,OAAO,YAAA,MAAA,CAAS,OAAO,WAAA,MAAA,CAAQ,OAAO,eAC/D,GAAG,CACJ;EACF;EAED,OAAO,CAAA,CAAA,EAAA,aAAA,CAAA,OAAO,EAAC,MAAM,EAAE,EAAE,CAAC;AAC5B,CAAC;AA7BY,OAAA,CAAA,MAAM,GAAA,MAAA","sourcesContent":["import { pattern, Struct } from 'superstruct';\n\nimport { assert } from './assert';\n\nexport type Base64Options = {\n  /**\n   * Is the `=` padding at the end required or not.\n   *\n   * @default false\n   */\n  // Padding is optional in RFC 4648, that's why the default value is false\n  paddingRequired?: boolean;\n  /**\n   * Which character set should be used.\n   * The sets are based on {@link https://datatracker.ietf.org/doc/html/rfc4648 RFC 4648}.\n   *\n   * @default 'base64'\n   */\n  characterSet?: 'base64' | 'base64url';\n};\n\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nexport const base64 = <T extends string, S>(\n  struct: Struct<T, S>,\n  options: Base64Options = {},\n) => {\n  const paddingRequired = options.paddingRequired ?? false;\n  const characterSet = options.characterSet ?? 'base64';\n\n  let letters: string;\n  if (characterSet === 'base64') {\n    letters = String.raw`[A-Za-z0-9+\\/]`;\n  } else {\n    assert(characterSet === 'base64url');\n    letters = String.raw`[-_A-Za-z0-9]`;\n  }\n\n  let re: RegExp;\n  if (paddingRequired) {\n    re = new RegExp(\n      `^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`,\n      'u',\n    );\n  } else {\n    re = new RegExp(\n      `^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`,\n      'u',\n    );\n  }\n\n  return pattern(struct, re);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}