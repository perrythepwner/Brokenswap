{"ast":null,"code":"\"use strict\";\n\nvar _wrapRegExp = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/wrapRegExp.js\").default;\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zeroValue = exports.structHash = exports.encodeData = exports.typeHash = exports.encodeType = exports.generateTypedDataHash = exports.noString = exports.noNumber = exports.noBool = exports.defined = exports.eip712OptionalSchema = exports.eip712OptionalType = exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES = exports.EIP712_ATOMIC_TYPES = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar t = __importStar(require(\"io-ts\"));\nvar web3_eth_abi_1 = __importDefault(require(\"web3-eth-abi\"));\n/** Array of all EIP-712 atomic type names. */\nexports.EIP712_ATOMIC_TYPES = ['bytes1', 'bytes32', 'uint8', 'uint64', 'uint256',\n// This list should technically include all types from uint8 to uint256, and int8 to int256\n'int8', 'int256', 'bool', 'address'];\nexports.EIP712_DYNAMIC_TYPES = ['bytes', 'string'];\nexports.EIP712_BUILTIN_TYPES = exports.EIP712_ATOMIC_TYPES.concat(exports.EIP712_DYNAMIC_TYPES);\n// Regular expression used to identify and parse EIP-712 array type strings.\nvar EIP712_ARRAY_REGEXP = /*#__PURE__*/_wrapRegExp(/^([\\w<>\\[\\]_\\-]+)(\\[(\\d+)?\\])$/, {\n  memberType: 1,\n  fixedLength: 3\n});\n// Regular experssion used to identity EIP-712 integer types (e.g. int256, uint256, uint8).\nvar EIP712_INT_REGEXP = /^u?int\\d*$/;\n/**\n * Utility to build EIP712Optional<T> types to insert in EIP-712 type arrays.\n * @param typeName EIP-712 string type name. Should be builtin or defined in the EIP712Types\n * structure into which this type will be merged.\n */\nvar eip712OptionalType = function eip712OptionalType(typeName) {\n  var _a;\n  return _a = {}, _a[\"Optional<\".concat(typeName, \">\")] = [{\n    name: 'defined',\n    type: 'bool'\n  }, {\n    name: 'value',\n    type: typeName\n  }], _a;\n};\nexports.eip712OptionalType = eip712OptionalType;\n/**\n * Utility to build EIP712Optional<T> schemas for encoding and decoding with io-ts.\n * @param schema io-ts type (a.k.a. schema or codec) describing the inner type.\n */\nvar eip712OptionalSchema = function eip712OptionalSchema(schema) {\n  return t.type({\n    defined: t.boolean,\n    value: schema\n  });\n};\nexports.eip712OptionalSchema = eip712OptionalSchema;\n/** Utility to construct an defined EIP712Optional value with inferred type. */\nvar defined = function defined(value) {\n  return {\n    defined: true,\n    value: value\n  };\n};\nexports.defined = defined;\n/** Undefined EIP712Optional type with value type boolean. */\nexports.noBool = {\n  defined: false,\n  value: false\n};\n/** Undefined EIP712Optional type with value type number. */\nexports.noNumber = {\n  defined: false,\n  value: 0\n};\n/** Undefined EIP712Optional type with value type string. */\nexports.noString = {\n  defined: false,\n  value: ''\n};\n/**\n * Generates the EIP712 Typed Data hash for signing\n * @param   typedData An object that conforms to the EIP712TypedData interface\n * @return  A Buffer containing the hash of the typed data.\n */\nfunction generateTypedDataHash(typedData) {\n  return (0, ethereumjs_util_1.keccak)(Buffer.concat([Buffer.from('1901', 'hex'), structHash('EIP712Domain', typedData.domain, typedData.types), structHash(typedData.primaryType, typedData.message, typedData.types)]));\n}\nexports.generateTypedDataHash = generateTypedDataHash;\n/**\n * Given the primary type, and dictionary of types, this function assembles a sorted list\n * representing the transitive dependency closure of the primary type. (Inclusive of the primary\n * type itself.)\n */\nfunction findDependencies(primaryType, types, found) {\n  var e_1, _a;\n  var _b;\n  if (found === void 0) {\n    found = [];\n  }\n  // If we have aready found the dependencies of this type, or it is a builtin, return early.\n  if (found.includes(primaryType) || exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {\n    return [];\n  }\n  // If this is an array type, return the results for its member type.\n  if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n    var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n    var memberType = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.memberType;\n    return findDependencies(memberType, types, found);\n  }\n  // If this is not a builtin and is not defined, we cannot correctly construct a type encoding.\n  if (types[primaryType] === undefined) {\n    throw new Error(\"Unrecognized type \".concat(primaryType, \" is not included in the EIP-712 type list\"));\n  }\n  // Execute a depth-first search to populate the (inclusive) dependencies list.\n  // By the first invarient of this function, the resulting list should not contain duplicates.\n  var dependencies = [primaryType];\n  try {\n    for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var field = _d.value;\n      dependencies.push.apply(dependencies, __spreadArray([], __read(findDependencies(field.type, types, found.concat(dependencies))), false));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return dependencies;\n}\n/**\n * Creates a string encoding of the primary type, including all dependencies.\n * E.g. \"Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)\"\n */\nfunction encodeType(primaryType, types) {\n  var e_2, _a;\n  var deps = findDependencies(primaryType, types);\n  deps = deps.filter(function (d) {\n    return d !== primaryType;\n  });\n  deps = [primaryType].concat(deps.sort());\n  var result = '';\n  try {\n    for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n      var dep = deps_1_1.value;\n      result += \"\".concat(dep, \"(\").concat(types[dep].map(function (_a) {\n        var name = _a.name,\n          type = _a.type;\n        return \"\".concat(type, \" \").concat(name);\n      }).join(','), \")\");\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return result;\n}\nexports.encodeType = encodeType;\nfunction typeHash(primaryType, types) {\n  return (0, ethereumjs_util_1.keccak)(encodeType(primaryType, types));\n}\nexports.typeHash = typeHash;\n/** Encodes a single EIP-712 value to a 32-byte buffer */\nfunction encodeValue(valueType, value, types) {\n  var _a;\n  // Encode the atomic types as their corresponding soldity ABI type.\n  if (exports.EIP712_ATOMIC_TYPES.includes(valueType)) {\n    // @ts-ignore TypeScript does not believe encodeParameter exists.\n    var hexEncoded = web3_eth_abi_1.default.encodeParameter(valueType, normalizeValue(valueType, value));\n    return Buffer.from((0, address_1.trimLeading0x)(hexEncoded), 'hex');\n  }\n  // Encode `string` and `bytes` types as their keccak hash.\n  if (valueType === 'string') {\n    // Converting to Buffer before passing to `keccak` prevents an issue where the string is\n    // interpretted as a hex-encoded string when is starts with 0x.\n    // https://github.com/ethereumjs/ethereumjs-util/blob/7e3be1d97b4e11fbc4924836b8c444e644f643ac/index.js#L155-L183\n    return (0, ethereumjs_util_1.keccak)(Buffer.from(value, 'utf8'));\n  }\n  if (valueType === 'bytes') {\n    // Allow the user to use either utf8 (plain string) or hex encoding for their bytes.\n    // Note: keccak throws if the value cannot be converted into a Buffer,\n    return (0, ethereumjs_util_1.keccak)(value);\n  }\n  // Encode structs as its hashStruct (e.g. keccak(typeHash || encodeData(struct)) ).\n  if (types[valueType] !== undefined) {\n    // tslint:disable-next-line:no-unnecessary-type-assertion.\n    return structHash(valueType, value, types);\n  }\n  // Encode arrays as the hash of the concatenated encoding of the underlying types.\n  if (EIP712_ARRAY_REGEXP.test(valueType)) {\n    // Note: If a fixed length is provided in the type, it is not checked.\n    var match = EIP712_ARRAY_REGEXP.exec(valueType);\n    var memberType_1 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat(value.map(function (member) {\n      return encodeValue(memberType_1, member, types);\n    })));\n  }\n  throw new Error(\"Unrecognized or unsupported type in EIP-712 encoding: \".concat(valueType));\n}\nfunction normalizeValue(type, value) {\n  var normalizedValue = EIP712_INT_REGEXP.test(type) && bignumber_js_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n  return normalizedValue;\n}\n/**\n * Constructs the struct encoding of the data as the primary type.\n */\nfunction encodeData(primaryType, data, types) {\n  var fields = types[primaryType];\n  if (fields === undefined) {\n    throw new Error(\"Unrecognized primary type in EIP-712 encoding: \".concat(primaryType));\n  }\n  return Buffer.concat(fields.map(function (field) {\n    return encodeValue(field.type, data[field.name], types);\n  }));\n}\nexports.encodeData = encodeData;\nfunction structHash(primaryType, data, types) {\n  return (0, ethereumjs_util_1.keccak)(Buffer.concat([typeHash(primaryType, types), encodeData(primaryType, data, types)]));\n}\nexports.structHash = structHash;\n/**\n * Produce the zero value for a given type.\n *\n * @remarks\n * All atomic types will encode as the 32-byte zero value. Dynamic types as an empty hash.\n * Dynamic arrays will return an empty array. Fixed length arrays will have members set to zero.\n * Structs will have the values of all fields set to zero recursively.\n *\n * Note that EIP-712 does not specify zero values, and so this is non-standard.\n */\nfunction zeroValue(primaryType, types) {\n  var _a, _b;\n  if (types === void 0) {\n    types = {};\n  }\n  // If the type is a built-in, return a pre-defined zero value.\n  if (['bytes', 'bytes1', 'bytes32'].includes(primaryType)) {\n    return Buffer.alloc(0);\n  }\n  if (['uint8', 'uint256', 'int8', 'int256'].includes(primaryType)) {\n    return 0;\n  }\n  if (primaryType === 'bool') {\n    return false;\n  }\n  if (primaryType === 'address') {\n    return address_1.NULL_ADDRESS;\n  }\n  if (primaryType === 'string') {\n    return '';\n  }\n  // If the type is an array, return an empty array or an array of the given fixed length.\n  if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n    var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n    var memberType_2 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n    var fixedLengthStr = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.fixedLength;\n    var fixedLength = fixedLengthStr === undefined ? 0 : parseInt(fixedLengthStr, 10);\n    return __spreadArray([], __read(Array(fixedLength).keys()), false).map(function () {\n      return zeroValue(memberType_2, types);\n    });\n  }\n  // Must be user-defined type. Return an object with all fields set to their zero value.\n  var fields = types[primaryType];\n  if (fields === undefined) {\n    throw new Error(\"Unrecognized primary type for EIP-712 zero value: \".concat(primaryType));\n  }\n  return fields.reduce(function (obj, field) {\n    var _a;\n    return __assign(__assign({}, obj), (_a = {}, _a[field.name] = zeroValue(field.type, types), _a));\n  }, {});\n}\nexports.zeroValue = zeroValue;","map":null,"metadata":{},"sourceType":"script"}