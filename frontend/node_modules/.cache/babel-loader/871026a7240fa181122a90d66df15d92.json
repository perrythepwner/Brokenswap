{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = a => a instanceof Uint8Array;\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : \"0x\".concat(hex));\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(\"\".concat(title, \" must be valid hex string, got \\\"\").concat(hex, \"\\\". Cause: \").concat(e));\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(\"\".concat(title, \" must be hex string or Uint8Array\"));\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(\"\".concat(title, \" expected \").concat(expectedLength, \" bytes, got \").concat(len));\n  return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach(a => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(\"utf8ToBytes expected string, got \".concat(typeof str));\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = n => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = function h() {\n    for (var _len2 = arguments.length, b = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      b[_key2] = arguments[_key2];\n    }\n    return hmacFn(k, v, ...b);\n  }; // hmac(k)(v, ...values)\n  const reseed = function reseed() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u8n();\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators) {\n  let optValidators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(\"Invalid validator \\\"\".concat(type, \"\\\", expected function\"));\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\"Invalid param \".concat(String(fieldName), \"=\").concat(val, \" (\").concat(typeof val, \"), expected \").concat(type));\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\nexports.validateObject = validateObject;\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });","map":{"version":3,"sources":["../src/abstract/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject;\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}