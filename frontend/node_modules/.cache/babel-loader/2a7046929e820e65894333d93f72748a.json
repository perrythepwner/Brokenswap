{"ast":null,"code":"import{Pair,Token}from'@ubeswap/sdk';import{useCallback,useEffect,useMemo}from'react';import ReactGA from'react-ga';import{shallowEqual,useDispatch,useSelector}from'react-redux';import{colors}from'../../theme';import{addSerializedPair,addSerializedToken,updateUserAllowMoolaWithdrawal,updateUserDarkMode,updateUserDeadline,updateUserDisableSmartRouting,updateUserExpertMode,updateUserMinApprove,updateUserSingleHopOnly,updateUserSlippageTolerance}from'./actions';function serializeToken(token){return{chainId:token.chainId,address:token.address,decimals:token.decimals,symbol:token.symbol,name:token.name};}function deserializeToken(serializedToken){return new Token(serializedToken.chainId,serializedToken.address,serializedToken.decimals,serializedToken.symbol,serializedToken.name);}export function useIsDarkMode(){const{userDarkMode,matchesDarkMode}=useSelector(_ref=>{let{user:{matchesDarkMode,userDarkMode}}=_ref;return{userDarkMode,matchesDarkMode};},shallowEqual);return userDarkMode===null?matchesDarkMode:userDarkMode;}export function useDarkModeManager(){const dispatch=useDispatch();const darkMode=true;// should be useIsDarkMode() but in this ctf only dark mode allowed\nuseEffect(()=>{const _colors=colors(darkMode);},[darkMode]);const toggleSetDarkMode=useCallback(()=>{dispatch(updateUserDarkMode({userDarkMode:!darkMode}));},[darkMode,dispatch]);return[darkMode,toggleSetDarkMode];}export function useIsExpertMode(){return useSelector(state=>state.user.userExpertMode);}export function useExpertModeManager(){const dispatch=useDispatch();const expertMode=useIsExpertMode();const toggleSetExpertMode=useCallback(()=>{dispatch(updateUserExpertMode({userExpertMode:!expertMode}));},[expertMode,dispatch]);return[expertMode,toggleSetExpertMode];}export function useUserMinApprove(){const dispatch=useDispatch();const minApprove=useSelector(state=>state.user.userMinApprove);const setMinApprove=useCallback(newMinApprove=>{dispatch(updateUserMinApprove({userMinApprove:newMinApprove}));},[dispatch]);return[minApprove,setMinApprove];}export function useUserAllowMoolaWithdrawal(){const dispatch=useDispatch();const allowMoolaWithdrawal=useSelector(state=>state.user.userAllowMoolaWithdrawal);const setAllowMoolaWithdrawal=useCallback(newallowMoolaWithdrawal=>{dispatch(updateUserAllowMoolaWithdrawal({userAllowMoolaWithdrawal:newallowMoolaWithdrawal}));},[dispatch]);return[allowMoolaWithdrawal,setAllowMoolaWithdrawal];}export function useUserDisableSmartRouting(){const dispatch=useDispatch();const disableSmartRouting=useSelector(state=>state.user.userDisableSmartRouting);const setDisableSmartRouting=useCallback(newSmartRouting=>{dispatch(updateUserDisableSmartRouting({userDisableSmartRouting:newSmartRouting}));},[dispatch]);return[disableSmartRouting,setDisableSmartRouting];}export function useUserSingleHopOnly(){const dispatch=useDispatch();const singleHopOnly=useSelector(state=>state.user.userSingleHopOnly);const setSingleHopOnly=useCallback(newSingleHopOnly=>{ReactGA.event({category:'Routing',action:newSingleHopOnly?'enable single hop':'disable single hop'});dispatch(updateUserSingleHopOnly({userSingleHopOnly:newSingleHopOnly}));},[dispatch]);return[singleHopOnly,setSingleHopOnly];}export function useUserSlippageTolerance(){const dispatch=useDispatch();const userSlippageTolerance=useSelector(state=>{return state.user.userSlippageTolerance;});const setUserSlippageTolerance=useCallback(userSlippageTolerance=>{dispatch(updateUserSlippageTolerance({userSlippageTolerance}));},[dispatch]);return[userSlippageTolerance,setUserSlippageTolerance];}export function useUserTransactionTTL(){const dispatch=useDispatch();const userDeadline=useSelector(state=>{return state.user.userDeadline;});const setUserDeadline=useCallback(userDeadline=>{dispatch(updateUserDeadline({userDeadline}));},[dispatch]);return[userDeadline,setUserDeadline];}export function useAddUserToken(){const dispatch=useDispatch();return useCallback(token=>{dispatch(addSerializedToken({serializedToken:serializeToken(token)}));},[dispatch]);}export function useUserAddedTokens(){const serializedTokensMap=useSelector(_ref2=>{let{user:{tokens}}=_ref2;return tokens;});return useMemo(()=>{var _serializedTokensMap$;return Object.values((_serializedTokensMap$=serializedTokensMap[1])!==null&&_serializedTokensMap$!==void 0?_serializedTokensMap$:{}).map(deserializeToken);},[serializedTokensMap,1]);}function serializePair(pair){return{token0:serializeToken(pair.token0),token1:serializeToken(pair.token1)};}export function usePairAdder(){const dispatch=useDispatch();return useCallback(pair=>{dispatch(addSerializedPair({serializedPair:serializePair(pair)}));},[dispatch]);}export function useURLWarningVisible(){return useSelector(state=>state.user.URLWarningVisible);}/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */export function toV2LiquidityToken(_ref3){let[tokenA,tokenB]=_ref3;return new Token(tokenA.chainId,Pair.getAddress(tokenA,tokenB),18,'ULP','Ubeswap LP Token');}","map":null,"metadata":{},"sourceType":"module"}