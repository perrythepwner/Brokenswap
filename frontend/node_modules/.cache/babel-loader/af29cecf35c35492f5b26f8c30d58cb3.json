{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\nconst node_1 = require(\"../node\");\nconst tree_1 = require(\"../tree\");\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\nfunction createMultiProof(rootNode, gindices) {\n  const tree = new tree_1.Tree(rootNode);\n  const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map(gindex => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n  const leafGindices = gindices.slice().sort((a, b) => a < b ? 1 : -1);\n  const leaves = leafGindices.map(gindex => tree.getRoot(gindex));\n  const witnesses = witnessGindices.map(gindex => tree.getRoot(gindex));\n  return [leaves, witnesses, leafGindices];\n}\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n  var _leafBitstrings$0$len, _leafBitstrings$, _witnessBitstrings$0$, _witnessBitstrings$;\n  if (leaves.length !== gindices.length) {\n    throw new Error(\"Leaves length should equal gindices length\");\n  }\n  const leafBitstrings = gindices.map(gindex => gindex.toString(2));\n  const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n  if (witnessBitstrings.length !== witnesses.length) {\n    throw new Error(\"Witnesses length should equal witnesses gindices length\");\n  }\n  // Algorithm:\n  // create an object which tracks key-values for each level\n  // pre-load leaves and witnesses into the level object\n  // level by level, starting from the bottom,\n  // find the sibling, create the parent, store it in the next level up\n  // the root is in level 1\n  const maxLevel = Math.max((_leafBitstrings$0$len = (_leafBitstrings$ = leafBitstrings[0]) === null || _leafBitstrings$ === void 0 ? void 0 : _leafBitstrings$.length) !== null && _leafBitstrings$0$len !== void 0 ? _leafBitstrings$0$len : 0, (_witnessBitstrings$0$ = (_witnessBitstrings$ = witnessBitstrings[0]) === null || _witnessBitstrings$ === void 0 ? void 0 : _witnessBitstrings$.length) !== null && _witnessBitstrings$0$ !== void 0 ? _witnessBitstrings$0$ : 0);\n  const levels = Object.fromEntries(Array.from({\n    length: maxLevel\n  }, (_, i) => [i + 1, {}]));\n  // preload leaves and witnesses\n  for (let i = 0; i < leafBitstrings.length; i++) {\n    const leafBitstring = leafBitstrings[i];\n    const leaf = leaves[i];\n    levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n  }\n  for (let i = 0; i < witnessBitstrings.length; i++) {\n    const witnessBitstring = witnessBitstrings[i];\n    const witness = witnesses[i];\n    levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n  }\n  for (let i = maxLevel; i > 1; i--) {\n    const level = levels[i];\n    const parentLevel = levels[i - 1];\n    for (const bitstring of Object.keys(level)) {\n      const node = level[bitstring];\n      // if the node doesn't exist, we've already processed its sibling\n      if (!node) {\n        continue;\n      }\n      const isLeft = bitstring[bitstring.length - 1] === \"0\";\n      const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n      const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n      const siblingNode = level[siblingBitstring];\n      if (!siblingNode) {\n        throw new Error(\"Sibling not found: \".concat(siblingBitstring));\n      }\n      // store the parent node\n      const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n      parentLevel[parentBitstring] = parentNode;\n      // delete the used nodes\n      delete level[bitstring];\n      delete level[siblingBitstring];\n    }\n  }\n  const root = levels[1][\"1\"];\n  if (!root) {\n    throw new Error(\"Internal consistency error: no root found\");\n  }\n  return root;\n}\nexports.createNodeFromMultiProof = createNodeFromMultiProof;","map":null,"metadata":{},"sourceType":"script"}