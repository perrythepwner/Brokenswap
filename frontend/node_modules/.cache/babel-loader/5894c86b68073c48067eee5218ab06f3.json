{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcEngine = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nclass JsonRpcEngine extends safe_event_emitter_1.default {\n  constructor() {\n    super();\n    this._middleware = [];\n  }\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n  handle(req, cb) {\n    if (cb && typeof cb !== 'function') {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n      return this._handleBatch(req);\n    }\n    if (cb) {\n      return this._handle(req, cb);\n    }\n    return this._promiseHandle(req);\n  }\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware() {\n    var _this = this;\n    return /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next, end) {\n        try {\n          const [middlewareError, isComplete, returnHandlers] = yield JsonRpcEngine._runAllMiddleware(req, res, _this._middleware);\n          if (isComplete) {\n            yield JsonRpcEngine._runReturnHandlers(returnHandlers);\n            return end(middlewareError);\n          }\n          return next( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (handlerCallback) {\n              try {\n                yield JsonRpcEngine._runReturnHandlers(returnHandlers);\n              } catch (error) {\n                return handlerCallback(error);\n              }\n              return handlerCallback();\n            });\n            return function (_x5) {\n              return _ref2.apply(this, arguments);\n            };\n          }());\n        } catch (error) {\n          return end(error);\n        }\n      });\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  _handleBatch(reqs, cb) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // The order here is important\n      try {\n        // 2. Wait for all requests to finish, or throw on some kind of fatal\n        // error\n        const responses = yield Promise.all(\n        // 1. Begin executing each request in the order received\n        reqs.map(_this2._promiseHandle.bind(_this2)));\n        // 3. Return batch response\n        if (cb) {\n          return cb(null, responses);\n        }\n        return responses;\n      } catch (error) {\n        if (cb) {\n          return cb(error);\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * A promise-wrapped _handle.\n   */\n  _promiseHandle(req) {\n    return new Promise(resolve => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n  _handle(callerReq, cb) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== 'object') {\n        const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, \"Requests must be plain objects. Received: \".concat(typeof callerReq), {\n          request: callerReq\n        });\n        return cb(error, {\n          id: undefined,\n          jsonrpc: '2.0',\n          error\n        });\n      }\n      if (typeof callerReq.method !== 'string') {\n        const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, \"Must specify a string method. Received: \".concat(typeof callerReq.method), {\n          request: callerReq\n        });\n        return cb(error, {\n          id: callerReq.id,\n          jsonrpc: '2.0',\n          error\n        });\n      }\n      const req = Object.assign({}, callerReq);\n      const res = {\n        id: req.id,\n        jsonrpc: req.jsonrpc\n      };\n      let error = null;\n      try {\n        yield _this3._processRequest(req, res);\n      } catch (_error) {\n        // A request handler error, a re-thrown middleware error, or something\n        // unexpected.\n        error = _error;\n      }\n      if (error) {\n        // Ensure no result is present on an errored response\n        delete res.result;\n        if (!res.error) {\n          res.error = eth_rpc_errors_1.serializeError(error);\n        }\n      }\n      return cb(error, res);\n    })();\n  }\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n  _processRequest(req, res) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const [error, isComplete, returnHandlers] = yield JsonRpcEngine._runAllMiddleware(req, res, _this4._middleware);\n      // Throw if \"end\" was not called, or if the response has neither a result\n      // nor an error.\n      JsonRpcEngine._checkForCompletion(req, res, isComplete);\n      // The return handlers should run even if an error was encountered during\n      // middleware processing.\n      yield JsonRpcEngine._runReturnHandlers(returnHandlers);\n      // Now we re-throw the middleware processing error, if any, to catch it\n      // further up the call chain.\n      if (error) {\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  static _runAllMiddleware(req, res, middlewareStack) {\n    return _asyncToGenerator(function* () {\n      const returnHandlers = [];\n      let error = null;\n      let isComplete = false;\n      // Go down stack of middleware, call and collect optional returnHandlers\n      for (const middleware of middlewareStack) {\n        [error, isComplete] = yield JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);\n        if (isComplete) {\n          break;\n        }\n      }\n      return [error, isComplete, returnHandlers.reverse()];\n    })();\n  }\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n        if (error) {\n          res.error = eth_rpc_errors_1.serializeError(error);\n        }\n        // True indicates that the request should end\n        resolve([error, true]);\n      };\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== 'function') {\n              end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, \"JsonRpcEngine: \\\"next\\\" return handlers must be functions. \" + \"Received \\\"\".concat(typeof returnHandler, \"\\\" for request:\\n\").concat(jsonify(req)), {\n                request: req\n              }));\n            }\n            returnHandlers.push(returnHandler);\n          }\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n  static _runReturnHandlers(handlers) {\n    return _asyncToGenerator(function* () {\n      for (const handler of handlers) {\n        yield new Promise((resolve, reject) => {\n          handler(err => err ? reject(err) : resolve());\n        });\n      }\n    })();\n  }\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n  static _checkForCompletion(req, res, isComplete) {\n    if (!('result' in res) && !('error' in res)) {\n      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, \"JsonRpcEngine: Response has no error or result for request:\\n\".concat(jsonify(req)), {\n        request: req\n      });\n    }\n    if (!isComplete) {\n      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, \"JsonRpcEngine: Nothing ended request:\\n\".concat(jsonify(req)), {\n        request: req\n      });\n    }\n  }\n}\nexports.JsonRpcEngine = JsonRpcEngine;\nfunction jsonify(request) {\n  return JSON.stringify(request, null, 2);\n}","map":{"version":3,"sources":["../src/JsonRpcEngine.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonRpcEngine = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nclass JsonRpcEngine extends safe_event_emitter_1.default {\n    constructor() {\n        super();\n        this._middleware = [];\n    }\n    /**\n     * Add a middleware function to the engine's middleware stack.\n     *\n     * @param middleware - The middleware function to add.\n     */\n    push(middleware) {\n        this._middleware.push(middleware);\n    }\n    handle(req, cb) {\n        if (cb && typeof cb !== 'function') {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n     * Returns this engine as a middleware function that can be pushed to other\n     * engines.\n     *\n     * @returns This engine as a middleware function.\n     */\n    asMiddleware() {\n        return async (req, res, next, end) => {\n            try {\n                const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JsonRpcEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback) => {\n                    try {\n                        await JsonRpcEngine._runReturnHandlers(returnHandlers);\n                    }\n                    catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            }\n            catch (error) {\n                return end(error);\n            }\n        };\n    }\n    async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(\n            // 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        }\n        catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n     * A promise-wrapped _handle.\n     */\n    _promiseHandle(req) {\n        return new Promise((resolve) => {\n            this._handle(req, (_err, res) => {\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                resolve(res);\n            });\n        });\n    }\n    /**\n     * Ensures that the request object is valid, processes it, and passes any\n     * error and the response object to the given callback.\n     *\n     * Does not reject.\n     */\n    async _handle(callerReq, cb) {\n        if (!callerReq ||\n            Array.isArray(callerReq) ||\n            typeof callerReq !== 'object') {\n            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });\n            return cb(error, { id: undefined, jsonrpc: '2.0', error });\n        }\n        if (typeof callerReq.method !== 'string') {\n            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });\n            return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });\n        }\n        const req = Object.assign({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc,\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        }\n        catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                res.error = eth_rpc_errors_1.serializeError(error);\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n     * For the given request and response, runs all middleware and their return\n     * handlers, if any, and ensures that internal request processing semantics\n     * are satisfied.\n     */\n    async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JsonRpcEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JsonRpcEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n    /**\n     * Serially executes the given stack of middleware.\n     *\n     * @returns An array of any error encountered during middleware execution,\n     * a boolean indicating whether the request was completed, and an array of\n     * middleware-defined return handlers.\n     */\n    static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack) {\n            [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [error, isComplete, returnHandlers.reverse()];\n    }\n    /**\n     * Runs an individual middleware.\n     *\n     * @returns An array of any error encountered during middleware exection,\n     * and a boolean indicating whether the request should end.\n     */\n    static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve) => {\n            const end = (err) => {\n                const error = err || res.error;\n                if (error) {\n                    res.error = eth_rpc_errors_1.serializeError(error);\n                }\n                // True indicates that the request should end\n                resolve([error, true]);\n            };\n            const next = (returnHandler) => {\n                if (res.error) {\n                    end(res.error);\n                }\n                else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== 'function') {\n                            end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: \"next\" return handlers must be functions. ` +\n                                `Received \"${typeof returnHandler}\" for request:\\n${jsonify(req)}`, { request: req }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([null, false]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            }\n            catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n     * Serially executes array of return handlers. The request and response are\n     * assumed to be in their scope.\n     */\n    static async _runReturnHandlers(handlers) {\n        for (const handler of handlers) {\n            await new Promise((resolve, reject) => {\n                handler((err) => (err ? reject(err) : resolve()));\n            });\n        }\n    }\n    /**\n     * Throws an error if the response has neither a result nor an error, or if\n     * the \"isComplete\" flag is falsy.\n     */\n    static _checkForCompletion(req, res, isComplete) {\n        if (!('result' in res) && !('error' in res)) {\n            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\\n${jsonify(req)}`, { request: req });\n        }\n        if (!isComplete) {\n            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\\n${jsonify(req)}`, { request: req });\n        }\n    }\n}\nexports.JsonRpcEngine = JsonRpcEngine;\nfunction jsonify(request) {\n    return JSON.stringify(request, null, 2);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSnNvblJwY0VuZ2luZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9Kc29uUnBjRW5naW5lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHNGQUE0RDtBQUM1RCxtREFBOEU7QUF1RjlFOzs7R0FHRztBQUNILE1BQWEsYUFBYyxTQUFRLDRCQUFnQjtJQUdqRDtRQUNFLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLENBQU8sVUFBbUM7UUFDNUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBaUQsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUEyQ0QsTUFBTSxDQUFDLEdBQVksRUFBRSxFQUFRO1FBQzNCLElBQUksRUFBRSxJQUFJLE9BQU8sRUFBRSxLQUFLLFVBQVUsRUFBRTtZQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7U0FDL0Q7UUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdEIsSUFBSSxFQUFFLEVBQUU7Z0JBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUNuQztZQUNELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMvQjtRQUVELElBQUksRUFBRSxFQUFFO1lBQ04sT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQThCLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDekQ7UUFDRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBOEIsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFlBQVk7UUFDVixPQUFPLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUNuQyxJQUFJ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"]},"metadata":{},"sourceType":"script"}