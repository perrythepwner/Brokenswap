{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ByteListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst byteArray_1 = require(\"./byteArray\");\n/**\n * ByteList: Immutable alias of List[byte, N]\n * - Notation: `ByteList[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteList is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteList.\n *\n * For a `ByteListType` with mutability, use `ListBasicType(byteType)`\n */\nclass ByteListType extends byteArray_1.ByteArrayType {\n  constructor(limitBytes, opts) {\n    var _opts$typeName;\n    super();\n    this.limitBytes = limitBytes;\n    this.fixedSize = null;\n    this.isList = true;\n    if (limitBytes === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"ByteList[\".concat(limitBytes, \"]\");\n    this.maxChunkCount = Math.ceil(this.limitBytes / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = 1 + this.chunkDepth;\n    this.minSize = 0;\n    this.maxSize = this.limitBytes;\n  }\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(ByteListType, opts.typeName))(limitBits, opts);\n  }\n  // Views: inherited from ByteArrayType\n  // Serialization + deserialization\n  value_serializedSize(value) {\n    return value.length;\n  }\n  // value_* inherited from ByteArrayType\n  tree_serializedSize(node) {\n    return arrayBasic_1.getLengthFromRootNode(node);\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n    const byteLen = arrayBasic_1.getLengthFromRootNode(node);\n    const chunkLen = Math.ceil(byteLen / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n    return offset + byteLen;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n    return arrayBasic_1.addLengthNode(chunksNode, end - start);\n  }\n  tree_getByteLen(node) {\n    if (!node) throw new Error(\"ByteListType requires a node to get leaves\");\n    return arrayBasic_1.getLengthFromRootNode(node);\n  }\n  // Merkleization: inherited from ByteArrayType\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);\n  }\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from ByteArrayType\n  assertValidSize(size) {\n    if (size > this.limitBytes) {\n      throw Error(\"ByteList invalid size \".concat(size, \" limit \").concat(this.limitBytes));\n    }\n  }\n}\nexports.ByteListType = ByteListType;","map":null,"metadata":{},"sourceType":"script"}