{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixTheme = exports.contrastCheck = exports.contrast = exports.luminance = exports.RGBToHex = exports.hexToRGB = exports.Color = void 0;\nconst default_1 = __importDefault(require(\"../theme/default\"));\nconst logger_1 = require(\"./logger\");\nconst minmax = function minmax(value) {\n  let lowerBound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let higherBound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return Math.max(lowerBound, Math.min(higherBound, value));\n};\nconst round2 = num => Math.round((num + Number.EPSILON) * 100) / 100;\nvar Format;\n(function (Format) {\n  Format[Format[\"Hex\"] = 0] = \"Hex\";\n  Format[Format[\"Rgb\"] = 1] = \"Rgb\";\n})(Format || (Format = {}));\nclass Color {\n  constructor(color) {\n    this.a = null;\n    if (color.startsWith('#')) {\n      if (color.length === 4) {\n        // eg: #fff, #000\n        this.r = parseInt(color.slice(1, 2) + color.slice(1, 2), 16);\n        this.g = parseInt(color.slice(2, 3) + color.slice(2, 3), 16);\n        this.b = parseInt(color.slice(3, 4) + color.slice(3, 4), 16);\n      } else {\n        // eg: #ffffff, #000000\n        this.r = parseInt(color.slice(1, 3), 16);\n        this.g = parseInt(color.slice(3, 5), 16);\n        this.b = parseInt(color.slice(5, 7), 16);\n        if (color.length === 9) {\n          // eg: #ffffff80, #000000ff\n          this.a = round2(minmax(parseInt(color.slice(7, 9), 16) / 255));\n        }\n      }\n    } else if (color.startsWith('rgb')) {\n      // eg: rgb(0, 0, 0)\n      const values = color.split('(')[1].split(')')[0].split(',');\n      this.r = parseInt(values[0].trim(), 10);\n      this.g = parseInt(values[1].trim(), 10);\n      this.b = parseInt(values[2].trim(), 10);\n      if (values[3]) {\n        // eg: rgba(0, 0, 0, 1)\n        this.a = round2(minmax(parseFloat(values[3])));\n      }\n      (0, logger_1.getApplicationLogger)().warn('[colors]', \"RGB(A) values not officially supported, but were translated to hex (\".concat(color, \" -> \").concat(this.toHex(), \")\"));\n    } else if (color.startsWith('hsl')) {\n      // eg: hsl(100, 50%, 75%)\n      const values = color.split('(')[1].split(')')[0].split(',');\n      const h = parseInt(values[0].trim().replace('deg', ''), 10);\n      const s = parseInt(values[1].trim().replace('%', ''), 10);\n      let l = parseFloat(values[2].trim().replace('%', ''));\n      if (l > 1) {\n        l /= 100;\n      }\n      const a = s * Math.min(l, 1 - l) / 100;\n      const f = n => {\n        const k = (n + h / 30) % 12;\n        const unroundedColor = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n        return Math.round(255 * unroundedColor + Number.EPSILON);\n      };\n      this.r = f(0);\n      this.g = f(8);\n      this.b = f(4);\n      if (values[3]) {\n        // eg: hsla(100, 50%, 75%, 0.8)\n        this.a = round2(minmax(parseFloat(values[3])));\n      }\n      (0, logger_1.getApplicationLogger)().warn('[colors]', \"HSL(A) values not officially supported, but were translated to hex (\".concat(color, \" -> \").concat(this.toHex(), \")\"));\n    } else {\n      throw new Error(\"Malformed color (\".concat(color, \")\"));\n    }\n  }\n  opacity(alpha) {\n    if (alpha != null) {\n      this.a = round2(minmax(alpha));\n    }\n    return this;\n  }\n  toRGB() {\n    if (this.a !== null) {\n      return \"rgba(\".concat(this.r, \", \").concat(this.g, \", \").concat(this.b, \", \").concat(this.a, \")\");\n    }\n    return \"rgb(\".concat(this.r, \", \").concat(this.g, \", \").concat(this.b, \")\");\n  }\n  toHex() {\n    const hex = [this.r.toString(16).padStart(2, '0'), this.g.toString(16).padStart(2, '0'), this.b.toString(16).padStart(2, '0')].join('');\n    if (this.a !== null) {\n      // 0 <= this.a <= 1\n      const alpha = Math.round(this.a * 256).toString(16).padStart(2, '0');\n      return \"#\".concat(hex).concat(alpha);\n    }\n    return \"#\".concat(hex);\n  }\n  toString(format) {\n    switch (format) {\n      case Format.Hex:\n        return this.toHex();\n      case Format.Rgb:\n        return this.toRGB();\n    }\n  }\n}\nexports.Color = Color;\nfunction hexToRGB(hex, alpha) {\n  return new Color(hex).opacity(alpha).toRGB();\n}\nexports.hexToRGB = hexToRGB;\nfunction RGBToHex(rgba) {\n  return new Color(rgba).toHex();\n}\nexports.RGBToHex = RGBToHex;\n// https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_.22gamma_encoded.22_colorspaces\nfunction luminance(color) {\n  const a = [color.r, color.g, color.b].map(v => {\n    v /= 255;\n    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n  });\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n}\nexports.luminance = luminance;\nfunction contrast(a, b) {\n  const lum1 = luminance(a);\n  const lum2 = luminance(b);\n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n  return round2((brightest + 0.05) / (darkest + 0.05));\n}\nexports.contrast = contrast;\nfunction contrastCheck(theme) {\n  // minimal recommended contrast ratio is 4.\n  // or 3 for larger font-sizes\n  const textToBg = contrast(new Color(theme.background), new Color(theme.text));\n  if (textToBg <= 4) {\n    (0, logger_1.getApplicationLogger)().warn('[colors]', \"Potential accessibility issue between text and background colors (\".concat(textToBg, \")\"));\n  }\n  const textSecondaryToBg = contrast(new Color(theme.background), new Color(theme.textSecondary));\n  if (textSecondaryToBg <= 4) {\n    (0, logger_1.getApplicationLogger)().warn('[colors]', \"Potential accessibility issue between textSecondary and background colors (\".concat(textSecondaryToBg, \")\"));\n  }\n  const primaryToSecondary = contrast(new Color(theme.background), new Color(theme.secondary));\n  if (primaryToSecondary <= 3) {\n    (0, logger_1.getApplicationLogger)().warn('[colors]', \"Potential accessibility issue between primary and secondary colors (\".concat(primaryToSecondary, \")\"));\n  }\n}\nexports.contrastCheck = contrastCheck;\nfunction fixTheme(theme) {\n  Object.entries(theme).forEach(_ref => {\n    let [key, value] = _ref;\n    if (!(key in default_1.default.light)) {\n      (0, logger_1.getApplicationLogger)().error('[colors]', \"Theme key \".concat(key, \" is not valid.\"));\n    }\n    const _key = key;\n    try {\n      const color = new Color(value);\n      theme[_key] = color.toHex();\n    } catch (e) {\n      theme[_key] = '#FF0000';\n      (0, logger_1.getApplicationLogger)().error('[colors]', \"Could not parse theme. \".concat(_key, \" with value \").concat(value, \". Replaced it with red!\"));\n    }\n  });\n}\nexports.fixTheme = fixTheme;","map":null,"metadata":{},"sourceType":"script"}