{"ast":null,"code":"import _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { useCelo, useProvider } from '@celo/react-celo';\nimport { currencyEquals, JSBI, Pair, Percent, Price, Token, TokenAmount, TradeType } from '@ubeswap/sdk';\nimport { ERC20_ABI } from 'constants/abis/erc20';\nimport { BASES_TO_CHECK_TRADES_AGAINST, BETTER_TRADE_LESS_HOPS_THRESHOLD, DEXES_TO_EXCLUDE, FETCH_MINIMA_ROUTER_TIMER, MINIMA_API_URL, UBESWAP_MOOLA_ROUTER_ADDRESS } from 'constants/index';\nimport { PairState, usePairs } from 'data/Reserves';\nimport { BigNumber, ethers } from 'ethers';\nimport { useAllTokens } from 'hooks/Tokens';\nimport _ from 'lodash';\nimport flatMap from 'lodash.flatmap';\nimport React, { useMemo } from 'react';\nimport { useUserDisableSmartRouting, useUserSingleHopOnly, useUserSlippageTolerance } from 'state/user/hooks';\nimport { getProviderOrSigner, isBTest } from 'utils';\nimport { isTradeBetter } from 'utils/trades';\nimport { MoolaDirectTrade } from '../moola/MoolaDirectTrade';\nimport { getMoolaDual } from '../moola/useMoola';\nimport { useMoolaDirectRoute } from '../moola/useMoolaDirectRoute';\nimport { UbeswapTrade } from '../trade';\nimport { MinimaRouterTrade } from './../trade';\nimport { bestTradeExactIn, bestTradeExactOut } from './calculateBestTrades';\nimport { useDirectTradeExactIn, useDirectTradeExactOut } from './directTrades';\n\n/**\n * Uses all common pairs between the two tokens, plus searches the moola duals\n * @param tokenA\n * @param tokenB\n * @returns\n */\nexport function useAllCommonPairsWithMoolaDuals(tokenA, tokenB) {\n  _s();\n  const {\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const bases = useMemo(() => chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [], [chainId]);\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])).filter(_ref => {\n    var _getMoolaDual, _getMoolaDual2;\n    let [t0, t1] = _ref;\n    return t0.address !== t1.address &&\n    // ensure we don't fetch duals\n    t0.address !== ((_getMoolaDual = getMoolaDual(t1)) === null || _getMoolaDual === void 0 ? void 0 : _getMoolaDual.address) && t1.address !== ((_getMoolaDual2 = getMoolaDual(t0)) === null || _getMoolaDual2 === void 0 ? void 0 : _getMoolaDual2.address);\n  }), [bases]);\n  const tokenADual = tokenA && getMoolaDual(tokenA);\n  const tokenBDual = tokenB && getMoolaDual(tokenB);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [\n  // the direct pair\n  [tokenA, tokenB],\n  // token A against all bases\n  ...bases.map(base => [tokenA, base]),\n  // token B against all bases\n  ...bases.map(base => [tokenB, base]),\n  // each base against all bases\n  ...basePairs,\n  // handle duals\n  // direct pair\n  ...(tokenADual ? [[tokenADual, tokenB]] : []), ...(tokenBDual ? [[tokenA, tokenBDual]] : []), ...(tokenADual && tokenBDual ? [[tokenADual, tokenBDual]] : []),\n  // token A against all bases\n  ...bases.map(base => [tokenA, base]), ...(tokenADual ? bases.map(base => [tokenADual, base]) : []),\n  // token B against all bases\n  ...bases.map(base => [tokenB, base]), ...(tokenBDual ? bases.map(base => [tokenBDual, base]) : [])].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(_ref2 => {\n    let [t0, t1] = _ref2;\n    return t0.address !== t1.address;\n  }) : [], [tokenA, tokenB, bases, basePairs, tokenADual, tokenBDual]);\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(() => Object.values(allPairs\n  // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1]))\n  // filter out duplicated pairs\n  .reduce((memo, _ref3) => {\n    var _memo$curr$liquidityT;\n    let [, curr] = _ref3;\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n_s(useAllCommonPairsWithMoolaDuals, \"tOhdysywKGFAxLTOWEnY1gEWJtk=\", false, function () {\n  return [useCelo, usePairs];\n});\nconst MAX_HOPS = 3;\nconst moolaRouter = {\n  routerAddress: UBESWAP_MOOLA_ROUTER_ADDRESS\n};\nexport class MoolaRouterTrade extends UbeswapTrade {\n  /**\n   *\n   * @param originalTokenIn If null, the original token is the path token\n   * @param originalTokenOut If null, the original token is the path token\n   * @param innerTrade\n   */\n  constructor(originalTokenIn, originalTokenOut, innerTrade) {\n    super(innerTrade.route, innerTrade.tradeType === TradeType.EXACT_INPUT ? innerTrade.inputAmount : innerTrade.outputAmount, innerTrade.tradeType, moolaRouter, [...(originalTokenIn ? [originalTokenIn] : []), ...innerTrade.route.path, ...(originalTokenOut ? [originalTokenOut] : [])]);\n    this.originalTokenIn = originalTokenIn;\n    this.originalTokenOut = originalTokenOut;\n    this.innerTrade = innerTrade;\n    this.inputAmount = void 0;\n    this.outputAmount = void 0;\n    this.executionPrice = void 0;\n    this.inputAmount = new TokenAmount(originalTokenIn !== null && originalTokenIn !== void 0 ? originalTokenIn : innerTrade.inputAmount.token, innerTrade.inputAmount.raw);\n    this.outputAmount = new TokenAmount(originalTokenOut !== null && originalTokenOut !== void 0 ? originalTokenOut : innerTrade.outputAmount.token, innerTrade.outputAmount.raw);\n    const baseIsInput = currencyEquals(innerTrade.executionPrice.baseCurrency, innerTrade.inputAmount.token);\n    this.executionPrice = new Price(baseIsInput ? this.inputAmount.token : this.outputAmount.token, !baseIsInput ? this.inputAmount.token : this.outputAmount.token, innerTrade.executionPrice.denominator, innerTrade.executionPrice.numerator);\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  minimumAmountOut(slippageTolerance) {\n    var _this$originalTokenOu;\n    const amt = this.innerTrade.minimumAmountOut(slippageTolerance);\n    return new TokenAmount((_this$originalTokenOu = this.originalTokenOut) !== null && _this$originalTokenOu !== void 0 ? _this$originalTokenOu : amt.token, amt.raw);\n  }\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  maximumAmountIn(slippageTolerance) {\n    var _this$originalTokenIn;\n    const amt = this.innerTrade.maximumAmountIn(slippageTolerance);\n    return new TokenAmount((_this$originalTokenIn = this.originalTokenIn) !== null && _this$originalTokenIn !== void 0 ? _this$originalTokenIn : amt.token, amt.raw);\n  }\n}\n\n/**\n * Converts the trade to a Moola Router trade, if the original tokens are lost\n * @param originalTokenIn\n * @param originalTokenOut\n * @param trade\n * @returns\n */\nconst convertToMoolaRouterTradeIfApplicable = (originalTokenIn, originalTokenOut, trade) => {\n  const inUnchanged = trade.inputAmount.token.address === originalTokenIn.address;\n  const outUnchanged = trade.outputAmount.token.address === originalTokenOut.address;\n  if (inUnchanged && outUnchanged) {\n    return trade;\n  }\n  return new MoolaRouterTrade(inUnchanged ? originalTokenIn : null, outUnchanged ? originalTokenOut : null, trade);\n};\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useUbeswapTradeExactIn(tokenAmountIn, tokenOut) {\n  _s2();\n  const [disableSmartRouting] = useUserDisableSmartRouting();\n  const directTrade = useDirectTradeExactIn(tokenAmountIn, tokenOut);\n  const allowedPairs = useAllCommonPairsWithMoolaDuals(tokenAmountIn === null || tokenAmountIn === void 0 ? void 0 : tokenAmountIn.token, tokenOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  const moolaRoute = useMoolaDirectRoute(tokenAmountIn === null || tokenAmountIn === void 0 ? void 0 : tokenAmountIn.token, tokenOut);\n  return useMemo(() => {\n    const bestTrade = (() => {\n      if (disableSmartRouting) {\n        return directTrade;\n      }\n      if (tokenAmountIn && tokenOut && allowedPairs.length > 0) {\n        if (singleHopOnly) {\n          const singleHopTrade = bestTradeExactIn(allowedPairs.slice(), tokenAmountIn, tokenOut, directTrade, {\n            maxHops: 1,\n            maxNumResults: 1,\n            minimumDelta: BETTER_TRADE_LESS_HOPS_THRESHOLD\n          });\n          return singleHopTrade ? convertToMoolaRouterTradeIfApplicable(tokenAmountIn.token, tokenOut, singleHopTrade) : null;\n        }\n        // search through trades with varying hops, find best trade out of them\n        let bestTradeSoFar = null;\n        for (let i = 1; i <= MAX_HOPS; i++) {\n          const currentTrade = bestTradeExactIn(allowedPairs.slice(), tokenAmountIn, tokenOut, directTrade, {\n            maxHops: i,\n            maxNumResults: 1,\n            minimumDelta: BETTER_TRADE_LESS_HOPS_THRESHOLD\n          });\n          // if current trade is best yet, save it\n          if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n            bestTradeSoFar = currentTrade;\n          }\n        }\n        return bestTradeSoFar;\n      }\n      return null;\n    })();\n    if (moolaRoute && tokenAmountIn) {\n      try {\n        const moolaTrade = MoolaDirectTrade.fromIn(moolaRoute, tokenAmountIn);\n        if (isTradeBetter(bestTrade, moolaTrade, new Percent('0'))) {\n          return moolaTrade;\n        }\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n    return bestTrade;\n  }, [allowedPairs, tokenAmountIn, tokenOut, singleHopOnly, directTrade, disableSmartRouting, moolaRoute]);\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n_s2(useUbeswapTradeExactIn, \"xtLUC7zu+Cu2t9SHeBaQPgo0oMI=\", false, function () {\n  return [useUserDisableSmartRouting, useDirectTradeExactIn, useAllCommonPairsWithMoolaDuals, useUserSingleHopOnly, useMoolaDirectRoute];\n});\nexport function useUbeswapTradeExactOut(tokenIn, tokenAmountOut) {\n  _s3();\n  const [disableSmartRouting] = useUserDisableSmartRouting();\n  const directTrade = useDirectTradeExactOut(tokenIn, tokenAmountOut);\n  const allowedPairs = useAllCommonPairsWithMoolaDuals(tokenIn, tokenAmountOut === null || tokenAmountOut === void 0 ? void 0 : tokenAmountOut.token);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  const moolaRoute = useMoolaDirectRoute(tokenIn, tokenAmountOut === null || tokenAmountOut === void 0 ? void 0 : tokenAmountOut.token);\n  return useMemo(() => {\n    const bestTrade = (() => {\n      if (disableSmartRouting) {\n        return directTrade;\n      }\n      if (tokenIn && tokenAmountOut && allowedPairs.length > 0) {\n        if (singleHopOnly) {\n          const singleHopTrade = bestTradeExactOut(allowedPairs.slice(), tokenIn, tokenAmountOut, directTrade, {\n            maxHops: 1,\n            maxNumResults: 1\n          });\n          return singleHopTrade ? convertToMoolaRouterTradeIfApplicable(tokenIn, tokenAmountOut.token, singleHopTrade) : null;\n        }\n        // search through trades with varying hops, find best trade out of them\n        let bestTradeSoFar = null;\n        for (let i = 1; i <= MAX_HOPS; i++) {\n          const currentTrade = bestTradeExactOut(allowedPairs.slice(), tokenIn, tokenAmountOut, directTrade, {\n            maxHops: i,\n            maxNumResults: 1\n          });\n          if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n            bestTradeSoFar = currentTrade;\n          }\n        }\n        return bestTradeSoFar;\n      }\n      return null;\n    })();\n    if (moolaRoute && tokenAmountOut) {\n      try {\n        const moolaTrade = MoolaDirectTrade.fromOut(moolaRoute, tokenAmountOut);\n        if (isTradeBetter(bestTrade, moolaTrade, new Percent('0'))) {\n          return moolaTrade;\n        }\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n    return bestTrade;\n  }, [tokenIn, tokenAmountOut, allowedPairs, singleHopOnly, directTrade, disableSmartRouting, moolaRoute]);\n}\n_s3(useUbeswapTradeExactOut, \"qP0Wf4cCc5TaVA/erEk03XceGmE=\", false, function () {\n  return [useUserDisableSmartRouting, useDirectTradeExactOut, useAllCommonPairsWithMoolaDuals, useUserSingleHopOnly, useMoolaDirectRoute];\n});\nexport function useMinimaTrade(tokenAmountIn, tokenOut) {\n  _s4();\n  const [minimaTrade, setMinimaTrade] = React.useState(undefined);\n  const [deps, setDeps] = React.useState(undefined);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  const [allowedSlippage] = useUserSlippageTolerance();\n  const [fetchUpdatedData, setFetchUpdatedData] = React.useState(true);\n  const [fetchTimeout, setFetchTimeout] = React.useState(undefined);\n  const {\n    address: account,\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const library = useProvider();\n  const provider = getProviderOrSigner(library, account || undefined);\n  const tokens = useAllTokens();\n  const call = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {\n    var _tokenAmountIn$curren, _tokenOut$address, _process$env$REACT_AP;\n    if (!(tokenAmountIn !== null && tokenAmountIn !== void 0 && tokenAmountIn.currency.address) || !(tokenAmountIn !== null && tokenAmountIn !== void 0 && tokenAmountIn.raw) || !(tokenOut !== null && tokenOut !== void 0 && tokenOut.address)) {\n      setMinimaTrade(null);\n      setDeps(undefined);\n      return;\n    }\n    const curDeps = {\n      chainId,\n      account: account || null,\n      allowedSlippage,\n      singleHopOnly,\n      inputAddr: tokenAmountIn.currency.address,\n      outputAddr: tokenOut.address,\n      inputAmount: tokenAmountIn.raw.toString()\n    };\n    if (_.isEqual(deps, curDeps) && !fetchUpdatedData) {\n      return;\n    }\n    if (!fetchUpdatedData) {\n      setMinimaTrade(undefined);\n    }\n    setDeps(curDeps);\n    setFetchUpdatedData(false);\n    // fetch information of minima router\n    yield fetch(\"\".concat(MINIMA_API_URL, \"?exclude=\").concat(DEXES_TO_EXCLUDE, \"&tokenIn=\").concat((_tokenAmountIn$curren = tokenAmountIn === null || tokenAmountIn === void 0 ? void 0 : tokenAmountIn.currency.address) !== null && _tokenAmountIn$curren !== void 0 ? _tokenAmountIn$curren : '', \"&tokenOut=\").concat((_tokenOut$address = tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.address) !== null && _tokenOut$address !== void 0 ? _tokenOut$address : '', \"&amountIn=\").concat(tokenAmountIn === null || tokenAmountIn === void 0 ? void 0 : tokenAmountIn.raw, \"&slippage=\").concat(allowedSlippage, \"&maxHops=\").concat(singleHopOnly ? 1 : MAX_HOPS, \"&includeTxn=true&priceImpact=true\").concat(account ? '&from=' + account : ''), {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-KEY': (_process$env$REACT_AP = process.env.REACT_APP_MINIMA_KEY) !== null && _process$env$REACT_AP !== void 0 ? _process$env$REACT_AP : ''\n      }\n    }).then( /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (res) {\n        if (res.status !== 200) {\n          setMinimaTrade(null);\n          return;\n        }\n        yield res.json().then( /*#__PURE__*/function () {\n          var _ref6 = _asyncToGenerator(function* (data) {\n            if (data.details) {\n              var _data$minimumExpected;\n              const path = yield Promise.all(data.details.path.map( /*#__PURE__*/function () {\n                var _ref7 = _asyncToGenerator(function* (pathItem) {\n                  if (!tokens[pathItem]) {\n                    // in case of a token address cannot be found on Ubeswap or Uniswap tokenlists\n                    const tokenContract = new ethers.Contract(pathItem, ERC20_ABI, provider);\n                    const [tokenName, symbol, decimals] = yield Promise.all([tokenContract.name(), tokenContract.symbol(), tokenContract.decimals()]);\n                    return new Token(chainId, pathItem, decimals, symbol, tokenName);\n                  }\n                  return tokens[pathItem];\n                });\n                return function (_x3) {\n                  return _ref7.apply(this, arguments);\n                };\n              }()));\n              const trade = MinimaRouterTrade.fromMinimaTradePayload([new Pair(new TokenAmount(tokenAmountIn.currency, JSBI.BigInt(10000)), new TokenAmount(tokenOut, JSBI.BigInt(20000)))], tokenAmountIn, new TokenAmount(tokenOut, JSBI.BigInt(data.details.expectedOutputAmount.toString())), data.routerAddress, new Percent(JSBI.BigInt(data.priceImpact.numerator), JSBI.BigInt(data.priceImpact.denominator)), path, _objectSpread(_objectSpread({}, data.details), {}, {\n                inputAmount: BigNumber.from(data.details.inputAmount),\n                minOutputAmount: BigNumber.from((_data$minimumExpected = data.minimumExpectedOut) !== null && _data$minimumExpected !== void 0 ? _data$minimumExpected : '0'),\n                expectedOutputAmount: BigNumber.from(data.details.expectedOutputAmount),\n                deadline: BigNumber.from(data.details.deadline)\n              }));\n              if (account && isBTest(account) && data.txn) {\n                var _data$txn, _data$txn2;\n                trade.txn = {\n                  to: (_data$txn = data.txn) === null || _data$txn === void 0 ? void 0 : _data$txn.to,\n                  data: (_data$txn2 = data.txn) === null || _data$txn2 === void 0 ? void 0 : _data$txn2.data\n                };\n              }\n              setMinimaTrade(trade);\n              clearTimeout(fetchTimeout);\n              setFetchTimeout(setTimeout(() => {\n                setFetchUpdatedData(true);\n              }, FETCH_MINIMA_ROUTER_TIMER));\n            }\n          });\n          return function (_x2) {\n            return _ref6.apply(this, arguments);\n          };\n        }()).catch(e => {\n          console.error(e);\n          setMinimaTrade(null);\n        });\n      });\n      return function (_x) {\n        return _ref5.apply(this, arguments);\n      };\n    }()).catch(e => {\n      console.error(e);\n      setMinimaTrade(null);\n    });\n  }), [account, allowedSlippage, chainId, deps, fetchTimeout, fetchUpdatedData, provider, singleHopOnly, tokenAmountIn, tokenOut, tokens]);\n  React.useEffect(() => {\n    call();\n  }, [call]);\n  return minimaTrade;\n}\n_s4(useMinimaTrade, \"KgEcgTSJMd/VBXSNDqDcb/u7omY=\", false, function () {\n  return [useUserSingleHopOnly, useUserSlippageTolerance, useCelo, useProvider, useAllTokens];\n});","map":{"version":3,"names":["useCelo","useProvider","currencyEquals","JSBI","Pair","Percent","Price","Token","TokenAmount","TradeType","ERC20_ABI","BASES_TO_CHECK_TRADES_AGAINST","BETTER_TRADE_LESS_HOPS_THRESHOLD","DEXES_TO_EXCLUDE","FETCH_MINIMA_ROUTER_TIMER","MINIMA_API_URL","UBESWAP_MOOLA_ROUTER_ADDRESS","PairState","usePairs","BigNumber","ethers","useAllTokens","_","flatMap","React","useMemo","useUserDisableSmartRouting","useUserSingleHopOnly","useUserSlippageTolerance","getProviderOrSigner","isBTest","isTradeBetter","MoolaDirectTrade","getMoolaDual","useMoolaDirectRoute","UbeswapTrade","MinimaRouterTrade","bestTradeExactIn","bestTradeExactOut","useDirectTradeExactIn","useDirectTradeExactOut","useAllCommonPairsWithMoolaDuals","tokenA","tokenB","_s","network","chainId","bases","basePairs","base","map","otherBase","filter","_ref","_getMoolaDual","_getMoolaDual2","t0","t1","address","tokenADual","tokenBDual","allPairCombinations","tokens","Boolean","_ref2","allPairs","Object","values","result","EXISTS","reduce","memo","_ref3","_memo$curr$liquidityT","curr","liquidityToken","MAX_HOPS","moolaRouter","routerAddress","MoolaRouterTrade","constructor","originalTokenIn","originalTokenOut","innerTrade","route","tradeType","EXACT_INPUT","inputAmount","outputAmount","path","executionPrice","token","raw","baseIsInput","baseCurrency","denominator","numerator","minimumAmountOut","slippageTolerance","_this$originalTokenOu","amt","maximumAmountIn","_this$originalTokenIn","convertToMoolaRouterTradeIfApplicable","trade","inUnchanged","outUnchanged","useUbeswapTradeExactIn","tokenAmountIn","tokenOut","_s2","disableSmartRouting","directTrade","allowedPairs","singleHopOnly","moolaRoute","bestTrade","length","singleHopTrade","slice","maxHops","maxNumResults","minimumDelta","bestTradeSoFar","i","currentTrade","moolaTrade","fromIn","e","console","warn","useUbeswapTradeExactOut","tokenIn","tokenAmountOut","_s3","fromOut","useMinimaTrade","_s4","minimaTrade","setMinimaTrade","useState","undefined","deps","setDeps","allowedSlippage","fetchUpdatedData","setFetchUpdatedData","fetchTimeout","setFetchTimeout","account","library","provider","call","useCallback","_asyncToGenerator","_tokenAmountIn$curren","_tokenOut$address","_process$env$REACT_AP","currency","curDeps","inputAddr","outputAddr","toString","isEqual","fetch","concat","method","headers","process","env","REACT_APP_MINIMA_KEY","then","_ref5","res","status","json","_ref6","data","details","_data$minimumExpected","Promise","all","_ref7","pathItem","tokenContract","Contract","tokenName","symbol","decimals","name","_x3","apply","arguments","fromMinimaTradePayload","BigInt","expectedOutputAmount","priceImpact","_objectSpread","from","minOutputAmount","minimumExpectedOut","deadline","txn","_data$txn","_data$txn2","to","clearTimeout","setTimeout","_x2","catch","error","_x","useEffect"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/hooks/useTrade.ts"],"sourcesContent":["import { ChainId, useCelo, useProvider } from '@celo/react-celo'\nimport { currencyEquals, JSBI, Pair, Percent, Price, Token, TokenAmount, Trade, TradeType } from '@ubeswap/sdk'\nimport { ERC20_ABI } from 'constants/abis/erc20'\nimport {\n  BASES_TO_CHECK_TRADES_AGAINST,\n  BETTER_TRADE_LESS_HOPS_THRESHOLD,\n  DEXES_TO_EXCLUDE,\n  FETCH_MINIMA_ROUTER_TIMER,\n  MINIMA_API_URL,\n  UBESWAP_MOOLA_ROUTER_ADDRESS,\n} from 'constants/index'\nimport { PairState, usePairs } from 'data/Reserves'\nimport { BigNumber, ContractInterface, ethers } from 'ethers'\nimport { Erc20 } from 'generated'\nimport { useAllTokens } from 'hooks/Tokens'\nimport _ from 'lodash'\nimport flatMap from 'lodash.flatmap'\nimport React, { useMemo } from 'react'\nimport { useUserDisableSmartRouting, useUserSingleHopOnly, useUserSlippageTolerance } from 'state/user/hooks'\nimport { getProviderOrSigner, isBTest } from 'utils'\nimport { isTradeBetter } from 'utils/trades'\n\nimport { MoolaDirectTrade } from '../moola/MoolaDirectTrade'\nimport { getMoolaDual } from '../moola/useMoola'\nimport { useMoolaDirectRoute } from '../moola/useMoolaDirectRoute'\nimport { MinimaTradePayload, TradeRouter, UbeswapTrade } from '../trade'\nimport { MinimaRouterTrade } from './../trade'\nimport { bestTradeExactIn, bestTradeExactOut } from './calculateBestTrades'\nimport { useDirectTradeExactIn, useDirectTradeExactOut } from './directTrades'\n\n/**\n * Uses all common pairs between the two tokens, plus searches the moola duals\n * @param tokenA\n * @param tokenB\n * @returns\n */\nexport function useAllCommonPairsWithMoolaDuals(tokenA?: Token, tokenB?: Token): readonly Pair[] {\n  const { network } = useCelo()\n  const chainId = network.chainId\n\n  const bases: readonly Token[] = useMemo(() => (chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []), [chainId])\n\n  const basePairs: readonly (readonly [Token, Token])[] = useMemo(\n    () =>\n      flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])).filter(\n        ([t0, t1]) =>\n          t0.address !== t1.address &&\n          // ensure we don't fetch duals\n          t0.address !== getMoolaDual(t1)?.address &&\n          t1.address !== getMoolaDual(t0)?.address\n      ),\n    [bases]\n  )\n\n  const tokenADual = tokenA && getMoolaDual(tokenA)\n  const tokenBDual = tokenB && getMoolaDual(tokenB)\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n            // handle duals\n            // direct pair\n            ...(tokenADual ? [[tokenADual, tokenB]] : []),\n            ...(tokenBDual ? [[tokenA, tokenBDual]] : []),\n            ...(tokenADual && tokenBDual ? [[tokenADual, tokenBDual]] : []),\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            ...(tokenADual ? bases.map((base): [Token, Token] => [tokenADual, base]) : []),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            ...(tokenBDual ? bases.map((base): [Token, Token] => [tokenBDual, base]) : []),\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n        : [],\n    [tokenA, tokenB, bases, basePairs, tokenADual, tokenBDual]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\nconst MAX_HOPS = 3\n\nconst moolaRouter: TradeRouter = {\n  routerAddress: UBESWAP_MOOLA_ROUTER_ADDRESS,\n}\n\nexport class MoolaRouterTrade extends UbeswapTrade {\n  inputAmount: TokenAmount\n  outputAmount: TokenAmount\n  executionPrice: Price\n  /**\n   *\n   * @param originalTokenIn If null, the original token is the path token\n   * @param originalTokenOut If null, the original token is the path token\n   * @param innerTrade\n   */\n  constructor(\n    public readonly originalTokenIn: Token | null,\n    public readonly originalTokenOut: Token | null,\n    public readonly innerTrade: Trade\n  ) {\n    super(\n      innerTrade.route,\n      innerTrade.tradeType === TradeType.EXACT_INPUT ? innerTrade.inputAmount : innerTrade.outputAmount,\n      innerTrade.tradeType,\n      moolaRouter,\n      [\n        ...(originalTokenIn ? [originalTokenIn] : []),\n        ...innerTrade.route.path,\n        ...(originalTokenOut ? [originalTokenOut] : []),\n      ]\n    )\n    this.inputAmount = new TokenAmount(originalTokenIn ?? innerTrade.inputAmount.token, innerTrade.inputAmount.raw)\n    this.outputAmount = new TokenAmount(originalTokenOut ?? innerTrade.outputAmount.token, innerTrade.outputAmount.raw)\n    const baseIsInput = currencyEquals(innerTrade.executionPrice.baseCurrency, innerTrade.inputAmount.token)\n    this.executionPrice = new Price(\n      baseIsInput ? this.inputAmount.token : this.outputAmount.token,\n      !baseIsInput ? this.inputAmount.token : this.outputAmount.token,\n      innerTrade.executionPrice.denominator,\n      innerTrade.executionPrice.numerator\n    )\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  minimumAmountOut(slippageTolerance: Percent): TokenAmount {\n    const amt = this.innerTrade.minimumAmountOut(slippageTolerance)\n    return new TokenAmount(this.originalTokenOut ?? amt.token, amt.raw)\n  }\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  maximumAmountIn(slippageTolerance: Percent): TokenAmount {\n    const amt = this.innerTrade.maximumAmountIn(slippageTolerance)\n    return new TokenAmount(this.originalTokenIn ?? amt.token, amt.raw)\n  }\n}\n\n/**\n * Converts the trade to a Moola Router trade, if the original tokens are lost\n * @param originalTokenIn\n * @param originalTokenOut\n * @param trade\n * @returns\n */\nconst convertToMoolaRouterTradeIfApplicable = (\n  originalTokenIn: Token,\n  originalTokenOut: Token,\n  trade: UbeswapTrade\n): UbeswapTrade => {\n  const inUnchanged = trade.inputAmount.token.address === originalTokenIn.address\n  const outUnchanged = trade.outputAmount.token.address === originalTokenOut.address\n  if (inUnchanged && outUnchanged) {\n    return trade\n  }\n  return new MoolaRouterTrade(inUnchanged ? originalTokenIn : null, outUnchanged ? originalTokenOut : null, trade)\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useUbeswapTradeExactIn(tokenAmountIn?: TokenAmount, tokenOut?: Token): UbeswapTrade | null {\n  const [disableSmartRouting] = useUserDisableSmartRouting()\n  const directTrade = useDirectTradeExactIn(tokenAmountIn, tokenOut)\n  const allowedPairs = useAllCommonPairsWithMoolaDuals(tokenAmountIn?.token, tokenOut)\n  const [singleHopOnly] = useUserSingleHopOnly()\n  const moolaRoute = useMoolaDirectRoute(tokenAmountIn?.token, tokenOut)\n\n  return useMemo(() => {\n    const bestTrade = (() => {\n      if (disableSmartRouting) {\n        return directTrade\n      }\n\n      if (tokenAmountIn && tokenOut && allowedPairs.length > 0) {\n        if (singleHopOnly) {\n          const singleHopTrade = bestTradeExactIn(allowedPairs.slice(), tokenAmountIn, tokenOut, directTrade, {\n            maxHops: 1,\n            maxNumResults: 1,\n            minimumDelta: BETTER_TRADE_LESS_HOPS_THRESHOLD,\n          })\n          return singleHopTrade\n            ? convertToMoolaRouterTradeIfApplicable(tokenAmountIn.token, tokenOut, singleHopTrade)\n            : null\n        }\n        // search through trades with varying hops, find best trade out of them\n        let bestTradeSoFar: UbeswapTrade | null = null\n        for (let i = 1; i <= MAX_HOPS; i++) {\n          const currentTrade: UbeswapTrade | null = bestTradeExactIn(\n            allowedPairs.slice(),\n            tokenAmountIn,\n            tokenOut,\n            directTrade,\n            {\n              maxHops: i,\n              maxNumResults: 1,\n              minimumDelta: BETTER_TRADE_LESS_HOPS_THRESHOLD,\n            }\n          )\n          // if current trade is best yet, save it\n          if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n            bestTradeSoFar = currentTrade\n          }\n        }\n        return bestTradeSoFar\n      }\n\n      return null\n    })()\n\n    if (moolaRoute && tokenAmountIn) {\n      try {\n        const moolaTrade = MoolaDirectTrade.fromIn(moolaRoute, tokenAmountIn)\n        if (isTradeBetter(bestTrade, moolaTrade, new Percent('0'))) {\n          return moolaTrade\n        }\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n    return bestTrade\n  }, [allowedPairs, tokenAmountIn, tokenOut, singleHopOnly, directTrade, disableSmartRouting, moolaRoute])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useUbeswapTradeExactOut(tokenIn?: Token, tokenAmountOut?: TokenAmount): UbeswapTrade | null {\n  const [disableSmartRouting] = useUserDisableSmartRouting()\n  const directTrade = useDirectTradeExactOut(tokenIn, tokenAmountOut)\n  const allowedPairs = useAllCommonPairsWithMoolaDuals(tokenIn, tokenAmountOut?.token)\n  const [singleHopOnly] = useUserSingleHopOnly()\n  const moolaRoute = useMoolaDirectRoute(tokenIn, tokenAmountOut?.token)\n\n  return useMemo(() => {\n    const bestTrade = (() => {\n      if (disableSmartRouting) {\n        return directTrade\n      }\n\n      if (tokenIn && tokenAmountOut && allowedPairs.length > 0) {\n        if (singleHopOnly) {\n          const singleHopTrade = bestTradeExactOut(allowedPairs.slice(), tokenIn, tokenAmountOut, directTrade, {\n            maxHops: 1,\n            maxNumResults: 1,\n          })\n          return singleHopTrade\n            ? convertToMoolaRouterTradeIfApplicable(tokenIn, tokenAmountOut.token, singleHopTrade)\n            : null\n        }\n        // search through trades with varying hops, find best trade out of them\n        let bestTradeSoFar: UbeswapTrade | null = null\n        for (let i = 1; i <= MAX_HOPS; i++) {\n          const currentTrade = bestTradeExactOut(allowedPairs.slice(), tokenIn, tokenAmountOut, directTrade, {\n            maxHops: i,\n            maxNumResults: 1,\n          })\n          if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n            bestTradeSoFar = currentTrade\n          }\n        }\n        return bestTradeSoFar\n      }\n      return null\n    })()\n\n    if (moolaRoute && tokenAmountOut) {\n      try {\n        const moolaTrade = MoolaDirectTrade.fromOut(moolaRoute, tokenAmountOut)\n        if (isTradeBetter(bestTrade, moolaTrade, new Percent('0'))) {\n          return moolaTrade\n        }\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n    return bestTrade\n  }, [tokenIn, tokenAmountOut, allowedPairs, singleHopOnly, directTrade, disableSmartRouting, moolaRoute])\n}\n\ninterface Dependencies {\n  chainId: ChainId\n  account: string | null\n  allowedSlippage: number\n  singleHopOnly: boolean\n  inputAddr: string | undefined\n  outputAddr: string | undefined\n  inputAmount: string | undefined\n}\n\nexport function useMinimaTrade(tokenAmountIn?: TokenAmount, tokenOut?: Token): MinimaRouterTrade | null | undefined {\n  const [minimaTrade, setMinimaTrade] = React.useState<MinimaRouterTrade | null | undefined>(undefined)\n  const [deps, setDeps] = React.useState<Dependencies | undefined>(undefined)\n  const [singleHopOnly] = useUserSingleHopOnly()\n  const [allowedSlippage] = useUserSlippageTolerance()\n  const [fetchUpdatedData, setFetchUpdatedData] = React.useState<boolean>(true)\n  const [fetchTimeout, setFetchTimeout] = React.useState<NodeJS.Timeout | undefined>(undefined)\n  const { address: account, network } = useCelo()\n  const chainId = network.chainId as ChainId\n  const library = useProvider()\n  const provider = getProviderOrSigner(library, account || undefined)\n  const tokens = useAllTokens()\n  const call = React.useCallback(async () => {\n    if (!tokenAmountIn?.currency.address || !tokenAmountIn?.raw || !tokenOut?.address) {\n      setMinimaTrade(null)\n      setDeps(undefined)\n      return\n    }\n    const curDeps = {\n      chainId,\n      account: account || null,\n      allowedSlippage,\n      singleHopOnly,\n      inputAddr: tokenAmountIn.currency.address,\n      outputAddr: tokenOut.address,\n      inputAmount: tokenAmountIn.raw.toString(),\n    }\n    if (_.isEqual(deps, curDeps) && !fetchUpdatedData) {\n      return\n    }\n    if (!fetchUpdatedData) {\n      setMinimaTrade(undefined)\n    }\n    setDeps(curDeps)\n    setFetchUpdatedData(false)\n    // fetch information of minima router\n    await fetch(\n      `${MINIMA_API_URL}?exclude=${DEXES_TO_EXCLUDE}&tokenIn=${tokenAmountIn?.currency.address ?? ''}&tokenOut=${\n        tokenOut?.address ?? ''\n      }&amountIn=${tokenAmountIn?.raw}&slippage=${allowedSlippage}&maxHops=${\n        singleHopOnly ? 1 : MAX_HOPS\n      }&includeTxn=true&priceImpact=true${account ? '&from=' + account : ''}`,\n      {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-KEY': process.env.REACT_APP_MINIMA_KEY ?? '',\n        },\n      }\n    )\n      .then(async (res) => {\n        if (res.status !== 200) {\n          setMinimaTrade(null)\n          return\n        }\n        await res\n          .json()\n          .then(async (data: MinimaTradePayload) => {\n            if (data.details) {\n              const path = await Promise.all(\n                data.details.path.map(async (pathItem) => {\n                  if (!tokens[pathItem]) {\n                    // in case of a token address cannot be found on Ubeswap or Uniswap tokenlists\n                    const tokenContract = new ethers.Contract(\n                      pathItem,\n                      ERC20_ABI as ContractInterface,\n                      provider\n                    ) as unknown as Erc20\n                    const [tokenName, symbol, decimals] = await Promise.all([\n                      tokenContract.name(),\n                      tokenContract.symbol(),\n                      tokenContract.decimals(),\n                    ])\n                    return new Token(chainId as number, pathItem, decimals, symbol, tokenName)\n                  }\n                  return tokens[pathItem]\n                })\n              )\n              const trade = MinimaRouterTrade.fromMinimaTradePayload(\n                [\n                  new Pair(\n                    new TokenAmount(tokenAmountIn.currency, JSBI.BigInt(10000)),\n                    new TokenAmount(tokenOut, JSBI.BigInt(20000))\n                  ),\n                ],\n                tokenAmountIn,\n                new TokenAmount(tokenOut, JSBI.BigInt(data.details.expectedOutputAmount.toString())),\n                data.routerAddress,\n                new Percent(JSBI.BigInt(data.priceImpact.numerator), JSBI.BigInt(data.priceImpact.denominator)),\n                path,\n                {\n                  ...data.details,\n                  inputAmount: BigNumber.from(data.details.inputAmount),\n                  minOutputAmount: BigNumber.from(data.minimumExpectedOut ?? '0'),\n                  expectedOutputAmount: BigNumber.from(data.details.expectedOutputAmount),\n                  deadline: BigNumber.from(data.details.deadline),\n                }\n              )\n\n              if (account && isBTest(account) && data.txn) {\n                trade.txn = { to: data.txn?.to, data: data.txn?.data }\n              }\n\n              setMinimaTrade(trade)\n              clearTimeout(fetchTimeout)\n              setFetchTimeout(\n                setTimeout(() => {\n                  setFetchUpdatedData(true)\n                }, FETCH_MINIMA_ROUTER_TIMER)\n              )\n            }\n          })\n          .catch((e) => {\n            console.error(e)\n            setMinimaTrade(null)\n          })\n      })\n      .catch((e) => {\n        console.error(e)\n        setMinimaTrade(null)\n      })\n  }, [\n    account,\n    allowedSlippage,\n    chainId,\n    deps,\n    fetchTimeout,\n    fetchUpdatedData,\n    provider,\n    singleHopOnly,\n    tokenAmountIn,\n    tokenOut,\n    tokens,\n  ])\n\n  React.useEffect(() => {\n    call()\n  }, [call])\n\n  return minimaTrade\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}