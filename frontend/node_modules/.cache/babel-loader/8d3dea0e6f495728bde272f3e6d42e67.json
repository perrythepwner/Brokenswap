{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst composite_1 = require(\"./composite\");\nconst bitArray_1 = require(\"../view/bitArray\");\nconst bitArray_2 = require(\"../viewDU/bitArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * BitArray: ordered array collection of boolean values\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitArrayType extends composite_1.CompositeType {\n  constructor() {\n    super(...arguments);\n    this.isViewMutable = true;\n  }\n  getView(tree) {\n    return new bitArray_1.BitArrayTreeView(this, tree);\n  }\n  getViewDU(node) {\n    return new bitArray_2.BitArrayTreeViewDU(this, node);\n  }\n  commitView(view) {\n    return view.node;\n  }\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n  // Merkleization\n  getRoots(value) {\n    return merkleize_1.splitIntoRootChunks(value.uint8Array);\n  }\n  // Proofs\n  getPropertyGindex() {\n    // Stop navigating below this type. Must only request complete data\n    return null;\n  }\n  getPropertyType() {\n    /* istanbul ignore next - unreachable code, getPropertyGindex null return prevents this call */\n    throw Error(\"Must only request BitArray complete data\");\n  }\n  getIndexProperty() {\n    /* istanbul ignore next - unreachable code, getPropertyGindex null return prevents this call */\n    throw Error(\"Must only request BitArray complete data\");\n  }\n  tree_fromProofNode(node) {\n    return {\n      node,\n      done: true\n    };\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    const byteLen = this.tree_getByteLen(rootNode);\n    const chunkCount = Math.ceil(byteLen / 32);\n    const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n    const gindices = new Array(chunkCount);\n    for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {\n      gindices[i] = gindex;\n    }\n    // include the length chunk\n    if (this.isList) {\n      gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    const uint8Array = byteArray_1.fromHexString(json);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    // value_deserializeFromBytes MUST validate length (limit, or length)\n    return this.value_deserializeFromBytes({\n      uint8Array,\n      dataView\n    }, 0, uint8Array.length);\n  }\n  toJson(value) {\n    return byteArray_1.toHexString(this.serialize(value));\n  }\n  clone(value) {\n    return value.clone();\n  }\n  equals(a, b) {\n    return a.bitLen === b.bitLen && byteArray_1.byteArrayEquals(a.uint8Array, b.uint8Array);\n  }\n}\nexports.BitArrayType = BitArrayType;","map":{"version":3,"sources":["../../src/type/bitArray.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst byteArray_1 = require(\"../util/byteArray\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst composite_1 = require(\"./composite\");\nconst bitArray_1 = require(\"../view/bitArray\");\nconst bitArray_2 = require(\"../viewDU/bitArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * BitArray: ordered array collection of boolean values\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitArrayType extends composite_1.CompositeType {\n    constructor() {\n        super(...arguments);\n        this.isViewMutable = true;\n    }\n    getView(tree) {\n        return new bitArray_1.BitArrayTreeView(this, tree);\n    }\n    getViewDU(node) {\n        return new bitArray_2.BitArrayTreeViewDU(this, node);\n    }\n    commitView(view) {\n        return view.node;\n    }\n    commitViewDU(view) {\n        view.commit();\n        return view.node;\n    }\n    cacheOfViewDU(view) {\n        return view.cache;\n    }\n    // Merkleization\n    getRoots(value) {\n        return merkleize_1.splitIntoRootChunks(value.uint8Array);\n    }\n    // Proofs\n    getPropertyGindex() {\n        // Stop navigating below this type. Must only request complete data\n        return null;\n    }\n    getPropertyType() {\n        /* istanbul ignore next - unreachable code, getPropertyGindex null return prevents this call */\n        throw Error(\"Must only request BitArray complete data\");\n    }\n    getIndexProperty() {\n        /* istanbul ignore next - unreachable code, getPropertyGindex null return prevents this call */\n        throw Error(\"Must only request BitArray complete data\");\n    }\n    tree_fromProofNode(node) {\n        return { node, done: true };\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        const byteLen = this.tree_getByteLen(rootNode);\n        const chunkCount = Math.ceil(byteLen / 32);\n        const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n        const gindices = new Array(chunkCount);\n        for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {\n            gindices[i] = gindex;\n        }\n        // include the length chunk\n        if (this.isList) {\n            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        const uint8Array = byteArray_1.fromHexString(json);\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        // value_deserializeFromBytes MUST validate length (limit, or length)\n        return this.value_deserializeFromBytes({ uint8Array, dataView }, 0, uint8Array.length);\n    }\n    toJson(value) {\n        return byteArray_1.toHexString(this.serialize(value));\n    }\n    clone(value) {\n        return value.clone();\n    }\n    equals(a, b) {\n        return a.bitLen === b.bitLen && byteArray_1.byteArrayEquals(a.uint8Array, b.uint8Array);\n    }\n}\nexports.BitArrayType = BitArrayType;\n//# sourceMappingURL=bitArray.js.map"]},"metadata":{},"sourceType":"script"}