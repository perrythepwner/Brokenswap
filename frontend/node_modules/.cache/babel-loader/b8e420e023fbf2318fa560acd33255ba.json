{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nfunction minSizeArrayComposite(elementType, minCount) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    return minCount * (4 + elementType.minSize);\n  }\n  // Fixed length\n  else {\n    return minCount * elementType.minSize;\n  }\n}\nexports.minSizeArrayComposite = minSizeArrayComposite;\nfunction maxSizeArrayComposite(elementType, maxCount) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    return maxCount * (4 + elementType.maxSize);\n  }\n  // Fixed length\n  else {\n    return maxCount * elementType.maxSize;\n  }\n}\nexports.maxSizeArrayComposite = maxSizeArrayComposite;\nfunction value_serializedSizeArrayComposite(elementType, length, value) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    let size = 0;\n    for (let i = 0; i < length; i++) {\n      size += 4 + elementType.value_serializedSize(value[i]);\n    }\n    return size;\n  }\n  // Fixed length\n  else {\n    return length * elementType.fixedSize;\n  }\n}\nexports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayComposite(elementType, length, output, offset, value) {\n  // Variable length\n  if (elementType.fixedSize === null) {\n    let variableIndex = offset + length * 4;\n    for (let i = 0; i < length; i++) {\n      // write offset\n      output.dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n      // write serialized element to variable section\n      variableIndex = elementType.value_serializeToBytes(output, variableIndex, value[i]);\n    }\n    return variableIndex;\n  }\n  // Fixed length\n  else {\n    for (let i = 0; i < length; i++) {\n      elementType.value_serializeToBytes(output, offset + i * elementType.fixedSize, value[i]);\n    }\n    return offset + length * elementType.fixedSize;\n  }\n}\nexports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;\nfunction value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {\n  const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n  const length = offsets.length; // Capture length before pushing end offset\n  const values = new Array(length);\n  // offests include the last element end\n  for (let i = 0; i < length; i++) {\n    // The offsets are relative to the start\n    const startEl = start + offsets[i];\n    const endEl = i === length - 1 ? end : start + offsets[i + 1];\n    values[i] = elementType.value_deserializeFromBytes(data, startEl, endEl);\n  }\n  return values;\n}\nexports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializedSizeArrayComposite(elementType, length, depth, node) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n    let size = 0;\n    for (let i = 0; i < nodes.length; i++) {\n      size += 4 + elementType.tree_serializedSize(nodes[i]);\n    }\n    return size;\n  }\n  // Fixed length\n  else {\n    return length * elementType.fixedSize;\n  }\n}\nexports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayComposite(elementType, length, depth, node, output, offset) {\n  const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n  // Variable Length\n  // Indices contain offsets, which are indices deeper in the byte array\n  if (elementType.fixedSize === null) {\n    let variableIndex = offset + length * 4;\n    const {\n      dataView\n    } = output;\n    for (let i = 0; i < nodes.length; i++) {\n      // write offset\n      dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n      // write serialized element to variable section\n      variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i]);\n    }\n    return variableIndex;\n  }\n  // Fixed length\n  else {\n    for (let i = 0; i < nodes.length; i++) {\n      offset = elementType.tree_serializeToBytes(output, offset, nodes[i]);\n    }\n    return offset;\n  }\n}\nexports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;\nfunction tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {\n  const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n  const length = offsets.length; // Capture length before pushing end offset\n  const nodes = new Array(length);\n  // offests include the last element end\n  for (let i = 0; i < length; i++) {\n    // The offsets are relative to the start\n    const startEl = start + offsets[i];\n    const endEl = i === length - 1 ? end : start + offsets[i + 1];\n    nodes[i] = elementType.tree_deserializeFromBytes(data, startEl, endEl);\n  }\n  // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n  const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);\n  // TODO: Add LeafNode.fromUint()\n  if (arrayProps.isList) {\n    return arrayBasic_1.addLengthNode(chunksNode, length);\n  } else {\n    return chunksNode;\n  }\n}\nexports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_getRootsArrayComposite(elementType, length, value) {\n  const roots = new Array(length);\n  for (let i = 0; i < length; i++) {\n    roots[i] = elementType.hashTreeRoot(value[i]);\n  }\n  return roots;\n}\nexports.value_getRootsArrayComposite = value_getRootsArrayComposite;\nfunction readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {\n  const size = end - start;\n  let offsets;\n  // Variable Length\n  // Indices contain offsets, which are indices deeper in the byte array\n  if (elementFixedSize === null) {\n    offsets = readVariableOffsetsArrayComposite(data, start, size);\n  }\n  // Fixed length\n  else {\n    // There's no valid CompositeType with fixed size 0, it's un-rechable code. But prevents diving by zero\n    /* istanbul ignore if */\n    if (elementFixedSize === 0) {\n      throw Error(\"element fixed length is 0\");\n    }\n    if (size % elementFixedSize !== 0) {\n      throw Error(\"size \".concat(size, \" is not multiple of element fixedSize \").concat(elementFixedSize));\n    }\n    const length = size / elementFixedSize;\n    offsets = new Uint32Array(length);\n    for (let i = 0; i < length; i++) {\n      offsets[i] = i * elementFixedSize;\n    }\n  }\n  // Vector + List length validation\n  arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);\n  return offsets;\n}\n/**\n * Reads the values of contiguous variable offsets. Provided buffer includes offsets that point to position\n * within `size`. This function also validates that all offsets are in range.\n */\nfunction readVariableOffsetsArrayComposite(dataView, start, size) {\n  if (size === 0) {\n    return new Uint32Array(0);\n  }\n  // all elements are variable-sized\n  // indices contain offsets, which are indices deeper in the byte array\n  // The serialized data will start with offsets of all the serialized objects (BYTES_PER_LENGTH_OFFSET bytes each)\n  const firstOffset = dataView.getUint32(start, true);\n  // Using the first offset, we can compute the length of the list (divide by BYTES_PER_LENGTH_OFFSET), as it gives\n  // us the total number of bytes in the offset data\n  const offsetDataLength = firstOffset;\n  if (firstOffset === 0) {\n    throw Error(\"First offset must be > 0\");\n  }\n  if (offsetDataLength % 4 !== 0) {\n    throw Error(\"Offset data length not multiple of 4\");\n  }\n  const offsetCount = offsetDataLength / 4;\n  const offsets = new Uint32Array(offsetCount);\n  offsets[0] = firstOffset;\n  // ArrayComposite has a contiguous section of offsets, then the data\n  //\n  //    [offset 1] [offset 2] [data 1 ..........] [data 2 ..]\n  // 0x 08000000   0e000000   010002000300        01000200\n  //\n  // Ensure that:\n  // - Offsets point to regions of > 0 bytes, i.e. are increasing\n  // - Offsets don't point to bytes outside of the array's size\n  //\n  // In the example above the first offset is 8, so 8 / 4 = 2 offsets.\n  // Then, read the rest of offsets to get offsets = [8, 14]\n  for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {\n    const offset = dataView.getUint32(start + offsetIdx * 4, true);\n    offsets[offsetIdx] = offset;\n    // Offsets must point to data within the Array bytes section\n    if (offset > size) {\n      throw new Error(\"Offset out of bounds \".concat(offset, \" > \").concat(size));\n    }\n    if (offset < offsets[offsetIdx - 1]) {\n      throw new Error(\"Offsets must be increasing \".concat(offset, \" < \").concat(offsets[offsetIdx - 1]));\n    }\n  }\n  return offsets;\n}","map":{"version":3,"sources":["../../src/type/arrayComposite.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nfunction minSizeArrayComposite(elementType, minCount) {\n    // Variable Length\n    if (elementType.fixedSize === null) {\n        return minCount * (4 + elementType.minSize);\n    }\n    // Fixed length\n    else {\n        return minCount * elementType.minSize;\n    }\n}\nexports.minSizeArrayComposite = minSizeArrayComposite;\nfunction maxSizeArrayComposite(elementType, maxCount) {\n    // Variable Length\n    if (elementType.fixedSize === null) {\n        return maxCount * (4 + elementType.maxSize);\n    }\n    // Fixed length\n    else {\n        return maxCount * elementType.maxSize;\n    }\n}\nexports.maxSizeArrayComposite = maxSizeArrayComposite;\nfunction value_serializedSizeArrayComposite(elementType, length, value) {\n    // Variable Length\n    if (elementType.fixedSize === null) {\n        let size = 0;\n        for (let i = 0; i < length; i++) {\n            size += 4 + elementType.value_serializedSize(value[i]);\n        }\n        return size;\n    }\n    // Fixed length\n    else {\n        return length * elementType.fixedSize;\n    }\n}\nexports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayComposite(elementType, length, output, offset, value) {\n    // Variable length\n    if (elementType.fixedSize === null) {\n        let variableIndex = offset + length * 4;\n        for (let i = 0; i < length; i++) {\n            // write offset\n            output.dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n            // write serialized element to variable section\n            variableIndex = elementType.value_serializeToBytes(output, variableIndex, value[i]);\n        }\n        return variableIndex;\n    }\n    // Fixed length\n    else {\n        for (let i = 0; i < length; i++) {\n            elementType.value_serializeToBytes(output, offset + i * elementType.fixedSize, value[i]);\n        }\n        return offset + length * elementType.fixedSize;\n    }\n}\nexports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;\nfunction value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {\n    const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n    const length = offsets.length; // Capture length before pushing end offset\n    const values = new Array(length);\n    // offests include the last element end\n    for (let i = 0; i < length; i++) {\n        // The offsets are relative to the start\n        const startEl = start + offsets[i];\n        const endEl = i === length - 1 ? end : start + offsets[i + 1];\n        values[i] = elementType.value_deserializeFromBytes(data, startEl, endEl);\n    }\n    return values;\n}\nexports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializedSizeArrayComposite(elementType, length, depth, node) {\n    // Variable Length\n    if (elementType.fixedSize === null) {\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n        let size = 0;\n        for (let i = 0; i < nodes.length; i++) {\n            size += 4 + elementType.tree_serializedSize(nodes[i]);\n        }\n        return size;\n    }\n    // Fixed length\n    else {\n        return length * elementType.fixedSize;\n    }\n}\nexports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayComposite(elementType, length, depth, node, output, offset) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n    // Variable Length\n    // Indices contain offsets, which are indices deeper in the byte array\n    if (elementType.fixedSize === null) {\n        let variableIndex = offset + length * 4;\n        const { dataView } = output;\n        for (let i = 0; i < nodes.length; i++) {\n            // write offset\n            dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n            // write serialized element to variable section\n            variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i]);\n        }\n        return variableIndex;\n    }\n    // Fixed length\n    else {\n        for (let i = 0; i < nodes.length; i++) {\n            offset = elementType.tree_serializeToBytes(output, offset, nodes[i]);\n        }\n        return offset;\n    }\n}\nexports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;\nfunction tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {\n    const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n    const length = offsets.length; // Capture length before pushing end offset\n    const nodes = new Array(length);\n    // offests include the last element end\n    for (let i = 0; i < length; i++) {\n        // The offsets are relative to the start\n        const startEl = start + offsets[i];\n        const endEl = i === length - 1 ? end : start + offsets[i + 1];\n        nodes[i] = elementType.tree_deserializeFromBytes(data, startEl, endEl);\n    }\n    // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n    const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);\n    // TODO: Add LeafNode.fromUint()\n    if (arrayProps.isList) {\n        return arrayBasic_1.addLengthNode(chunksNode, length);\n    }\n    else {\n        return chunksNode;\n    }\n}\nexports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_getRootsArrayComposite(elementType, length, value) {\n    const roots = new Array(length);\n    for (let i = 0; i < length; i++) {\n        roots[i] = elementType.hashTreeRoot(value[i]);\n    }\n    return roots;\n}\nexports.value_getRootsArrayComposite = value_getRootsArrayComposite;\nfunction readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {\n    const size = end - start;\n    let offsets;\n    // Variable Length\n    // Indices contain offsets, which are indices deeper in the byte array\n    if (elementFixedSize === null) {\n        offsets = readVariableOffsetsArrayComposite(data, start, size);\n    }\n    // Fixed length\n    else {\n        // There's no valid CompositeType with fixed size 0, it's un-rechable code. But prevents diving by zero\n        /* istanbul ignore if */\n        if (elementFixedSize === 0) {\n            throw Error(\"element fixed length is 0\");\n        }\n        if (size % elementFixedSize !== 0) {\n            throw Error(`size ${size} is not multiple of element fixedSize ${elementFixedSize}`);\n        }\n        const length = size / elementFixedSize;\n        offsets = new Uint32Array(length);\n        for (let i = 0; i < length; i++) {\n            offsets[i] = i * elementFixedSize;\n        }\n    }\n    // Vector + List length validation\n    arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);\n    return offsets;\n}\n/**\n * Reads the values of contiguous variable offsets. Provided buffer includes offsets that point to position\n * within `size`. This function also validates that all offsets are in range.\n */\nfunction readVariableOffsetsArrayComposite(dataView, start, size) {\n    if (size === 0) {\n        return new Uint32Array(0);\n    }\n    // all elements are variable-sized\n    // indices contain offsets, which are indices deeper in the byte array\n    // The serialized data will start with offsets of all the serialized objects (BYTES_PER_LENGTH_OFFSET bytes each)\n    const firstOffset = dataView.getUint32(start, true);\n    // Using the first offset, we can compute the length of the list (divide by BYTES_PER_LENGTH_OFFSET), as it gives\n    // us the total number of bytes in the offset data\n    const offsetDataLength = firstOffset;\n    if (firstOffset === 0) {\n        throw Error(\"First offset must be > 0\");\n    }\n    if (offsetDataLength % 4 !== 0) {\n        throw Error(\"Offset data length not multiple of 4\");\n    }\n    const offsetCount = offsetDataLength / 4;\n    const offsets = new Uint32Array(offsetCount);\n    offsets[0] = firstOffset;\n    // ArrayComposite has a contiguous section of offsets, then the data\n    //\n    //    [offset 1] [offset 2] [data 1 ..........] [data 2 ..]\n    // 0x 08000000   0e000000   010002000300        01000200\n    //\n    // Ensure that:\n    // - Offsets point to regions of > 0 bytes, i.e. are increasing\n    // - Offsets don't point to bytes outside of the array's size\n    //\n    // In the example above the first offset is 8, so 8 / 4 = 2 offsets.\n    // Then, read the rest of offsets to get offsets = [8, 14]\n    for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {\n        const offset = dataView.getUint32(start + offsetIdx * 4, true);\n        offsets[offsetIdx] = offset;\n        // Offsets must point to data within the Array bytes section\n        if (offset > size) {\n            throw new Error(`Offset out of bounds ${offset} > ${size}`);\n        }\n        if (offset < offsets[offsetIdx - 1]) {\n            throw new Error(`Offsets must be increasing ${offset} < ${offsets[offsetIdx - 1]}`);\n        }\n    }\n    return offsets;\n}\n//# sourceMappingURL=arrayComposite.js.map"]},"metadata":{},"sourceType":"script"}