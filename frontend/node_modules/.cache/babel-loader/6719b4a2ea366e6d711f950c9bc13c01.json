{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VectorBasicType = void 0;\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst arrayBasic_2 = require(\"../view/arrayBasic\");\nconst arrayBasic_3 = require(\"../viewDU/arrayBasic\");\nconst array_1 = require(\"./array\");\n/**\n * Vector: Ordered fixed-length homogeneous collection, with N values\n *\n * Array of Basic type:\n * - Basic types are max 32 bytes long so multiple values may be packed in the same node.\n * - Basic types are never returned in a view wrapper, but their value representation\n */\nclass VectorBasicType extends array_1.ArrayType {\n  constructor(elementType, length, opts) {\n    var _opts$typeName;\n    super(elementType);\n    this.elementType = elementType;\n    this.length = length;\n    this.isList = false;\n    this.isViewMutable = true;\n    if (!elementType.isBasic) throw Error(\"elementType must be basic\");\n    if (length === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"Vector[\".concat(elementType.typeName, \", \").concat(length, \"]\");\n    // TODO Check that itemsPerChunk is an integer\n    this.itemsPerChunk = 32 / elementType.byteLength;\n    this.maxChunkCount = Math.ceil(length * elementType.byteLength / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = this.chunkDepth;\n    this.fixedSize = length * elementType.byteLength;\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n    this.defaultLen = length;\n  }\n  static named(elementType, limit, opts) {\n    return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);\n  }\n  getView(tree) {\n    return new arrayBasic_2.ArrayBasicTreeView(this, tree);\n  }\n  getViewDU(node, cache) {\n    // cache type should be validated (if applicate) in the view\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache);\n  }\n  commitView(view) {\n    return view.node;\n  }\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n  // Serialization + deserialization\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n  value_serializeToBytes(output, offset, value) {\n    return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);\n  }\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);\n  }\n  // Helpers for TreeView\n  tree_getLength() {\n    return this.length;\n  }\n  tree_setLength() {\n    // Vector's length is immutable, ignore this call\n  }\n  tree_getChunksNode(node) {\n    return node;\n  }\n  tree_setChunksNode(rootNode, chunksNode) {\n    return chunksNode;\n  }\n  // Merkleization\n  getRoots(value) {\n    const uint8Array = new Uint8Array(this.fixedSize);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, {\n      uint8Array,\n      dataView\n    }, 0, value);\n    return merkleize_1.splitIntoRootChunks(uint8Array);\n  }\n}\nexports.VectorBasicType = VectorBasicType;","map":{"version":3,"sources":["../../src/type/vectorBasic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorBasicType = void 0;\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst arrayBasic_2 = require(\"../view/arrayBasic\");\nconst arrayBasic_3 = require(\"../viewDU/arrayBasic\");\nconst array_1 = require(\"./array\");\n/**\n * Vector: Ordered fixed-length homogeneous collection, with N values\n *\n * Array of Basic type:\n * - Basic types are max 32 bytes long so multiple values may be packed in the same node.\n * - Basic types are never returned in a view wrapper, but their value representation\n */\nclass VectorBasicType extends array_1.ArrayType {\n    constructor(elementType, length, opts) {\n        super(elementType);\n        this.elementType = elementType;\n        this.length = length;\n        this.isList = false;\n        this.isViewMutable = true;\n        if (!elementType.isBasic)\n            throw Error(\"elementType must be basic\");\n        if (length === 0)\n            throw Error(\"Vector length must be > 0\");\n        this.typeName = opts?.typeName ?? `Vector[${elementType.typeName}, ${length}]`;\n        // TODO Check that itemsPerChunk is an integer\n        this.itemsPerChunk = 32 / elementType.byteLength;\n        this.maxChunkCount = Math.ceil((length * elementType.byteLength) / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        this.depth = this.chunkDepth;\n        this.fixedSize = length * elementType.byteLength;\n        this.minSize = this.fixedSize;\n        this.maxSize = this.fixedSize;\n        this.defaultLen = length;\n    }\n    static named(elementType, limit, opts) {\n        return new (named_1.namedClass(VectorBasicType, opts.typeName))(elementType, limit, opts);\n    }\n    getView(tree) {\n        return new arrayBasic_2.ArrayBasicTreeView(this, tree);\n    }\n    getViewDU(node, cache) {\n        // cache type should be validated (if applicate) in the view\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new arrayBasic_3.ArrayBasicTreeViewDU(this, node, cache);\n    }\n    commitView(view) {\n        return view.node;\n    }\n    commitViewDU(view) {\n        view.commit();\n        return view.node;\n    }\n    cacheOfViewDU(view) {\n        return view.cache;\n    }\n    // Serialization + deserialization\n    value_serializedSize() {\n        return this.fixedSize;\n    }\n    value_serializeToBytes(output, offset, value) {\n        return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, output, offset, value);\n    }\n    value_deserializeFromBytes(data, start, end) {\n        return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);\n    }\n    tree_serializedSize() {\n        return this.fixedSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, this.length, this.depth, output, offset, node);\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.depth, data, start, end, this);\n    }\n    // Helpers for TreeView\n    tree_getLength() {\n        return this.length;\n    }\n    tree_setLength() {\n        // Vector's length is immutable, ignore this call\n    }\n    tree_getChunksNode(node) {\n        return node;\n    }\n    tree_setChunksNode(rootNode, chunksNode) {\n        return chunksNode;\n    }\n    // Merkleization\n    getRoots(value) {\n        const uint8Array = new Uint8Array(this.fixedSize);\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n        arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, this.length, { uint8Array, dataView }, 0, value);\n        return merkleize_1.splitIntoRootChunks(uint8Array);\n    }\n}\nexports.VectorBasicType = VectorBasicType;\n//# sourceMappingURL=vectorBasic.js.map"]},"metadata":{},"sourceType":"script"}