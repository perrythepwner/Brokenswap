{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must NOT have duplicate items (items ## \", \" and \", \" are identical)\"])), j, i);\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{i: \", \", j: \", \"}\"])), i, j);\n  }\n};\nconst def = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      parentSchema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && !schema) return;\n    const valid = gen.let(\"valid\");\n    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n    cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" === false\"])), schemaCode));\n    cxt.ok(valid);\n    function validateUniqueItems() {\n      const i = gen.let(\"i\", (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n      const j = gen.let(\"j\");\n      cxt.setParams({\n        i,\n        j\n      });\n      gen.assign(valid, true);\n      gen.if((0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" > 1\"])), i), () => (canOptimize() ? loopN : loopN2)(i, j));\n    }\n    function canOptimize() {\n      return itemTypes.length > 0 && !itemTypes.some(t => t === \"object\" || t === \"array\");\n    }\n    function loopN(i, j) {\n      const item = gen.name(\"item\");\n      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n      const indices = gen.const(\"indices\", (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"{}\"]))));\n      gen.for((0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\";\", \"--;\"])), i), () => {\n        gen.let(item, (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), data, i));\n        gen.if(wrongType, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"continue\"]))));\n        if (itemTypes.length > 1) gen.if((0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"])), item), (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \" += \\\"_\\\"\"])), item));\n        gen.if((0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"typeof \", \"[\", \"] == \\\"number\\\"\"])), indices, item), () => {\n          gen.assign(j, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), indices, item));\n          cxt.error();\n          gen.assign(valid, false).break();\n        }).code((0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \"[\", \"] = \", \"\"])), indices, item, i));\n      });\n    }\n    function loopN2(i, j) {\n      const eql = (0, util_1.useFunc)(gen, equal_1.default);\n      const outer = gen.name(\"outer\");\n      gen.label(outer).for((0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\";\", \"--;\"])), i), () => gen.for((0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \" = \", \"; \", \"--;\"])), j, i, j), () => gen.if((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \"(\", \"[\", \"], \", \"[\", \"])\"])), eql, data, i, data, j), () => {\n        cxt.error();\n        gen.assign(valid, false).break(outer);\n      })));\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/uniqueItems.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map"]},"metadata":{},"sourceType":"script"}