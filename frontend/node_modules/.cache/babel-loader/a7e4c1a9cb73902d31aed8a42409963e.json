{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = new Array(256);\nfunction toHexString(bytes) {\n  let hex = \"0x\";\n  for (const byte of bytes) {\n    if (!hexByByte[byte]) {\n      hexByByte[byte] = byte < 16 ? \"0\" + byte.toString(16) : byte.toString(16);\n    }\n    hex += hexByByte[byte];\n  }\n  return hex;\n}\nexports.toHexString = toHexString;\nfunction fromHexString(hex) {\n  if (typeof hex !== \"string\") {\n    throw new Error(\"hex argument type \".concat(typeof hex, \" must be of type string\"));\n  }\n  if (hex.startsWith(\"0x\")) {\n    hex = hex.slice(2);\n  }\n  if (hex.length % 2 !== 0) {\n    throw new Error(\"hex string length \".concat(hex.length, \" must be multiple of 2\"));\n  }\n  const byteLen = hex.length / 2;\n  const bytes = new Uint8Array(byteLen);\n  for (let i = 0; i < byteLen; i++) {\n    const byte = parseInt(hex.slice(i * 2, (i + 1) * 2), 16);\n    bytes[i] = byte;\n  }\n  return bytes;\n}\nexports.fromHexString = fromHexString;\nfunction byteArrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nexports.byteArrayEquals = byteArrayEquals;","map":{"version":3,"sources":["../../src/util/byteArray.ts"],"names":[],"mappings":";;;;;;AAEA;AACA,MAAM,SAAS,GAAG,IAAI,KAAK,CAAS,GAAG,CAAC;AAExC,SAAgB,WAAW,CAAC,KAA8B,EAAA;EACxD,IAAI,GAAG,GAAG,IAAI;EACd,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;IACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;MACpB,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;IAC1E;IACD,GAAG,IAAI,SAAS,CAAC,IAAI,CAAC;EACvB;EACD,OAAO,GAAG;AACZ;AATA,OAAA,CAAA,WAAA,GAAA,WAAA;AAWA,SAAgB,aAAa,CAAC,GAAW,EAAA;EACvC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAI,KAAK,sBAAA,MAAA,CAAsB,OAAO,GAAG,4BAAyB,CAAC;EAC1E;EAED,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;IACxB,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;EACnB;EAED,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACxB,MAAM,IAAI,KAAK,sBAAA,MAAA,CAAsB,GAAG,CAAC,MAAM,2BAAwB,CAAC;EACzE;EAED,MAAM,OAAO,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC;EAC9B,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC;EACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE;IAChC,MAAM,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC;IACxD,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI;EAChB;EACD,OAAO,KAAK;AACd;AApBA,OAAA,CAAA,aAAA,GAAA,aAAA;AAsBA,SAAgB,eAAe,CAAC,CAAa,EAAE,CAAa,EAAA;EAC1D,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;IACzB,OAAO,KAAK;EACb;EACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACjC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,KAAK;EAChC;EACD,OAAO,IAAI;AACb;AARA,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = new Array(256);\nfunction toHexString(bytes) {\n    let hex = \"0x\";\n    for (const byte of bytes) {\n        if (!hexByByte[byte]) {\n            hexByByte[byte] = byte < 16 ? \"0\" + byte.toString(16) : byte.toString(16);\n        }\n        hex += hexByByte[byte];\n    }\n    return hex;\n}\nexports.toHexString = toHexString;\nfunction fromHexString(hex) {\n    if (typeof hex !== \"string\") {\n        throw new Error(`hex argument type ${typeof hex} must be of type string`);\n    }\n    if (hex.startsWith(\"0x\")) {\n        hex = hex.slice(2);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(`hex string length ${hex.length} must be multiple of 2`);\n    }\n    const byteLen = hex.length / 2;\n    const bytes = new Uint8Array(byteLen);\n    for (let i = 0; i < byteLen; i++) {\n        const byte = parseInt(hex.slice(i * 2, (i + 1) * 2), 16);\n        bytes[i] = byte;\n    }\n    return bytes;\n}\nexports.fromHexString = fromHexString;\nfunction byteArrayEquals(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\nexports.byteArrayEquals = byteArrayEquals;\n//# sourceMappingURL=byteArray.js.map"]},"metadata":{},"sourceType":"script"}