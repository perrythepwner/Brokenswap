{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GovernanceWrapper = exports.hotfixToParams = exports.VoteValue = exports.proposalToParams = exports.ProposalStage = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar async_1 = require(\"@celo/base/lib/async\");\nvar collections_1 = require(\"@celo/base/lib/collections\");\nvar connect_1 = require(\"@celo/connect\");\nvar fixidity_1 = require(\"@celo/utils/lib/fixidity\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar BaseWrapper_1 = require(\"./BaseWrapper\");\nvar BaseWrapperForGoverning_1 = require(\"./BaseWrapperForGoverning\");\nvar ProposalStage;\n(function (ProposalStage) {\n  ProposalStage[\"None\"] = \"None\";\n  ProposalStage[\"Queued\"] = \"Queued\";\n  ProposalStage[\"Approval\"] = \"Approval\";\n  ProposalStage[\"Referendum\"] = \"Referendum\";\n  ProposalStage[\"Execution\"] = \"Execution\";\n  ProposalStage[\"Expiration\"] = \"Expiration\";\n})(ProposalStage = exports.ProposalStage || (exports.ProposalStage = {}));\nvar proposalToParams = function proposalToParams(proposal, descriptionURL) {\n  var data = proposal.map(function (tx) {\n    return (0, address_1.hexToBuffer)(tx.input);\n  });\n  return [proposal.map(function (tx) {\n    return tx.value;\n  }), proposal.map(function (tx) {\n    return tx.to;\n  }), (0, BaseWrapper_1.bufferToSolidityBytes)(Buffer.concat(data)), data.map(function (inp) {\n    return inp.length;\n  }), descriptionURL];\n};\nexports.proposalToParams = proposalToParams;\nvar VoteValue;\n(function (VoteValue) {\n  VoteValue[\"None\"] = \"None\";\n  VoteValue[\"Abstain\"] = \"Abstain\";\n  VoteValue[\"No\"] = \"No\";\n  VoteValue[\"Yes\"] = \"Yes\";\n})(VoteValue = exports.VoteValue || (exports.VoteValue = {}));\nvar hotfixToParams = function hotfixToParams(proposal, salt) {\n  var p = (0, exports.proposalToParams)(proposal, ''); // no description URL for hotfixes\n  return [p[0], p[1], p[2], p[3], (0, address_1.bufferToHex)(salt)];\n};\nexports.hotfixToParams = hotfixToParams;\nvar ZERO_BN = new bignumber_js_1.default(0);\n/**\n * Contract managing voting for governance proposals.\n */\nvar GovernanceWrapper = /** @class */function (_super) {\n  __extends(GovernanceWrapper, _super);\n  function GovernanceWrapper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Querying number of possible concurrent proposals.\n     * @returns Current number of possible concurrent proposals.\n     */\n    _this.concurrentProposals = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.concurrentProposals, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Query time of last proposal dequeue\n     * @returns Time of last dequeue\n     */\n    _this.lastDequeue = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.lastDequeue, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Query proposal dequeue frequency.\n     * @returns Current proposal dequeue frequency in seconds.\n     */\n    _this.dequeueFrequency = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.dequeueFrequency, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Query minimum deposit required to make a proposal.\n     * @returns Current minimum deposit.\n     */\n    _this.minDeposit = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.minDeposit, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Query queue expiry parameter.\n     * @return The number of seconds a proposal can stay in the queue before expiring.\n     */\n    _this.queueExpiry = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.queueExpiry, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Returns whether or not a particular account is voting on proposals.\n     * @param account The address of the account.\n     * @returns Whether or not the account is voting on proposals.\n     */\n    _this.isVoting = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isVoting);\n    /**\n     * Returns the metadata associated with a given proposal.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.getProposalMetadata = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getProposal, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString), function (res) {\n      return {\n        proposer: res[0],\n        deposit: (0, BaseWrapper_1.valueToBigNumber)(res[1]),\n        timestamp: (0, BaseWrapper_1.valueToBigNumber)(res[2]),\n        transactionCount: (0, BaseWrapper_1.valueToInt)(res[3]),\n        descriptionURL: res[4]\n      };\n    });\n    /**\n     * Returns the transaction at the given index associated with a given proposal.\n     * @param proposalID Governance proposal UUID\n     * @param txIndex Transaction index\n     */\n    _this.getProposalTransaction = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getProposalTransaction, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString, BaseWrapper_1.valueToString), function (res) {\n      return {\n        value: res[0],\n        to: res[1],\n        input: (0, BaseWrapper_1.solidityBytesToString)(res[2])\n      };\n    });\n    /**\n     * Returns whether a given proposal is approved.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.isApproved = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isApproved, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString));\n    /**\n     * Returns whether a dequeued proposal is expired.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.isDequeuedProposalExpired = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isDequeuedProposalExpired, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString));\n    /**\n     * Returns whether a dequeued proposal is expired.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.isQueuedProposalExpired = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isQueuedProposalExpired, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString));\n    /**\n     * Returns the approver address for proposals and hotfixes.\n     */\n    _this.getApprover = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.approver);\n    /**\n     * Returns the approver multisig contract for proposals and hotfixes.\n     */\n    _this.getApproverMultisig = function () {\n      return _this.getApprover().then(function (address) {\n        return _this.contracts.getMultiSig(address);\n      });\n    };\n    _this.getProposalStage = function (proposalID) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var queue, existsInQueue, expired, res;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, this.getQueue()];\n            case 1:\n              queue = _a.sent();\n              existsInQueue = queue.find(function (u) {\n                return u.proposalID === proposalID;\n              }) !== undefined;\n              if (!existsInQueue) return [3 /*break*/, 3];\n              return [4 /*yield*/, this.isQueuedProposalExpired(proposalID)];\n            case 2:\n              expired = _a.sent();\n              return [2 /*return*/, expired ? ProposalStage.Expiration : ProposalStage.Queued];\n            case 3:\n              return [4 /*yield*/, this.contract.methods.getProposalStage((0, BaseWrapper_1.valueToString)(proposalID)).call()];\n            case 4:\n              res = _a.sent();\n              return [2 /*return*/, Object.keys(ProposalStage)[(0, BaseWrapper_1.valueToInt)(res)]];\n          }\n        });\n      });\n    };\n    /**\n     * Returns whether a given proposal is passing relative to the constitution's threshold.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.isProposalPassing = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isProposalPassing, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString));\n    /**\n     * Withdraws refunded proposal deposits.\n     */\n    _this.withdraw = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.withdraw);\n    /**\n     * Submits a new governance proposal.\n     * @param proposal Governance proposal\n     * @param descriptionURL A URL where further information about the proposal can be viewed\n     */\n    _this.propose = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.propose, exports.proposalToParams);\n    /**\n     * Returns whether a governance proposal exists with the given ID.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.proposalExists = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.proposalExists, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString));\n    /**\n     * Returns the current upvoted governance proposal ID and applied vote weight (zeroes if none).\n     * @param upvoter Address of upvoter\n     */\n    _this.getUpvoteRecord = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getUpvoteRecord, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.identity), function (o) {\n      return {\n        proposalID: (0, BaseWrapper_1.valueToBigNumber)(o[0]),\n        upvotes: (0, BaseWrapper_1.valueToBigNumber)(o[1])\n      };\n    });\n    /**\n     * Returns whether a given proposal is queued.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.isQueued = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isQueued, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString));\n    /**\n     * Returns the value of proposal deposits that have been refunded.\n     * @param proposer Governance proposer address.\n     */\n    _this.getRefundedDeposits = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.refundedDeposits, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.stringIdentity), BaseWrapper_1.valueToBigNumber);\n    /*\n     * Returns the upvotes applied to a given proposal.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.getUpvotes = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getUpvotes, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString), BaseWrapper_1.valueToBigNumber);\n    /**\n     * Returns the yes, no, and abstain votes applied to a given proposal.\n     * @param proposalID Governance proposal UUID\n     */\n    _this.getVotes = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getVoteTotals, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString), function (res) {\n      var _a;\n      return _a = {}, _a[VoteValue.Yes] = (0, BaseWrapper_1.valueToBigNumber)(res[0]), _a[VoteValue.No] = (0, BaseWrapper_1.valueToBigNumber)(res[1]), _a[VoteValue.Abstain] = (0, BaseWrapper_1.valueToBigNumber)(res[2]), _a;\n    });\n    /**\n     * Returns the proposal queue as list of upvote records.\n     */\n    _this.getQueue = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.getQueue, undefined, function (arraysObject) {\n      return (0, collections_1.zip)(function (_id, _upvotes) {\n        return {\n          proposalID: (0, BaseWrapper_1.valueToBigNumber)(_id),\n          upvotes: (0, BaseWrapper_1.valueToBigNumber)(_upvotes)\n        };\n      }, arraysObject[0], arraysObject[1]);\n    });\n    /**\n     * Dequeues any queued proposals if `dequeueFrequency` seconds have elapsed since the last dequeue\n     */\n    _this.dequeueProposalsIfReady = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.dequeueProposalsIfReady);\n    _this.revokeVotes = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.revokeVotes);\n    /**\n     * Returns whether a given hotfix has been whitelisted by a given address.\n     * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n     * @param whitelister address of whitelister\n     */\n    _this.isHotfixWhitelistedBy = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isHotfixWhitelistedBy, (0, BaseWrapper_1.tupleParser)(address_1.bufferToHex, function (s) {\n      return (0, BaseWrapper_1.identity)(s);\n    }));\n    /**\n     * Returns whether a given hotfix can be passed.\n     * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n     */\n    _this.isHotfixPassing = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.isHotfixPassing, (0, BaseWrapper_1.tupleParser)(address_1.bufferToHex));\n    /**\n     * Returns the number of validators required to reach a Byzantine quorum\n     */\n    _this.minQuorumSize = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.minQuorumSizeInCurrentSet, undefined, BaseWrapper_1.valueToBigNumber);\n    /**\n     * Returns the number of validators that whitelisted the hotfix\n     * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n     */\n    _this.hotfixWhitelistValidatorTally = (0, BaseWrapper_1.proxyCall)(_this.contract.methods.hotfixWhitelistValidatorTally, (0, BaseWrapper_1.tupleParser)(address_1.bufferToHex));\n    /**\n     * Marks the given hotfix whitelisted by `sender`.\n     * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n     */\n    _this.whitelistHotfix = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.whitelistHotfix, (0, BaseWrapper_1.tupleParser)(address_1.bufferToHex));\n    /**\n     * Marks the given hotfix approved by `sender`.\n     * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n     * @notice Only the `approver` address will succeed in sending this transaction\n     */\n    _this.approveHotfix = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.approveHotfix, (0, BaseWrapper_1.tupleParser)(address_1.bufferToHex));\n    /**\n     * Marks the given hotfix prepared for current epoch if quorum of validators have whitelisted it.\n     * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n     */\n    _this.prepareHotfix = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.prepareHotfix, (0, BaseWrapper_1.tupleParser)(address_1.bufferToHex));\n    /**\n     * Executes a given sequence of transactions if the corresponding hash is prepared and approved.\n     * @param hotfix Governance hotfix proposal\n     * @param salt Secret which guarantees uniqueness of hash\n     * @notice keccak256 hash of abi encoded transactions computed on-chain\n     */\n    _this.executeHotfix = (0, BaseWrapper_1.proxySend)(_this.connection, _this.contract.methods.executeHotfix, exports.hotfixToParams);\n    return _this;\n  }\n  /**\n   * Query durations of different stages in proposal lifecycle.\n   * @returns Durations for approval, referendum and execution stages in seconds.\n   */\n  GovernanceWrapper.prototype.stageDurations = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.contract.methods.stageDurations().call()];\n          case 1:\n            res = _b.sent();\n            return [2 /*return*/, (_a = {}, _a[ProposalStage.Referendum] = (0, BaseWrapper_1.valueToBigNumber)(res[1]), _a[ProposalStage.Execution] = (0, BaseWrapper_1.valueToBigNumber)(res[2]), _a)];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the required ratio of yes:no votes needed to exceed in order to pass the proposal transaction.\n   * @param tx Transaction to determine the constitution for running.\n   */\n  GovernanceWrapper.prototype.getTransactionConstitution = function (tx) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var callSignature, value;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            callSignature = (0, address_1.ensureLeading0x)((0, address_1.trimLeading0x)(tx.input).slice(0, 8));\n            return [4 /*yield*/, this.contract.methods.getConstitution((_a = tx.to) !== null && _a !== void 0 ? _a : address_1.NULL_ADDRESS, callSignature).call()];\n          case 1:\n            value = _b.sent();\n            return [2 /*return*/, (0, fixidity_1.fromFixed)(new bignumber_js_1.default(value))];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the required ratio of yes:no votes needed to exceed in order to pass the proposal.\n   * @param proposal Proposal to determine the constitution for running.\n   */\n  GovernanceWrapper.prototype.getConstitution = function (proposal) {\n    return __awaiter(this, void 0, void 0, function () {\n      var constitution, _i, proposal_1, tx, _a, _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            constitution = new bignumber_js_1.default(0);\n            _i = 0, proposal_1 = proposal;\n            _c.label = 1;\n          case 1:\n            if (!(_i < proposal_1.length)) return [3 /*break*/, 4];\n            tx = proposal_1[_i];\n            _b = (_a = bignumber_js_1.default).max;\n            return [4 /*yield*/, this.getTransactionConstitution(tx)];\n          case 2:\n            constitution = _b.apply(_a, [_c.sent(), constitution]);\n            _c.label = 3;\n          case 3:\n            _i++;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, constitution];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the participation parameters.\n   * @returns The participation parameters.\n   */\n  GovernanceWrapper.prototype.getParticipationParameters = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contract.methods.getParticipationParameters().call()];\n          case 1:\n            res = _a.sent();\n            return [2 /*return*/, {\n              baseline: (0, fixidity_1.fromFixed)(new bignumber_js_1.default(res[0])),\n              baselineFloor: (0, fixidity_1.fromFixed)(new bignumber_js_1.default(res[1])),\n              baselineUpdateFactor: (0, fixidity_1.fromFixed)(new bignumber_js_1.default(res[2])),\n              baselineQuorumFactor: (0, fixidity_1.fromFixed)(new bignumber_js_1.default(res[3]))\n            }];\n        }\n      });\n    });\n  };\n  // simulates proposal.getSupportWithQuorumPadding\n  GovernanceWrapper.prototype.getSupport = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var participation, quorum, votes, total, lockedGold, networkWeight, required, support;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getParticipationParameters()];\n          case 1:\n            participation = _a.sent();\n            quorum = participation.baseline.times(participation.baselineQuorumFactor);\n            return [4 /*yield*/, this.getVotes(proposalID)];\n          case 2:\n            votes = _a.sent();\n            total = votes.Yes.plus(votes.No).plus(votes.Abstain);\n            return [4 /*yield*/, this.contracts.getLockedGold()\n            // NOTE: this networkWeight is not as governance calculates it,\n            // but we don't have access to proposal.networkWeight\n            ];\n\n          case 3:\n            lockedGold = _a.sent();\n            return [4 /*yield*/, lockedGold.getTotalLockedGold()];\n          case 4:\n            networkWeight = _a.sent();\n            required = networkWeight.times(quorum);\n            support = votes.Yes.div(votes.Yes.plus(votes.No));\n            return [2 /*return*/, {\n              support: support,\n              required: required,\n              total: total\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Returns current configuration parameters.\n   */\n  GovernanceWrapper.prototype.getConfig = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, Promise.all([this.concurrentProposals(), this.dequeueFrequency(), this.minDeposit(), this.queueExpiry(), this.stageDurations(), this.getParticipationParameters()])];\n          case 1:\n            res = _a.sent();\n            return [2 /*return*/, {\n              concurrentProposals: res[0],\n              dequeueFrequency: res[1],\n              minDeposit: res[2],\n              queueExpiry: res[3],\n              stageDurations: res[4],\n              participationParameters: res[5]\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * @dev Returns human readable configuration of the governance contract\n   * @return GovernanceConfig object\n   */\n  GovernanceWrapper.prototype.getHumanReadableConfig = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var config, stageDurations;\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.getConfig()];\n          case 1:\n            config = _b.sent();\n            stageDurations = (_a = {}, _a[ProposalStage.Referendum] = (0, BaseWrapper_1.secondsToDurationString)(config.stageDurations[ProposalStage.Referendum]), _a[ProposalStage.Execution] = (0, BaseWrapper_1.secondsToDurationString)(config.stageDurations[ProposalStage.Execution]), _a);\n            return [2 /*return*/, __assign(__assign({}, config), {\n              dequeueFrequency: (0, BaseWrapper_1.secondsToDurationString)(config.dequeueFrequency),\n              queueExpiry: (0, BaseWrapper_1.secondsToDurationString)(config.queueExpiry),\n              stageDurations: stageDurations\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the human readable metadata associated with a given proposal.\n   * @param proposalID Governance proposal UUID\n   */\n  GovernanceWrapper.prototype.getHumanReadableProposalMetadata = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var meta;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getProposalMetadata(proposalID)];\n          case 1:\n            meta = _a.sent();\n            return [2 /*return*/, __assign(__assign({}, meta), {\n              timestamp: (0, BaseWrapper_1.unixSecondsTimestampToDateString)(meta.timestamp)\n            })];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.proposalSchedule = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var meta, stage, queueExpiry, queueExpiration, durations, referendum, execution, expiration;\n      var _a, _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4 /*yield*/, this.getProposalMetadata(proposalID)];\n          case 1:\n            meta = _c.sent();\n            return [4 /*yield*/, this.getProposalStage(proposalID)];\n          case 2:\n            stage = _c.sent();\n            if (!(stage === ProposalStage.Queued)) return [3 /*break*/, 4];\n            return [4 /*yield*/, this.queueExpiry()];\n          case 3:\n            queueExpiry = _c.sent();\n            queueExpiration = meta.timestamp.plus(queueExpiry);\n            return [2 /*return*/, (_a = {}, _a[ProposalStage.Queued] = meta.timestamp, _a[ProposalStage.Expiration] = queueExpiration, _a)];\n          case 4:\n            return [4 /*yield*/, this.stageDurations()];\n          case 5:\n            durations = _c.sent();\n            referendum = meta.timestamp;\n            execution = referendum.plus(durations.Referendum);\n            expiration = execution.plus(durations.Execution);\n            return [2 /*return*/, (_b = {}, _b[ProposalStage.Referendum] = referendum, _b[ProposalStage.Execution] = execution, _b[ProposalStage.Expiration] = expiration, _b)];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.humanReadableProposalSchedule = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var schedule, dates, _i, _a, stage;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.proposalSchedule(proposalID)];\n          case 1:\n            schedule = _b.sent();\n            dates = {};\n            for (_i = 0, _a = Object.keys(schedule); _i < _a.length; _i++) {\n              stage = _a[_i];\n              dates[stage] = (0, BaseWrapper_1.unixSecondsTimestampToDateString)(schedule[stage]);\n            }\n            return [2 /*return*/, dates];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the proposal associated with a given id.\n   * @param proposalID Governance proposal UUID\n   */\n  GovernanceWrapper.prototype.getProposal = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, txIndices;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getProposalMetadata(proposalID)];\n          case 1:\n            metadata = _a.sent();\n            txIndices = (0, collections_1.zeroRange)(metadata.transactionCount);\n            return [2 /*return*/, (0, async_1.concurrentMap)(4, txIndices, function (idx) {\n              return _this.getProposalTransaction(proposalID, idx);\n            })];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.getApprovalStatus = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var multisig, approveTx, multisigTxs, confirmations, approvers;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getApproverMultisig()];\n          case 1:\n            multisig = _a.sent();\n            return [4 /*yield*/, this.approve(proposalID)];\n          case 2:\n            approveTx = _a.sent();\n            return [4 /*yield*/, multisig.getTransactionDataByContent(this.address, approveTx.txo)];\n          case 3:\n            multisigTxs = _a.sent();\n            confirmations = multisigTxs ? multisigTxs.confirmations : [];\n            return [4 /*yield*/, multisig.getOwners()];\n          case 4:\n            approvers = _a.sent();\n            return [2 /*return*/, {\n              completion: \"\".concat(confirmations.length, \" / \").concat(approvers.length),\n              confirmations: confirmations,\n              approvers: approvers\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the stage, metadata, upvotes, votes, and transactions associated with a given proposal.\n   * @param proposalID Governance proposal UUID\n   */\n  GovernanceWrapper.prototype.getProposalRecord = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, proposal, stage, record, _a, _b, _c, _d, _e;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4 /*yield*/, this.getProposalMetadata(proposalID)];\n          case 1:\n            metadata = _f.sent();\n            return [4 /*yield*/, this.getProposal(proposalID)];\n          case 2:\n            proposal = _f.sent();\n            return [4 /*yield*/, this.getProposalStage(proposalID)];\n          case 3:\n            stage = _f.sent();\n            record = {\n              proposal: proposal,\n              metadata: metadata,\n              stage: stage,\n              passed: false,\n              approved: false\n            };\n            if (!(stage === ProposalStage.Queued)) return [3 /*break*/, 5];\n            _a = record;\n            return [4 /*yield*/, this.getUpvotes(proposalID)];\n          case 4:\n            _a.upvotes = _f.sent();\n            return [3 /*break*/, 10];\n          case 5:\n            if (!(stage === ProposalStage.Referendum || stage === ProposalStage.Execution)) return [3 /*break*/, 10];\n            record.approved = true;\n            _b = record;\n            return [4 /*yield*/, this.isProposalPassing(proposalID)];\n          case 6:\n            _b.passed = _f.sent();\n            _c = record;\n            return [4 /*yield*/, this.getVotes(proposalID)];\n          case 7:\n            _c.votes = _f.sent();\n            _d = record;\n            return [4 /*yield*/, this.isApproved(proposalID)];\n          case 8:\n            _d.approved = _f.sent();\n            _e = record;\n            return [4 /*yield*/, this.getApprovalStatus(proposalID)];\n          case 9:\n            _e.approvals = _f.sent();\n            _f.label = 10;\n          case 10:\n            return [2 /*return*/, record];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.isUpvoting = function (upvoter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var upvote, _a, _b;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4 /*yield*/, this.getUpvoteRecord(upvoter)];\n          case 1:\n            upvote = _c.sent();\n            _b = !upvote.proposalID.isZero();\n            if (!_b) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.isQueued(upvote.proposalID)];\n          case 2:\n            _b = _c.sent();\n            _c.label = 3;\n          case 3:\n            _a = _b;\n            if (!_a) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.isQueuedProposalExpired(upvote.proposalID)];\n          case 4:\n            _a = !_c.sent();\n            _c.label = 5;\n          case 5:\n            return [2 /*return*/, _a];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the corresponding vote record\n   * @param voter Address of voter\n   * @param proposalID Governance proposal UUID\n   */\n  GovernanceWrapper.prototype.getVoteRecord = function (voter, proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proposalIndex, res, _1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n            return [4 /*yield*/, this.getDequeueIndex(proposalID)];\n          case 1:\n            proposalIndex = _a.sent();\n            return [4 /*yield*/, this.contract.methods.getVoteRecord(voter, proposalIndex).call()];\n          case 2:\n            res = _a.sent();\n            return [2 /*return*/, {\n              proposalID: (0, BaseWrapper_1.valueToBigNumber)(res[0]),\n              value: Object.keys(VoteValue)[(0, BaseWrapper_1.valueToInt)(res[1])],\n              votes: (0, BaseWrapper_1.valueToBigNumber)(res[2]),\n              yesVotes: (0, BaseWrapper_1.valueToBigNumber)(res[3]),\n              noVotes: (0, BaseWrapper_1.valueToBigNumber)(res[4]),\n              abstainVotes: (0, BaseWrapper_1.valueToBigNumber)(res[5])\n            }];\n          case 3:\n            _1 = _a.sent();\n            // The proposal ID may not be present in the dequeued list, or the voter may not have a vote\n            // record for the proposal.\n            return [2 /*return*/, null];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the (existing) proposal dequeue as list of proposal IDs.\n   */\n  GovernanceWrapper.prototype.getDequeue = function (filterZeroes) {\n    if (filterZeroes === void 0) {\n      filterZeroes = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var dequeue, dequeueIds;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contract.methods.getDequeue().call()\n            // filter non-zero as dequeued indices are reused and `deleteDequeuedProposal` zeroes\n            ];\n\n          case 1:\n            dequeue = _a.sent();\n            dequeueIds = dequeue.map(BaseWrapper_1.valueToBigNumber);\n            return [2 /*return*/, filterZeroes ? dequeueIds.filter(function (id) {\n              return !id.isZero();\n            }) : dequeueIds];\n        }\n      });\n    });\n  };\n  /*\n   * Returns the vote records for a given voter.\n   */\n  GovernanceWrapper.prototype.getVoteRecords = function (voter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var dequeue, voteRecords;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getDequeue()];\n          case 1:\n            dequeue = _a.sent();\n            return [4 /*yield*/, Promise.all(dequeue.map(function (id) {\n              return _this.getVoteRecord(voter, id);\n            }))];\n          case 2:\n            voteRecords = _a.sent();\n            return [2 /*return*/, voteRecords.filter(function (record) {\n              return record != null;\n            })];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.isVotingReferendum = function (voter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var records;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getVoteRecords(voter)];\n          case 1:\n            records = _a.sent();\n            return [2 /*return*/, records.length !== 0];\n        }\n      });\n    });\n  };\n  /*\n   * Returns information pertaining to a voter in governance.\n   */\n  GovernanceWrapper.prototype.getVoter = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, Promise.all([this.getUpvoteRecord(account), this.getVoteRecords(account), this.getRefundedDeposits(account)])];\n          case 1:\n            res = _a.sent();\n            return [2 /*return*/, {\n              upvote: res[0],\n              votes: res[1],\n              refundedDeposits: res[2]\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the number of votes that will be applied to a proposal for a given voter.\n   * @param voter Address of voter\n   */\n  GovernanceWrapper.prototype.getVoteWeight = function (voter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var lockedGoldContract;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contracts.getLockedGold()];\n          case 1:\n            lockedGoldContract = _a.sent();\n            return [2 /*return*/, lockedGoldContract.getAccountTotalLockedGold(voter)];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.getIndex = function (id, array) {\n    var index = array.findIndex(function (bn) {\n      return bn.isEqualTo(id);\n    });\n    if (index === -1) {\n      throw new Error(\"ID \".concat(id, \" not found in array \").concat(array));\n    }\n    return index;\n  };\n  GovernanceWrapper.prototype.getDequeueIndex = function (proposalID, dequeue) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!dequeue) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.getDequeue()];\n          case 1:\n            dequeue = _a.sent();\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/, this.getIndex(proposalID, dequeue)];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.getQueueIndex = function (proposalID, queue) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!queue) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.getQueue()];\n          case 1:\n            queue = _a.sent();\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/, {\n              index: this.getIndex(proposalID, queue.map(function (record) {\n                return record.proposalID;\n              })),\n              queue: queue\n            }];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.lesserAndGreater = function (proposalID, _queue) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, index, queue;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.getQueueIndex(proposalID, _queue)];\n          case 1:\n            _a = _b.sent(), index = _a.index, queue = _a.queue;\n            return [2 /*return*/, {\n              lesserID: index === 0 ? ZERO_BN : queue[index - 1].proposalID,\n              greaterID: index === queue.length - 1 ? ZERO_BN : queue[index + 1].proposalID\n            }];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.sortedQueue = function (queue) {\n    return queue.sort(function (a, b) {\n      return a.upvotes.comparedTo(b.upvotes);\n    });\n  };\n  GovernanceWrapper.prototype.withUpvoteRevoked = function (upvoter, _queue) {\n    return __awaiter(this, void 0, void 0, function () {\n      var upvoteRecord, _a, index, queue;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.getUpvoteRecord(upvoter)];\n          case 1:\n            upvoteRecord = _b.sent();\n            return [4 /*yield*/, this.getQueueIndex(upvoteRecord.proposalID, _queue)];\n          case 2:\n            _a = _b.sent(), index = _a.index, queue = _a.queue;\n            queue[index].upvotes = queue[index].upvotes.minus(upvoteRecord.upvotes);\n            return [2 /*return*/, {\n              queue: this.sortedQueue(queue),\n              upvoteRecord: upvoteRecord\n            }];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.withUpvoteApplied = function (upvoter, proposalID, _queue) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, index, queue, weight;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.getQueueIndex(proposalID, _queue)];\n          case 1:\n            _a = _b.sent(), index = _a.index, queue = _a.queue;\n            return [4 /*yield*/, this.getVoteWeight(upvoter)];\n          case 2:\n            weight = _b.sent();\n            queue[index].upvotes = queue[index].upvotes.plus(weight);\n            return [2 /*return*/, this.sortedQueue(queue)];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.lesserAndGreaterAfterRevoke = function (upvoter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, queue, upvoteRecord;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.withUpvoteRevoked(upvoter)];\n          case 1:\n            _a = _b.sent(), queue = _a.queue, upvoteRecord = _a.upvoteRecord;\n            return [2 /*return*/, this.lesserAndGreater(upvoteRecord.proposalID, queue)];\n        }\n      });\n    });\n  };\n  GovernanceWrapper.prototype.lesserAndGreaterAfterUpvote = function (upvoter, proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var upvoteRecord, recordQueued, queue, _a, upvoteQueue;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.getUpvoteRecord(upvoter)];\n          case 1:\n            upvoteRecord = _b.sent();\n            return [4 /*yield*/, this.isQueued(upvoteRecord.proposalID)\n            // if existing upvote exists in queue, revoke it before applying new upvote\n            ];\n\n          case 2:\n            recordQueued = _b.sent();\n            if (!recordQueued) return [3 /*break*/, 4];\n            return [4 /*yield*/, this.withUpvoteRevoked(upvoter)];\n          case 3:\n            _a = _b.sent().queue;\n            return [3 /*break*/, 6];\n          case 4:\n            return [4 /*yield*/, this.getQueue()];\n          case 5:\n            _a = _b.sent();\n            _b.label = 6;\n          case 6:\n            queue = _a;\n            return [4 /*yield*/, this.withUpvoteApplied(upvoter, proposalID, queue)];\n          case 7:\n            upvoteQueue = _b.sent();\n            return [2 /*return*/, this.lesserAndGreater(proposalID, upvoteQueue)];\n        }\n      });\n    });\n  };\n  /**\n   * Applies provided upvoter's upvote to given proposal.\n   * @param proposalID Governance proposal UUID\n   * @param upvoter Address of upvoter\n   */\n  GovernanceWrapper.prototype.upvote = function (proposalID, upvoter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, lesserID, greaterID;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.lesserAndGreaterAfterUpvote(upvoter, proposalID)];\n          case 1:\n            _a = _b.sent(), lesserID = _a.lesserID, greaterID = _a.greaterID;\n            return [2 /*return*/, (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.upvote((0, BaseWrapper_1.valueToString)(proposalID), (0, BaseWrapper_1.valueToString)(lesserID), (0, BaseWrapper_1.valueToString)(greaterID)))];\n        }\n      });\n    });\n  };\n  /**\n   * Revokes provided upvoter's upvote.\n   * @param upvoter Address of upvoter\n   */\n  GovernanceWrapper.prototype.revokeUpvote = function (upvoter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, lesserID, greaterID;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.lesserAndGreaterAfterRevoke(upvoter)];\n          case 1:\n            _a = _b.sent(), lesserID = _a.lesserID, greaterID = _a.greaterID;\n            return [2 /*return*/, (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.revokeUpvote((0, BaseWrapper_1.valueToString)(lesserID), (0, BaseWrapper_1.valueToString)(greaterID)))];\n        }\n      });\n    });\n  };\n  /**\n   * Approves given proposal, allowing it to later move to `referendum`.\n   * @param proposalID Governance proposal UUID\n   * @notice Only the `approver` address will succeed in sending this transaction\n   */\n  GovernanceWrapper.prototype.approve = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proposalIndex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getDequeueIndex(proposalID)];\n          case 1:\n            proposalIndex = _a.sent();\n            return [2 /*return*/, (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.approve((0, BaseWrapper_1.valueToString)(proposalID), proposalIndex))];\n        }\n      });\n    });\n  };\n  /**\n   * Applies `sender`'s vote choice to a given proposal.\n   * @param proposalID Governance proposal UUID\n   * @param vote Choice to apply (yes, no, abstain)\n   */\n  GovernanceWrapper.prototype.vote = function (proposalID, vote) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proposalIndex, voteNum;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getDequeueIndex(proposalID)];\n          case 1:\n            proposalIndex = _a.sent();\n            voteNum = Object.keys(VoteValue).indexOf(vote);\n            return [2 /*return*/, (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.vote((0, BaseWrapper_1.valueToString)(proposalID), proposalIndex, voteNum))];\n        }\n      });\n    });\n  };\n  /**\n   * Applies `sender`'s vote choice to a given proposal.\n   * @param proposalID Governance proposal UUID.\n   * @param yesVotes The yes votes.\n   * @param noVotes The no votes.\n   * @param abstainVotes The abstain votes.\n   */\n  GovernanceWrapper.prototype.votePartially = function (proposalID, yesVotes, noVotes, abstainVotes) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proposalIndex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getDequeueIndex(proposalID)];\n          case 1:\n            proposalIndex = _a.sent();\n            return [2 /*return*/, (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.votePartially((0, BaseWrapper_1.valueToString)(proposalID), proposalIndex, (0, BaseWrapper_1.valueToString)(yesVotes), (0, BaseWrapper_1.valueToString)(noVotes), (0, BaseWrapper_1.valueToString)(abstainVotes)))];\n        }\n      });\n    });\n  };\n  /**\n   * Returns `voter`'s vote choice on a given proposal.\n   * @param proposalID Governance proposal UUID\n   * @param voter Address of voter\n   */\n  GovernanceWrapper.prototype.getVoteValue = function (proposalID, voter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proposalIndex, res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getDequeueIndex(proposalID)];\n          case 1:\n            proposalIndex = _a.sent();\n            return [4 /*yield*/, this.contract.methods.getVoteRecord(voter, proposalIndex).call()];\n          case 2:\n            res = _a.sent();\n            return [2 /*return*/, Object.keys(VoteValue)[(0, BaseWrapper_1.valueToInt)(res[1])]];\n        }\n      });\n    });\n  };\n  /**\n   * Executes a given proposal's associated transactions.\n   * @param proposalID Governance proposal UUID\n   */\n  GovernanceWrapper.prototype.execute = function (proposalID) {\n    return __awaiter(this, void 0, void 0, function () {\n      var proposalIndex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.getDequeueIndex(proposalID)];\n          case 1:\n            proposalIndex = _a.sent();\n            return [2 /*return*/, (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.execute((0, BaseWrapper_1.valueToString)(proposalID), proposalIndex))];\n        }\n      });\n    });\n  };\n  /**\n   * Returns approved, executed, and prepared status associated with a given hotfix.\n   * @param hash keccak256 hash of hotfix's associated abi encoded transactions\n   */\n  GovernanceWrapper.prototype.getHotfixRecord = function (hash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.contract.methods.getHotfixRecord((0, address_1.bufferToHex)(hash)).call()];\n          case 1:\n            res = _a.sent();\n            return [2 /*return*/, {\n              approved: res[0],\n              executed: res[1],\n              preparedEpoch: (0, BaseWrapper_1.valueToBigNumber)(res[2])\n            }];\n        }\n      });\n    });\n  };\n  return GovernanceWrapper;\n}(BaseWrapperForGoverning_1.BaseWrapperForGoverning);\nexports.GovernanceWrapper = GovernanceWrapper;","map":null,"metadata":{},"sourceType":"script"}