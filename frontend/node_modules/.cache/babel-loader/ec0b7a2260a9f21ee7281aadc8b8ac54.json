{"ast":null,"code":"import { __read } from \"tslib\";\nimport { eventToSentryRequest, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, initAPIDetails, sessionToSentryRequest } from '@sentry/core';\nimport { createClientReportEnvelope, disabledUntil, dsnToString, eventStatusFromHttpCode, getGlobalObject, isRateLimited, logger, makePromiseBuffer, serializeEnvelope, updateRateLimits } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { sendReport } from './utils';\nfunction requestTypeToCategory(ty) {\n  var tyStr = ty;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\nvar global = getGlobalObject();\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */function () {\n  function BaseTransport(options) {\n    var _this = this;\n    this.options = options;\n    /** A simple buffer holding all requests. */\n    this._buffer = makePromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n    this._rateLimits = {};\n    this._outcomes = {};\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', function () {\n        if (global.document.visibilityState === 'hidden') {\n          _this._flushOutcomes();\n        }\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendEvent = function (event) {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendSession = function (session) {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.recordLostEvent = function (reason, category) {\n    var _a;\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    var key = requestTypeToCategory(category) + \":\" + reason;\n    IS_DEBUG_BUILD && logger.log(\"Adding outcome: \" + key);\n    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;\n  };\n  /**\n   * Send outcomes as an envelope\n   */\n  BaseTransport.prototype._flushOutcomes = function () {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    var outcomes = this._outcomes;\n    this._outcomes = {};\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      IS_DEBUG_BUILD && logger.log('No outcomes to flush');\n      return;\n    }\n    IS_DEBUG_BUILD && logger.log(\"Flushing outcomes:\\n\" + JSON.stringify(outcomes, null, 2));\n    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n    var discardedEvents = Object.keys(outcomes).map(function (key) {\n      var _a = __read(key.split(':'), 2),\n        category = _a[0],\n        reason = _a[1];\n      return {\n        reason: reason,\n        category: category,\n        quantity: outcomes[key]\n      };\n      // TODO: Improve types on discarded_events to get rid of cast\n    });\n\n    var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      IS_DEBUG_BUILD && logger.error(e);\n    }\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n      response = _a.response,\n      headers = _a.headers,\n      resolve = _a.resolve,\n      reject = _a.reject;\n    var status = eventStatusFromHttpCode(response.status);\n    this._rateLimits = updateRateLimits(this._rateLimits, headers);\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(requestType)) {\n      IS_DEBUG_BUILD &&\n      // eslint-disable-next-line deprecation/deprecation\n      logger.warn(\"Too many \" + requestType + \" requests, backing off until: \" + this._disabledUntil(requestType));\n    }\n    if (status === 'success') {\n      resolve({\n        status: status\n      });\n      return;\n    }\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   *\n   * @deprecated Please use `disabledUntil` from @sentry/utils\n   */\n  BaseTransport.prototype._disabledUntil = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return new Date(disabledUntil(this._rateLimits, category));\n  };\n  /**\n   * Checks if a category is rate limited\n   *\n   * @deprecated Please use `isRateLimited` from @sentry/utils\n   */\n  BaseTransport.prototype._isRateLimited = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return isRateLimited(this._rateLimits, category);\n  };\n  return BaseTransport;\n}();\nexport { BaseTransport };","map":null,"metadata":{},"sourceType":"module"}