{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\n// @ts-nocheck\n\nimport { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, parseCallKey, removeMulticallListeners, toCallKey } from './actions';\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(xi => isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg));\n}\nconst INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\n\n// use this options object\nexport const NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls, options) {\n  _s();\n  const chainId = 31337;\n  const callResults = useSelector(state => state.multicall.callResults);\n  const dispatch = useDispatch();\n  const serializedCallKeys = useMemo(() => {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(c => Boolean(c))) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]);\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    const calls = callKeys.map(key => parseCallKey(key));\n    dispatch(addMulticallListeners({\n      chainId,\n      calls,\n      options\n    }));\n    return () => {\n      dispatch(removeMulticallListeners({\n        chainId,\n        calls,\n        options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(() => calls.map(call => {\n    var _callResults$chainId;\n    if (!chainId || !call) return INVALID_RESULT;\n    const result = (_callResults$chainId = callResults[chainId]) === null || _callResults$chainId === void 0 ? void 0 : _callResults$chainId[toCallKey(call)];\n    let data;\n    if (result !== null && result !== void 0 && result.data && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n      data = result.data;\n    }\n    return {\n      valid: true,\n      data,\n      blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n    };\n  }), [callResults, calls, chainId]);\n}\n_s(useCallsData, \"340R1Nm5WdFFc4sSQhHlz/D24eM=\", false, function () {\n  return [useSelector, useDispatch];\n});\nconst INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nconst LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  const {\n    valid,\n    data,\n    blockNumber\n  } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  let result = undefined;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  };\n}\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  _s2();\n  const fragment = useMemo(() => {\n    var _contract$interface;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(inputs => {\n    return {\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    };\n  }) : [], [callInputs, contract, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\n_s2(useSingleContractMultipleData, \"wqKdm+GSVZDiHjC/KX/lpl3BZbE=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  _s3();\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  const callData = useMemo(() => fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined, [callInputs, contractInterface, fragment]);\n  const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData ? addresses.map(address => {\n    return address && callData ? {\n      address,\n      callData\n    } : undefined;\n  }) : [], [addresses, callData, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\n_s3(useMultipleContractSingleData, \"L2gBuYFIsXQlVxDNfOpFFd7DoVg=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  _s4();\n  const fragment = useMemo(() => {\n    var _contract$interface2;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  const result = useCallsData(calls, options)[0];\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}\n_s4(useSingleCallResult, \"w3FP0tU2v530x+kbmRIp+PuTg70=\", false, function () {\n  return [useCallsData, useBlockNumber];\n});","map":{"version":3,"names":["useEffect","useMemo","useDispatch","useSelector","useBlockNumber","addMulticallListeners","parseCallKey","removeMulticallListeners","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","_s","chainId","callResults","state","multicall","dispatch","serializedCallKeys","_calls$filter$map$sor","_calls$filter","_calls$filter$map","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","_callResults$chainId","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","_s2","_contract$interface","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","_s3","useSingleCallResult","_s4","_contract$interface2"],"sources":["/app/src/state/multicall/hooks.ts"],"sourcesContent":["// @ts-nocheck\nimport { FunctionFragment, Interface } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addMulticallListeners,\n  Call,\n  ListenerOptions,\n  parseCallKey,\n  removeMulticallListeners,\n  toCallKey,\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const chainId = 31337\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(\n    (state) => state.multicall.callResults\n  )\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map((key) => parseCallKey(key))\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options,\n      })\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options,\n        })\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>((call) => {\n        if (!chainId || !call) return INVALID_RESULT\n        const result = callResults[chainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, chainId]\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success,\n  }\n}\n\nexport function useSingleContractMultipleData<T extends Contract = Contract>(\n  contract: T | null | undefined,\n  methodName: keyof T['estimateGas'] & string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions\n): readonly CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>((inputs) => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\n            }\n          })\n        : [],\n    [callInputs, contract, fragment]\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: readonly (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  )\n\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>((address) => {\n            return address && callData\n              ? {\n                  address,\n                  callData,\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, fragment]\n  )\n  const results = useCallsData(calls, options)\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\n          },\n        ]\n      : []\n  }, [contract, fragment, inputs])\n\n  const result = useCallsData(calls, options)[0]\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\n  }, [result, contract, fragment, latestBlockNumber])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}