{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { parseUnits } from '@ethersproject/units';\nimport { cUSD, JSBI, Token, TokenAmount } from '@ubeswap/sdk';\nimport { useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useCurrency } from '../../hooks/Tokens';\nimport { isAddress } from '../../utils';\nimport { Field, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nexport function useSwapState() {\n  _s();\n  return useSelector(state => state.swap);\n}\n_s(useSwapState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\nexport function useSwapActionHandlers() {\n  _s2();\n  const dispatch = useDispatch();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency instanceof Token ? currency.address : ''\n    }));\n  }, [dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n}\n\n// try to parse a user entered amount for a given token\n_s2(useSwapActionHandlers, \"oIW3xZhV8GZLW5UVB2t9AN9x/ck=\", false, function () {\n  return [useDispatch];\n});\nexport function tryParseAmount(value, currency) {\n  if (!value || !currency) {\n    return undefined;\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n    if (typedValueParsed !== '0') {\n      return new TokenAmount(currency, JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(\"Failed to parse input amount: \\\"\".concat(value, \"\\\"\"), error);\n  }\n  // necessary for all paths to return a value\n  return new TokenAmount(currency, JSBI.BigInt(0));\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo() {\n  _s3();\n  var _ref;\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: {\n      currencyId: inputCurrencyId\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrencyId\n    }\n  } = useSwapState();\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const isExactIn = independentField === Field.INPUT;\n  const parsedAmount = tryParseAmount(typedValue, (_ref = isExactIn ? inputCurrency : outputCurrency) !== null && _ref !== void 0 ? _ref : undefined);\n  const currencies = {\n    [Field.INPUT]: inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,\n    [Field.OUTPUT]: outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined\n  };\n  return {\n    currencies,\n    parsedAmount\n  };\n}\n_s3(useDerivedSwapInfo, \"CL5Q0Gb9y6QWv3rojPwXYLpAGmU=\", false, function () {\n  return [useSwapState, useCurrency, useCurrency];\n});\nfunction parseCurrencyFromURLParameter(urlParam, chainId) {\n  var _cUSD$chainId$address;\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === 'CUSD') return cUSD[chainId].address;\n    if (valid === false) return cUSD[chainId].address;\n  }\n  return (_cUSD$chainId$address = cUSD[chainId].address) !== null && _cUSD$chainId$address !== void 0 ? _cUSD$chainId$address : '';\n}\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\nexport function queryParametersToSwapState(parsedQs, chainId) {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId);\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = '';\n    } else {\n      outputCurrency = '';\n    }\n  }\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  };\n}","map":{"version":3,"names":["parseUnits","cUSD","JSBI","Token","TokenAmount","useCallback","useDispatch","useSelector","useCurrency","isAddress","Field","selectCurrency","setRecipient","switchCurrencies","typeInput","useSwapState","_s","state","swap","useSwapActionHandlers","_s2","dispatch","onCurrencySelection","field","currency","currencyId","address","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","BigInt","error","console","debug","concat","useDerivedSwapInfo","_s3","_ref","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","isExactIn","parsedAmount","currencies","parseCurrencyFromURLParameter","urlParam","chainId","_cUSD$chainId$address","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField"],"sources":["/app/src/state/swap/hooks.ts"],"sourcesContent":["import { parseUnits } from '@ethersproject/units'\nimport { ChainId as UbeswapChainId, cUSD, JSBI, Token, TokenAmount } from '@ubeswap/sdk'\nimport { ParsedQs } from 'qs'\nimport { useCallback } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { useCurrency } from '../../hooks/Tokens'\nimport { isAddress } from '../../utils'\nimport { AppDispatch, AppState } from '../index'\nimport { Field, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions'\nimport { SwapState } from './reducer'\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>((state) => state.swap)\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Token) => void\n  onSwitchTokens: () => void\n  onUserInput: (field: Field, typedValue: string) => void\n  onChangeRecipient: (recipient: string | null) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Token) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency instanceof Token ? currency.address : '',\n        })\n      )\n    },\n    [dispatch]\n  )\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies())\n  }, [dispatch])\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  }\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount(value?: string, currency?: Token): TokenAmount | undefined {\n  if (!value || !currency) {\n    return undefined\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString()\n    if (typedValueParsed !== '0') {\n      return new TokenAmount(currency as Token, JSBI.BigInt(typedValueParsed))\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error)\n  }\n  // necessary for all paths to return a value\n  return new TokenAmount(currency as Token, JSBI.BigInt(0))\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Token }\n  parsedAmount: TokenAmount | undefined\n} {\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n  } = useSwapState()\n\n  const inputCurrency = useCurrency(inputCurrencyId)\n  const outputCurrency = useCurrency(outputCurrencyId)\n\n  const isExactIn: boolean = independentField === Field.INPUT\n  const parsedAmount = tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined)\n\n  const currencies: { [field in Field]?: Token } = {\n    [Field.INPUT]: inputCurrency ?? undefined,\n    [Field.OUTPUT]: outputCurrency ?? undefined,\n  }\n\n  return {\n    currencies,\n    parsedAmount,\n  }\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any, chainId: UbeswapChainId): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam)\n    if (valid) return valid\n    if (urlParam.toUpperCase() === 'CUSD') return cUSD[chainId].address\n    if (valid === false) return cUSD[chainId].address\n  }\n  return cUSD[chainId].address ?? ''\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : ''\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null\n  const address = isAddress(recipient)\n  if (address) return address\n  if (ENS_NAME_REGEX.test(recipient)) return recipient\n  if (ADDRESS_REGEX.test(recipient)) return recipient\n  return null\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs, chainId: UbeswapChainId): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency, chainId)\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency, chainId)\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = ''\n    } else {\n      outputCurrency = ''\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient)\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}