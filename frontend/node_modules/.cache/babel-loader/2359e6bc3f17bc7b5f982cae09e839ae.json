{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({\n      missingProperty: (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \"\"])), prop)\n    }, true);\n    cxt.error();\n  });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp(_ref, properties, missing) {\n  let {\n    gen,\n    data,\n    it: {\n      opts\n    }\n  } = _ref;\n  return (0, codegen_1.or)(...properties.map(prop => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" = \", \"\"])), missing, prop))));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n  cxt.setParams({\n    missingProperty: missing\n  }, true);\n  cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"Object.prototype.hasOwnProperty\"])))\n  });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n  return (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".call(\", \", \", \")\"])), hasPropFunc(gen), data, property);\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \"\", \" !== undefined\"])), data, (0, codegen_1.getProperty)(property));\n  return ownProperties ? (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), cond, isOwnProperty(gen, data, property)) : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"\", \" === undefined\"])), data, (0, codegen_1.getProperty)(property));\n  return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n  return schemaMap ? Object.keys(schemaMap).filter(p => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n  return allSchemaProperties(schemaMap).filter(p => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode(_ref2, func, context, passSchema) {\n  let {\n    schemaCode,\n    data,\n    it: {\n      gen,\n      topSchemaRef,\n      schemaPath,\n      errorPath\n    },\n    it\n  } = _ref2;\n  const dataAndSchema = passSchema ? (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \", \", \", \", \"\", \"\"])), schemaCode, data, topSchemaRef, schemaPath) : data;\n  const valCxt = [[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it.parentData], [names_1.default.parentDataProperty, it.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];\n  if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n  const args = (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \", \", \"\"])), dataAndSchema, gen.object(...valCxt));\n  return context !== codegen_1.nil ? (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".call(\", \", \", \")\"])), func, context, args) : (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), func, args);\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"new RegExp\"])));\nfunction usePattern(_ref3, pattern) {\n  let {\n    gen,\n    it: {\n      opts\n    }\n  } = _ref3;\n  const u = opts.unicodeRegExp ? \"u\" : \"\";\n  const {\n    regExp\n  } = opts.code;\n  const rx = regExp(pattern, u);\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \"(\", \", \", \")\"])), regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp), pattern, u)\n  });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true);\n    validateItems(() => gen.assign(validArr, false));\n    return validArr;\n  }\n  gen.var(valid, true);\n  validateItems(() => gen.break());\n  return valid;\n  function validateItems(notValid) {\n    const len = gen.const(\"len\", (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n    gen.forRange(\"i\", 0, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      gen.if((0, codegen_1.not)(valid), notValid);\n    });\n  }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n  const {\n    gen,\n    schema,\n    keyword,\n    it\n  } = cxt;\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n  const alwaysValid = schema.some(sch => (0, util_1.alwaysValidSchema)(it, sch));\n  if (alwaysValid && !it.opts.unevaluated) return;\n  const valid = gen.let(\"valid\", false);\n  const schValid = gen.name(\"_valid\");\n  gen.block(() => schema.forEach((_sch, i) => {\n    const schCxt = cxt.subschema({\n      keyword,\n      schemaProp: i,\n      compositeRule: true\n    }, schValid);\n    gen.assign(valid, (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \" || \", \"\"])), valid, schValid));\n    const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n    // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n    // or if all properties and items were evaluated (it.props === true && it.items === true)\n    if (!merged) gen.if((0, codegen_1.not)(valid));\n  }));\n  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;","map":null,"metadata":{},"sourceType":"script"}