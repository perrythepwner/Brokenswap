{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must have required property '\", \"'\"])), missingProperty);\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{missingProperty: \", \"}\"])), missingProperty);\n  }\n};\nconst def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      schemaCode,\n      data,\n      $data,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    if (!$data && schema.length === 0) return;\n    const useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties;\n      const {\n        definedProperties\n      } = cxt.it;\n      for (const requiredKey of schema) {\n        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n          const msg = \"required property \\\"\".concat(requiredKey, \"\\\" is not defined at \\\"\").concat(schemaPath, \"\\\" (strictRequired)\");\n          (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n        }\n      }\n    }\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        for (const prop of schema) {\n          (0, code_1.checkReportMissingProp)(cxt, prop);\n        }\n      }\n    }\n    function exitOnErrorMode() {\n      const missing = gen.let(\"missing\");\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n        cxt.ok(valid);\n      } else {\n        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n        (0, code_1.reportMissingProp)(cxt, missing);\n        gen.else();\n      }\n    }\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, prop => {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n      });\n    }\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, () => {\n        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n        gen.if((0, codegen_1.not)(valid), () => {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n};\nexports.default = def;","map":null,"metadata":{},"sourceType":"script"}