{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.digest64HashObjects = exports.digest2Bytes32 = exports.digest64 = exports.digest = exports.SHA256 = exports.hashObjectToByteArray = exports.byteArrayToHashObject = void 0;\nconst wasm_1 = require(\"./wasm\");\nconst hashObject_1 = require(\"./hashObject\");\nObject.defineProperty(exports, \"byteArrayToHashObject\", {\n  enumerable: true,\n  get: function get() {\n    return hashObject_1.byteArrayToHashObject;\n  }\n});\nObject.defineProperty(exports, \"hashObjectToByteArray\", {\n  enumerable: true,\n  get: function get() {\n    return hashObject_1.hashObjectToByteArray;\n  }\n});\nconst sha256_1 = __importDefault(require(\"./sha256\"));\nexports.SHA256 = sha256_1.default;\nconst ctx = wasm_1.newInstance();\nconst wasmInputValue = ctx.input.value;\nconst wasmOutputValue = ctx.output.value;\nconst inputUint8Array = new Uint8Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nconst outputUint8Array = new Uint8Array(ctx.memory.buffer, wasmOutputValue, 32);\nconst inputUint32Array = new Uint32Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nfunction digest(data) {\n  if (data.length === 64) {\n    return digest64(data);\n  }\n  if (data.length <= ctx.INPUT_LENGTH) {\n    inputUint8Array.set(data);\n    ctx.digest(data.length);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n  ctx.init();\n  update(data);\n  return final();\n}\nexports.digest = digest;\nfunction digest64(data) {\n  if (data.length === 64) {\n    inputUint8Array.set(data);\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n  throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest64 = digest64;\nfunction digest2Bytes32(bytes1, bytes2) {\n  if (bytes1.length === 32 && bytes2.length === 32) {\n    inputUint8Array.set(bytes1);\n    inputUint8Array.set(bytes2, 32);\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n  }\n  throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest2Bytes32 = digest2Bytes32;\n/**\n * Digest 2 objects, each has 8 properties from h0 to h7.\n * The performance is a little bit better than digest64 due to the use of Uint32Array\n * and the memory is a little bit better than digest64 due to no temporary Uint8Array.\n * @returns\n */\nfunction digest64HashObjects(obj1, obj2) {\n  // TODO: expect obj1 and obj2 as HashObject\n  inputUint32Array[0] = obj1.h0;\n  inputUint32Array[1] = obj1.h1;\n  inputUint32Array[2] = obj1.h2;\n  inputUint32Array[3] = obj1.h3;\n  inputUint32Array[4] = obj1.h4;\n  inputUint32Array[5] = obj1.h5;\n  inputUint32Array[6] = obj1.h6;\n  inputUint32Array[7] = obj1.h7;\n  inputUint32Array[8] = obj2.h0;\n  inputUint32Array[9] = obj2.h1;\n  inputUint32Array[10] = obj2.h2;\n  inputUint32Array[11] = obj2.h3;\n  inputUint32Array[12] = obj2.h4;\n  inputUint32Array[13] = obj2.h5;\n  inputUint32Array[14] = obj2.h6;\n  inputUint32Array[15] = obj2.h7;\n  ctx.digest64(wasmInputValue, wasmOutputValue);\n  // extracting numbers from Uint32Array causes more memory\n  return hashObject_1.byteArrayToHashObject(outputUint8Array);\n}\nexports.digest64HashObjects = digest64HashObjects;\nfunction update(data) {\n  const INPUT_LENGTH = ctx.INPUT_LENGTH;\n  if (data.length > INPUT_LENGTH) {\n    for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n      const sliced = data.slice(i, i + INPUT_LENGTH);\n      inputUint8Array.set(sliced);\n      ctx.update(wasmInputValue, sliced.length);\n    }\n  } else {\n    inputUint8Array.set(data);\n    ctx.update(wasmInputValue, data.length);\n  }\n}\nfunction final() {\n  ctx.final(wasmOutputValue);\n  const output = new Uint8Array(32);\n  output.set(outputUint8Array);\n  return output;\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.digest64HashObjects = exports.digest2Bytes32 = exports.digest64 = exports.digest = exports.SHA256 = exports.hashObjectToByteArray = exports.byteArrayToHashObject = void 0;\nconst wasm_1 = require(\"./wasm\");\nconst hashObject_1 = require(\"./hashObject\");\nObject.defineProperty(exports, \"byteArrayToHashObject\", { enumerable: true, get: function () { return hashObject_1.byteArrayToHashObject; } });\nObject.defineProperty(exports, \"hashObjectToByteArray\", { enumerable: true, get: function () { return hashObject_1.hashObjectToByteArray; } });\nconst sha256_1 = __importDefault(require(\"./sha256\"));\nexports.SHA256 = sha256_1.default;\nconst ctx = wasm_1.newInstance();\nconst wasmInputValue = ctx.input.value;\nconst wasmOutputValue = ctx.output.value;\nconst inputUint8Array = new Uint8Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nconst outputUint8Array = new Uint8Array(ctx.memory.buffer, wasmOutputValue, 32);\nconst inputUint32Array = new Uint32Array(ctx.memory.buffer, wasmInputValue, ctx.INPUT_LENGTH);\nfunction digest(data) {\n    if (data.length === 64) {\n        return digest64(data);\n    }\n    if (data.length <= ctx.INPUT_LENGTH) {\n        inputUint8Array.set(data);\n        ctx.digest(data.length);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    ctx.init();\n    update(data);\n    return final();\n}\nexports.digest = digest;\nfunction digest64(data) {\n    if (data.length === 64) {\n        inputUint8Array.set(data);\n        ctx.digest64(wasmInputValue, wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest64 = digest64;\nfunction digest2Bytes32(bytes1, bytes2) {\n    if (bytes1.length === 32 && bytes2.length === 32) {\n        inputUint8Array.set(bytes1);\n        inputUint8Array.set(bytes2, 32);\n        ctx.digest64(wasmInputValue, wasmOutputValue);\n        const output = new Uint8Array(32);\n        output.set(outputUint8Array);\n        return output;\n    }\n    throw new Error(\"InvalidLengthForDigest64\");\n}\nexports.digest2Bytes32 = digest2Bytes32;\n/**\n * Digest 2 objects, each has 8 properties from h0 to h7.\n * The performance is a little bit better than digest64 due to the use of Uint32Array\n * and the memory is a little bit better than digest64 due to no temporary Uint8Array.\n * @returns\n */\nfunction digest64HashObjects(obj1, obj2) {\n    // TODO: expect obj1 and obj2 as HashObject\n    inputUint32Array[0] = obj1.h0;\n    inputUint32Array[1] = obj1.h1;\n    inputUint32Array[2] = obj1.h2;\n    inputUint32Array[3] = obj1.h3;\n    inputUint32Array[4] = obj1.h4;\n    inputUint32Array[5] = obj1.h5;\n    inputUint32Array[6] = obj1.h6;\n    inputUint32Array[7] = obj1.h7;\n    inputUint32Array[8] = obj2.h0;\n    inputUint32Array[9] = obj2.h1;\n    inputUint32Array[10] = obj2.h2;\n    inputUint32Array[11] = obj2.h3;\n    inputUint32Array[12] = obj2.h4;\n    inputUint32Array[13] = obj2.h5;\n    inputUint32Array[14] = obj2.h6;\n    inputUint32Array[15] = obj2.h7;\n    ctx.digest64(wasmInputValue, wasmOutputValue);\n    // extracting numbers from Uint32Array causes more memory\n    return hashObject_1.byteArrayToHashObject(outputUint8Array);\n}\nexports.digest64HashObjects = digest64HashObjects;\nfunction update(data) {\n    const INPUT_LENGTH = ctx.INPUT_LENGTH;\n    if (data.length > INPUT_LENGTH) {\n        for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n            const sliced = data.slice(i, i + INPUT_LENGTH);\n            inputUint8Array.set(sliced);\n            ctx.update(wasmInputValue, sliced.length);\n        }\n    }\n    else {\n        inputUint8Array.set(data);\n        ctx.update(wasmInputValue, data.length);\n    }\n}\nfunction final() {\n    ctx.final(wasmOutputValue);\n    const output = new Uint8Array(32);\n    output.set(outputUint8Array);\n    return output;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}