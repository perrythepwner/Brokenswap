{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;\nconst node_1 = require(\"../node\");\nconst gindex_1 = require(\"../gindex\");\nexports.ERR_INVALID_NAV = \"Invalid tree navigation\";\nfunction createSingleProof(rootNode, index) {\n  const witnesses = [];\n  let node = rootNode;\n  for (const i of gindex_1.gindexIterator(index)) {\n    if (i) {\n      if (node.isLeaf()) throw new Error(exports.ERR_INVALID_NAV);\n      witnesses.push(node.left.root);\n      node = node.right;\n    } else {\n      if (node.isLeaf()) throw new Error(exports.ERR_INVALID_NAV);\n      witnesses.push(node.right.root);\n      node = node.left;\n    }\n  }\n  return [node.root, witnesses.reverse()];\n}\nexports.createSingleProof = createSingleProof;\nfunction createNodeFromSingleProof(gindex, leaf, witnesses) {\n  let node = node_1.LeafNode.fromRoot(leaf);\n  const w = witnesses.slice().reverse();\n  while (gindex > 1) {\n    const sibling = node_1.LeafNode.fromRoot(w.pop());\n    if (gindex % BigInt(2) === BigInt(0)) {\n      node = new node_1.BranchNode(node, sibling);\n    } else {\n      node = new node_1.BranchNode(sibling, node);\n    }\n    gindex = gindex / BigInt(2);\n  }\n  return node;\n}\nexports.createNodeFromSingleProof = createNodeFromSingleProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","createNodeFromSingleProof","createSingleProof","ERR_INVALID_NAV","node_1","require","gindex_1","rootNode","index","witnesses","node","i","gindexIterator","isLeaf","Error","push","left","root","right","reverse","gindex","leaf","LeafNode","fromRoot","w","slice","sibling","pop","BigInt","BranchNode"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;\nconst node_1 = require(\"../node\");\nconst gindex_1 = require(\"../gindex\");\nexports.ERR_INVALID_NAV = \"Invalid tree navigation\";\nfunction createSingleProof(rootNode, index) {\n    const witnesses = [];\n    let node = rootNode;\n    for (const i of gindex_1.gindexIterator(index)) {\n        if (i) {\n            if (node.isLeaf())\n                throw new Error(exports.ERR_INVALID_NAV);\n            witnesses.push(node.left.root);\n            node = node.right;\n        }\n        else {\n            if (node.isLeaf())\n                throw new Error(exports.ERR_INVALID_NAV);\n            witnesses.push(node.right.root);\n            node = node.left;\n        }\n    }\n    return [node.root, witnesses.reverse()];\n}\nexports.createSingleProof = createSingleProof;\nfunction createNodeFromSingleProof(gindex, leaf, witnesses) {\n    let node = node_1.LeafNode.fromRoot(leaf);\n    const w = witnesses.slice().reverse();\n    while (gindex > 1) {\n        const sibling = node_1.LeafNode.fromRoot(w.pop());\n        if (gindex % BigInt(2) === BigInt(0)) {\n            node = new node_1.BranchNode(node, sibling);\n        }\n        else {\n            node = new node_1.BranchNode(sibling, node);\n        }\n        gindex = gindex / BigInt(2);\n    }\n    return node;\n}\nexports.createNodeFromSingleProof = createNodeFromSingleProof;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,yBAAyB,GAAGF,OAAO,CAACG,iBAAiB,GAAGH,OAAO,CAACI,eAAe,GAAG,KAAK,CAAC;AAChG,MAAMC,MAAM,GAAGC,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMC,QAAQ,GAAGD,OAAO,CAAC,WAAW,CAAC;AACrCN,OAAO,CAACI,eAAe,GAAG,yBAAyB;AACnD,SAASD,iBAAiBA,CAACK,QAAQ,EAAEC,KAAK,EAAE;EACxC,MAAMC,SAAS,GAAG,EAAE;EACpB,IAAIC,IAAI,GAAGH,QAAQ;EACnB,KAAK,MAAMI,CAAC,IAAIL,QAAQ,CAACM,cAAc,CAACJ,KAAK,CAAC,EAAE;IAC5C,IAAIG,CAAC,EAAE;MACH,IAAID,IAAI,CAACG,MAAM,CAAC,CAAC,EACb,MAAM,IAAIC,KAAK,CAACf,OAAO,CAACI,eAAe,CAAC;MAC5CM,SAAS,CAACM,IAAI,CAACL,IAAI,CAACM,IAAI,CAACC,IAAI,CAAC;MAC9BP,IAAI,GAAGA,IAAI,CAACQ,KAAK;IACrB,CAAC,MACI;MACD,IAAIR,IAAI,CAACG,MAAM,CAAC,CAAC,EACb,MAAM,IAAIC,KAAK,CAACf,OAAO,CAACI,eAAe,CAAC;MAC5CM,SAAS,CAACM,IAAI,CAACL,IAAI,CAACQ,KAAK,CAACD,IAAI,CAAC;MAC/BP,IAAI,GAAGA,IAAI,CAACM,IAAI;IACpB;EACJ;EACA,OAAO,CAACN,IAAI,CAACO,IAAI,EAAER,SAAS,CAACU,OAAO,CAAC,CAAC,CAAC;AAC3C;AACApB,OAAO,CAACG,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,yBAAyBA,CAACmB,MAAM,EAAEC,IAAI,EAAEZ,SAAS,EAAE;EACxD,IAAIC,IAAI,GAAGN,MAAM,CAACkB,QAAQ,CAACC,QAAQ,CAACF,IAAI,CAAC;EACzC,MAAMG,CAAC,GAAGf,SAAS,CAACgB,KAAK,CAAC,CAAC,CAACN,OAAO,CAAC,CAAC;EACrC,OAAOC,MAAM,GAAG,CAAC,EAAE;IACf,MAAMM,OAAO,GAAGtB,MAAM,CAACkB,QAAQ,CAACC,QAAQ,CAACC,CAAC,CAACG,GAAG,CAAC,CAAC,CAAC;IACjD,IAAIP,MAAM,GAAGQ,MAAM,CAAC,CAAC,CAAC,KAAKA,MAAM,CAAC,CAAC,CAAC,EAAE;MAClClB,IAAI,GAAG,IAAIN,MAAM,CAACyB,UAAU,CAACnB,IAAI,EAAEgB,OAAO,CAAC;IAC/C,CAAC,MACI;MACDhB,IAAI,GAAG,IAAIN,MAAM,CAACyB,UAAU,CAACH,OAAO,EAAEhB,IAAI,CAAC;IAC/C;IACAU,MAAM,GAAGA,MAAM,GAAGQ,MAAM,CAAC,CAAC,CAAC;EAC/B;EACA,OAAOlB,IAAI;AACf;AACAX,OAAO,CAACE,yBAAyB,GAAGA,yBAAyB"},"metadata":{},"sourceType":"script"}