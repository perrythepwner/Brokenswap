{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;\nconst node_1 = require(\"../node\");\nconst util_1 = require(\"./util\");\n/**\n * Compute offsets and leaves of a tree-offset proof\n *\n * Recursive function\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n * @param node current node in the tree\n * @param gindex current generalized index in the tree\n * @param proofGindices generalized indices to left include in the proof - must be sorted in-order according to the tree\n */\nfunction nodeToTreeOffsetProof(node, gindex, proofGindices) {\n  if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {\n    // there are no proof indices left OR the current subtree contains no remaining proof indices\n    return [[], []];\n  } else if (gindex === proofGindices[0]) {\n    // the current node is at the next proof index\n    proofGindices.shift();\n    return [[], [node.root]];\n  } else {\n    // recursively compute offsets, leaves for the left and right subtree\n    const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + \"0\", proofGindices);\n    const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + \"1\", proofGindices);\n    // the offset prepended to the list is # of leaves in the left subtree\n    const pivot = leftLeaves.length;\n    return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];\n  }\n}\nexports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;\n/**\n * Recreate a `Node` given offsets and leaves of a tree-offset proof\n *\n * Recursive definition\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n */\nfunction treeOffsetProofToNode(offsets, leaves) {\n  if (!leaves.length) {\n    throw new Error(\"Proof must contain gt 0 leaves\");\n  } else if (leaves.length === 1) {\n    return node_1.LeafNode.fromRoot(leaves[0]);\n  } else {\n    // the offset popped from the list is the # of leaves in the left subtree\n    const pivot = offsets[0];\n    return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));\n  }\n}\nexports.treeOffsetProofToNode = treeOffsetProofToNode;\n/**\n * Create a tree-offset proof\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices to include in the proof\n */\nfunction createTreeOffsetProof(rootNode, gindices) {\n  return nodeToTreeOffsetProof(rootNode, \"1\", util_1.computeMultiProofBitstrings(gindices.map(g => g.toString(2))));\n}\nexports.createTreeOffsetProof = createTreeOffsetProof;\n/**\n * Recreate a `Node` given a tree-offset proof\n *\n * @param offsets offsets of a tree-offset proof\n * @param leaves leaves of a tree-offset proof\n */\nfunction createNodeFromTreeOffsetProof(offsets, leaves) {\n  // TODO validation\n  return treeOffsetProofToNode(offsets, leaves);\n}\nexports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;\nfunction computeTreeOffsetProofSerializedLength(offsets, leaves) {\n  // add 1 for # of leaves\n  return (offsets.length + 1) * 2 + leaves.length * 32;\n}\nexports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength;\n// Serialized tree offset proof structure:\n// # of leaves - 2 bytes\n// offsets - 2 bytes each\n// leaves - 32 bytes each\nfunction serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {\n  const writer = new DataView(output.buffer, output.byteOffset, output.byteLength);\n  // set # of leaves\n  writer.setUint16(byteOffset, leaves.length, true);\n  // set offsets\n  const offsetsStartIndex = byteOffset + 2;\n  for (let i = 0; i < offsets.length; i++) {\n    writer.setUint16(i * 2 + offsetsStartIndex, offsets[i], true);\n  }\n  // set leaves\n  const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n  for (let i = 0; i < leaves.length; i++) {\n    output.set(leaves[i], i * 32 + leavesStartIndex);\n  }\n}\nexports.serializeTreeOffsetProof = serializeTreeOffsetProof;\nfunction deserializeTreeOffsetProof(data, byteOffset) {\n  const reader = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  // get # of leaves\n  const leafCount = reader.getUint16(byteOffset, true);\n  if (data.length < (leafCount - 1) * 2 + leafCount * 32) {\n    throw new Error(\"Unable to deserialize tree offset proof: not enough bytes\");\n  }\n  // get offsets\n  const offsetsStartIndex = byteOffset + 2;\n  const offsets = Array.from({\n    length: leafCount - 1\n  }, (_, i) => reader.getUint16(i * 2 + offsetsStartIndex, true));\n  // get leaves\n  const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n  const leaves = Array.from({\n    length: leafCount\n  }, (_, i) => data.subarray(i * 32 + leavesStartIndex, (i + 1) * 32 + leavesStartIndex));\n  return [offsets, leaves];\n}\nexports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;","map":null,"metadata":{},"sourceType":"script"}