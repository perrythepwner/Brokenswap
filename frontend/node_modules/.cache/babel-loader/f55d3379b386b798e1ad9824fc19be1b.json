{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;\n/** Globally cache this information. @see getUint8ByteToBitBooleanArray */\nconst uint8ByteToBitBooleanArrays = new Array(256);\n/**\n * BitArray may be represented as an array of bits or compressed into an array of bytes.\n *\n * **Array of bits**:\n * Require 8.87 bytes per bit, so for 512 bits = 4500 bytes.\n * Are 'faster' to iterate with native tooling but are as fast as array of bytes with precomputed caches.\n *\n * **Array of bytes**:\n * Require an average cost of Uint8Array in JS = 220 bytes for 32 bytes, so for 512 bits = 220 bytes.\n * With precomputed boolean arrays per bytes value are as fast to iterate as an array of bits above.\n *\n * This BitArray implementation will represent data as a Uint8Array since it's very cheap to deserialize and can be as\n * fast to iterate as a native array of booleans, precomputing boolean arrays (total memory cost of 16000 bytes).\n */\nclass BitArray {\n  constructor( /** Underlying BitArray Uint8Array data */\n  uint8Array, /** Immutable bitLen of this BitArray */\n  bitLen) {\n    this.uint8Array = uint8Array;\n    this.bitLen = bitLen;\n    if (uint8Array.length !== Math.ceil(bitLen / 8)) {\n      throw Error(\"BitArray uint8Array length does not match bitLen\");\n    }\n  }\n  /** Returns a zero'ed BitArray of `bitLen` */\n  static fromBitLen(bitLen) {\n    return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);\n  }\n  /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */\n  static fromSingleBit(bitLen, bitIndex) {\n    const bitArray = BitArray.fromBitLen(bitLen);\n    bitArray.set(bitIndex, true);\n    return bitArray;\n  }\n  /** Returns a BitArray from an array of booleans representation */\n  static fromBoolArray(bitBoolArr) {\n    const bitArray = BitArray.fromBitLen(bitBoolArr.length);\n    for (let i = 0; i < bitBoolArr.length; i++) {\n      if (bitBoolArr[i] === true) {\n        bitArray.set(i, true);\n      }\n    }\n    return bitArray;\n  }\n  clone() {\n    // TODO: Benchmark if Uint8Array.slice(0) is the fastest way to copy data here\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);\n  }\n  /**\n   * Get bit value at index `bitIndex`\n   */\n  get(bitIndex) {\n    const byteIdx = Math.floor(bitIndex / 8);\n    const bitInBit = bitIndex % 8;\n    const mask = 1 << bitInBit;\n    return (this.uint8Array[byteIdx] & mask) === mask;\n  }\n  /**\n   * Set bit value at index `bitIndex`\n   */\n  set(bitIndex, bit) {\n    if (bitIndex >= this.bitLen) {\n      throw Error(\"BitArray set bitIndex \".concat(bitIndex, \" beyond bitLen \").concat(this.bitLen));\n    }\n    const byteIdx = Math.floor(bitIndex / 8);\n    const bitInBit = bitIndex % 8;\n    const mask = 1 << bitInBit;\n    let byte = this.uint8Array[byteIdx];\n    if (bit) {\n      // For bit in byte, 1,0 OR 1 = 1\n      // byte 100110\n      // mask 010000\n      // res  110110\n      byte |= mask;\n      this.uint8Array[byteIdx] = byte;\n    } else {\n      // For bit in byte, 1,0 OR 1 = 0\n      if ((byte & mask) === mask) {\n        // byte 110110\n        // mask 010000\n        // res  100110\n        byte ^= mask;\n        this.uint8Array[byteIdx] = byte;\n      } else {\n        // Ok, bit is already 0\n      }\n    }\n  }\n  /** Merge two BitArray bitfields with OR. Must have the same bitLen */\n  mergeOrWith(bitArray2) {\n    if (bitArray2.bitLen !== this.bitLen) {\n      throw Error(\"Must merge BitArrays of same bitLen\");\n    }\n    // Merge bitFields\n    for (let i = 0; i < this.uint8Array.length; i++) {\n      this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];\n    }\n  }\n  /**\n   * Returns an array with the indexes which have a bit set to true\n   */\n  intersectValues(values) {\n    const yes = [];\n    if (values.length !== this.bitLen) {\n      throw Error(\"Must not intersect values of length \".concat(values.length, \" != bitLen \").concat(this.bitLen));\n    }\n    const fullByteLen = Math.floor(this.bitLen / 8);\n    const remainderBits = this.bitLen % 8;\n    // Iterate over each byte of bits\n    const bytes = this.uint8Array;\n    for (let iByte = 0; iByte < fullByteLen; iByte++) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit]) {\n          yes.push(values[iByte * 8 + iBit]);\n        }\n      }\n    }\n    if (remainderBits > 0) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < remainderBits; iBit++) {\n        if (booleansInByte[iBit]) {\n          yes.push(values[fullByteLen * 8 + iBit]);\n        }\n      }\n    }\n    return yes;\n  }\n  /**\n   * Returns the positions of all bits that are set to true\n   */\n  getTrueBitIndexes() {\n    const indexes = [];\n    // Iterate over each byte of bits\n    const bytes = this.uint8Array;\n    for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit]) {\n          indexes.push(iByte * 8 + iBit);\n        }\n      }\n    }\n    return indexes;\n  }\n  /**\n   * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.\n   * @returns\n   *  - number: if there's a single bit set, the number it the single bit set position\n   *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET\n   * @throws\n   *  - ERROR_MORE_THAN_ONE_BIT_SET\n   *  - ERROR_NO_BIT_SET\n   */\n  getSingleTrueBit() {\n    let index = null;\n    const bytes = this.uint8Array;\n    // Iterate over each byte of bits\n    for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n      // If it's exactly zero, there won't be any indexes, continue early\n      if (bytes[iByte] === 0) {\n        continue;\n      }\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit] === true) {\n          if (index !== null) {\n            // ERROR_MORE_THAN_ONE_BIT_SET\n            return null;\n          }\n          index = iByte * 8 + iBit;\n        }\n      }\n    }\n    if (index === null) {\n      // ERROR_NO_BIT_SET\n      return null;\n    } else {\n      return index;\n    }\n  }\n  toBoolArray() {\n    const bitBoolArr = new Array(this.bitLen);\n    for (let i = 0; i < this.bitLen; i++) {\n      bitBoolArr[i] = this.get(i);\n    }\n    return bitBoolArr;\n  }\n}\nexports.BitArray = BitArray;\n/**\n * Given a byte (0 -> 255), return a Array of boolean with length = 8, big endian.\n * Ex: 1 => [true false false false false false false false]\n *     5 => [true false true false false fase false false]\n */\nfunction getUint8ByteToBitBooleanArray(byte) {\n  if (!uint8ByteToBitBooleanArrays[byte]) {\n    uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);\n  }\n  return uint8ByteToBitBooleanArrays[byte];\n}\nexports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;\n/** @see getUint8ByteToBitBooleanArray */\nfunction computeUint8ByteToBitBooleanArray(byte) {\n  // this returns little endian\n  const binaryStr = byte.toString(2);\n  const binaryLength = binaryStr.length;\n  const bits = new Array(8);\n  for (let i = 0; i < 8; i++) {\n    bits[i] = i < binaryLength ?\n    //\n    binaryStr[binaryLength - i - 1] === \"1\" : false;\n  }\n  return bits;\n}","map":null,"metadata":{},"sourceType":"script"}