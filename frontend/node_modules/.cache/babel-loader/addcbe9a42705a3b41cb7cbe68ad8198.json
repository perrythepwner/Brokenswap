{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo,useConnectedSigner}from'@celo/react-celo';import{ChainId}from'@ubeswap/sdk';import{useCallback}from'react';import{useTransactionAdder}from'state/transactions/hooks';import{calculateGasMargin}from'utils';const estimateGas=/*#__PURE__*/function(){var _ref=_asyncToGenerator(function*(call){const{contract,methodName,args,value}=call;const fullArgs=value?[...args,{value}]:args;try{return yield contract.estimateGas[methodName](...fullArgs);}catch(gasError){console.debug('Gas estimate failed, trying eth_call to extract error',call);try{const result=yield contract.callStatic[methodName](...fullArgs);console.debug('Unexpected successful call after failed estimate gas',call,gasError,result);throw new Error('Unexpected issue with estimating the gas. Please try again.');}catch(callError){console.debug('Call threw error',call,callError);let errorMessage;switch(callError.reason){case'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':case'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':errorMessage='This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';break;default:errorMessage=\"The transaction cannot succeed due to error: \".concat(callError.reason,\". This is probably an issue with one of the tokens you are swapping.\");}throw new Error(errorMessage);}}});return function estimateGas(_x){return _ref.apply(this,arguments);};}();/**\n * Allows performing transactions.\n * @returns\n */export const useDoTransaction=()=>{const addTransaction=useTransactionAdder();const{network}=useCelo();const connectedSigner=useConnectedSigner();const chainId=network.chainId;return useCallback(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(function*(contractDisconnected,methodName,args){var _args$overrides;if(chainId===ChainId.BAKLAVA){throw new Error('baklava not supported');}if(!connectedSigner){throw new Error('no signer');}const contract=contractDisconnected.connect(connectedSigner);const call={contract,methodName,args:args.args,value:(_args$overrides=args.overrides)===null||_args$overrides===void 0?void 0:_args$overrides.value};const gasEstimate=yield estimateGas(call);try{let response;if(args.raw){response=yield connectedSigner.sendTransaction(args.raw);}else{response=yield contract[methodName](...args.args,_objectSpread({gasLimit:calculateGasMargin(gasEstimate)},args.overrides));}addTransaction(response,{summary:args.summary,approval:args.approval,claim:args.claim});return response;}catch(error){// if the user rejected the tx, pass this along\nif((error===null||error===void 0?void 0:error.code)===4001){throw new Error('Transaction rejected.');}else{// otherwise, the error was unexpected and we need to convey that\nconsole.error(\"Transaction failed\",error,methodName,args,call.value);throw new Error(\"Transaction failed: \".concat(error.message));}}});return function(_x2,_x3,_x4){return _ref2.apply(this,arguments);};}(),[addTransaction,chainId,connectedSigner]);};","map":{"version":3,"names":["useCelo","useConnectedSigner","ChainId","useCallback","useTransactionAdder","calculateGasMargin","estimateGas","_ref","_asyncToGenerator","call","contract","methodName","args","value","fullArgs","gasError","console","debug","result","callStatic","Error","callError","errorMessage","reason","concat","_x","apply","arguments","useDoTransaction","addTransaction","network","connectedSigner","chainId","_ref2","contractDisconnected","_args$overrides","BAKLAVA","connect","overrides","gasEstimate","response","raw","sendTransaction","_objectSpread","gasLimit","summary","approval","claim","error","code","message","_x2","_x3","_x4"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/index.ts"],"sourcesContent":["import { useCelo, useConnectedSigner } from '@celo/react-celo'\nimport { JsonRpcSigner, TransactionRequest } from '@ethersproject/providers'\nimport { ChainId, Trade } from '@ubeswap/sdk'\nimport { BigNumber, BigNumberish, CallOverrides, Contract, ContractTransaction, PayableOverrides } from 'ethers'\nimport { useCallback } from 'react'\nimport { useTransactionAdder } from 'state/transactions/hooks'\nimport { calculateGasMargin } from 'utils'\n\ntype Head<T extends any[]> = Required<T> extends [...infer H, any] ? H : never\ntype Last<T extends Array<unknown>> = Required<T> extends [...unknown[], infer L] ? L : never\ntype MethodArgs<C extends Contract, M extends keyof C['estimateGas']> = Head<Parameters<C['estimateGas'][M]>>\n\nexport type DoTransactionFn = <\n  C extends Contract,\n  M extends string & keyof C['estimateGas'],\n  O extends Last<Parameters<C['estimateGas'][M]>> & (PayableOverrides | CallOverrides)\n>(\n  contract: C,\n  methodName: M,\n  args: {\n    args: MethodArgs<C, M>\n    raw?: TransactionRequest\n    overrides?: O\n    summary?: string\n    approval?: { tokenAddress: string; spender: string }\n    claim?: { recipient: string }\n  }\n) => Promise<ContractTransaction>\n\nexport interface TradeExecutor<T extends Trade> {\n  (args: {\n    trade: T\n    signer: JsonRpcSigner\n    chainId: ChainId.MAINNET | ChainId.ALFAJORES\n    doTransaction: DoTransactionFn\n    recipient?: string | null\n    withRecipient?: string\n  }): Promise<{\n    hash: string\n  }>\n}\n\nexport interface CancelLimitOrderExecutor {\n  (args: {\n    orderHash: string\n    signer: JsonRpcSigner\n    chainId: ChainId.MAINNET | ChainId.ALFAJORES\n    doTransaction: DoTransactionFn\n  }): Promise<{\n    hash: string\n  }>\n}\n\ntype ContractCall = {\n  contract: Contract\n  methodName: string\n  args: unknown[]\n  value?: BigNumberish | Promise<BigNumberish>\n}\n\nconst estimateGas = async (call: ContractCall): Promise<BigNumber> => {\n  const { contract, methodName, args, value } = call\n  const fullArgs = value ? [...args, { value }] : args\n  try {\n    return await contract.estimateGas[methodName](...fullArgs)\n  } catch (gasError) {\n    console.debug('Gas estimate failed, trying eth_call to extract error', call)\n    try {\n      const result = await contract.callStatic[methodName](...fullArgs)\n      console.debug('Unexpected successful call after failed estimate gas', call, gasError, result)\n      throw new Error('Unexpected issue with estimating the gas. Please try again.')\n    } catch (callError: any) {\n      console.debug('Call threw error', call, callError)\n      let errorMessage: string\n      switch (callError.reason) {\n        case 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':\n        case 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':\n          errorMessage =\n            'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.'\n          break\n        default:\n          errorMessage = `The transaction cannot succeed due to error: ${callError.reason}. This is probably an issue with one of the tokens you are swapping.`\n      }\n      throw new Error(errorMessage)\n    }\n  }\n}\n\n/**\n * Allows performing transactions.\n * @returns\n */\nexport const useDoTransaction = (): DoTransactionFn => {\n  const addTransaction = useTransactionAdder()\n  const { network } = useCelo()\n  const connectedSigner = useConnectedSigner()\n  const chainId = network.chainId as unknown as ChainId\n  return useCallback(\n    async (contractDisconnected, methodName, args): Promise<ContractTransaction> => {\n      if (chainId === ChainId.BAKLAVA) {\n        throw new Error('baklava not supported')\n      }\n      if (!connectedSigner) {\n        throw new Error('no signer')\n      }\n      const contract = contractDisconnected.connect(connectedSigner)\n      const call = { contract, methodName, args: args.args, value: args.overrides?.value }\n      const gasEstimate = await estimateGas(call)\n\n      try {\n        let response: ContractTransaction\n        if (args.raw) {\n          response = await connectedSigner.sendTransaction(args.raw)\n        } else {\n          response = await contract[methodName](...args.args, {\n            gasLimit: calculateGasMargin(gasEstimate),\n            ...args.overrides,\n          })\n        }\n        addTransaction(response, {\n          summary: args.summary,\n          approval: args.approval,\n          claim: args.claim,\n        })\n        return response\n      } catch (error: any) {\n        // if the user rejected the tx, pass this along\n        if (error?.code === 4001) {\n          throw new Error('Transaction rejected.')\n        } else {\n          // otherwise, the error was unexpected and we need to convey that\n          console.error(`Transaction failed`, error, methodName, args, call.value)\n          throw new Error(`Transaction failed: ${error.message}`)\n        }\n      }\n    },\n    [addTransaction, chainId, connectedSigner]\n  )\n}\n"],"mappings":"6VAAA,OAASA,OAAO,CAAEC,kBAAkB,KAAQ,kBAAkB,CAE9D,OAASC,OAAO,KAAe,cAAc,CAE7C,OAASC,WAAW,KAAQ,OAAO,CACnC,OAASC,mBAAmB,KAAQ,0BAA0B,CAC9D,OAASC,kBAAkB,KAAQ,OAAO,CAsD1C,KAAM,CAAAC,WAAW,6BAAAC,IAAA,CAAAC,iBAAA,CAAG,UAAOC,IAAkB,CAAyB,CACpE,KAAM,CAAEC,QAAQ,CAAEC,UAAU,CAAEC,IAAI,CAAEC,KAAM,CAAC,CAAGJ,IAAI,CAClD,KAAM,CAAAK,QAAQ,CAAGD,KAAK,CAAG,CAAC,GAAGD,IAAI,CAAE,CAAEC,KAAM,CAAC,CAAC,CAAGD,IAAI,CACpD,GAAI,CACF,YAAa,CAAAF,QAAQ,CAACJ,WAAW,CAACK,UAAU,CAAC,CAAC,GAAGG,QAAQ,CAAC,CAC5D,CAAE,MAAOC,QAAQ,CAAE,CACjBC,OAAO,CAACC,KAAK,CAAC,uDAAuD,CAAER,IAAI,CAAC,CAC5E,GAAI,CACF,KAAM,CAAAS,MAAM,MAAS,CAAAR,QAAQ,CAACS,UAAU,CAACR,UAAU,CAAC,CAAC,GAAGG,QAAQ,CAAC,CACjEE,OAAO,CAACC,KAAK,CAAC,sDAAsD,CAAER,IAAI,CAAEM,QAAQ,CAAEG,MAAM,CAAC,CAC7F,KAAM,IAAI,CAAAE,KAAK,CAAC,6DAA6D,CAAC,CAChF,CAAE,MAAOC,SAAc,CAAE,CACvBL,OAAO,CAACC,KAAK,CAAC,kBAAkB,CAAER,IAAI,CAAEY,SAAS,CAAC,CAClD,GAAI,CAAAC,YAAoB,CACxB,OAAQD,SAAS,CAACE,MAAM,EACtB,IAAK,6CAA6C,CAClD,IAAK,yCAAyC,CAC5CD,YAAY,CACV,4HAA4H,CAC9H,MACF,QACEA,YAAY,iDAAAE,MAAA,CAAmDH,SAAS,CAACE,MAAM,wEAAsE,CACzJ,CACA,KAAM,IAAI,CAAAH,KAAK,CAACE,YAAY,CAAC,CAC/B,CACF,CACF,CAAC,iBA1BK,CAAAhB,WAAWA,CAAAmB,EAAA,SAAAlB,IAAA,CAAAmB,KAAA,MAAAC,SAAA,OA0BhB,CAED;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAC,gBAAgB,CAAGA,CAAA,GAAuB,CACrD,KAAM,CAAAC,cAAc,CAAGzB,mBAAmB,CAAC,CAAC,CAC5C,KAAM,CAAE0B,OAAQ,CAAC,CAAG9B,OAAO,CAAC,CAAC,CAC7B,KAAM,CAAA+B,eAAe,CAAG9B,kBAAkB,CAAC,CAAC,CAC5C,KAAM,CAAA+B,OAAO,CAAGF,OAAO,CAACE,OAA6B,CACrD,MAAO,CAAA7B,WAAW,6BAAA8B,KAAA,CAAAzB,iBAAA,CAChB,UAAO0B,oBAAoB,CAAEvB,UAAU,CAAEC,IAAI,CAAmC,KAAAuB,eAAA,CAC9E,GAAIH,OAAO,GAAK9B,OAAO,CAACkC,OAAO,CAAE,CAC/B,KAAM,IAAI,CAAAhB,KAAK,CAAC,uBAAuB,CAAC,CAC1C,CACA,GAAI,CAACW,eAAe,CAAE,CACpB,KAAM,IAAI,CAAAX,KAAK,CAAC,WAAW,CAAC,CAC9B,CACA,KAAM,CAAAV,QAAQ,CAAGwB,oBAAoB,CAACG,OAAO,CAACN,eAAe,CAAC,CAC9D,KAAM,CAAAtB,IAAI,CAAG,CAAEC,QAAQ,CAAEC,UAAU,CAAEC,IAAI,CAAEA,IAAI,CAACA,IAAI,CAAEC,KAAK,EAAAsB,eAAA,CAAEvB,IAAI,CAAC0B,SAAS,UAAAH,eAAA,iBAAdA,eAAA,CAAgBtB,KAAM,CAAC,CACpF,KAAM,CAAA0B,WAAW,MAAS,CAAAjC,WAAW,CAACG,IAAI,CAAC,CAE3C,GAAI,CACF,GAAI,CAAA+B,QAA6B,CACjC,GAAI5B,IAAI,CAAC6B,GAAG,CAAE,CACZD,QAAQ,MAAS,CAAAT,eAAe,CAACW,eAAe,CAAC9B,IAAI,CAAC6B,GAAG,CAAC,CAC5D,CAAC,IAAM,CACLD,QAAQ,MAAS,CAAA9B,QAAQ,CAACC,UAAU,CAAC,CAAC,GAAGC,IAAI,CAACA,IAAI,CAAA+B,aAAA,EAChDC,QAAQ,CAAEvC,kBAAkB,CAACkC,WAAW,CAAC,EACtC3B,IAAI,CAAC0B,SAAS,CAClB,CAAC,CACJ,CACAT,cAAc,CAACW,QAAQ,CAAE,CACvBK,OAAO,CAAEjC,IAAI,CAACiC,OAAO,CACrBC,QAAQ,CAAElC,IAAI,CAACkC,QAAQ,CACvBC,KAAK,CAAEnC,IAAI,CAACmC,KACd,CAAC,CAAC,CACF,MAAO,CAAAP,QAAQ,CACjB,CAAE,MAAOQ,KAAU,CAAE,CACnB;AACA,GAAI,CAAAA,KAAK,SAALA,KAAK,iBAALA,KAAK,CAAEC,IAAI,IAAK,IAAI,CAAE,CACxB,KAAM,IAAI,CAAA7B,KAAK,CAAC,uBAAuB,CAAC,CAC1C,CAAC,IAAM,CACL;AACAJ,OAAO,CAACgC,KAAK,sBAAuBA,KAAK,CAAErC,UAAU,CAAEC,IAAI,CAAEH,IAAI,CAACI,KAAK,CAAC,CACxE,KAAM,IAAI,CAAAO,KAAK,wBAAAI,MAAA,CAAwBwB,KAAK,CAACE,OAAO,CAAE,CAAC,CACzD,CACF,CACF,CAAC,kBAAAC,GAAA,CAAAC,GAAA,CAAAC,GAAA,SAAApB,KAAA,CAAAP,KAAA,MAAAC,SAAA,QACD,CAACE,cAAc,CAAEG,OAAO,CAAED,eAAe,CAC3C,CAAC,CACH,CAAC"},"metadata":{},"sourceType":"module"}