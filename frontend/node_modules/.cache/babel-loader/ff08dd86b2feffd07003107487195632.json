{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitArrayTreeViewDU = void 0;\nconst abstract_1 = require(\"./abstract\");\n/**\n * Thin wrapper around BitArray to upstream changes after `this.commit()`\n */\nclass BitArrayTreeViewDU extends abstract_1.TreeViewDU {\n  constructor(type, _rootNode) {\n    super();\n    this.type = type;\n    this._rootNode = _rootNode;\n    /** Cached BitArray instance computed only on demand */\n    this._bitArray = null;\n  }\n  get node() {\n    return this._rootNode;\n  }\n  get cache() {\n    return;\n  }\n  commit() {\n    if (this._bitArray !== null) {\n      this._rootNode = this.type.value_toTree(this._bitArray);\n    }\n  }\n  // Wrapped API from BitArray\n  /** @see BitArray.uint8Array */\n  get uint8Array() {\n    return this.bitArray.uint8Array;\n  }\n  /** @see BitArray.bitLen */\n  get bitLen() {\n    return this.bitArray.bitLen;\n  }\n  /** @see BitArray.get */\n  get(bitIndex) {\n    return this.bitArray.get(bitIndex);\n  }\n  /** @see BitArray.set */\n  set(bitIndex, bit) {\n    this.bitArray.set(bitIndex, bit);\n  }\n  /** @see BitArray.mergeOrWith */\n  mergeOrWith(bitArray2) {\n    this.bitArray.mergeOrWith(bitArray2);\n  }\n  /** @see BitArray.intersectValues */\n  intersectValues(values) {\n    return this.bitArray.intersectValues(values);\n  }\n  /** @see BitArray.getTrueBitIndexes */\n  getTrueBitIndexes() {\n    return this.bitArray.getTrueBitIndexes();\n  }\n  /** @see BitArray.getSingleTrueBit */\n  getSingleTrueBit() {\n    return this.bitArray.getSingleTrueBit();\n  }\n  /** @see BitArray.toBoolArray */\n  toBoolArray() {\n    return this.bitArray.toBoolArray();\n  }\n  /** Lazily computed bitArray instance */\n  get bitArray() {\n    if (this._bitArray === null) {\n      this._bitArray = this.type.tree_toValue(this._rootNode);\n    }\n    return this._bitArray;\n  }\n  clearCache() {\n    this._bitArray = null;\n  }\n}\nexports.BitArrayTreeViewDU = BitArrayTreeViewDU;","map":{"version":3,"sources":["../../src/viewDU/bitArray.ts"],"names":[],"mappings":";;;;;;AAGA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAEA;;AAEG;AACH,MAAa,kBAAmB,SAAQ,UAAA,CAAA,UAAqD,CAAA;EAI3F,WAAA,CAAqB,IAA+C,EAAY,SAAe,EAAA;IAC7F,KAAK,CAAA,CAAE;IADY,IAAA,CAAA,IAAI,GAAJ,IAAI;IAAuD,IAAA,CAAA,SAAS,GAAT,SAAS;IAHzF;IACQ,IAAA,CAAA,SAAS,GAAoB,IAAI;EAIzC;EAEA,IAAI,IAAI,CAAA,EAAA;IACN,OAAO,IAAI,CAAC,SAAS;EACvB;EAEA,IAAI,KAAK,CAAA,EAAA;IACP;EACF;EAEA,MAAM,CAAA,EAAA;IACJ,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;MAC3B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC;IACxD;EACH;EAEA;EAEA;EACA,IAAI,UAAU,CAAA,EAAA;IACZ,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU;EACjC;EAEA;EACA,IAAI,MAAM,CAAA,EAAA;IACR,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM;EAC7B;EAEA;EACA,GAAG,CAAC,QAAgB,EAAA;IAClB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC;EACpC;EAEA;EACA,GAAG,CAAC,QAAgB,EAAE,GAAY,EAAA;IAChC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAG,CAAC;EAClC;EAEA;EACA,WAAW,CAAC,SAAmB,EAAA;IAC7B,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,SAAS,CAAC;EACtC;EAEA;EACA,eAAe,CAAI,MAAW,EAAA;IAC5B,OAAO,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,MAAM,CAAC;EAC9C;EAEA;EACA,iBAAiB,CAAA,EAAA;IACf,OAAO,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAA,CAAE;EAC1C;EAEA;EACA,gBAAgB,CAAA,EAAA;IACd,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAA,CAAE;EACzC;EAEA;EACA,WAAW,CAAA,EAAA;IACT,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAA,CAAE;EACpC;EAEA;EACA,IAAY,QAAQ,CAAA,EAAA;IAClB,IAAI,IAAI,CAAC,SAAS,KAAK,IAAI,EAAE;MAC3B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC;IACxD;IACD,OAAO,IAAI,CAAC,SAAS;EACvB;EAEU,UAAU,CAAA,EAAA;IAClB,IAAI,CAAC,SAAS,GAAG,IAAI;EACvB;AACD;AAhFD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitArrayTreeViewDU = void 0;\nconst abstract_1 = require(\"./abstract\");\n/**\n * Thin wrapper around BitArray to upstream changes after `this.commit()`\n */\nclass BitArrayTreeViewDU extends abstract_1.TreeViewDU {\n    constructor(type, _rootNode) {\n        super();\n        this.type = type;\n        this._rootNode = _rootNode;\n        /** Cached BitArray instance computed only on demand */\n        this._bitArray = null;\n    }\n    get node() {\n        return this._rootNode;\n    }\n    get cache() {\n        return;\n    }\n    commit() {\n        if (this._bitArray !== null) {\n            this._rootNode = this.type.value_toTree(this._bitArray);\n        }\n    }\n    // Wrapped API from BitArray\n    /** @see BitArray.uint8Array */\n    get uint8Array() {\n        return this.bitArray.uint8Array;\n    }\n    /** @see BitArray.bitLen */\n    get bitLen() {\n        return this.bitArray.bitLen;\n    }\n    /** @see BitArray.get */\n    get(bitIndex) {\n        return this.bitArray.get(bitIndex);\n    }\n    /** @see BitArray.set */\n    set(bitIndex, bit) {\n        this.bitArray.set(bitIndex, bit);\n    }\n    /** @see BitArray.mergeOrWith */\n    mergeOrWith(bitArray2) {\n        this.bitArray.mergeOrWith(bitArray2);\n    }\n    /** @see BitArray.intersectValues */\n    intersectValues(values) {\n        return this.bitArray.intersectValues(values);\n    }\n    /** @see BitArray.getTrueBitIndexes */\n    getTrueBitIndexes() {\n        return this.bitArray.getTrueBitIndexes();\n    }\n    /** @see BitArray.getSingleTrueBit */\n    getSingleTrueBit() {\n        return this.bitArray.getSingleTrueBit();\n    }\n    /** @see BitArray.toBoolArray */\n    toBoolArray() {\n        return this.bitArray.toBoolArray();\n    }\n    /** Lazily computed bitArray instance */\n    get bitArray() {\n        if (this._bitArray === null) {\n            this._bitArray = this.type.tree_toValue(this._rootNode);\n        }\n        return this._bitArray;\n    }\n    clearCache() {\n        this._bitArray = null;\n    }\n}\nexports.BitArrayTreeViewDU = BitArrayTreeViewDU;\n//# sourceMappingURL=bitArray.js.map"]},"metadata":{},"sourceType":"script"}