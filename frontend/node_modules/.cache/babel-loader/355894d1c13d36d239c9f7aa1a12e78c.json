{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction(_ref, body) {\n  let {\n    gen,\n    validateName,\n    schema,\n    schemaEnv,\n    opts\n  } = _ref;\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, names_1.default.valCxt), schemaEnv.$async, () => {\n      gen.code((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\\"use strict\\\"; \", \"\"])), funcSourceUrl(schema, opts)));\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, destructureValCxt(opts)), schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{\", \"=\\\"\\\", \", \", \", \", \", \"=\", \"\", \"}={}\"])), names_1.default.instancePath, names_1.default.parentData, names_1.default.parentDataProperty, names_1.default.rootData, names_1.default.data, opts.dynamicRef ? (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\", \", \"={}\"])), names_1.default.dynamicAnchors) : codegen_1.nil);\n}\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.instancePath));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentData));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentDataProperty));\n    gen.var(names_1.default.rootData, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.rootData));\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.dynamicAnchors));\n  }, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"{}\"]))));\n  });\n}\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \".evaluated\"])), validateName));\n  gen.if((0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \".dynamicProps\"])), it.evaluated), () => gen.assign((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".props\"])), it.evaluated), (0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"undefined\"])))));\n  gen.if((0, codegen_1._)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"\", \".dynamicItems\"])), it.evaluated), () => gen.assign((0, codegen_1._)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"\", \".items\"])), it.evaluated), (0, codegen_1._)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"undefined\"])))));\n}\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"/*# sourceURL=\", \" */\"])), schId) : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules(_ref2) {\n  let {\n    schema,\n    self\n  } = _ref2;\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (self.RULES.all[key]) return true;\n  return false;\n}\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount);\n  // TODO var\n  gen.var(valid, (0, codegen_1._)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), errsCount, names_1.default.errors));\n}\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = (0, dataType_1.getSchemaTypes)(it.schema);\n  const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(\"$ref: keywords ignored in schema at path \\\"\".concat(errSchemaPath, \"\\\"\"));\n  }\n}\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword(_ref3) {\n  let {\n    gen,\n    schemaEnv,\n    schema,\n    errSchemaPath,\n    opts\n  } = _ref3;\n  const msg = schema.$comment;\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"\", \".logger.log(\", \")\"])), names_1.default.self, msg));\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = (0, codegen_1.str)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"\", \"/$comment\"])), errSchemaPath);\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"\", \".opts.$comment(\", \", \", \", \", \".schema)\"])), names_1.default.self, msg, schemaPath, rootName));\n  }\n}\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors), () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"new \", \"(\", \")\"])), ValidationError, names_1.default.vErrors)));\n  } else {\n    gen.assign((0, codegen_1._)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"\", \".errors\"])), validateName), names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors));\n  }\n}\nfunction assignEvaluated(_ref4) {\n  let {\n    gen,\n    evaluated,\n    props,\n    items\n  } = _ref4;\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"\", \".props\"])), evaluated), props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"\", \".items\"])), evaluated), items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n    return;\n  }\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n    groupKeywords(RULES.post);\n  });\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if((0, codegen_1._)(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), names_1.default.errors, errsCount || 0));\n  }\n}\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, \"type \\\"\".concat(t, \"\\\" not allowed by context \\\"\").concat(it.dataTypes.join(\",\"), \"\\\"\"));\n    }\n  });\n  narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, \"missing type \\\"\".concat(type.join(\",\"), \"\\\" for keyword \\\"\").concat(keyword, \"\\\"\"));\n      }\n    }\n  }\n}\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction narrowSchemaTypes(it, withTypes) {\n  const ts = [];\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t);else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\");\n  }\n  it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += \" at \\\"\".concat(schemaPath, \"\\\" (strictTypes)\");\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(\"\".concat(keyword, \" value must be \").concat(JSON.stringify(def.schemaType)));\n      }\n    }\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n  result(condition, successAction, failAction) {\n    this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n  }\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n  pass(condition, failAction) {\n    this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n  }\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n      return;\n    }\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail((0, codegen_1._)(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral([\"\", \" !== undefined && (\", \")\"])), schemaCode, (0, codegen_1.or)(this.invalid$data(), condition)));\n  }\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n      this._error(append, errorPaths);\n      this.setParams({});\n      return;\n    }\n    this._error(append, errorPaths);\n  }\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n  $dataError() {\n    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n  }\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n  block$data(valid, codeBlock) {\n    let $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n  check$data() {\n    let valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    let $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if((0, codegen_1.or)((0, codegen_1._)(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral([\"\", \" === undefined\"])), schemaCode), $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n    gen.else();\n  }\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return (0, codegen_1._)(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral([\"\", \"\"])), (0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));\n      }\n      return codegen_1.nil;\n    }\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n        return (0, codegen_1._)(_templateObject37 || (_templateObject37 = _taggedTemplateLiteral([\"!\", \"(\", \")\"])), validateSchemaRef, schemaCode);\n      }\n      return codegen_1.nil;\n    }\n  }\n  subschema(appl, valid) {\n    const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n    (0, subschema_1.extendSubschemaMode)(subschema, appl);\n    const nextContext = _objectSpread(_objectSpread(_objectSpread({}, this.it), subschema), {}, {\n      items: undefined,\n      props: undefined\n    });\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, _ref5) {\n  let {\n    dataLevel,\n    dataNames,\n    dataPathArr\n  } = _ref5;\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    const up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n  for (const segment of segments) {\n    if (segment) {\n      data = (0, codegen_1._)(_templateObject38 || (_templateObject38 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment)));\n      expr = (0, codegen_1._)(_templateObject39 || (_templateObject39 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), expr, data);\n    }\n  }\n  return expr;\n  function errorMsg(pointerType, up) {\n    return \"Cannot access \".concat(pointerType, \" \").concat(up, \" levels up, current level is \").concat(dataLevel);\n  }\n}\nexports.getData = getData;","map":null,"metadata":{},"sourceType":"script"}