{"ast":null,"code":"import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo}from'@celo/react-celo';import{useEffect,useMemo,useRef}from'react';import{useDispatch,useSelector}from'react-redux';import{useMulticallContract}from'../../hooks/useContract';import useDebounce from'../../hooks/useDebounce';import chunkArray from'../../utils/chunkArray';import{CancelledError,retry,RetryableError}from'../../utils/retry';import{useBlockNumber}from'../application/hooks';import{errorFetchingMulticallResults,fetchingMulticallResults,parseCallKey,updateMulticallResults}from'./actions';// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE=500;/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */function fetchChunk(_x,_x2,_x3){return _fetchChunk.apply(this,arguments);}/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */function _fetchChunk(){_fetchChunk=_asyncToGenerator(function*(multicallContract,chunk,minBlockNumber){console.debug('Fetching chunk',multicallContract,chunk,minBlockNumber);let resultsBlockNumber,returnData;try{;[resultsBlockNumber,returnData]=yield multicallContract.aggregate(chunk.map(obj=>[obj.address,obj.callData]));}catch(error){console.debug('Failed to fetch chunk inside retry',error);throw error;}if(resultsBlockNumber.toNumber()<minBlockNumber){console.debug(\"Fetched results for old block number: \".concat(resultsBlockNumber.toString(),\" vs. \").concat(minBlockNumber));throw new RetryableError('Fetched for old block number');}return{results:returnData,blockNumber:resultsBlockNumber.toNumber()};});return _fetchChunk.apply(this,arguments);}export function activeListeningKeys(allListeners,chainId){if(!allListeners||!chainId)return{};const listeners=allListeners[chainId];if(!listeners)return{};return Object.keys(listeners).reduce((memo,callKey)=>{const keyListeners=listeners[callKey];memo[callKey]=Object.keys(keyListeners).filter(key=>{const blocksPerFetch=parseInt(key);if(blocksPerFetch<=0)return false;return keyListeners[blocksPerFetch]>0;}).reduce((previousMin,current)=>{return Math.min(previousMin,parseInt(current));},Infinity);return memo;},{});}/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */export function outdatedListeningKeys(callResults,listeningKeys,chainId,latestBlockNumber){if(!chainId||!latestBlockNumber)return[];const results=callResults[chainId];// no results at all, load everything\nif(!results)return Object.keys(listeningKeys);return Object.keys(listeningKeys).filter(callKey=>{const blocksPerFetch=listeningKeys[callKey];const data=callResults[chainId][callKey];// no data, must fetch\nif(!data)return true;const minDataBlockNumber=latestBlockNumber-(blocksPerFetch-1);// already fetching it for a recent enough block, don't refetch it\nif(data.fetchingBlockNumber&&data.fetchingBlockNumber>=minDataBlockNumber)return false;// if data is older than minDataBlockNumber, fetch it\nreturn!data.blockNumber||data.blockNumber<minDataBlockNumber;});}export default function Updater(){const dispatch=useDispatch();const state=useSelector(state=>state.multicall);// wait for listeners to settle before triggering updates\nconst debouncedListeners=useDebounce(state.callListeners,100);const latestBlockNumber=useBlockNumber();const{network}=useCelo();const chainId=network.chainId;const multicallContract=useMulticallContract();const cancellations=useRef();const listeningKeys=useMemo(()=>{return activeListeningKeys(debouncedListeners,chainId);},[debouncedListeners,chainId]);const unserializedOutdatedCallKeys=useMemo(()=>{return outdatedListeningKeys(state.callResults,listeningKeys,chainId,latestBlockNumber);},[chainId,state.callResults,listeningKeys,latestBlockNumber]);const serializedOutdatedCallKeys=useMemo(()=>JSON.stringify(unserializedOutdatedCallKeys.sort()),[unserializedOutdatedCallKeys]);useEffect(()=>{var _cancellations$curren;if(!latestBlockNumber||!chainId||!multicallContract)return;const outdatedCallKeys=JSON.parse(serializedOutdatedCallKeys);if(outdatedCallKeys.length===0)return;const calls=outdatedCallKeys.map(key=>parseCallKey(key));const chunkedCalls=chunkArray(calls,CALL_CHUNK_SIZE);if(cancellations.current&&latestBlockNumber-((_cancellations$curren=cancellations.current)===null||_cancellations$curren===void 0?void 0:_cancellations$curren.blockNumber)>2){var _cancellations$curren2,_cancellations$curren3;(_cancellations$curren2=cancellations.current)===null||_cancellations$curren2===void 0?void 0:(_cancellations$curren3=_cancellations$curren2.cancellations)===null||_cancellations$curren3===void 0?void 0:_cancellations$curren3.forEach(c=>c());}dispatch(fetchingMulticallResults({calls,chainId,fetchingBlockNumber:latestBlockNumber}));cancellations.current={blockNumber:latestBlockNumber,cancellations:chunkedCalls.map((chunk,index)=>{const{cancel,promise}=retry(()=>fetchChunk(multicallContract,chunk,latestBlockNumber),{n:Infinity,minWait:2500,maxWait:3500});promise.then(_ref=>{let{results:returnData,blockNumber:fetchBlockNumber}=_ref;cancellations.current={cancellations:[],blockNumber:latestBlockNumber};// accumulates the length of all previous indices\nconst firstCallKeyIndex=chunkedCalls.slice(0,index).reduce((memo,curr)=>memo+curr.length,0);const lastCallKeyIndex=firstCallKeyIndex+returnData.length;dispatch(updateMulticallResults({chainId,results:outdatedCallKeys.slice(firstCallKeyIndex,lastCallKeyIndex).reduce((memo,callKey,i)=>{var _returnData$i;memo[callKey]=(_returnData$i=returnData[i])!==null&&_returnData$i!==void 0?_returnData$i:null;return memo;},{}),blockNumber:fetchBlockNumber}));}).catch(error=>{if(error instanceof CancelledError){console.debug('Cancelled fetch for blockNumber',latestBlockNumber);return;}console.error('Failed to fetch multicall chunk',chunk,chainId,error);dispatch(errorFetchingMulticallResults({calls:chunk,chainId,fetchingBlockNumber:latestBlockNumber}));});return cancel;})};},[chainId,multicallContract,dispatch,serializedOutdatedCallKeys,latestBlockNumber]);return null;}","map":{"version":3,"names":["useCelo","useEffect","useMemo","useRef","useDispatch","useSelector","useMulticallContract","useDebounce","chunkArray","CancelledError","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","CALL_CHUNK_SIZE","fetchChunk","_x","_x2","_x3","_fetchChunk","apply","arguments","_asyncToGenerator","multicallContract","chunk","minBlockNumber","console","debug","resultsBlockNumber","returnData","aggregate","map","obj","address","callData","error","toNumber","concat","toString","results","blockNumber","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","Math","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","data","minDataBlockNumber","fetchingBlockNumber","Updater","dispatch","state","multicall","debouncedListeners","callListeners","network","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","_cancellations$curren","outdatedCallKeys","parse","length","calls","chunkedCalls","_cancellations$curren2","_cancellations$curren3","forEach","c","index","cancel","promise","n","minWait","maxWait","then","_ref","fetchBlockNumber","firstCallKeyIndex","slice","curr","lastCallKeyIndex","i","_returnData$i","catch"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/multicall/updater.tsx"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { useMulticallContract } from '../../hooks/useContract'\nimport useDebounce from '../../hooks/useDebounce'\nimport chunkArray from '../../utils/chunkArray'\nimport { CancelledError, retry, RetryableError } from '../../utils/retry'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  Call,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  parseCallKey,\n  updateMulticallResults,\n} from './actions'\n\n// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE = 500\n\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nasync function fetchChunk(\n  multicallContract: Contract,\n  chunk: Call[],\n  minBlockNumber: number\n): Promise<{ results: string[]; blockNumber: number }> {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\n  let resultsBlockNumber, returnData\n  try {\n    ;[resultsBlockNumber, returnData] = await multicallContract.aggregate(\n      chunk.map((obj) => [obj.address, obj.callData])\n    )\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number')\n  }\n  return { results: returnData, blockNumber: resultsBlockNumber.toNumber() }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter((key) => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter((callKey) => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport default function Updater(): null {\n  const dispatch = useDispatch<AppDispatch>()\n  const state = useSelector<AppState, AppState['multicall']>((state) => state.multicall)\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const latestBlockNumber = useBlockNumber()\n  const { network } = useCelo()\n  const chainId = network.chainId\n  const multicallContract = useMulticallContract()\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId)\n  }, [debouncedListeners, chainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(\n    () => JSON.stringify(unserializedOutdatedCallKeys.sort()),\n    [unserializedOutdatedCallKeys]\n  )\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !multicallContract) return\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\n\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\n\n    if (cancellations.current && latestBlockNumber - cancellations.current?.blockNumber > 2) {\n      cancellations.current?.cancellations?.forEach((c) => c())\n    }\n\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      })\n    )\n\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500,\n        })\n        promise\n          .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\n\n            dispatch(\n              updateMulticallResults({\n                chainId,\n                results: outdatedCallKeys\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\n                    memo[callKey] = returnData[i] ?? null\n                    return memo\n                  }, {}),\n                blockNumber: fetchBlockNumber,\n              })\n            )\n          })\n          .catch((error: any) => {\n            if (error instanceof CancelledError) {\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber)\n              return\n            }\n            console.error('Failed to fetch multicall chunk', chunk, chainId, error)\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId,\n                fetchingBlockNumber: latestBlockNumber,\n              })\n            )\n          })\n        return cancel\n      }),\n    }\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n\n  return null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}