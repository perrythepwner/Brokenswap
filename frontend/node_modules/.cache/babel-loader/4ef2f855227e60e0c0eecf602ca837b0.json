{"ast":null,"code":"var D = Object.getOwnPropertySymbols;\nvar z = Object.prototype.hasOwnProperty,\n  G = Object.prototype.propertyIsEnumerable;\nvar T = (e, t) => {\n  var r = {};\n  for (var n in e) z.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);\n  if (e != null && D) for (var n of D(e)) t.indexOf(n) < 0 && G.call(e, n) && (r[n] = e[n]);\n  return r;\n};\nimport { useState as X, useRef as d, useCallback as Y } from \"react\";\nimport { useEffect as Z, useLayoutEffect as _ } from \"react\";\nvar J = Object.defineProperty,\n  H = Object.defineProperties,\n  K = Object.getOwnPropertyDescriptors,\n  j = Object.getOwnPropertySymbols,\n  Q = Object.prototype.hasOwnProperty,\n  W = Object.prototype.propertyIsEnumerable,\n  I = (e, t, r) => t in e ? J(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: r\n  }) : e[t] = r,\n  x = (e, t) => {\n    for (var r in t || (t = {})) Q.call(t, r) && I(e, r, t[r]);\n    if (j) for (var r of j(t)) W.call(t, r) && I(e, r, t[r]);\n    return e;\n  },\n  U = (e, t) => H(e, K(t)),\n  S = typeof window == \"undefined\" ? Z : _,\n  h = _ref => {\n    let {\n      isPlaying: e,\n      duration: t,\n      startAt: r = 0,\n      updateInterval: n = 0,\n      onComplete: i,\n      onUpdate: y\n    } = _ref;\n    let [p, g] = X(r),\n      v = d(r * -1e3),\n      s = d(null),\n      m = d(null),\n      f = d(null),\n      o = d({\n        elapsedTimeRef: 0,\n        startAtRef: r,\n        durationRef: t,\n        updateIntervalRef: n\n      });\n    o.current = U(x({}, o.current), {\n      durationRef: t,\n      updateIntervalRef: n\n    });\n    let c = a => {\n        let u = a / 1e3;\n        if (m.current === null) {\n          m.current = u, s.current = requestAnimationFrame(c);\n          return;\n        }\n        let {\n            durationRef: l,\n            elapsedTimeRef: F,\n            updateIntervalRef: C,\n            startAtRef: b\n          } = o.current,\n          O = u - m.current,\n          E = F + O;\n        m.current = u, o.current = U(x({}, o.current), {\n          elapsedTimeRef: E\n        });\n        let M = b + (C === 0 ? E : (E / C | 0) * C),\n          N = b + E,\n          A = typeof l == \"number\" && N >= l;\n        g(A ? l : M), A || (s.current = requestAnimationFrame(c));\n      },\n      R = () => {\n        s.current && cancelAnimationFrame(s.current), f.current && clearTimeout(f.current), m.current = null;\n      },\n      P = Y(a => {\n        let u = typeof a == \"number\" ? a : r;\n        R(), o.current = U(x({}, o.current), {\n          elapsedTimeRef: 0,\n          startAtRef: u\n        }), g(u), e && (s.current = requestAnimationFrame(c));\n      }, [e, r]);\n    return S(() => {\n      if (y == null || y(p), t && p >= t) {\n        v.current += t * 1e3;\n        let {\n          shouldRepeat: a = !1,\n          delay: u = 0,\n          newStartAt: l\n        } = (i == null ? void 0 : i(v.current / 1e3)) || {};\n        a && (f.current = setTimeout(() => P(l), u * 1e3));\n      }\n    }, [p, t]), S(() => (e && (s.current = requestAnimationFrame(c)), R), [e]), {\n      elapsedTime: p,\n      reset: P\n    };\n  };\nvar q = {\n    easeInCubic: (e, t, r, n) => (e /= n, r * e * e * e + t),\n    easeOutCubic: (e, t, r, n) => (e /= n, e--, r * (e * e * e + 1) + t),\n    linear: (e, t, r, n) => r * e / n + t\n  },\n  V = q.easeOutCubic,\n  L = e => typeof e == \"function\" ? e : q[e];\nvar ee = (e, t) => {\n    if (typeof e == \"number\") return typeof t == \"number\" ? t : 2;\n  },\n  $ = (e, t) => e.replace(/\\B(?=(\\d{3})+(?!\\d))/g, t),\n  k = e => (e.toString().split(\".\")[1] || \"\").length,\n  te = (e, t) => {\n    let r = k(e),\n      n = k(t || 1);\n    return r >= n ? r : n;\n  },\n  w = _ref2 => {\n    let {\n      isCounting: e = !1,\n      start: t = 0,\n      end: r,\n      duration: n,\n      decimalPlaces: i = te(t, r),\n      decimalSeparator: y = \".\",\n      thousandsSeparator: p = \"\",\n      onComplete: g,\n      easing: v = V,\n      formatter: s,\n      updateInterval: m,\n      onUpdate: f\n    } = _ref2;\n    let o = ee(r, n),\n      c = a => {\n        let u;\n        if (o === 0 && typeof r == \"number\") u = r;else if (typeof r == \"number\" && typeof o == \"number\") {\n          let b = L(v),\n            O = a < o ? a : o;\n          u = b(O, t, r - t, o);\n        } else u = t + a;\n        if (typeof s == \"function\") return s(u);\n        if (i === 0) {\n          let b = Math.round(u).toString();\n          return $(b, p);\n        }\n        let [l, F] = u.toFixed(i).split(\".\");\n        return \"\".concat($(l, p)).concat(y).concat(F);\n      },\n      {\n        elapsedTime: R,\n        reset: P\n      } = h({\n        isPlaying: e,\n        duration: o,\n        onComplete: g,\n        updateInterval: m,\n        onUpdate: typeof f == \"function\" ? a => f(c(a)) : void 0\n      });\n    return {\n      value: c(R),\n      reset: P\n    };\n  };\nvar B = r => {\n  var n = r,\n    {\n      children: e\n    } = n,\n    t = T(n, [\"children\"]);\n  let i = w(t);\n  return typeof e == \"function\" ? e(i) : i.value;\n};\nB.displayName = \"CountUp\";\nexport { B as CountUp, w as useCountUp };","map":null,"metadata":{},"sourceType":"module"}