{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.byteArrayEquals = exports.fromHexString = exports.toHexString = void 0;\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = new Array(256);\nfunction toHexString(bytes) {\n  let hex = \"0x\";\n  for (const byte of bytes) {\n    if (!hexByByte[byte]) {\n      hexByByte[byte] = byte < 16 ? \"0\" + byte.toString(16) : byte.toString(16);\n    }\n    hex += hexByByte[byte];\n  }\n  return hex;\n}\nexports.toHexString = toHexString;\nfunction fromHexString(hex) {\n  if (typeof hex !== \"string\") {\n    throw new Error(\"hex argument type \".concat(typeof hex, \" must be of type string\"));\n  }\n  if (hex.startsWith(\"0x\")) {\n    hex = hex.slice(2);\n  }\n  if (hex.length % 2 !== 0) {\n    throw new Error(\"hex string length \".concat(hex.length, \" must be multiple of 2\"));\n  }\n  const byteLen = hex.length / 2;\n  const bytes = new Uint8Array(byteLen);\n  for (let i = 0; i < byteLen; i++) {\n    const byte = parseInt(hex.slice(i * 2, (i + 1) * 2), 16);\n    bytes[i] = byte;\n  }\n  return bytes;\n}\nexports.fromHexString = fromHexString;\nfunction byteArrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nexports.byteArrayEquals = byteArrayEquals;","map":null,"metadata":{},"sourceType":"script"}