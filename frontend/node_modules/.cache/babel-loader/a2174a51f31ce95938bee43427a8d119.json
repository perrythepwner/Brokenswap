{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ByteVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst byteArray_1 = require(\"./byteArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * ByteVector: Immutable alias of Vector[byte, N]\n * - Notation: `ByteVector[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteVector is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteVector.\n *\n * For a `ByteVectorType` with mutability, use `VectorBasicType(byteType)`\n */\nclass ByteVectorType extends byteArray_1.ByteArrayType {\n  constructor(lengthBytes, opts) {\n    var _opts$typeName;\n    super();\n    this.lengthBytes = lengthBytes;\n    this.isList = false;\n    if (lengthBytes === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"ByteVector[\".concat(lengthBytes, \"]\");\n    this.maxChunkCount = Math.ceil(this.lengthBytes / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = this.chunkDepth;\n    this.fixedSize = this.lengthBytes;\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n  }\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);\n  }\n  // Views: inherited from ByteArrayType\n  // Serialization + deserialization\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n  // value_* inherited from ByteArrayType\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n    return offset + this.fixedSize;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n  }\n  tree_getByteLen() {\n    return this.lengthBytes;\n  }\n  // Merkleization: inherited from ByteArrayType\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from ByteArrayType\n  assertValidSize(size) {\n    if (size !== this.lengthBytes) {\n      throw Error(\"ByteVector invalid size \".concat(size, \" expected \").concat(this.lengthBytes));\n    }\n  }\n}\nexports.ByteVectorType = ByteVectorType;","map":{"version":3,"sources":["../../src/type/byteVector.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAQA;AAEA;;;;;;;;;;;AAWG;AACH,MAAa,cAAe,SAAQ,WAAA,CAAA,aAAa,CAAA;EAW/C,WAAA,CAAqB,WAAmB,EAAE,IAAwB,EAAA;IAAA,IAAA,cAAA;IAChE,KAAK,CAAA,CAAE;IADY,IAAA,CAAA,WAAW,GAAX,WAAW;IAFvB,IAAA,CAAA,MAAM,GAAG,KAAK;IAKrB,IAAI,WAAW,KAAK,CAAC,EAAE,MAAM,KAAK,CAAC,2BAA2B,CAAC;IAE/D,IAAI,CAAC,QAAQ,IAAA,cAAA,GAAG,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,QAAQ,cAAA,cAAA,cAAA,cAAA,iBAAA,MAAA,CAAkB,WAAW,MAAG;IAC9D,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;IACrD,IAAI,CAAC,UAAU,GAAG,WAAA,CAAA,gBAAgB,CAAC,IAAI,CAAC,aAAa,CAAC;IACtD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU;IAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW;IACjC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS;IAC7B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS;EAC/B;EAEA,OAAO,KAAK,CAAC,SAAiB,EAAE,IAA4C,EAAA;IAC1E,OAAO,KAAK,OAAA,CAAA,UAAU,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC;EACzE;EAEA;EAEA;EAEA,oBAAoB,CAAA,EAAA;IAClB,OAAO,IAAI,CAAC,SAAS;EACvB;EAEA;EAEA,mBAAmB,CAAA,EAAA;IACjB,OAAO,IAAI,CAAC,SAAS;EACvB;EAEA,qBAAqB,CAAC,MAAiB,EAAE,MAAc,EAAE,IAAU,EAAA;IACjE,MAAM,KAAK,GAAG,wBAAA,CAAA,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC;IAC3E,wBAAA,CAAA,sBAAsB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC;IACtE,OAAO,MAAM,GAAG,IAAI,CAAC,SAAS;EAChC;EAEA,yBAAyB,CAAC,IAAe,EAAE,KAAa,EAAE,GAAW,EAAA;IACnE,IAAI,CAAC,eAAe,CAAC,GAAG,GAAG,KAAK,CAAC;IACjC,OAAO,wBAAA,CAAA,sBAAsB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,CAAC;EAC3E;EAEA,eAAe,CAAA,EAAA;IACb,OAAO,IAAI,CAAC,WAAW;EACzB;EAEA;EAEA;EAEA;EAEU,eAAe,CAAC,IAAY,EAAA;IACpC,IAAI,IAAI,KAAK,IAAI,CAAC,WAAW,EAAE;MAC7B,MAAM,KAAK,4BAAA,MAAA,CAA4B,IAAI,gBAAA,MAAA,CAAa,IAAI,CAAC,WAAW,CAAE,CAAC;IAC5E;EACH;AACD;AArED,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ByteVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst byteArray_1 = require(\"./byteArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * ByteVector: Immutable alias of Vector[byte, N]\n * - Notation: `ByteVector[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteVector is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteVector.\n *\n * For a `ByteVectorType` with mutability, use `VectorBasicType(byteType)`\n */\nclass ByteVectorType extends byteArray_1.ByteArrayType {\n    constructor(lengthBytes, opts) {\n        super();\n        this.lengthBytes = lengthBytes;\n        this.isList = false;\n        if (lengthBytes === 0)\n            throw Error(\"Vector length must be > 0\");\n        this.typeName = opts?.typeName ?? `ByteVector[${lengthBytes}]`;\n        this.maxChunkCount = Math.ceil(this.lengthBytes / 32);\n        this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        this.depth = this.chunkDepth;\n        this.fixedSize = this.lengthBytes;\n        this.minSize = this.fixedSize;\n        this.maxSize = this.fixedSize;\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);\n    }\n    // Views: inherited from ByteArrayType\n    // Serialization + deserialization\n    value_serializedSize() {\n        return this.fixedSize;\n    }\n    // value_* inherited from ByteArrayType\n    tree_serializedSize() {\n        return this.fixedSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n        return offset + this.fixedSize;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n    }\n    tree_getByteLen() {\n        return this.lengthBytes;\n    }\n    // Merkleization: inherited from ByteArrayType\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from ByteArrayType\n    assertValidSize(size) {\n        if (size !== this.lengthBytes) {\n            throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);\n        }\n    }\n}\nexports.ByteVectorType = ByteVectorType;\n//# sourceMappingURL=byteVector.js.map"]},"metadata":{},"sourceType":"script"}