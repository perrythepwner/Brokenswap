{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = void 0;\nconst util_1 = require(\"../util\");\n/**\n *\n * @param plainText string to be encrypted\n * @param secret hex representation of 32-byte secret\n * returns hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the\n * encrypted plainText.\n */\nfunction encrypt(_x, _x2) {\n  return _encrypt.apply(this, arguments);\n}\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator(function* (plainText, secret) {\n    if (secret.length !== 64) throw Error(\"secret must be 256 bits\");\n    const ivBytes = crypto.getRandomValues(new Uint8Array(12));\n    const secretKey = yield crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n      name: \"aes-gcm\"\n    }, false, [\"encrypt\", \"decrypt\"]);\n    const enc = new TextEncoder();\n    // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end\n    const encryptedResult = yield window.crypto.subtle.encrypt({\n      name: \"AES-GCM\",\n      iv: ivBytes\n    }, secretKey, enc.encode(plainText));\n    const tagLength = 16;\n    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);\n    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);\n    const authTagBytes = new Uint8Array(authTag);\n    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);\n    const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);\n    return (0, util_1.uint8ArrayToHex)(concatted);\n  });\n  return _encrypt.apply(this, arguments);\n}\nexports.encrypt = encrypt;\n/**\n *\n * @param cipherText hex string representation of bytes in the order: initialization vector (iv),\n * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.\n * @param secret hex string representation of 32-byte secret\n */\nfunction decrypt(cipherText, secret) {\n  if (secret.length !== 64) throw Error(\"secret must be 256 bits\");\n  return new Promise((resolve, reject) => {\n    void _asyncToGenerator(function* () {\n      const secretKey = yield crypto.subtle.importKey(\"raw\", (0, util_1.hexStringToUint8Array)(secret), {\n        name: \"aes-gcm\"\n      }, false, [\"encrypt\", \"decrypt\"]);\n      const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);\n      const ivBytes = encrypted.slice(0, 12);\n      const authTagBytes = encrypted.slice(12, 28);\n      const encryptedPlaintextBytes = encrypted.slice(28);\n      const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);\n      const algo = {\n        name: \"AES-GCM\",\n        iv: new Uint8Array(ivBytes)\n      };\n      try {\n        const decrypted = yield window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);\n        const decoder = new TextDecoder();\n        resolve(decoder.decode(decrypted));\n      } catch (err) {\n        reject(err);\n      }\n    })();\n  });\n}\nexports.decrypt = decrypt;","map":null,"metadata":{},"sourceType":"script"}