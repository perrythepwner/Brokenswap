{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{Trade}from'@ubeswap/sdk';import flatMap from'lodash.flatmap';import{useMemo}from'react';import{useUserSingleHopOnly}from'state/user/hooks';import{isTradeBetter}from'utils/trades';import{BASES_TO_CHECK_TRADES_AGAINST,BETTER_TRADE_LESS_HOPS_THRESHOLD}from'../../../../constants';import{PairState,usePairs}from'../../../../data/Reserves';import{UbeswapTrade}from'../trade';function useAllCommonPairs(tokenA,tokenB){const{network}=useCelo();const chainId=network.chainId;const bases=useMemo(()=>{var _BASES_TO_CHECK_TRADE;if(!chainId)return[];const common=(_BASES_TO_CHECK_TRADE=BASES_TO_CHECK_TRADES_AGAINST[chainId])!==null&&_BASES_TO_CHECK_TRADE!==void 0?_BASES_TO_CHECK_TRADE:[];return[...common];},[chainId]);const basePairs=useMemo(()=>flatMap(bases,base=>bases.map(otherBase=>[base,otherBase])),[bases]);const allPairCombinations=useMemo(()=>tokenA&&tokenB?[// the direct pair\n[tokenA,tokenB],// token A against all bases\n...bases.map(base=>[tokenA,base]),// token B against all bases\n...bases.map(base=>[tokenB,base]),// each base against all bases\n...basePairs].filter(tokens=>Boolean(tokens[0]&&tokens[1])).filter(_ref=>{let[t0,t1]=_ref;return t0.address!==t1.address;}):[],[tokenA,tokenB,bases,basePairs]);const allPairs=usePairs(allPairCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(()=>Object.values(allPairs// filter out invalid pairs\n.filter(result=>Boolean(result[0]===PairState.EXISTS&&result[1]))// filter out duplicated pairs\n.reduce((memo,_ref2)=>{var _memo$curr$liquidityT;let[,curr]=_ref2;memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{})),[allPairs]);}const MAX_HOPS=3;/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useDirectTradeExactIn(currencyAmountIn,currencyOut){const allowedPairs=useAllCommonPairs(currencyAmountIn===null||currencyAmountIn===void 0?void 0:currencyAmountIn.currency,currencyOut);const[singleHopOnly]=useUserSingleHopOnly();return useMemo(()=>{if(currencyAmountIn&&currencyOut&&allowedPairs.length>0){if(singleHopOnly){var _Trade$bestTradeExact;const bestTrade=(_Trade$bestTradeExact=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact!==void 0?_Trade$bestTradeExact:null;return bestTrade?UbeswapTrade.fromNormalTrade(bestTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){var _Trade$bestTradeExact2;const currentTradeRaw=(_Trade$bestTradeExact2=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact2!==void 0?_Trade$bestTradeExact2:null;const currentTrade=currentTradeRaw?UbeswapTrade.fromNormalTrade(currentTradeRaw):null;// if current trade is best yet, save it\nif(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[allowedPairs,currencyAmountIn,currencyOut,singleHopOnly]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useDirectTradeExactOut(currencyIn,currencyAmountOut){const allowedPairs=useAllCommonPairs(currencyIn,currencyAmountOut===null||currencyAmountOut===void 0?void 0:currencyAmountOut.currency);const[singleHopOnly]=useUserSingleHopOnly();return useMemo(()=>{if(currencyIn&&currencyAmountOut&&allowedPairs.length>0){if(singleHopOnly){var _Trade$bestTradeExact3;const bestTrade=(_Trade$bestTradeExact3=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact3!==void 0?_Trade$bestTradeExact3:null;return bestTrade?UbeswapTrade.fromNormalTrade(bestTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){var _Trade$bestTradeExact4;const currentTradeRaw=(_Trade$bestTradeExact4=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact4!==void 0?_Trade$bestTradeExact4:null;const currentTrade=currentTradeRaw?UbeswapTrade.fromNormalTrade(currentTradeRaw):null;if(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[currencyIn,currencyAmountOut,allowedPairs,singleHopOnly]);}","map":{"version":3,"names":["useCelo","Trade","flatMap","useMemo","useUserSingleHopOnly","isTradeBetter","BASES_TO_CHECK_TRADES_AGAINST","BETTER_TRADE_LESS_HOPS_THRESHOLD","PairState","usePairs","UbeswapTrade","useAllCommonPairs","tokenA","tokenB","network","chainId","bases","_BASES_TO_CHECK_TRADE","common","basePairs","base","map","otherBase","allPairCombinations","filter","tokens","Boolean","_ref","t0","t1","address","allPairs","Object","values","result","EXISTS","reduce","memo","_ref2","_memo$curr$liquidityT","curr","liquidityToken","MAX_HOPS","useDirectTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","singleHopOnly","length","_Trade$bestTradeExact","bestTrade","bestTradeExactIn","maxHops","maxNumResults","fromNormalTrade","bestTradeSoFar","i","_Trade$bestTradeExact2","currentTradeRaw","currentTrade","useDirectTradeExactOut","currencyIn","currencyAmountOut","_Trade$bestTradeExact3","bestTradeExactOut","_Trade$bestTradeExact4"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/hooks/directTrades.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { Pair, Token, TokenAmount, Trade } from '@ubeswap/sdk'\nimport flatMap from 'lodash.flatmap'\nimport { useMemo } from 'react'\nimport { useUserSingleHopOnly } from 'state/user/hooks'\nimport { isTradeBetter } from 'utils/trades'\n\nimport { BASES_TO_CHECK_TRADES_AGAINST, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../../../../constants'\nimport { PairState, usePairs } from '../../../../data/Reserves'\nimport { UbeswapTrade } from '../trade'\n\nfunction useAllCommonPairs(tokenA?: Token, tokenB?: Token): Pair[] {\n  const { network } = useCelo()\n  const chainId = network.chainId\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId) return []\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    return [...common]\n  }, [chainId])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () => flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])),\n    [bases]\n  )\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n        : [],\n    [tokenA, tokenB, bases, basePairs]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\nconst MAX_HOPS = 3\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useDirectTradeExactIn(currencyAmountIn?: TokenAmount, currencyOut?: Token): UbeswapTrade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        const bestTrade =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        return bestTrade ? UbeswapTrade.fromNormalTrade(bestTrade) : null\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: UbeswapTrade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTradeRaw: Trade | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        const currentTrade: UbeswapTrade | null = currentTradeRaw ? UbeswapTrade.fromNormalTrade(currentTradeRaw) : null\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useDirectTradeExactOut(currencyIn?: Token, currencyAmountOut?: TokenAmount): UbeswapTrade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        const bestTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        return bestTrade ? UbeswapTrade.fromNormalTrade(bestTrade) : null\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: UbeswapTrade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTradeRaw =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        const currentTrade = currentTradeRaw ? UbeswapTrade.fromNormalTrade(currentTradeRaw) : null\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n    return null\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}