{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nexport default class TransportWebUSB extends Transport {\n  constructor(device, interfaceNumber) {\n    var _this;\n    super();\n    _this = this;\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.interfaceNumber = void 0;\n    this._disconnectEmitted = false;\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n    this.exchange = apdu => this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator(function* () {\n      const {\n        channel,\n        packetSize\n      } = _this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        yield _this.device.transferOut(endpointNumber, blocks[i]);\n      } // Read...\n\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = yield _this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    })).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static request() {\n    return _asyncToGenerator(function* () {\n      const device = yield requestLedgerDevice();\n      return TransportWebUSB.open(device);\n    })();\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n  static openConnected() {\n    return _asyncToGenerator(function* () {\n      const devices = yield getLedgerDevices();\n      if (devices.length === 0) return null;\n      return TransportWebUSB.open(devices[0]);\n    })();\n  }\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n\n  static open(device) {\n    return _asyncToGenerator(function* () {\n      yield device.open();\n      if (device.configuration === null) {\n        yield device.selectConfiguration(configurationValue);\n      }\n      yield gracefullyResetDevice(device);\n      const iface = device.configurations[0].interfaces.find(_ref2 => {\n        let {\n          alternates\n        } = _ref2;\n        return alternates.some(a => a.interfaceClass === 255);\n      });\n      if (!iface) {\n        throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n      }\n      const interfaceNumber = iface.interfaceNumber;\n      try {\n        yield device.claimInterface(interfaceNumber);\n      } catch (e) {\n        yield device.close();\n        throw new TransportInterfaceNotAvailable(e.message);\n      }\n      const transport = new TransportWebUSB(device, interfaceNumber);\n      const onDisconnect = e => {\n        if (device === e.device) {\n          // $FlowFixMe\n          navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n          transport._emitDisconnect(new DisconnectedDevice());\n        }\n      }; // $FlowFixMe\n\n      navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n      return transport;\n    })();\n  }\n\n  /**\n   * Release the transport device\n   */\n  close() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.exchangeBusyPromise;\n      yield _this2.device.releaseInterface(_this2.interfaceNumber);\n      yield gracefullyResetDevice(_this2.device);\n      yield _this2.device.close();\n    })();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n  setScrambleKey() {}\n}\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\nTransportWebUSB.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe\n  };\n};\nfunction gracefullyResetDevice(_x) {\n  return _gracefullyResetDevice.apply(this, arguments);\n}\nfunction _gracefullyResetDevice() {\n  _gracefullyResetDevice = _asyncToGenerator(function* (device) {\n    try {\n      yield device.reset();\n    } catch (err) {\n      console.warn(err);\n    }\n  });\n  return _gracefullyResetDevice.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}