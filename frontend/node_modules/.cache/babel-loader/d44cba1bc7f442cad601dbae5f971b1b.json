{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{parseUnits}from'@ethersproject/units';import{CELO,cEUR,cUSD,JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{useMinimaTrade,useUbeswapTradeExactIn,useUbeswapTradeExactOut}from'components/swap/routing/hooks/useTrade';import{useCallback,useEffect,useState}from'react';import{useDispatch,useSelector}from'react-redux';import{ROUTER_ADDRESS}from'../../constants';import{useCurrency}from'../../hooks/Tokens';import useENS from'../../hooks/useENS';import useParsedQueryString from'../../hooks/useParsedQueryString';import{isAddress}from'../../utils';import{computeSlippageAdjustedAmounts}from'../../utils/prices';import{useUserSlippageTolerance}from'../user/hooks';import{useCurrencyBalances}from'../wallet/hooks';import{Field,replaceSwapState,selectCurrency,setRecipient,switchCurrencies,typeInput}from'./actions';export function useSwapState(){return useSelector(state=>state.swap);}export function useSwapActionHandlers(){const dispatch=useDispatch();const onCurrencySelection=useCallback((field,currency)=>{dispatch(selectCurrency({field,currencyId:currency instanceof Token?currency.address:''}));},[dispatch]);const onSwitchTokens=useCallback(()=>{dispatch(switchCurrencies());},[dispatch]);const onUserInput=useCallback((field,typedValue)=>{dispatch(typeInput({field,typedValue}));},[dispatch]);const onChangeRecipient=useCallback(recipient=>{dispatch(setRecipient({recipient}));},[dispatch]);return{onSwitchTokens,onCurrencySelection,onUserInput,onChangeRecipient};}// try to parse a user entered amount for a given token\nexport function tryParseAmount(value,currency){if(!value||!currency){return undefined;}try{const typedValueParsed=parseUnits(value,currency.decimals).toString();if(typedValueParsed!=='0'){return new TokenAmount(currency,JSBI.BigInt(typedValueParsed));}}catch(error){// should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\nconsole.debug(\"Failed to parse input amount: \\\"\".concat(value,\"\\\"\"),error);}// necessary for all paths to return a value\nreturn new TokenAmount(currency,JSBI.BigInt(0));}const BAD_RECIPIENT_ADDRESSES=['',ROUTER_ADDRESS];/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */function involvesAddress(trade,checksummedAddress){return trade.route.path.some(token=>token.address===checksummedAddress)||trade.route.pairs.some(pair=>pair.liquidityToken.address===checksummedAddress);}// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(){var _ref,_ref2;const{address:account,network}=useCelo();const{independentField,typedValue,[Field.INPUT]:{currencyId:inputCurrencyId},[Field.OUTPUT]:{currencyId:outputCurrencyId},recipient}=useSwapState();const inputCurrency=useCurrency(inputCurrencyId);const outputCurrency=useCurrency(outputCurrencyId);const recipientLookup=useENS(recipient!==null&&recipient!==void 0?recipient:undefined);const to=(_ref=recipient===null?account:recipientLookup.address)!==null&&_ref!==void 0?_ref:null;const relevantTokenBalances=useCurrencyBalances(account!==null&&account!==void 0?account:undefined,[inputCurrency!==null&&inputCurrency!==void 0?inputCurrency:undefined,outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined]);const isExactIn=independentField===Field.INPUT;const parsedAmount=tryParseAmount(typedValue,(_ref2=isExactIn?inputCurrency:outputCurrency)!==null&&_ref2!==void 0?_ref2:undefined);const minimaBestTradeExactIn=useMinimaTrade(isExactIn?parsedAmount:undefined,outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined);const ubeBestTradeExactIn=useUbeswapTradeExactIn(isExactIn?parsedAmount:undefined,outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined);const bestTradeExactIn=minimaBestTradeExactIn===undefined?undefined:minimaBestTradeExactIn!==null&&minimaBestTradeExactIn!==void 0?minimaBestTradeExactIn:ubeBestTradeExactIn;const bestTradeExactOut=useUbeswapTradeExactOut(inputCurrency!==null&&inputCurrency!==void 0?inputCurrency:undefined,!isExactIn?parsedAmount:undefined);const v2Trade=isExactIn?bestTradeExactIn:bestTradeExactOut;const currencyBalances={[Field.INPUT]:relevantTokenBalances[0],[Field.OUTPUT]:relevantTokenBalances[1]};const currencies={[Field.INPUT]:inputCurrency!==null&&inputCurrency!==void 0?inputCurrency:undefined,[Field.OUTPUT]:outputCurrency!==null&&outputCurrency!==void 0?outputCurrency:undefined};let inputError;if(!account){inputError='Connect Wallet';}if(!parsedAmount){var _inputError;inputError=(_inputError=inputError)!==null&&_inputError!==void 0?_inputError:'Enter an amount';}if(!currencies[Field.INPUT]||!currencies[Field.OUTPUT]){var _inputError2;inputError=(_inputError2=inputError)!==null&&_inputError2!==void 0?_inputError2:'Select a token';}const formattedTo=isAddress(to);if(!to||!formattedTo){var _inputError3;inputError=(_inputError3=inputError)!==null&&_inputError3!==void 0?_inputError3:'Enter a recipient';}else{if(BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo)!==-1||bestTradeExactIn&&involvesAddress(bestTradeExactIn,formattedTo)||bestTradeExactOut&&involvesAddress(bestTradeExactOut,formattedTo)){var _inputError4;inputError=(_inputError4=inputError)!==null&&_inputError4!==void 0?_inputError4:'Invalid recipient';}}const[allowedSlippage]=useUserSlippageTolerance();const slippageAdjustedAmounts=v2Trade&&allowedSlippage&&computeSlippageAdjustedAmounts(v2Trade,allowedSlippage);// compare input balance to max input based on version\nconst[balanceIn,amountIn]=[currencyBalances[Field.INPUT],slippageAdjustedAmounts?slippageAdjustedAmounts[Field.INPUT]:null];let showRamp=false;if(balanceIn&&amountIn&&balanceIn.lessThan(amountIn)){if(amountIn.currency.address===cUSD[network.chainId].address||amountIn.currency.address===CELO[network.chainId].address||amountIn.currency.address===cEUR[network.chainId].address){showRamp=true;}inputError='Insufficient '+amountIn.currency.symbol+' balance';}return{currencies,currencyBalances,parsedAmount,v2Trade:v2Trade!==null&&v2Trade!==void 0?v2Trade:undefined,showRamp,inputError};}function parseCurrencyFromURLParameter(urlParam,chainId){var _cUSD$chainId$address;if(typeof urlParam==='string'){const valid=isAddress(urlParam);if(valid)return valid;if(urlParam.toUpperCase()==='CUSD')return cUSD[chainId].address;if(valid===false)return cUSD[chainId].address;}return(_cUSD$chainId$address=cUSD[chainId].address)!==null&&_cUSD$chainId$address!==void 0?_cUSD$chainId$address:'';}function parseTokenAmountURLParameter(urlParam){return typeof urlParam==='string'&&!isNaN(parseFloat(urlParam))?urlParam:'';}function parseIndependentFieldURLParameter(urlParam){return typeof urlParam==='string'&&urlParam.toLowerCase()==='output'?Field.OUTPUT:Field.INPUT;}const ENS_NAME_REGEX=/^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;const ADDRESS_REGEX=/^0x[a-fA-F0-9]{40}$/;function validatedRecipient(recipient){if(typeof recipient!=='string')return null;const address=isAddress(recipient);if(address)return address;if(ENS_NAME_REGEX.test(recipient))return recipient;if(ADDRESS_REGEX.test(recipient))return recipient;return null;}export function queryParametersToSwapState(parsedQs,chainId){let inputCurrency=parseCurrencyFromURLParameter(parsedQs.inputCurrency,chainId);let outputCurrency=parseCurrencyFromURLParameter(parsedQs.outputCurrency,chainId);if(inputCurrency===outputCurrency){if(typeof parsedQs.outputCurrency==='string'){inputCurrency='';}else{outputCurrency='';}}const recipient=validatedRecipient(parsedQs.recipient);return{[Field.INPUT]:{currencyId:inputCurrency},[Field.OUTPUT]:{currencyId:outputCurrency},typedValue:parseTokenAmountURLParameter(parsedQs.exactAmount),independentField:parseIndependentFieldURLParameter(parsedQs.exactField),recipient};}// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch(){const{network}=useCelo();const chainId=network.chainId;const dispatch=useDispatch();const parsedQs=useParsedQueryString();const[result,setResult]=useState();useEffect(()=>{if(!chainId)return;const parsed=queryParametersToSwapState(parsedQs,chainId);dispatch(replaceSwapState({typedValue:parsed.typedValue,field:parsed.independentField,inputCurrencyId:parsed[Field.INPUT].currencyId,outputCurrencyId:parsed[Field.OUTPUT].currencyId,recipient:parsed.recipient}));setResult({inputCurrencyId:parsed[Field.INPUT].currencyId,outputCurrencyId:parsed[Field.OUTPUT].currencyId});// eslint-disable-next-line react-hooks/exhaustive-deps\n},[dispatch,chainId]);return result;}","map":null,"metadata":{},"sourceType":"module"}