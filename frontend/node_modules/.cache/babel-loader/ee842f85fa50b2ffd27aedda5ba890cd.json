{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.packedNodeRootsToBytes = exports.packedRootsBytesToLeafNodes = exports.packedRootsBytesToNode = void 0;\nconst subtree_1 = require(\"./subtree\");\nconst node_1 = require(\"./node\");\nfunction packedRootsBytesToNode(depth, dataView, start, end) {\n  const leafNodes = packedRootsBytesToLeafNodes(dataView, start, end);\n  return subtree_1.subtreeFillToContents(leafNodes, depth);\n}\nexports.packedRootsBytesToNode = packedRootsBytesToNode;\n/**\n * Optimized deserialization of linear bytes to consecutive leaf nodes\n */\nfunction packedRootsBytesToLeafNodes(dataView, start, end) {\n  const size = end - start;\n  // If the offset in data is not a multiple of 4, Uint32Array can't be used\n  // > start offset of Uint32Array should be a multiple of 4\n  // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n  const fullNodeCount = Math.floor(size / 32);\n  const leafNodes = new Array(Math.ceil(size / 32));\n  // Efficiently construct the tree writing to hashObjects directly\n  // TODO: Optimize, with this approach each h property is written twice\n  for (let i = 0; i < fullNodeCount; i++) {\n    const offset = start + i * 32;\n    leafNodes[i] = new node_1.LeafNode(dataView.getInt32(offset + 0, true), dataView.getInt32(offset + 4, true), dataView.getInt32(offset + 8, true), dataView.getInt32(offset + 12, true), dataView.getInt32(offset + 16, true), dataView.getInt32(offset + 20, true), dataView.getInt32(offset + 24, true), dataView.getInt32(offset + 28, true));\n  }\n  // Consider that the last node may only include partial data\n  const remainderBytes = size % 32;\n  // Last node\n  if (remainderBytes > 0) {\n    const node = new node_1.LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n    leafNodes[fullNodeCount] = node;\n    // Loop to dynamically copy the full h values\n    const fullHCount = Math.floor(remainderBytes / 4);\n    for (let h = 0; h < fullHCount; h++) {\n      node_1.setNodeH(node, h, dataView.getInt32(start + fullNodeCount * 32 + h * 4, true));\n    }\n    const remainderUint32 = size % 4;\n    if (remainderUint32 > 0) {\n      let h = 0;\n      for (let i = 0; i < remainderUint32; i++) {\n        h |= dataView.getUint8(start + size - remainderUint32 + i) << i * 8;\n      }\n      node_1.setNodeH(node, fullHCount, h);\n    }\n  }\n  return leafNodes;\n}\nexports.packedRootsBytesToLeafNodes = packedRootsBytesToLeafNodes;\n/**\n * Optimized serialization of consecutive leave nodes to linear bytes\n */\nfunction packedNodeRootsToBytes(dataView, start, size, nodes) {\n  // If the offset in data is not a multiple of 4, Uint32Array can't be used\n  // > start offset of Uint32Array should be a multiple of 4\n  // NOTE: Performance tests show that using a DataView is as fast as Uint32Array\n  // Consider that the last node may only include partial data\n  const remainderBytes = size % 32;\n  // Full nodes\n  // Efficiently get hashObjects data into data\n  const fullNodeCount = Math.floor(size / 32);\n  for (let i = 0; i < fullNodeCount; i++) {\n    const node = nodes[i];\n    const offset = start + i * 32;\n    dataView.setInt32(offset + 0, node.h0, true);\n    dataView.setInt32(offset + 4, node.h1, true);\n    dataView.setInt32(offset + 8, node.h2, true);\n    dataView.setInt32(offset + 12, node.h3, true);\n    dataView.setInt32(offset + 16, node.h4, true);\n    dataView.setInt32(offset + 20, node.h5, true);\n    dataView.setInt32(offset + 24, node.h6, true);\n    dataView.setInt32(offset + 28, node.h7, true);\n  }\n  // Last node\n  if (remainderBytes > 0) {\n    const node = nodes[fullNodeCount];\n    // Loop to dynamically copy the full h values\n    const fullHCount = Math.floor(remainderBytes / 4);\n    for (let h = 0; h < fullHCount; h++) {\n      dataView.setInt32(start + fullNodeCount * 32 + h * 4, node_1.getNodeH(node, h), true);\n    }\n    const remainderUint32 = size % 4;\n    if (remainderUint32 > 0) {\n      const h = node_1.getNodeH(node, fullHCount);\n      for (let i = 0; i < remainderUint32; i++) {\n        dataView.setUint8(start + size - remainderUint32 + i, h >> i * 8 & 0xff);\n      }\n    }\n  }\n}\nexports.packedNodeRootsToBytes = packedNodeRootsToBytes;","map":null,"metadata":{},"sourceType":"script"}