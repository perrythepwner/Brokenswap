{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBasicType = exports.BasicType = void 0;\nconst abstract_1 = require(\"./abstract\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * Represents a basic type as defined in the spec:\n * https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#basic-types\n */\nclass BasicType extends abstract_1.Type {\n  constructor() {\n    super(...arguments);\n    this.isBasic = true;\n    // Basic types merkleize to exactly one chunk, thus depth of 0\n    this.depth = 0;\n    // Basic types merkleize to exactly one chunk\n    this.maxChunkCount = 1;\n  }\n  value_serializedSize() {\n    return this.byteLength;\n  }\n  tree_serializedSize() {\n    return this.byteLength;\n  }\n  assertValidSize(size) {\n    if (size !== this.byteLength) {\n      throw Error(\"BasicType invalid size \".concat(size, \" expected \").concat(this.byteLength));\n    }\n  }\n  hashTreeRoot(value) {\n    // TODO: Optimize\n    const uint8Array = new Uint8Array(32);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    this.value_serializeToBytes({\n      uint8Array,\n      dataView\n    }, 0, value);\n    return uint8Array;\n  }\n  clone(value) {\n    // All basic types are represented by primitive Javascript types, don't require clone\n    return value;\n  }\n  equals(a, b) {\n    // All basic types are represented by primitive Javascript types, the operator === is sufficient\n    return a === b;\n  }\n}\nexports.BasicType = BasicType;\nfunction isBasicType(type) {\n  return type.isBasic;\n}\nexports.isBasicType = isBasicType;","map":null,"metadata":{},"sourceType":"script"}