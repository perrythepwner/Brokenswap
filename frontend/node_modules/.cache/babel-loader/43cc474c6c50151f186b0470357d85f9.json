{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must match format \\\"\", \"\\\"\"])), schemaCode);\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{format: \", \"}\"])), schemaCode);\n  }\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, schemaCode));\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\");\n      // TODO simplify\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" == \\\"object\\\" && !(\", \" instanceof RegExp)\"])), fDef, fDef), () => gen.assign(fType, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".type || \\\"string\\\"\"])), fDef)).assign(format, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".validate\"])), fDef)), () => gen.assign(fType, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\\\"string\\\"\"])))).assign(format, fDef));\n      cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" && !\", \"\"])), schemaCode, format);\n      }\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"(\", \".async ? await \", \"(\", \") : \", \"(\", \"))\"])), fDef, format, data, format, data) : (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), format, data);\n        const validData = (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"(typeof \", \" == \\\"function\\\" ? \", \" : \", \".test(\", \"))\"])), format, callFormat, format, data);\n        return (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" && \", \" !== true && \", \" === \", \" && !\", \"\"])), format, format, fType, ruleType, validData);\n      }\n    }\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n        throw new Error(unknownMsg());\n        function unknownMsg() {\n          return \"unknown format \\\"\".concat(schema, \"\\\" ignored in schema at path \\\"\").concat(errSchemaPath, \"\\\"\");\n        }\n      }\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, (0, codegen_1.getProperty)(schema)) : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \".validate\"])), fmt)];\n        }\n        return [\"string\", fmtDef, fmt];\n      }\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"await \", \"(\", \")\"])), fmtRef, data);\n        }\n        return typeof format == \"function\" ? (0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \"(\", \")\"])), fmtRef, data) : (0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), fmtRef, data);\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/format/format.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map"]},"metadata":{},"sourceType":"script"}