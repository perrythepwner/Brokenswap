{"ast":null,"code":"import { currencyEquals, TokenAmount, Trade } from '@ubeswap/sdk';\nimport { ONE_HUNDRED_PERCENT, ZERO_PERCENT } from 'constants/index';\nimport { getMoolaDual } from '../moola/useMoola';\nimport { MoolaRouterTrade } from './useTrade';\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\n// does not check currency matching\nexport function isDualTradeBetter(tradeA, tradeB) {\n  let minimumDelta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ZERO_PERCENT;\n  if (tradeA && !tradeB) return false;\n  if (tradeB && !tradeA) return true;\n  if (!tradeA || !tradeB) return undefined;\n  const inTokenA = tradeA.inputAmount.token;\n  const inTokenB = tradeB.inputAmount.token;\n  const outTokenA = tradeA.outputAmount.token;\n  const outTokenB = tradeB.outputAmount.token;\n  if (tradeA.tradeType !== tradeB.tradeType || !currencyEquals(inTokenA, inTokenB) || !currencyEquals(outTokenA, outTokenB)) {\n    throw new Error('Trades are not comparable');\n  }\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice);\n  } else {\n    return tradeA.executionPrice.raw.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice);\n  }\n}\nexport const bestTradeExactOut = (pairs, tokenIn, tokenAmountOut, directTrade, options) => {\n  var _filter$reduce;\n  const inDual = tokenIn && getMoolaDual(tokenIn);\n  const outDual = tokenAmountOut && getMoolaDual(tokenAmountOut.token);\n  const inDualTrades = inDual ? Trade.bestTradeExactOut(pairs.slice(), inDual, tokenAmountOut, options).map(trade => new MoolaRouterTrade(tokenIn, null, trade)) : [];\n  const outDualTrades = outDual ? Trade.bestTradeExactOut(pairs.slice(), tokenIn, new TokenAmount(outDual, tokenAmountOut.raw), options).map(trade => new MoolaRouterTrade(null, tokenAmountOut.token, trade)) : [];\n  const inAndOutDualTrades = inDual && outDual ? Trade.bestTradeExactOut(pairs.slice(), inDual, new TokenAmount(outDual, tokenAmountOut.raw), options).map(trade => new MoolaRouterTrade(tokenIn, tokenAmountOut.token, trade)) : [];\n  return (_filter$reduce = [directTrade, inDualTrades[0], outDualTrades[0], inAndOutDualTrades[0]].filter(x => !!x).reduce((best, trade) => isDualTradeBetter(best, trade, options === null || options === void 0 ? void 0 : options.minimumDelta) ? trade : best, null)) !== null && _filter$reduce !== void 0 ? _filter$reduce : null;\n};\nexport const bestTradeExactIn = (pairs, tokenAmountIn, tokenOut, directTrade, options) => {\n  var _filter$reduce2;\n  const inDual = tokenAmountIn && getMoolaDual(tokenAmountIn.token);\n  const outDual = tokenOut && getMoolaDual(tokenOut);\n  const inDualTrades = inDual ? Trade.bestTradeExactIn(pairs.slice(), new TokenAmount(inDual, tokenAmountIn.raw), tokenOut, options).map(trade => new MoolaRouterTrade(tokenAmountIn.token, null, trade)) : [];\n  const outDualTrades = outDual ? Trade.bestTradeExactIn(pairs.slice(), tokenAmountIn, outDual, options).map(trade => new MoolaRouterTrade(null, tokenOut, trade)) : [];\n  const inAndOutDualTrades = inDual && outDual ? Trade.bestTradeExactIn(pairs.slice(), new TokenAmount(inDual, tokenAmountIn.raw), outDual, options).map(trade => new MoolaRouterTrade(tokenAmountIn.token, tokenOut, trade)) : [];\n  return (_filter$reduce2 = [directTrade, inDualTrades[0], outDualTrades[0], inAndOutDualTrades[0]].filter(x => !!x).reduce((best, trade) => best === null || isDualTradeBetter(best, trade, options === null || options === void 0 ? void 0 : options.minimumDelta) ? trade : best, null)) !== null && _filter$reduce2 !== void 0 ? _filter$reduce2 : null;\n};","map":{"version":3,"names":["currencyEquals","TokenAmount","Trade","ONE_HUNDRED_PERCENT","ZERO_PERCENT","getMoolaDual","MoolaRouterTrade","isDualTradeBetter","tradeA","tradeB","minimumDelta","arguments","length","undefined","inTokenA","inputAmount","token","inTokenB","outTokenA","outputAmount","outTokenB","tradeType","Error","equalTo","executionPrice","lessThan","raw","multiply","add","bestTradeExactOut","pairs","tokenIn","tokenAmountOut","directTrade","options","_filter$reduce","inDual","outDual","inDualTrades","slice","map","trade","outDualTrades","inAndOutDualTrades","filter","x","reduce","best","bestTradeExactIn","tokenAmountIn","tokenOut","_filter$reduce2"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/hooks/calculateBestTrades.ts"],"sourcesContent":["import { BestTradeOptions, currencyEquals, Pair, Percent, Token, TokenAmount, Trade } from '@ubeswap/sdk'\nimport { ONE_HUNDRED_PERCENT, ZERO_PERCENT } from 'constants/index'\n\nimport { getMoolaDual } from '../moola/useMoola'\nimport { UbeswapTrade } from '../trade'\nimport { MoolaRouterTrade } from './useTrade'\n\n// returns whether tradeB is better than tradeA by at least a threshold percentage amount\n// does not check currency matching\nexport function isDualTradeBetter(\n  tradeA: UbeswapTrade | undefined | null,\n  tradeB: UbeswapTrade | undefined | null,\n  minimumDelta: Percent = ZERO_PERCENT\n): boolean | undefined {\n  if (tradeA && !tradeB) return false\n  if (tradeB && !tradeA) return true\n\n  if (!tradeA || !tradeB) return undefined\n\n  const inTokenA = tradeA.inputAmount.token\n  const inTokenB = tradeB.inputAmount.token\n\n  const outTokenA = tradeA.outputAmount.token\n  const outTokenB = tradeB.outputAmount.token\n\n  if (\n    tradeA.tradeType !== tradeB.tradeType ||\n    !currencyEquals(inTokenA, inTokenB) ||\n    !currencyEquals(outTokenA, outTokenB)\n  ) {\n    throw new Error('Trades are not comparable')\n  }\n\n  if (minimumDelta.equalTo(ZERO_PERCENT)) {\n    return tradeA.executionPrice.lessThan(tradeB.executionPrice)\n  } else {\n    return tradeA.executionPrice.raw.multiply(minimumDelta.add(ONE_HUNDRED_PERCENT)).lessThan(tradeB.executionPrice)\n  }\n}\n\ninterface BestUbeswapTradeOptions extends BestTradeOptions {\n  minimumDelta?: Percent\n}\n\nexport const bestTradeExactOut = (\n  pairs: readonly Pair[],\n  tokenIn: Token,\n  tokenAmountOut: TokenAmount,\n  directTrade: UbeswapTrade | null,\n  options?: BestUbeswapTradeOptions\n): UbeswapTrade | null => {\n  const inDual = tokenIn && getMoolaDual(tokenIn)\n  const outDual = tokenAmountOut && getMoolaDual(tokenAmountOut.token)\n\n  const inDualTrades = inDual\n    ? Trade.bestTradeExactOut(pairs.slice(), inDual, tokenAmountOut, options).map(\n        (trade) => new MoolaRouterTrade(tokenIn, null, trade)\n      )\n    : []\n  const outDualTrades = outDual\n    ? Trade.bestTradeExactOut(pairs.slice(), tokenIn, new TokenAmount(outDual, tokenAmountOut.raw), options).map(\n        (trade) => new MoolaRouterTrade(null, tokenAmountOut.token, trade)\n      )\n    : []\n  const inAndOutDualTrades =\n    inDual && outDual\n      ? Trade.bestTradeExactOut(pairs.slice(), inDual, new TokenAmount(outDual, tokenAmountOut.raw), options).map(\n          (trade) => new MoolaRouterTrade(tokenIn, tokenAmountOut.token, trade)\n        )\n      : []\n\n  return (\n    [directTrade, inDualTrades[0], outDualTrades[0], inAndOutDualTrades[0]]\n      .filter((x) => !!x)\n      .reduce(\n        (best: UbeswapTrade | null, trade) => (isDualTradeBetter(best, trade, options?.minimumDelta) ? trade : best),\n        null\n      ) ?? null\n  )\n}\n\nexport const bestTradeExactIn = (\n  pairs: readonly Pair[],\n  tokenAmountIn: TokenAmount,\n  tokenOut: Token,\n  directTrade: UbeswapTrade | null,\n  options?: BestUbeswapTradeOptions\n): UbeswapTrade | null => {\n  const inDual = tokenAmountIn && getMoolaDual(tokenAmountIn.token)\n  const outDual = tokenOut && getMoolaDual(tokenOut)\n\n  const inDualTrades = inDual\n    ? Trade.bestTradeExactIn(pairs.slice(), new TokenAmount(inDual, tokenAmountIn.raw), tokenOut, options).map(\n        (trade) => new MoolaRouterTrade(tokenAmountIn.token, null, trade)\n      )\n    : []\n  const outDualTrades = outDual\n    ? Trade.bestTradeExactIn(pairs.slice(), tokenAmountIn, outDual, options).map(\n        (trade) => new MoolaRouterTrade(null, tokenOut, trade)\n      )\n    : []\n  const inAndOutDualTrades =\n    inDual && outDual\n      ? Trade.bestTradeExactIn(pairs.slice(), new TokenAmount(inDual, tokenAmountIn.raw), outDual, options).map(\n          (trade) => new MoolaRouterTrade(tokenAmountIn.token, tokenOut, trade)\n        )\n      : []\n\n  return (\n    [directTrade, inDualTrades[0], outDualTrades[0], inAndOutDualTrades[0]]\n      .filter((x) => !!x)\n      .reduce(\n        (best: UbeswapTrade | null, trade) =>\n          best === null || isDualTradeBetter(best, trade, options?.minimumDelta) ? trade : best,\n        null\n      ) ?? null\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}