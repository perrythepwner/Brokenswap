{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;\nconst node_1 = require(\"./node\");\nconst zeroNode_1 = require(\"./zeroNode\");\nfunction subtreeFillToDepth(bottom, depth) {\n  let node = bottom;\n  while (depth > 0) {\n    node = new node_1.BranchNode(node, node);\n    depth--;\n  }\n  return node;\n}\nexports.subtreeFillToDepth = subtreeFillToDepth;\nfunction subtreeFillToLength(bottom, depth, length) {\n  const maxLength = 1 << depth;\n  if (length > maxLength) throw new Error(\"ERR_TOO_MANY_NODES\");\n  if (length === maxLength) return subtreeFillToDepth(bottom, depth);\n  if (depth === 0) {\n    if (length === 1) return bottom;else throw new Error(\"ERR_NAVIGATION\");\n  }\n  if (depth === 1) {\n    return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));\n  }\n  const pivot = maxLength >> 1;\n  if (length <= pivot) {\n    return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));\n  } else {\n    return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));\n  }\n}\nexports.subtreeFillToLength = subtreeFillToLength;\n/**\n * WARNING: Mutates the provided nodes array.\n * TODO: Don't mutate the nodes array.\n */\nfunction subtreeFillToContents(nodes, depth) {\n  const maxLength = 2 ** depth;\n  if (nodes.length > maxLength) {\n    throw new Error(\"nodes.length \".concat(nodes.length, \" over maxIndex at depth \").concat(depth));\n  }\n  if (nodes.length === 0) {\n    return zeroNode_1.zeroNode(depth);\n  }\n  if (depth === 0) {\n    return nodes[0];\n  }\n  if (depth === 1) {\n    return nodes.length > 1 ?\n    // All nodes at depth 1 available\n    new node_1.BranchNode(nodes[0], nodes[1]) :\n    // Pad with zero node\n    new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0));\n  }\n  let count = nodes.length;\n  for (let d = depth; d > 0; d--) {\n    const countRemainder = count % 2;\n    const countEven = count - countRemainder;\n    // For each depth level compute the new BranchNodes and overwrite the nodes array\n    for (let i = 0; i < countEven; i += 2) {\n      nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n    }\n    if (countRemainder > 0) {\n      nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));\n    }\n    // If there was remainer, 2 nodes are added to the count\n    count = countEven / 2 + countRemainder;\n  }\n  return nodes[0];\n}\nexports.subtreeFillToContents = subtreeFillToContents;","map":{"version":3,"names":["Object","defineProperty","exports","value","subtreeFillToContents","subtreeFillToLength","subtreeFillToDepth","node_1","require","zeroNode_1","bottom","depth","node","BranchNode","length","maxLength","Error","zeroNode","pivot","nodes","concat","count","d","countRemainder","countEven","i"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;\nconst node_1 = require(\"./node\");\nconst zeroNode_1 = require(\"./zeroNode\");\nfunction subtreeFillToDepth(bottom, depth) {\n    let node = bottom;\n    while (depth > 0) {\n        node = new node_1.BranchNode(node, node);\n        depth--;\n    }\n    return node;\n}\nexports.subtreeFillToDepth = subtreeFillToDepth;\nfunction subtreeFillToLength(bottom, depth, length) {\n    const maxLength = 1 << depth;\n    if (length > maxLength)\n        throw new Error(\"ERR_TOO_MANY_NODES\");\n    if (length === maxLength)\n        return subtreeFillToDepth(bottom, depth);\n    if (depth === 0) {\n        if (length === 1)\n            return bottom;\n        else\n            throw new Error(\"ERR_NAVIGATION\");\n    }\n    if (depth === 1) {\n        return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));\n    }\n    const pivot = maxLength >> 1;\n    if (length <= pivot) {\n        return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));\n    }\n    else {\n        return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));\n    }\n}\nexports.subtreeFillToLength = subtreeFillToLength;\n/**\n * WARNING: Mutates the provided nodes array.\n * TODO: Don't mutate the nodes array.\n */\nfunction subtreeFillToContents(nodes, depth) {\n    const maxLength = 2 ** depth;\n    if (nodes.length > maxLength) {\n        throw new Error(`nodes.length ${nodes.length} over maxIndex at depth ${depth}`);\n    }\n    if (nodes.length === 0) {\n        return zeroNode_1.zeroNode(depth);\n    }\n    if (depth === 0) {\n        return nodes[0];\n    }\n    if (depth === 1) {\n        return nodes.length > 1\n            ? // All nodes at depth 1 available\n                new node_1.BranchNode(nodes[0], nodes[1])\n            : // Pad with zero node\n                new node_1.BranchNode(nodes[0], zeroNode_1.zeroNode(0));\n    }\n    let count = nodes.length;\n    for (let d = depth; d > 0; d--) {\n        const countRemainder = count % 2;\n        const countEven = count - countRemainder;\n        // For each depth level compute the new BranchNodes and overwrite the nodes array\n        for (let i = 0; i < countEven; i += 2) {\n            nodes[i / 2] = new node_1.BranchNode(nodes[i], nodes[i + 1]);\n        }\n        if (countRemainder > 0) {\n            nodes[countEven / 2] = new node_1.BranchNode(nodes[countEven], zeroNode_1.zeroNode(depth - d));\n        }\n        // If there was remainer, 2 nodes are added to the count\n        count = countEven / 2 + countRemainder;\n    }\n    return nodes[0];\n}\nexports.subtreeFillToContents = subtreeFillToContents;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}