{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListBasicType = void 0;\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst listBasic_1 = require(\"../view/listBasic\");\nconst listBasic_2 = require(\"../viewDU/listBasic\");\nconst array_1 = require(\"./array\");\n/**\n * List: ordered variable-length homogeneous collection, limited to N values\n *\n * Array of Basic type:\n * - Basic types are max 32 bytes long so multiple values may be packed in the same node.\n * - Basic types are never returned in a view wrapper, but their value representation\n */\nclass ListBasicType extends array_1.ArrayType {\n  constructor(elementType, limit, opts) {\n    var _opts$typeName;\n    super(elementType);\n    this.elementType = elementType;\n    this.limit = limit;\n    this.fixedSize = null;\n    this.isList = true;\n    this.isViewMutable = true;\n    this.defaultLen = 0;\n    if (!elementType.isBasic) throw Error(\"elementType must be basic\");\n    if (limit === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"List[\".concat(elementType.typeName, \", \").concat(limit, \"]\");\n    // TODO Check that itemsPerChunk is an integer\n    this.itemsPerChunk = 32 / elementType.byteLength;\n    this.maxChunkCount = Math.ceil(this.limit * elementType.byteLength / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Depth includes the extra level for the length node\n    this.depth = this.chunkDepth + 1;\n    this.minSize = 0;\n    this.maxSize = this.limit * elementType.maxSize;\n  }\n  static named(elementType, limit, opts) {\n    return new (named_1.namedClass(ListBasicType, opts.typeName))(elementType, limit, opts);\n  }\n  getView(tree) {\n    return new listBasic_1.ListBasicTreeView(this, tree);\n  }\n  getViewDU(node, cache) {\n    // cache type should be validated (if applicate) in the view\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new listBasic_2.ListBasicTreeViewDU(this, node, cache);\n  }\n  commitView(view) {\n    return view.node;\n  }\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n  // Serialization + deserialization\n  value_serializedSize(value) {\n    return value.length * this.elementType.byteLength;\n  }\n  value_serializeToBytes(output, offset, value) {\n    return arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value.length, output, offset, value);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    return arrayBasic_1.value_deserializeFromBytesArrayBasic(this.elementType, data, start, end, this);\n  }\n  tree_serializedSize(node) {\n    return this.tree_getLength(node) * this.elementType.byteLength;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = this.tree_getChunksNode(node);\n    const length = this.tree_getLength(node);\n    return arrayBasic_1.tree_serializeToBytesArrayBasic(this.elementType, length, this.chunkDepth, output, offset, chunksNode);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    return arrayBasic_1.tree_deserializeFromBytesArrayBasic(this.elementType, this.chunkDepth, data, start, end, this);\n  }\n  // Helpers for TreeView\n  tree_getLength(node) {\n    return node.right.getUint(4, 0);\n  }\n  tree_setLength(tree, length) {\n    tree.rootNode = arrayBasic_1.addLengthNode(tree.rootNode.left, length);\n  }\n  tree_getChunksNode(node) {\n    return node.left;\n  }\n  tree_setChunksNode(rootNode, chunksNode, newLength) {\n    return arrayBasic_1.setChunksNode(rootNode, chunksNode, newLength);\n  }\n  // Merkleization\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.length);\n  }\n  getRoots(value) {\n    const uint8Array = new Uint8Array(this.value_serializedSize(value));\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    arrayBasic_1.value_serializeToBytesArrayBasic(this.elementType, value.length, {\n      uint8Array,\n      dataView\n    }, 0, value);\n    return merkleize_1.splitIntoRootChunks(uint8Array);\n  }\n}\nexports.ListBasicType = ListBasicType;","map":null,"metadata":{},"sourceType":"script"}