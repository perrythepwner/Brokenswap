{"ast":null,"code":"import { Trie } from \"@wry/trie\";\nimport { canUseWeakMap } from \"../../utilities/index.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nvar SuspenseCache = function () {\n  function SuspenseCache(options) {\n    if (options === void 0) {\n      options = Object.create(null);\n    }\n    this.queryRefs = new Trie(canUseWeakMap);\n    this.options = options;\n  }\n  SuspenseCache.prototype.getQueryRef = function (cacheKey, createObservable) {\n    var ref = this.queryRefs.lookupArray(cacheKey);\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        key: cacheKey,\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: function onDispose() {\n          delete ref.current;\n        }\n      });\n    }\n    return ref.current;\n  };\n  return SuspenseCache;\n}();\nexport { SuspenseCache };","map":{"version":3,"sources":["../../../src/react/cache/SuspenseCache.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,QAAQ,WAAW;AAEhC,SAAS,aAAa,QAAQ,0BAA0B;AACxD,SAAS,sBAAsB,QAAQ,qBAAqB;AAiB5D,IAAA,aAAA,GAAA,YAAA;EAME,SAAA,aAAA,CAAY,OAAmD,EAAA;IAAnD,IAAA,OAAA,KAAA,KAAA,CAAA,EAAA;MAAA,OAAA,GAAgC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;IAAA;IALvD,IAAA,CAAA,SAAS,GAAG,IAAI,IAAI,CAC1B,aAAa,CACd;IAIC,IAAI,CAAC,OAAO,GAAG,OAAO;EACxB;EAEA,aAAA,CAAA,SAAA,CAAA,WAAW,GAAX,UACE,QAAkB,EAClB,gBAA8C,EAAA;IAE9C,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC;IAEhD,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE;MAChB,GAAG,CAAC,OAAO,GAAG,IAAI,sBAAsB,CAAC,gBAAgB,CAAA,CAAE,EAAE;QAC3D,GAAG,EAAE,QAAQ;QACb,oBAAoB,EAAE,IAAI,CAAC,OAAO,CAAC,oBAAoB;QACvD,SAAS,EAAE,SAAA,UAAA,EAAA;UACT,OAAO,GAAG,CAAC,OAAO;QACpB;OACD,CAAC;IACH;IAED,OAAO,GAAG,CAAC,OAAwC;EACrD,CAAC;EACH,OAAA,aAAC;AAAD,CAAC,CAAA,CAAA","sourcesContent":["import { Trie } from \"@wry/trie\";\nimport type { ObservableQuery } from \"../../core/index.js\";\nimport { canUseWeakMap } from \"../../utilities/index.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>(\n    canUseWeakMap\n  );\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = Object.create(null)) {\n    this.options = options;\n  }\n\n  getQueryRef<TData = any>(\n    cacheKey: CacheKey,\n    createObservable: () => ObservableQuery<TData>\n  ) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        key: cacheKey,\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current as InternalQueryReference<TData>;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}