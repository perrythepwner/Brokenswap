{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo,useProvider}from'@celo/react-celo';import{currencyEquals,JSBI,Pair,Percent,Price,Token,TokenAmount,TradeType}from'@ubeswap/sdk';import{ERC20_ABI}from'constants/abis/erc20';import{BASES_TO_CHECK_TRADES_AGAINST,BETTER_TRADE_LESS_HOPS_THRESHOLD,DEXES_TO_EXCLUDE,FETCH_MINIMA_ROUTER_TIMER,MINIMA_API_URL,UBESWAP_MOOLA_ROUTER_ADDRESS}from'constants/index';import{PairState,usePairs}from'data/Reserves';import{BigNumber,ethers}from'ethers';import{useAllTokens}from'hooks/Tokens';import _ from'lodash';import flatMap from'lodash.flatmap';import React,{useMemo}from'react';import{useUserDisableSmartRouting,useUserSingleHopOnly,useUserSlippageTolerance}from'state/user/hooks';import{getProviderOrSigner,isBTest}from'utils';import{isTradeBetter}from'utils/trades';import{MoolaDirectTrade}from'../moola/MoolaDirectTrade';import{getMoolaDual}from'../moola/useMoola';import{useMoolaDirectRoute}from'../moola/useMoolaDirectRoute';import{UbeswapTrade}from'../trade';import{MinimaRouterTrade}from'./../trade';import{bestTradeExactIn,bestTradeExactOut}from'./calculateBestTrades';import{useDirectTradeExactIn,useDirectTradeExactOut}from'./directTrades';/**\n * Uses all common pairs between the two tokens, plus searches the moola duals\n * @param tokenA\n * @param tokenB\n * @returns\n */export function useAllCommonPairsWithMoolaDuals(tokenA,tokenB){const{network}=useCelo();const chainId=network.chainId;const bases=useMemo(()=>chainId?BASES_TO_CHECK_TRADES_AGAINST[chainId]:[],[chainId]);const basePairs=useMemo(()=>flatMap(bases,base=>bases.map(otherBase=>[base,otherBase])).filter(_ref=>{var _getMoolaDual,_getMoolaDual2;let[t0,t1]=_ref;return t0.address!==t1.address&&// ensure we don't fetch duals\nt0.address!==((_getMoolaDual=getMoolaDual(t1))===null||_getMoolaDual===void 0?void 0:_getMoolaDual.address)&&t1.address!==((_getMoolaDual2=getMoolaDual(t0))===null||_getMoolaDual2===void 0?void 0:_getMoolaDual2.address);}),[bases]);const tokenADual=tokenA&&getMoolaDual(tokenA);const tokenBDual=tokenB&&getMoolaDual(tokenB);const allPairCombinations=useMemo(()=>tokenA&&tokenB?[// the direct pair\n[tokenA,tokenB],// token A against all bases\n...bases.map(base=>[tokenA,base]),// token B against all bases\n...bases.map(base=>[tokenB,base]),// each base against all bases\n...basePairs,// handle duals\n// direct pair\n...(tokenADual?[[tokenADual,tokenB]]:[]),...(tokenBDual?[[tokenA,tokenBDual]]:[]),...(tokenADual&&tokenBDual?[[tokenADual,tokenBDual]]:[]),// token A against all bases\n...bases.map(base=>[tokenA,base]),...(tokenADual?bases.map(base=>[tokenADual,base]):[]),// token B against all bases\n...bases.map(base=>[tokenB,base]),...(tokenBDual?bases.map(base=>[tokenBDual,base]):[])].filter(tokens=>Boolean(tokens[0]&&tokens[1])).filter(_ref2=>{let[t0,t1]=_ref2;return t0.address!==t1.address;}):[],[tokenA,tokenB,bases,basePairs,tokenADual,tokenBDual]);const allPairs=usePairs(allPairCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(()=>Object.values(allPairs// filter out invalid pairs\n.filter(result=>Boolean(result[0]===PairState.EXISTS&&result[1]))// filter out duplicated pairs\n.reduce((memo,_ref3)=>{var _memo$curr$liquidityT;let[,curr]=_ref3;memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{})),[allPairs]);}const MAX_HOPS=3;const moolaRouter={routerAddress:UBESWAP_MOOLA_ROUTER_ADDRESS};export class MoolaRouterTrade extends UbeswapTrade{/**\n   *\n   * @param originalTokenIn If null, the original token is the path token\n   * @param originalTokenOut If null, the original token is the path token\n   * @param innerTrade\n   */constructor(originalTokenIn,originalTokenOut,innerTrade){super(innerTrade.route,innerTrade.tradeType===TradeType.EXACT_INPUT?innerTrade.inputAmount:innerTrade.outputAmount,innerTrade.tradeType,moolaRouter,[...(originalTokenIn?[originalTokenIn]:[]),...innerTrade.route.path,...(originalTokenOut?[originalTokenOut]:[])]);this.originalTokenIn=originalTokenIn;this.originalTokenOut=originalTokenOut;this.innerTrade=innerTrade;this.inputAmount=void 0;this.outputAmount=void 0;this.executionPrice=void 0;this.inputAmount=new TokenAmount(originalTokenIn!==null&&originalTokenIn!==void 0?originalTokenIn:innerTrade.inputAmount.token,innerTrade.inputAmount.raw);this.outputAmount=new TokenAmount(originalTokenOut!==null&&originalTokenOut!==void 0?originalTokenOut:innerTrade.outputAmount.token,innerTrade.outputAmount.raw);const baseIsInput=currencyEquals(innerTrade.executionPrice.baseCurrency,innerTrade.inputAmount.token);this.executionPrice=new Price(baseIsInput?this.inputAmount.token:this.outputAmount.token,!baseIsInput?this.inputAmount.token:this.outputAmount.token,innerTrade.executionPrice.denominator,innerTrade.executionPrice.numerator);}/**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */minimumAmountOut(slippageTolerance){var _this$originalTokenOu;const amt=this.innerTrade.minimumAmountOut(slippageTolerance);return new TokenAmount((_this$originalTokenOu=this.originalTokenOut)!==null&&_this$originalTokenOu!==void 0?_this$originalTokenOu:amt.token,amt.raw);}/**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */maximumAmountIn(slippageTolerance){var _this$originalTokenIn;const amt=this.innerTrade.maximumAmountIn(slippageTolerance);return new TokenAmount((_this$originalTokenIn=this.originalTokenIn)!==null&&_this$originalTokenIn!==void 0?_this$originalTokenIn:amt.token,amt.raw);}}/**\n * Converts the trade to a Moola Router trade, if the original tokens are lost\n * @param originalTokenIn\n * @param originalTokenOut\n * @param trade\n * @returns\n */const convertToMoolaRouterTradeIfApplicable=(originalTokenIn,originalTokenOut,trade)=>{const inUnchanged=trade.inputAmount.token.address===originalTokenIn.address;const outUnchanged=trade.outputAmount.token.address===originalTokenOut.address;if(inUnchanged&&outUnchanged){return trade;}return new MoolaRouterTrade(inUnchanged?originalTokenIn:null,outUnchanged?originalTokenOut:null,trade);};/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useUbeswapTradeExactIn(tokenAmountIn,tokenOut){const[disableSmartRouting]=useUserDisableSmartRouting();const directTrade=useDirectTradeExactIn(tokenAmountIn,tokenOut);const allowedPairs=useAllCommonPairsWithMoolaDuals(tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.token,tokenOut);const[singleHopOnly]=useUserSingleHopOnly();const moolaRoute=useMoolaDirectRoute(tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.token,tokenOut);return useMemo(()=>{const bestTrade=(()=>{if(disableSmartRouting){return directTrade;}if(tokenAmountIn&&tokenOut&&allowedPairs.length>0){if(singleHopOnly){const singleHopTrade=bestTradeExactIn(allowedPairs.slice(),tokenAmountIn,tokenOut,directTrade,{maxHops:1,maxNumResults:1,minimumDelta:BETTER_TRADE_LESS_HOPS_THRESHOLD});return singleHopTrade?convertToMoolaRouterTradeIfApplicable(tokenAmountIn.token,tokenOut,singleHopTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){const currentTrade=bestTradeExactIn(allowedPairs.slice(),tokenAmountIn,tokenOut,directTrade,{maxHops:i,maxNumResults:1,minimumDelta:BETTER_TRADE_LESS_HOPS_THRESHOLD});// if current trade is best yet, save it\nif(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;})();if(moolaRoute&&tokenAmountIn){try{const moolaTrade=MoolaDirectTrade.fromIn(moolaRoute,tokenAmountIn);if(isTradeBetter(bestTrade,moolaTrade,new Percent('0'))){return moolaTrade;}}catch(e){console.warn(e);}}return bestTrade;},[allowedPairs,tokenAmountIn,tokenOut,singleHopOnly,directTrade,disableSmartRouting,moolaRoute]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useUbeswapTradeExactOut(tokenIn,tokenAmountOut){const[disableSmartRouting]=useUserDisableSmartRouting();const directTrade=useDirectTradeExactOut(tokenIn,tokenAmountOut);const allowedPairs=useAllCommonPairsWithMoolaDuals(tokenIn,tokenAmountOut===null||tokenAmountOut===void 0?void 0:tokenAmountOut.token);const[singleHopOnly]=useUserSingleHopOnly();const moolaRoute=useMoolaDirectRoute(tokenIn,tokenAmountOut===null||tokenAmountOut===void 0?void 0:tokenAmountOut.token);return useMemo(()=>{const bestTrade=(()=>{if(disableSmartRouting){return directTrade;}if(tokenIn&&tokenAmountOut&&allowedPairs.length>0){if(singleHopOnly){const singleHopTrade=bestTradeExactOut(allowedPairs.slice(),tokenIn,tokenAmountOut,directTrade,{maxHops:1,maxNumResults:1});return singleHopTrade?convertToMoolaRouterTradeIfApplicable(tokenIn,tokenAmountOut.token,singleHopTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){const currentTrade=bestTradeExactOut(allowedPairs.slice(),tokenIn,tokenAmountOut,directTrade,{maxHops:i,maxNumResults:1});if(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;})();if(moolaRoute&&tokenAmountOut){try{const moolaTrade=MoolaDirectTrade.fromOut(moolaRoute,tokenAmountOut);if(isTradeBetter(bestTrade,moolaTrade,new Percent('0'))){return moolaTrade;}}catch(e){console.warn(e);}}return bestTrade;},[tokenIn,tokenAmountOut,allowedPairs,singleHopOnly,directTrade,disableSmartRouting,moolaRoute]);}export function useMinimaTrade(tokenAmountIn,tokenOut){const[minimaTrade,setMinimaTrade]=React.useState(undefined);const[deps,setDeps]=React.useState(undefined);const[singleHopOnly]=useUserSingleHopOnly();const[allowedSlippage]=useUserSlippageTolerance();const[fetchUpdatedData,setFetchUpdatedData]=React.useState(true);const[fetchTimeout,setFetchTimeout]=React.useState(undefined);const{address:account,network}=useCelo();const chainId=network.chainId;const library=useProvider();const provider=getProviderOrSigner(library,account||undefined);const tokens=useAllTokens();const call=React.useCallback(/*#__PURE__*/_asyncToGenerator(function*(){var _tokenAmountIn$curren,_tokenOut$address,_process$env$REACT_AP;if(!(tokenAmountIn!==null&&tokenAmountIn!==void 0&&tokenAmountIn.currency.address)||!(tokenAmountIn!==null&&tokenAmountIn!==void 0&&tokenAmountIn.raw)||!(tokenOut!==null&&tokenOut!==void 0&&tokenOut.address)){setMinimaTrade(null);setDeps(undefined);return;}const curDeps={chainId,account:account||null,allowedSlippage,singleHopOnly,inputAddr:tokenAmountIn.currency.address,outputAddr:tokenOut.address,inputAmount:tokenAmountIn.raw.toString()};if(_.isEqual(deps,curDeps)&&!fetchUpdatedData){return;}if(!fetchUpdatedData){setMinimaTrade(undefined);}setDeps(curDeps);setFetchUpdatedData(false);// fetch information of minima router\nyield fetch(\"\".concat(MINIMA_API_URL,\"?exclude=\").concat(DEXES_TO_EXCLUDE,\"&tokenIn=\").concat((_tokenAmountIn$curren=tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.currency.address)!==null&&_tokenAmountIn$curren!==void 0?_tokenAmountIn$curren:'',\"&tokenOut=\").concat((_tokenOut$address=tokenOut===null||tokenOut===void 0?void 0:tokenOut.address)!==null&&_tokenOut$address!==void 0?_tokenOut$address:'',\"&amountIn=\").concat(tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.raw,\"&slippage=\").concat(allowedSlippage,\"&maxHops=\").concat(singleHopOnly?1:MAX_HOPS,\"&includeTxn=true&priceImpact=true\").concat(account?'&from='+account:''),{method:'GET',headers:{'Content-Type':'application/json','X-API-KEY':(_process$env$REACT_AP=process.env.REACT_APP_MINIMA_KEY)!==null&&_process$env$REACT_AP!==void 0?_process$env$REACT_AP:''}}).then(/*#__PURE__*/function(){var _ref5=_asyncToGenerator(function*(res){if(res.status!==200){setMinimaTrade(null);return;}yield res.json().then(/*#__PURE__*/function(){var _ref6=_asyncToGenerator(function*(data){if(data.details){var _data$minimumExpected;const path=yield Promise.all(data.details.path.map(/*#__PURE__*/function(){var _ref7=_asyncToGenerator(function*(pathItem){if(!tokens[pathItem]){// in case of a token address cannot be found on Ubeswap or Uniswap tokenlists\nconst tokenContract=new ethers.Contract(pathItem,ERC20_ABI,provider);const[tokenName,symbol,decimals]=yield Promise.all([tokenContract.name(),tokenContract.symbol(),tokenContract.decimals()]);return new Token(chainId,pathItem,decimals,symbol,tokenName);}return tokens[pathItem];});return function(_x3){return _ref7.apply(this,arguments);};}()));const trade=MinimaRouterTrade.fromMinimaTradePayload([new Pair(new TokenAmount(tokenAmountIn.currency,JSBI.BigInt(10000)),new TokenAmount(tokenOut,JSBI.BigInt(20000)))],tokenAmountIn,new TokenAmount(tokenOut,JSBI.BigInt(data.details.expectedOutputAmount.toString())),data.routerAddress,new Percent(JSBI.BigInt(data.priceImpact.numerator),JSBI.BigInt(data.priceImpact.denominator)),path,_objectSpread(_objectSpread({},data.details),{},{inputAmount:BigNumber.from(data.details.inputAmount),minOutputAmount:BigNumber.from((_data$minimumExpected=data.minimumExpectedOut)!==null&&_data$minimumExpected!==void 0?_data$minimumExpected:'0'),expectedOutputAmount:BigNumber.from(data.details.expectedOutputAmount),deadline:BigNumber.from(data.details.deadline)}));if(account&&isBTest(account)&&data.txn){var _data$txn,_data$txn2;trade.txn={to:(_data$txn=data.txn)===null||_data$txn===void 0?void 0:_data$txn.to,data:(_data$txn2=data.txn)===null||_data$txn2===void 0?void 0:_data$txn2.data};}setMinimaTrade(trade);clearTimeout(fetchTimeout);setFetchTimeout(setTimeout(()=>{setFetchUpdatedData(true);},FETCH_MINIMA_ROUTER_TIMER));}});return function(_x2){return _ref6.apply(this,arguments);};}()).catch(e=>{console.error(e);setMinimaTrade(null);});});return function(_x){return _ref5.apply(this,arguments);};}()).catch(e=>{console.error(e);setMinimaTrade(null);});}),[account,allowedSlippage,chainId,deps,fetchTimeout,fetchUpdatedData,provider,singleHopOnly,tokenAmountIn,tokenOut,tokens]);React.useEffect(()=>{call();},[call]);return minimaTrade;}","map":{"version":3,"names":["useCelo","useProvider","currencyEquals","JSBI","Pair","Percent","Price","Token","TokenAmount","TradeType","ERC20_ABI","BASES_TO_CHECK_TRADES_AGAINST","BETTER_TRADE_LESS_HOPS_THRESHOLD","DEXES_TO_EXCLUDE","FETCH_MINIMA_ROUTER_TIMER","MINIMA_API_URL","UBESWAP_MOOLA_ROUTER_ADDRESS","PairState","usePairs","BigNumber","ethers","useAllTokens","_","flatMap","React","useMemo","useUserDisableSmartRouting","useUserSingleHopOnly","useUserSlippageTolerance","getProviderOrSigner","isBTest","isTradeBetter","MoolaDirectTrade","getMoolaDual","useMoolaDirectRoute","UbeswapTrade","MinimaRouterTrade","bestTradeExactIn","bestTradeExactOut","useDirectTradeExactIn","useDirectTradeExactOut","useAllCommonPairsWithMoolaDuals","tokenA","tokenB","network","chainId","bases","basePairs","base","map","otherBase","filter","_ref","_getMoolaDual","_getMoolaDual2","t0","t1","address","tokenADual","tokenBDual","allPairCombinations","tokens","Boolean","_ref2","allPairs","Object","values","result","EXISTS","reduce","memo","_ref3","_memo$curr$liquidityT","curr","liquidityToken","MAX_HOPS","moolaRouter","routerAddress","MoolaRouterTrade","constructor","originalTokenIn","originalTokenOut","innerTrade","route","tradeType","EXACT_INPUT","inputAmount","outputAmount","path","executionPrice","token","raw","baseIsInput","baseCurrency","denominator","numerator","minimumAmountOut","slippageTolerance","_this$originalTokenOu","amt","maximumAmountIn","_this$originalTokenIn","convertToMoolaRouterTradeIfApplicable","trade","inUnchanged","outUnchanged","useUbeswapTradeExactIn","tokenAmountIn","tokenOut","disableSmartRouting","directTrade","allowedPairs","singleHopOnly","moolaRoute","bestTrade","length","singleHopTrade","slice","maxHops","maxNumResults","minimumDelta","bestTradeSoFar","i","currentTrade","moolaTrade","fromIn","e","console","warn","useUbeswapTradeExactOut","tokenIn","tokenAmountOut","fromOut","useMinimaTrade","minimaTrade","setMinimaTrade","useState","undefined","deps","setDeps","allowedSlippage","fetchUpdatedData","setFetchUpdatedData","fetchTimeout","setFetchTimeout","account","library","provider","call","useCallback","_asyncToGenerator","_tokenAmountIn$curren","_tokenOut$address","_process$env$REACT_AP","currency","curDeps","inputAddr","outputAddr","toString","isEqual","fetch","concat","method","headers","process","env","REACT_APP_MINIMA_KEY","then","_ref5","res","status","json","_ref6","data","details","_data$minimumExpected","Promise","all","_ref7","pathItem","tokenContract","Contract","tokenName","symbol","decimals","name","_x3","apply","arguments","fromMinimaTradePayload","BigInt","expectedOutputAmount","priceImpact","_objectSpread","from","minOutputAmount","minimumExpectedOut","deadline","txn","_data$txn","_data$txn2","to","clearTimeout","setTimeout","_x2","catch","error","_x","useEffect"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/hooks/useTrade.ts"],"sourcesContent":["import { ChainId, useCelo, useProvider } from '@celo/react-celo'\nimport { currencyEquals, JSBI, Pair, Percent, Price, Token, TokenAmount, Trade, TradeType } from '@ubeswap/sdk'\nimport { ERC20_ABI } from 'constants/abis/erc20'\nimport {\n  BASES_TO_CHECK_TRADES_AGAINST,\n  BETTER_TRADE_LESS_HOPS_THRESHOLD,\n  DEXES_TO_EXCLUDE,\n  FETCH_MINIMA_ROUTER_TIMER,\n  MINIMA_API_URL,\n  UBESWAP_MOOLA_ROUTER_ADDRESS,\n} from 'constants/index'\nimport { PairState, usePairs } from 'data/Reserves'\nimport { BigNumber, ContractInterface, ethers } from 'ethers'\nimport { Erc20 } from 'generated'\nimport { useAllTokens } from 'hooks/Tokens'\nimport _ from 'lodash'\nimport flatMap from 'lodash.flatmap'\nimport React, { useMemo } from 'react'\nimport { useUserDisableSmartRouting, useUserSingleHopOnly, useUserSlippageTolerance } from 'state/user/hooks'\nimport { getProviderOrSigner, isBTest } from 'utils'\nimport { isTradeBetter } from 'utils/trades'\n\nimport { MoolaDirectTrade } from '../moola/MoolaDirectTrade'\nimport { getMoolaDual } from '../moola/useMoola'\nimport { useMoolaDirectRoute } from '../moola/useMoolaDirectRoute'\nimport { MinimaTradePayload, TradeRouter, UbeswapTrade } from '../trade'\nimport { MinimaRouterTrade } from './../trade'\nimport { bestTradeExactIn, bestTradeExactOut } from './calculateBestTrades'\nimport { useDirectTradeExactIn, useDirectTradeExactOut } from './directTrades'\n\n/**\n * Uses all common pairs between the two tokens, plus searches the moola duals\n * @param tokenA\n * @param tokenB\n * @returns\n */\nexport function useAllCommonPairsWithMoolaDuals(tokenA?: Token, tokenB?: Token): readonly Pair[] {\n  const { network } = useCelo()\n  const chainId = network.chainId\n\n  const bases: readonly Token[] = useMemo(() => (chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []), [chainId])\n\n  const basePairs: readonly (readonly [Token, Token])[] = useMemo(\n    () =>\n      flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])).filter(\n        ([t0, t1]) =>\n          t0.address !== t1.address &&\n          // ensure we don't fetch duals\n          t0.address !== getMoolaDual(t1)?.address &&\n          t1.address !== getMoolaDual(t0)?.address\n      ),\n    [bases]\n  )\n\n  const tokenADual = tokenA && getMoolaDual(tokenA)\n  const tokenBDual = tokenB && getMoolaDual(tokenB)\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n            // handle duals\n            // direct pair\n            ...(tokenADual ? [[tokenADual, tokenB]] : []),\n            ...(tokenBDual ? [[tokenA, tokenBDual]] : []),\n            ...(tokenADual && tokenBDual ? [[tokenADual, tokenBDual]] : []),\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            ...(tokenADual ? bases.map((base): [Token, Token] => [tokenADual, base]) : []),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            ...(tokenBDual ? bases.map((base): [Token, Token] => [tokenBDual, base]) : []),\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n        : [],\n    [tokenA, tokenB, bases, basePairs, tokenADual, tokenBDual]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\nconst MAX_HOPS = 3\n\nconst moolaRouter: TradeRouter = {\n  routerAddress: UBESWAP_MOOLA_ROUTER_ADDRESS,\n}\n\nexport class MoolaRouterTrade extends UbeswapTrade {\n  inputAmount: TokenAmount\n  outputAmount: TokenAmount\n  executionPrice: Price\n  /**\n   *\n   * @param originalTokenIn If null, the original token is the path token\n   * @param originalTokenOut If null, the original token is the path token\n   * @param innerTrade\n   */\n  constructor(\n    public readonly originalTokenIn: Token | null,\n    public readonly originalTokenOut: Token | null,\n    public readonly innerTrade: Trade\n  ) {\n    super(\n      innerTrade.route,\n      innerTrade.tradeType === TradeType.EXACT_INPUT ? innerTrade.inputAmount : innerTrade.outputAmount,\n      innerTrade.tradeType,\n      moolaRouter,\n      [\n        ...(originalTokenIn ? [originalTokenIn] : []),\n        ...innerTrade.route.path,\n        ...(originalTokenOut ? [originalTokenOut] : []),\n      ]\n    )\n    this.inputAmount = new TokenAmount(originalTokenIn ?? innerTrade.inputAmount.token, innerTrade.inputAmount.raw)\n    this.outputAmount = new TokenAmount(originalTokenOut ?? innerTrade.outputAmount.token, innerTrade.outputAmount.raw)\n    const baseIsInput = currencyEquals(innerTrade.executionPrice.baseCurrency, innerTrade.inputAmount.token)\n    this.executionPrice = new Price(\n      baseIsInput ? this.inputAmount.token : this.outputAmount.token,\n      !baseIsInput ? this.inputAmount.token : this.outputAmount.token,\n      innerTrade.executionPrice.denominator,\n      innerTrade.executionPrice.numerator\n    )\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  minimumAmountOut(slippageTolerance: Percent): TokenAmount {\n    const amt = this.innerTrade.minimumAmountOut(slippageTolerance)\n    return new TokenAmount(this.originalTokenOut ?? amt.token, amt.raw)\n  }\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  maximumAmountIn(slippageTolerance: Percent): TokenAmount {\n    const amt = this.innerTrade.maximumAmountIn(slippageTolerance)\n    return new TokenAmount(this.originalTokenIn ?? amt.token, amt.raw)\n  }\n}\n\n/**\n * Converts the trade to a Moola Router trade, if the original tokens are lost\n * @param originalTokenIn\n * @param originalTokenOut\n * @param trade\n * @returns\n */\nconst convertToMoolaRouterTradeIfApplicable = (\n  originalTokenIn: Token,\n  originalTokenOut: Token,\n  trade: UbeswapTrade\n): UbeswapTrade => {\n  const inUnchanged = trade.inputAmount.token.address === originalTokenIn.address\n  const outUnchanged = trade.outputAmount.token.address === originalTokenOut.address\n  if (inUnchanged && outUnchanged) {\n    return trade\n  }\n  return new MoolaRouterTrade(inUnchanged ? originalTokenIn : null, outUnchanged ? originalTokenOut : null, trade)\n}\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useUbeswapTradeExactIn(tokenAmountIn?: TokenAmount, tokenOut?: Token): UbeswapTrade | null {\n  const [disableSmartRouting] = useUserDisableSmartRouting()\n  const directTrade = useDirectTradeExactIn(tokenAmountIn, tokenOut)\n  const allowedPairs = useAllCommonPairsWithMoolaDuals(tokenAmountIn?.token, tokenOut)\n  const [singleHopOnly] = useUserSingleHopOnly()\n  const moolaRoute = useMoolaDirectRoute(tokenAmountIn?.token, tokenOut)\n\n  return useMemo(() => {\n    const bestTrade = (() => {\n      if (disableSmartRouting) {\n        return directTrade\n      }\n\n      if (tokenAmountIn && tokenOut && allowedPairs.length > 0) {\n        if (singleHopOnly) {\n          const singleHopTrade = bestTradeExactIn(allowedPairs.slice(), tokenAmountIn, tokenOut, directTrade, {\n            maxHops: 1,\n            maxNumResults: 1,\n            minimumDelta: BETTER_TRADE_LESS_HOPS_THRESHOLD,\n          })\n          return singleHopTrade\n            ? convertToMoolaRouterTradeIfApplicable(tokenAmountIn.token, tokenOut, singleHopTrade)\n            : null\n        }\n        // search through trades with varying hops, find best trade out of them\n        let bestTradeSoFar: UbeswapTrade | null = null\n        for (let i = 1; i <= MAX_HOPS; i++) {\n          const currentTrade: UbeswapTrade | null = bestTradeExactIn(\n            allowedPairs.slice(),\n            tokenAmountIn,\n            tokenOut,\n            directTrade,\n            {\n              maxHops: i,\n              maxNumResults: 1,\n              minimumDelta: BETTER_TRADE_LESS_HOPS_THRESHOLD,\n            }\n          )\n          // if current trade is best yet, save it\n          if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n            bestTradeSoFar = currentTrade\n          }\n        }\n        return bestTradeSoFar\n      }\n\n      return null\n    })()\n\n    if (moolaRoute && tokenAmountIn) {\n      try {\n        const moolaTrade = MoolaDirectTrade.fromIn(moolaRoute, tokenAmountIn)\n        if (isTradeBetter(bestTrade, moolaTrade, new Percent('0'))) {\n          return moolaTrade\n        }\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n    return bestTrade\n  }, [allowedPairs, tokenAmountIn, tokenOut, singleHopOnly, directTrade, disableSmartRouting, moolaRoute])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useUbeswapTradeExactOut(tokenIn?: Token, tokenAmountOut?: TokenAmount): UbeswapTrade | null {\n  const [disableSmartRouting] = useUserDisableSmartRouting()\n  const directTrade = useDirectTradeExactOut(tokenIn, tokenAmountOut)\n  const allowedPairs = useAllCommonPairsWithMoolaDuals(tokenIn, tokenAmountOut?.token)\n  const [singleHopOnly] = useUserSingleHopOnly()\n  const moolaRoute = useMoolaDirectRoute(tokenIn, tokenAmountOut?.token)\n\n  return useMemo(() => {\n    const bestTrade = (() => {\n      if (disableSmartRouting) {\n        return directTrade\n      }\n\n      if (tokenIn && tokenAmountOut && allowedPairs.length > 0) {\n        if (singleHopOnly) {\n          const singleHopTrade = bestTradeExactOut(allowedPairs.slice(), tokenIn, tokenAmountOut, directTrade, {\n            maxHops: 1,\n            maxNumResults: 1,\n          })\n          return singleHopTrade\n            ? convertToMoolaRouterTradeIfApplicable(tokenIn, tokenAmountOut.token, singleHopTrade)\n            : null\n        }\n        // search through trades with varying hops, find best trade out of them\n        let bestTradeSoFar: UbeswapTrade | null = null\n        for (let i = 1; i <= MAX_HOPS; i++) {\n          const currentTrade = bestTradeExactOut(allowedPairs.slice(), tokenIn, tokenAmountOut, directTrade, {\n            maxHops: i,\n            maxNumResults: 1,\n          })\n          if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n            bestTradeSoFar = currentTrade\n          }\n        }\n        return bestTradeSoFar\n      }\n      return null\n    })()\n\n    if (moolaRoute && tokenAmountOut) {\n      try {\n        const moolaTrade = MoolaDirectTrade.fromOut(moolaRoute, tokenAmountOut)\n        if (isTradeBetter(bestTrade, moolaTrade, new Percent('0'))) {\n          return moolaTrade\n        }\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n    return bestTrade\n  }, [tokenIn, tokenAmountOut, allowedPairs, singleHopOnly, directTrade, disableSmartRouting, moolaRoute])\n}\n\ninterface Dependencies {\n  chainId: ChainId\n  account: string | null\n  allowedSlippage: number\n  singleHopOnly: boolean\n  inputAddr: string | undefined\n  outputAddr: string | undefined\n  inputAmount: string | undefined\n}\n\nexport function useMinimaTrade(tokenAmountIn?: TokenAmount, tokenOut?: Token): MinimaRouterTrade | null | undefined {\n  const [minimaTrade, setMinimaTrade] = React.useState<MinimaRouterTrade | null | undefined>(undefined)\n  const [deps, setDeps] = React.useState<Dependencies | undefined>(undefined)\n  const [singleHopOnly] = useUserSingleHopOnly()\n  const [allowedSlippage] = useUserSlippageTolerance()\n  const [fetchUpdatedData, setFetchUpdatedData] = React.useState<boolean>(true)\n  const [fetchTimeout, setFetchTimeout] = React.useState<NodeJS.Timeout | undefined>(undefined)\n  const { address: account, network } = useCelo()\n  const chainId = network.chainId as ChainId\n  const library = useProvider()\n  const provider = getProviderOrSigner(library, account || undefined)\n  const tokens = useAllTokens()\n  const call = React.useCallback(async () => {\n    if (!tokenAmountIn?.currency.address || !tokenAmountIn?.raw || !tokenOut?.address) {\n      setMinimaTrade(null)\n      setDeps(undefined)\n      return\n    }\n    const curDeps = {\n      chainId,\n      account: account || null,\n      allowedSlippage,\n      singleHopOnly,\n      inputAddr: tokenAmountIn.currency.address,\n      outputAddr: tokenOut.address,\n      inputAmount: tokenAmountIn.raw.toString(),\n    }\n    if (_.isEqual(deps, curDeps) && !fetchUpdatedData) {\n      return\n    }\n    if (!fetchUpdatedData) {\n      setMinimaTrade(undefined)\n    }\n    setDeps(curDeps)\n    setFetchUpdatedData(false)\n    // fetch information of minima router\n    await fetch(\n      `${MINIMA_API_URL}?exclude=${DEXES_TO_EXCLUDE}&tokenIn=${tokenAmountIn?.currency.address ?? ''}&tokenOut=${\n        tokenOut?.address ?? ''\n      }&amountIn=${tokenAmountIn?.raw}&slippage=${allowedSlippage}&maxHops=${\n        singleHopOnly ? 1 : MAX_HOPS\n      }&includeTxn=true&priceImpact=true${account ? '&from=' + account : ''}`,\n      {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-KEY': process.env.REACT_APP_MINIMA_KEY ?? '',\n        },\n      }\n    )\n      .then(async (res) => {\n        if (res.status !== 200) {\n          setMinimaTrade(null)\n          return\n        }\n        await res\n          .json()\n          .then(async (data: MinimaTradePayload) => {\n            if (data.details) {\n              const path = await Promise.all(\n                data.details.path.map(async (pathItem) => {\n                  if (!tokens[pathItem]) {\n                    // in case of a token address cannot be found on Ubeswap or Uniswap tokenlists\n                    const tokenContract = new ethers.Contract(\n                      pathItem,\n                      ERC20_ABI as ContractInterface,\n                      provider\n                    ) as unknown as Erc20\n                    const [tokenName, symbol, decimals] = await Promise.all([\n                      tokenContract.name(),\n                      tokenContract.symbol(),\n                      tokenContract.decimals(),\n                    ])\n                    return new Token(chainId as number, pathItem, decimals, symbol, tokenName)\n                  }\n                  return tokens[pathItem]\n                })\n              )\n              const trade = MinimaRouterTrade.fromMinimaTradePayload(\n                [\n                  new Pair(\n                    new TokenAmount(tokenAmountIn.currency, JSBI.BigInt(10000)),\n                    new TokenAmount(tokenOut, JSBI.BigInt(20000))\n                  ),\n                ],\n                tokenAmountIn,\n                new TokenAmount(tokenOut, JSBI.BigInt(data.details.expectedOutputAmount.toString())),\n                data.routerAddress,\n                new Percent(JSBI.BigInt(data.priceImpact.numerator), JSBI.BigInt(data.priceImpact.denominator)),\n                path,\n                {\n                  ...data.details,\n                  inputAmount: BigNumber.from(data.details.inputAmount),\n                  minOutputAmount: BigNumber.from(data.minimumExpectedOut ?? '0'),\n                  expectedOutputAmount: BigNumber.from(data.details.expectedOutputAmount),\n                  deadline: BigNumber.from(data.details.deadline),\n                }\n              )\n\n              if (account && isBTest(account) && data.txn) {\n                trade.txn = { to: data.txn?.to, data: data.txn?.data }\n              }\n\n              setMinimaTrade(trade)\n              clearTimeout(fetchTimeout)\n              setFetchTimeout(\n                setTimeout(() => {\n                  setFetchUpdatedData(true)\n                }, FETCH_MINIMA_ROUTER_TIMER)\n              )\n            }\n          })\n          .catch((e) => {\n            console.error(e)\n            setMinimaTrade(null)\n          })\n      })\n      .catch((e) => {\n        console.error(e)\n        setMinimaTrade(null)\n      })\n  }, [\n    account,\n    allowedSlippage,\n    chainId,\n    deps,\n    fetchTimeout,\n    fetchUpdatedData,\n    provider,\n    singleHopOnly,\n    tokenAmountIn,\n    tokenOut,\n    tokens,\n  ])\n\n  React.useEffect(() => {\n    call()\n  }, [call])\n\n  return minimaTrade\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}