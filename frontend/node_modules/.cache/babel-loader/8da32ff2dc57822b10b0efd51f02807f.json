{"ast":null,"code":"import _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { MINIMA_ROUTER_ADDRESS } from '../../../../constants';\nimport { MinimaRouter__factory } from '../../../../generated';\n/**\n * Executes a trade on Minima.\n * @param trade\n * @returns\n */\nexport const executeMinimaTrade = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (_ref) {\n    let {\n      trade,\n      signer,\n      doTransaction,\n      recipient,\n      withRecipient\n    } = _ref;\n    const contract = MinimaRouter__factory.connect(MINIMA_ROUTER_ADDRESS, signer);\n    const {\n      details,\n      inputAmount,\n      outputAmount\n    } = trade;\n    const inputToken = inputAmount.token;\n    const outputToken = outputAmount.token;\n    const convert = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* () {\n        var _inputToken$symbol, _outputToken$symbol;\n        const inputSymbol = (_inputToken$symbol = inputToken.symbol) !== null && _inputToken$symbol !== void 0 ? _inputToken$symbol : null;\n        const outputSymbol = (_outputToken$symbol = outputToken.symbol) !== null && _outputToken$symbol !== void 0 ? _outputToken$symbol : null;\n        const tokenAmountIn = inputAmount.toSignificant(3);\n        const tokenAmountOut = outputAmount.toSignificant(3);\n        return yield doTransaction(contract, 'swapExactInputForOutput', {\n          args: [_objectSpread(_objectSpread({}, details), {}, {\n            to: recipient !== null && recipient !== void 0 ? recipient : ''\n          })],\n          summary: \"Swap \".concat(tokenAmountIn, \" \").concat(inputSymbol, \" for \").concat(tokenAmountOut, \" \").concat(outputSymbol).concat(withRecipient),\n          raw: trade === null || trade === void 0 ? void 0 : trade.txn\n        });\n      });\n      return function convert() {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    return {\n      hash: (yield convert()).hash\n    };\n  });\n  return function executeMinimaTrade(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["MINIMA_ROUTER_ADDRESS","MinimaRouter__factory","executeMinimaTrade","_ref2","_asyncToGenerator","_ref","trade","signer","doTransaction","recipient","withRecipient","contract","connect","details","inputAmount","outputAmount","inputToken","token","outputToken","convert","_ref3","_inputToken$symbol","_outputToken$symbol","inputSymbol","symbol","outputSymbol","tokenAmountIn","toSignificant","tokenAmountOut","args","_objectSpread","to","summary","concat","raw","txn","apply","arguments","hash","_x"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/minima/executeMinimaTrade.ts"],"sourcesContent":["import { ContractTransaction } from 'ethers'\n\nimport { MINIMA_ROUTER_ADDRESS } from '../../../../constants'\nimport { MinimaRouter__factory } from '../../../../generated'\nimport { TradeExecutor } from '..'\nimport { MinimaRouterTrade } from '../trade'\n\n/**\n * Executes a trade on Minima.\n * @param trade\n * @returns\n */\nexport const executeMinimaTrade: TradeExecutor<MinimaRouterTrade> = async ({\n  trade,\n  signer,\n  doTransaction,\n  recipient,\n  withRecipient,\n}) => {\n  const contract = MinimaRouter__factory.connect(MINIMA_ROUTER_ADDRESS, signer)\n\n  const { details, inputAmount, outputAmount } = trade\n  const inputToken = inputAmount.token\n  const outputToken = outputAmount.token\n\n  const convert = async (): Promise<ContractTransaction> => {\n    const inputSymbol = inputToken.symbol ?? null\n    const outputSymbol = outputToken.symbol ?? null\n\n    const tokenAmountIn = inputAmount.toSignificant(3)\n    const tokenAmountOut = outputAmount.toSignificant(3)\n\n    return await doTransaction(contract, 'swapExactInputForOutput', {\n      args: [{ ...details, to: recipient ?? '' }],\n      summary: `Swap ${tokenAmountIn} ${inputSymbol} for ${tokenAmountOut} ${outputSymbol}${withRecipient}`,\n      raw: trade?.txn,\n    })\n  }\n\n  return { hash: (await convert()).hash }\n}\n"],"mappings":";;AAEA,SAASA,qBAAqB,QAAQ,uBAAuB;AAC7D,SAASC,qBAAqB,QAAQ,uBAAuB;AAI7D;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAoD;EAAA,IAAAC,KAAA,GAAAC,iBAAA,CAAG,WAAAC,IAAA,EAM9D;IAAA,IANqE;MACzEC,KAAK;MACLC,MAAM;MACNC,aAAa;MACbC,SAAS;MACTC;IACF,CAAC,GAAAL,IAAA;IACC,MAAMM,QAAQ,GAAGV,qBAAqB,CAACW,OAAO,CAACZ,qBAAqB,EAAEO,MAAM,CAAC;IAE7E,MAAM;MAAEM,OAAO;MAAEC,WAAW;MAAEC;IAAa,CAAC,GAAGT,KAAK;IACpD,MAAMU,UAAU,GAAGF,WAAW,CAACG,KAAK;IACpC,MAAMC,WAAW,GAAGH,YAAY,CAACE,KAAK;IAEtC,MAAME,OAAO;MAAA,IAAAC,KAAA,GAAAhB,iBAAA,CAAG,aAA0C;QAAA,IAAAiB,kBAAA,EAAAC,mBAAA;QACxD,MAAMC,WAAW,IAAAF,kBAAA,GAAGL,UAAU,CAACQ,MAAM,cAAAH,kBAAA,cAAAA,kBAAA,GAAI,IAAI;QAC7C,MAAMI,YAAY,IAAAH,mBAAA,GAAGJ,WAAW,CAACM,MAAM,cAAAF,mBAAA,cAAAA,mBAAA,GAAI,IAAI;QAE/C,MAAMI,aAAa,GAAGZ,WAAW,CAACa,aAAa,CAAC,CAAC,CAAC;QAClD,MAAMC,cAAc,GAAGb,YAAY,CAACY,aAAa,CAAC,CAAC,CAAC;QAEpD,aAAanB,aAAa,CAACG,QAAQ,EAAE,yBAAyB,EAAE;UAC9DkB,IAAI,EAAE,CAAAC,aAAA,CAAAA,aAAA,KAAMjB,OAAO;YAAEkB,EAAE,EAAEtB,SAAS,aAATA,SAAS,cAATA,SAAS,GAAI;UAAE,GAAG;UAC3CuB,OAAO,UAAAC,MAAA,CAAUP,aAAa,OAAAO,MAAA,CAAIV,WAAW,WAAAU,MAAA,CAAQL,cAAc,OAAAK,MAAA,CAAIR,YAAY,EAAAQ,MAAA,CAAGvB,aAAa,CAAE;UACrGwB,GAAG,EAAE5B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAE6B;QACd,CAAC,CAAC;MACJ,CAAC;MAAA,gBAZKhB,OAAOA,CAAA;QAAA,OAAAC,KAAA,CAAAgB,KAAA,OAAAC,SAAA;MAAA;IAAA,GAYZ;IAED,OAAO;MAAEC,IAAI,EAAE,OAAOnB,OAAO,CAAC,CAAC,EAAEmB;IAAK,CAAC;EACzC,CAAC;EAAA,gBA5BYpC,kBAAoDA,CAAAqC,EAAA;IAAA,OAAApC,KAAA,CAAAiC,KAAA,OAAAC,SAAA;EAAA;AAAA,GA4BhE"},"metadata":{},"sourceType":"module"}