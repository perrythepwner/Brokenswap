{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/* eslint-disable @typescript-eslint/member-ordering */\nconst MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);\nconst BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);\nconst BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);\nconst BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);\n// const BIGINT_64_MAX = BigInt(\"0xffffffffffffffff\");\nconst NUMBER_2_POW_32 = 2 ** 32;\nconst NUMBER_32_MAX = 0xffffffff;\nexports.uintNumberByteLens = [1, 2, 4, 8];\nexports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintNumber is represented as the Javascript primitive value 'Number'.\n *\n * The Number type is a double-precision 64-bit binary format IEEE 754 value (numbers between -(2^53 − 1) and\n * 2^53 − 1). It also has the symbolic value: +Infinity.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. Some values are spec'ed as Uint64 but\n * practically they will never exceed 53 bits, such as any unit time or simple counters. This type is an optimization\n * for these cases, as UintNumber64 can represent any value between 0 and 2^53−1 as well as the max value 2^64-1.\n */\nclass UintNumberType extends basic_1.BasicType {\n  constructor(byteLength, opts) {\n    var _opts$typeName;\n    super();\n    this.byteLength = byteLength;\n    if (byteLength > 8) {\n      throw Error(\"UintNumber byteLength limit is 8\");\n    }\n    if (Math.log2(byteLength) % 1 !== 0) {\n      throw Error(\"byteLength must be a power of 2\");\n    }\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"uint\".concat(byteLength * 8);\n    if (opts !== null && opts !== void 0 && opts.clipInfinity) this.typeName += \"Inf\";\n    if (opts !== null && opts !== void 0 && opts.setBitwiseOR) this.typeName += \"OR\";\n    this.itemsPerChunk = 32 / this.byteLength;\n    this.fixedSize = byteLength;\n    this.minSize = byteLength;\n    this.maxSize = byteLength;\n    this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);\n    this.clipInfinity = (opts === null || opts === void 0 ? void 0 : opts.clipInfinity) === true;\n    this.setBitwiseOR = (opts === null || opts === void 0 ? void 0 : opts.setBitwiseOR) === true;\n  }\n  static named(byteLength, opts) {\n    return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);\n  }\n  defaultValue() {\n    return 0;\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(_ref, offset, value) {\n    let {\n      dataView\n    } = _ref;\n    switch (this.byteLength) {\n      case 1:\n        dataView.setInt8(offset, value);\n        break;\n      case 2:\n        dataView.setUint16(offset, value, true);\n        break;\n      case 4:\n        dataView.setUint32(offset, value, true);\n        break;\n      case 8:\n        if (value === Infinity) {\n          // TODO: Benchmark if it's faster to set BIGINT_64_MAX once\n          dataView.setUint32(offset, 0xffffffff);\n          dataView.setUint32(offset + 4, 0xffffffff);\n        } else {\n          dataView.setUint32(offset, value & 0xffffffff, true);\n          dataView.setUint32(offset + 4, value / NUMBER_2_POW_32 & 0xffffffff, true);\n        }\n        break;\n    }\n    return offset + this.byteLength;\n  }\n  value_deserializeFromBytes(_ref2, start, end) {\n    let {\n      dataView\n    } = _ref2;\n    this.assertValidSize(end - start);\n    switch (this.byteLength) {\n      case 1:\n        return dataView.getUint8(start);\n      case 2:\n        return dataView.getUint16(start, true);\n      case 4:\n        return dataView.getUint32(start, true);\n      case 8:\n        {\n          const a = dataView.getUint32(start, true);\n          const b = dataView.getUint32(start + 4, true);\n          if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {\n            return Infinity;\n          } else {\n            return b * NUMBER_2_POW_32 + a;\n          }\n        }\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const value = node.getUint(this.byteLength, 0, this.clipInfinity);\n    this.value_serializeToBytes(output, offset, value);\n    return offset + this.byteLength;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = this.value_deserializeFromBytes(data, start, end);\n    const node = persistent_merkle_tree_1.LeafNode.fromZero();\n    node.setUint(this.byteLength, 0, value, this.clipInfinity);\n    return node;\n  }\n  // Fast Tree access\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(this.byteLength, 0, this.clipInfinity);\n  }\n  tree_setToNode(leafNode, value) {\n    this.tree_setToPackedNode(leafNode, 0, value);\n  }\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);\n  }\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    // TODO: Benchmark the cost of this if, and consider using a different class\n    if (this.setBitwiseOR) {\n      leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);\n    } else {\n      leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);\n    }\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json === \"number\") {\n      return json;\n    } else if (typeof json === \"string\") {\n      if (this.clipInfinity && json === this.maxDecimalStr) {\n        // Allow to handle max possible number\n        return Infinity;\n      } else {\n        const num = parseInt(json, 10);\n        if (isNaN(num)) {\n          throw Error(\"JSON invalid number isNaN\");\n        } else if (num > Number.MAX_SAFE_INTEGER) {\n          // Throw to prevent decimal precision errors downstream\n          throw Error(\"JSON invalid number > MAX_SAFE_INTEGER\");\n        } else {\n          return num;\n        }\n      }\n    } else if (typeof json === \"bigint\") {\n      if (json > MAX_SAFE_INTEGER_BN) {\n        // Throw to prevent decimal precision errors downstream\n        throw Error(\"JSON invalid number > MAX_SAFE_INTEGER_BN\");\n      } else {\n        return Number(json);\n      }\n    } else {\n      throw Error(\"JSON invalid type \".concat(typeof json, \" expected number\"));\n    }\n  }\n  toJson(value) {\n    if (value === Infinity) {\n      return this.maxDecimalStr;\n    } else {\n      return value.toString(10);\n    }\n  }\n}\nexports.UintNumberType = UintNumberType;\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintBigint is represented as the Javascript primitive value 'BigInt'.\n *\n * The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision.\n * With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. For Uint values under 53 bits use UintNumber.\n * For other values that may exceed 53 bits, use UintBigint.\n */\nclass UintBigintType extends basic_1.BasicType {\n  constructor(byteLength, opts) {\n    var _opts$typeName2;\n    super();\n    this.byteLength = byteLength;\n    if (byteLength > 32) {\n      throw Error(\"UintBigint byteLength limit is 32\");\n    }\n    if (Math.log2(byteLength) % 1 !== 0) {\n      throw Error(\"byteLength must be a power of 2\");\n    }\n    this.typeName = (_opts$typeName2 = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName2 !== void 0 ? _opts$typeName2 : \"uintBigint\".concat(byteLength * 8);\n    this.byteLength = byteLength;\n    this.itemsPerChunk = 32 / this.byteLength;\n    this.fixedSize = byteLength;\n    this.minSize = byteLength;\n    this.maxSize = byteLength;\n  }\n  static named(byteLength, opts) {\n    return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);\n  }\n  defaultValue() {\n    return BigInt(0);\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(_ref3, offset, value) {\n    let {\n      dataView\n    } = _ref3;\n    switch (this.byteLength) {\n      case 1:\n        dataView.setInt8(offset, Number(value));\n        break;\n      case 2:\n        dataView.setUint16(offset, Number(value), true);\n        break;\n      case 4:\n        dataView.setUint32(offset, Number(value), true);\n        break;\n      case 8:\n        dataView.setBigUint64(offset, value, true);\n        break;\n      default:\n        {\n          for (let i = 0; i < this.byteLength; i += 8) {\n            if (i > 0) value = value / BIGINT_2_POW_64;\n            const lo = BigInt.asUintN(64, value);\n            dataView.setBigUint64(offset + i, lo, true);\n          }\n        }\n    }\n    return offset + this.byteLength;\n  }\n  value_deserializeFromBytes(_ref4, start, end) {\n    let {\n      dataView\n    } = _ref4;\n    const size = end - start;\n    if (size !== this.byteLength) {\n      throw Error(\"Invalid size \".concat(size, \" expected \").concat(this.byteLength));\n    }\n    // Note: pre-assigning the right function at the constructor to avoid this switch is not faster\n    switch (this.byteLength) {\n      case 1:\n        return BigInt(dataView.getUint8(start));\n      case 2:\n        return BigInt(dataView.getUint16(start, true));\n      case 4:\n        return BigInt(dataView.getUint32(start, true));\n      case 8:\n        return dataView.getBigUint64(start, true);\n      case 16:\n        {\n          const a = dataView.getBigUint64(start, true);\n          const b = dataView.getBigUint64(start + 8, true);\n          return b * BIGINT_2_POW_64 + a;\n        }\n      case 32:\n        {\n          const a = dataView.getBigUint64(start, true);\n          const b = dataView.getBigUint64(start + 8, true);\n          const c = dataView.getBigUint64(start + 16, true);\n          const d = dataView.getBigUint64(start + 24, true);\n          return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;\n        }\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const value = node.getUintBigint(this.byteLength, 0);\n    this.value_serializeToBytes(output, offset, value);\n    return offset + this.byteLength;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const size = end - start;\n    if (size !== this.byteLength) {\n      throw Error(\"Invalid size \".concat(size, \" expected \").concat(this.byteLength));\n    }\n    const value = this.value_deserializeFromBytes(data, start, end);\n    const node = persistent_merkle_tree_1.LeafNode.fromZero();\n    node.setUintBigint(this.byteLength, 0, value);\n    return node;\n  }\n  // Fast Tree access\n  tree_getFromNode(leafNode) {\n    return leafNode.getUintBigint(this.byteLength, 0);\n  }\n  /** Mutates node to set value */\n  tree_setToNode(leafNode, value) {\n    this.tree_setToPackedNode(leafNode, 0, value);\n  }\n  /** EXAMPLE of `tree_getFromNode` */\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    return leafNode.getUintBigint(this.byteLength, offsetBytes);\n  }\n  /** Mutates node to set value */\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n    // TODO: Not-optimized, copy pasted from UintNumberType\n    leafNode.setUintBigint(this.byteLength, offsetBytes, value);\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json === \"bigint\") {\n      return json;\n    } else if (typeof json === \"string\" || typeof json === \"number\") {\n      return BigInt(json);\n    } else {\n      throw Error(\"JSON invalid type \".concat(typeof json, \" expected bigint\"));\n    }\n  }\n  toJson(value) {\n    return value.toString(10);\n  }\n}\nexports.UintBigintType = UintBigintType;","map":{"version":3,"sources":["../../src/type/uint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UintBigintType = exports.UintNumberType = exports.uintBigintByteLens = exports.uintNumberByteLens = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/* eslint-disable @typescript-eslint/member-ordering */\nconst MAX_SAFE_INTEGER_BN = BigInt(Number.MAX_SAFE_INTEGER);\nconst BIGINT_2_POW_64 = BigInt(2) ** BigInt(64);\nconst BIGINT_2_POW_128 = BigInt(2) ** BigInt(128);\nconst BIGINT_2_POW_192 = BigInt(2) ** BigInt(192);\n// const BIGINT_64_MAX = BigInt(\"0xffffffffffffffff\");\nconst NUMBER_2_POW_32 = 2 ** 32;\nconst NUMBER_32_MAX = 0xffffffff;\nexports.uintNumberByteLens = [1, 2, 4, 8];\nexports.uintBigintByteLens = [1, 2, 4, 8, 16, 32];\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintNumber is represented as the Javascript primitive value 'Number'.\n *\n * The Number type is a double-precision 64-bit binary format IEEE 754 value (numbers between -(2^53 − 1) and\n * 2^53 − 1). It also has the symbolic value: +Infinity.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. Some values are spec'ed as Uint64 but\n * practically they will never exceed 53 bits, such as any unit time or simple counters. This type is an optimization\n * for these cases, as UintNumber64 can represent any value between 0 and 2^53−1 as well as the max value 2^64-1.\n */\nclass UintNumberType extends basic_1.BasicType {\n    constructor(byteLength, opts) {\n        super();\n        this.byteLength = byteLength;\n        if (byteLength > 8) {\n            throw Error(\"UintNumber byteLength limit is 8\");\n        }\n        if (Math.log2(byteLength) % 1 !== 0) {\n            throw Error(\"byteLength must be a power of 2\");\n        }\n        this.typeName = opts?.typeName ?? `uint${byteLength * 8}`;\n        if (opts?.clipInfinity)\n            this.typeName += \"Inf\";\n        if (opts?.setBitwiseOR)\n            this.typeName += \"OR\";\n        this.itemsPerChunk = 32 / this.byteLength;\n        this.fixedSize = byteLength;\n        this.minSize = byteLength;\n        this.maxSize = byteLength;\n        this.maxDecimalStr = (BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1)).toString(10);\n        this.clipInfinity = opts?.clipInfinity === true;\n        this.setBitwiseOR = opts?.setBitwiseOR === true;\n    }\n    static named(byteLength, opts) {\n        return new (named_1.namedClass(UintNumberType, opts.typeName))(byteLength, opts);\n    }\n    defaultValue() {\n        return 0;\n    }\n    // Serialization + deserialization\n    value_serializeToBytes({ dataView }, offset, value) {\n        switch (this.byteLength) {\n            case 1:\n                dataView.setInt8(offset, value);\n                break;\n            case 2:\n                dataView.setUint16(offset, value, true);\n                break;\n            case 4:\n                dataView.setUint32(offset, value, true);\n                break;\n            case 8:\n                if (value === Infinity) {\n                    // TODO: Benchmark if it's faster to set BIGINT_64_MAX once\n                    dataView.setUint32(offset, 0xffffffff);\n                    dataView.setUint32(offset + 4, 0xffffffff);\n                }\n                else {\n                    dataView.setUint32(offset, value & 0xffffffff, true);\n                    dataView.setUint32(offset + 4, (value / NUMBER_2_POW_32) & 0xffffffff, true);\n                }\n                break;\n        }\n        return offset + this.byteLength;\n    }\n    value_deserializeFromBytes({ dataView }, start, end) {\n        this.assertValidSize(end - start);\n        switch (this.byteLength) {\n            case 1:\n                return dataView.getUint8(start);\n            case 2:\n                return dataView.getUint16(start, true);\n            case 4:\n                return dataView.getUint32(start, true);\n            case 8: {\n                const a = dataView.getUint32(start, true);\n                const b = dataView.getUint32(start + 4, true);\n                if (b === NUMBER_32_MAX && a === NUMBER_32_MAX && this.clipInfinity) {\n                    return Infinity;\n                }\n                else {\n                    return b * NUMBER_2_POW_32 + a;\n                }\n            }\n        }\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const value = node.getUint(this.byteLength, 0, this.clipInfinity);\n        this.value_serializeToBytes(output, offset, value);\n        return offset + this.byteLength;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidSize(end - start);\n        const value = this.value_deserializeFromBytes(data, start, end);\n        const node = persistent_merkle_tree_1.LeafNode.fromZero();\n        node.setUint(this.byteLength, 0, value, this.clipInfinity);\n        return node;\n    }\n    // Fast Tree access\n    tree_getFromNode(leafNode) {\n        return leafNode.getUint(this.byteLength, 0, this.clipInfinity);\n    }\n    tree_setToNode(leafNode, value) {\n        this.tree_setToPackedNode(leafNode, 0, value);\n    }\n    tree_getFromPackedNode(leafNode, index) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        return leafNode.getUint(this.byteLength, offsetBytes, this.clipInfinity);\n    }\n    tree_setToPackedNode(leafNode, index, value) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        // TODO: Benchmark the cost of this if, and consider using a different class\n        if (this.setBitwiseOR) {\n            leafNode.bitwiseOrUint(this.byteLength, offsetBytes, value);\n        }\n        else {\n            leafNode.setUint(this.byteLength, offsetBytes, value, this.clipInfinity);\n        }\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json === \"number\") {\n            return json;\n        }\n        else if (typeof json === \"string\") {\n            if (this.clipInfinity && json === this.maxDecimalStr) {\n                // Allow to handle max possible number\n                return Infinity;\n            }\n            else {\n                const num = parseInt(json, 10);\n                if (isNaN(num)) {\n                    throw Error(\"JSON invalid number isNaN\");\n                }\n                else if (num > Number.MAX_SAFE_INTEGER) {\n                    // Throw to prevent decimal precision errors downstream\n                    throw Error(\"JSON invalid number > MAX_SAFE_INTEGER\");\n                }\n                else {\n                    return num;\n                }\n            }\n        }\n        else if (typeof json === \"bigint\") {\n            if (json > MAX_SAFE_INTEGER_BN) {\n                // Throw to prevent decimal precision errors downstream\n                throw Error(\"JSON invalid number > MAX_SAFE_INTEGER_BN\");\n            }\n            else {\n                return Number(json);\n            }\n        }\n        else {\n            throw Error(`JSON invalid type ${typeof json} expected number`);\n        }\n    }\n    toJson(value) {\n        if (value === Infinity) {\n            return this.maxDecimalStr;\n        }\n        else {\n            return value.toString(10);\n        }\n    }\n}\nexports.UintNumberType = UintNumberType;\n/**\n * Uint: N-bit unsigned integer (where N in [8, 16, 32, 64, 128, 256])\n * - Notation: uintN\n *\n * UintBigint is represented as the Javascript primitive value 'BigInt'.\n *\n * The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision.\n * With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers.\n *\n * As of 2021 performance of 'Number' is extremely faster than 'BigInt'. For Uint values under 53 bits use UintNumber.\n * For other values that may exceed 53 bits, use UintBigint.\n */\nclass UintBigintType extends basic_1.BasicType {\n    constructor(byteLength, opts) {\n        super();\n        this.byteLength = byteLength;\n        if (byteLength > 32) {\n            throw Error(\"UintBigint byteLength limit is 32\");\n        }\n        if (Math.log2(byteLength) % 1 !== 0) {\n            throw Error(\"byteLength must be a power of 2\");\n        }\n        this.typeName = opts?.typeName ?? `uintBigint${byteLength * 8}`;\n        this.byteLength = byteLength;\n        this.itemsPerChunk = 32 / this.byteLength;\n        this.fixedSize = byteLength;\n        this.minSize = byteLength;\n        this.maxSize = byteLength;\n    }\n    static named(byteLength, opts) {\n        return new (named_1.namedClass(UintBigintType, opts.typeName))(byteLength, opts);\n    }\n    defaultValue() {\n        return BigInt(0);\n    }\n    // Serialization + deserialization\n    value_serializeToBytes({ dataView }, offset, value) {\n        switch (this.byteLength) {\n            case 1:\n                dataView.setInt8(offset, Number(value));\n                break;\n            case 2:\n                dataView.setUint16(offset, Number(value), true);\n                break;\n            case 4:\n                dataView.setUint32(offset, Number(value), true);\n                break;\n            case 8:\n                dataView.setBigUint64(offset, value, true);\n                break;\n            default: {\n                for (let i = 0; i < this.byteLength; i += 8) {\n                    if (i > 0)\n                        value = value / BIGINT_2_POW_64;\n                    const lo = BigInt.asUintN(64, value);\n                    dataView.setBigUint64(offset + i, lo, true);\n                }\n            }\n        }\n        return offset + this.byteLength;\n    }\n    value_deserializeFromBytes({ dataView }, start, end) {\n        const size = end - start;\n        if (size !== this.byteLength) {\n            throw Error(`Invalid size ${size} expected ${this.byteLength}`);\n        }\n        // Note: pre-assigning the right function at the constructor to avoid this switch is not faster\n        switch (this.byteLength) {\n            case 1:\n                return BigInt(dataView.getUint8(start));\n            case 2:\n                return BigInt(dataView.getUint16(start, true));\n            case 4:\n                return BigInt(dataView.getUint32(start, true));\n            case 8:\n                return dataView.getBigUint64(start, true);\n            case 16: {\n                const a = dataView.getBigUint64(start, true);\n                const b = dataView.getBigUint64(start + 8, true);\n                return b * BIGINT_2_POW_64 + a;\n            }\n            case 32: {\n                const a = dataView.getBigUint64(start, true);\n                const b = dataView.getBigUint64(start + 8, true);\n                const c = dataView.getBigUint64(start + 16, true);\n                const d = dataView.getBigUint64(start + 24, true);\n                return d * BIGINT_2_POW_192 + c * BIGINT_2_POW_128 + b * BIGINT_2_POW_64 + a;\n            }\n        }\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const value = node.getUintBigint(this.byteLength, 0);\n        this.value_serializeToBytes(output, offset, value);\n        return offset + this.byteLength;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const size = end - start;\n        if (size !== this.byteLength) {\n            throw Error(`Invalid size ${size} expected ${this.byteLength}`);\n        }\n        const value = this.value_deserializeFromBytes(data, start, end);\n        const node = persistent_merkle_tree_1.LeafNode.fromZero();\n        node.setUintBigint(this.byteLength, 0, value);\n        return node;\n    }\n    // Fast Tree access\n    tree_getFromNode(leafNode) {\n        return leafNode.getUintBigint(this.byteLength, 0);\n    }\n    /** Mutates node to set value */\n    tree_setToNode(leafNode, value) {\n        this.tree_setToPackedNode(leafNode, 0, value);\n    }\n    /** EXAMPLE of `tree_getFromNode` */\n    tree_getFromPackedNode(leafNode, index) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        return leafNode.getUintBigint(this.byteLength, offsetBytes);\n    }\n    /** Mutates node to set value */\n    tree_setToPackedNode(leafNode, index, value) {\n        const offsetBytes = this.byteLength * (index % this.itemsPerChunk);\n        // TODO: Not-optimized, copy pasted from UintNumberType\n        leafNode.setUintBigint(this.byteLength, offsetBytes, value);\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json === \"bigint\") {\n            return json;\n        }\n        else if (typeof json === \"string\" || typeof json === \"number\") {\n            return BigInt(json);\n        }\n        else {\n            throw Error(`JSON invalid type ${typeof json} expected bigint`);\n        }\n    }\n    toJson(value) {\n        return value.toString(10);\n    }\n}\nexports.UintBigintType = UintBigintType;\n//# sourceMappingURL=uint.js.map"]},"metadata":{},"sourceType":"script"}