{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSolidityStringArray = exports.stringToBoolean = void 0;\nvar stringToBoolean = function stringToBoolean(inputString) {\n  var lowercasedInput = inputString.toLowerCase().trim();\n  if (lowercasedInput === 'true') {\n    return true;\n  } else if (lowercasedInput === 'false') {\n    return false;\n  }\n  throw new Error(\"Unable to parse '\".concat(inputString, \"' as boolean\"));\n};\nexports.stringToBoolean = stringToBoolean;\n/**\n * Parses an \"array of strings\" that is returned from a Solidity function\n *\n * @param stringLengths length of each string in bytes\n * @param data 0x-prefixed, hex-encoded string data in utf-8 bytes\n */\nvar parseSolidityStringArray = function parseSolidityStringArray(stringLengths, data) {\n  if (data === null) {\n    data = '0x';\n  }\n  var ret = [];\n  var offset = 0;\n  // @ts-ignore\n  var rawData = Buffer.from(data.slice(2), 'hex');\n  // tslint:disable-next-line:prefer-for-of\n  for (var i = 0; i < stringLengths.length; i++) {\n    var string = rawData.toString('utf-8', offset, offset + stringLengths[i]);\n    offset += stringLengths[i];\n    ret.push(string);\n  }\n  return ret;\n};\nexports.parseSolidityStringArray = parseSolidityStringArray;","map":{"version":3,"sources":["../src/parsing.ts"],"names":[],"mappings":";;;;;;AAAO,IAAM,eAAe,GAAG,SAAlB,eAAe,CAAI,WAAmB,EAAA;EACjD,IAAM,eAAe,GAAG,WAAW,CAAC,WAAW,CAAA,CAAE,CAAC,IAAI,CAAA,CAAE;EACxD,IAAI,eAAe,KAAK,MAAM,EAAE;IAC9B,OAAO,IAAI;GACZ,MAAM,IAAI,eAAe,KAAK,OAAO,EAAE;IACtC,OAAO,KAAK;EACb;EACD,MAAM,IAAI,KAAK,CAAC,mBAAA,CAAA,MAAA,CAAoB,WAAW,EAAA,cAAA,CAAc,CAAC;AAChE,CAAC;AARY,OAAA,CAAA,eAAe,GAAA,eAAA;AAU5B;;;;;AAKG;AACI,IAAM,wBAAwB,GAAG,SAA3B,wBAAwB,CAAI,aAAuB,EAAE,IAAY,EAAA;EAC5E,IAAI,IAAI,KAAK,IAAI,EAAE;IACjB,IAAI,GAAG,IAAI;EACZ;EACD,IAAM,GAAG,GAAa,EAAE;EACxB,IAAI,MAAM,GAAG,CAAC;EACd;EACA,IAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;EACjD;EACA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAC7C,IAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;IAC3E,MAAM,IAAI,aAAa,CAAC,CAAC,CAAC;IAC1B,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC;EACjB;EACD,OAAO,GAAG;AACZ,CAAC;AAfY,OAAA,CAAA,wBAAwB,GAAA,wBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseSolidityStringArray = exports.stringToBoolean = void 0;\nvar stringToBoolean = function (inputString) {\n    var lowercasedInput = inputString.toLowerCase().trim();\n    if (lowercasedInput === 'true') {\n        return true;\n    }\n    else if (lowercasedInput === 'false') {\n        return false;\n    }\n    throw new Error(\"Unable to parse '\".concat(inputString, \"' as boolean\"));\n};\nexports.stringToBoolean = stringToBoolean;\n/**\n * Parses an \"array of strings\" that is returned from a Solidity function\n *\n * @param stringLengths length of each string in bytes\n * @param data 0x-prefixed, hex-encoded string data in utf-8 bytes\n */\nvar parseSolidityStringArray = function (stringLengths, data) {\n    if (data === null) {\n        data = '0x';\n    }\n    var ret = [];\n    var offset = 0;\n    // @ts-ignore\n    var rawData = Buffer.from(data.slice(2), 'hex');\n    // tslint:disable-next-line:prefer-for-of\n    for (var i = 0; i < stringLengths.length; i++) {\n        var string = rawData.toString('utf-8', offset, offset + stringLengths[i]);\n        offset += stringLengths[i];\n        ret.push(string);\n    }\n    return ret;\n};\nexports.parseSolidityStringArray = parseSolidityStringArray;\n//# sourceMappingURL=parsing.js.map"]},"metadata":{},"sourceType":"script"}