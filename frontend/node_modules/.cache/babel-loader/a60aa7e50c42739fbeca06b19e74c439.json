{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncIterator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n  redirect: true,\n  expectStatusCode: 200,\n  headers: {},\n  full: false,\n  keepAlive: true,\n  cors: false,\n  referrer: false,\n  sslAllowSelfSigned: false,\n  _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n  constructor(msg, fingerprint256) {\n    super(msg);\n    this.fingerprint256 = fingerprint256;\n  }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n  constructor(statusCode) {\n    super(\"Request Failed. Status Code: \".concat(statusCode));\n    this.statusCode = statusCode;\n  }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n  if (!type || type === 'text' || type === 'json') {\n    try {\n      let text = new TextDecoder('utf8', {\n        fatal: true\n      }).decode(b);\n      if (type === 'text') return text;\n      try {\n        return JSON.parse(text);\n      } catch (err) {\n        if (type === 'json') throw err;\n        return text;\n      }\n    } catch (err) {\n      if (type === 'text' || type === 'json') throw err;\n    }\n  }\n  return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n  let options = _objectSpread(_objectSpread({}, DEFAULT_OPT), _options);\n  const http = require('http');\n  const https = require('https');\n  const zlib = require('zlib');\n  const {\n    promisify\n  } = require('util');\n  const {\n    resolve: urlResolve\n  } = require('url');\n  const isSecure = !!/^https/.test(url);\n  let opts = {\n    method: options.method || 'GET',\n    headers: {\n      'Accept-Encoding': 'gzip, deflate, br'\n    }\n  };\n  const compactFP = s => s.replace(/:| /g, '').toLowerCase();\n  if (options.keepAlive) {\n    var _options$sslPinnedCer;\n    const agentOpt = {\n      keepAlive: true,\n      keepAliveMsecs: 30 * 1000,\n      maxFreeSockets: 1024,\n      maxCachedSessions: 1024\n    };\n    const agentKey = [isSecure, isSecure && ((_options$sslPinnedCer = options.sslPinnedCertificates) === null || _options$sslPinnedCer === void 0 ? void 0 : _options$sslPinnedCer.map(i => compactFP(i)).sort())].join();\n    opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n  }\n  if (options.type === 'json') opts.headers['Content-Type'] = 'application/json';\n  if (options.data) {\n    if (!options.method) opts.method = 'POST';\n    opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n  }\n  opts.headers = _objectSpread(_objectSpread({}, opts.headers), options.headers);\n  if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n  const handleRes = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (res) {\n      const status = res.statusCode;\n      if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n        if (options._redirectCount == 10) throw new Error('Request failed. Too much redirects.');\n        options._redirectCount += 1;\n        return yield fetchNode(urlResolve(url, res.headers['location']), options);\n      }\n      if (options.expectStatusCode && status !== options.expectStatusCode) {\n        res.resume();\n        throw new InvalidStatusCodeError(status);\n      }\n      let buf = [];\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(res), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          {\n            buf.push(chunk);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      let bytes = Buffer.concat(buf);\n      const encoding = res.headers['content-encoding'];\n      if (encoding === 'br') bytes = yield promisify(zlib.brotliDecompress)(bytes);\n      if (encoding === 'gzip' || encoding === 'deflate') bytes = yield promisify(zlib.unzip)(bytes);\n      const body = detectType(bytes, options.type);\n      if (options.full) return {\n        headers: res.headers,\n        status,\n        body\n      };\n      return body;\n    });\n    return function handleRes(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return new Promise((resolve, reject) => {\n    var _options$sslPinnedCer2;\n    const handleError = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (err) {\n        if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n          try {\n            yield fetchNode(url, _objectSpread(_objectSpread({}, options), {}, {\n              sslAllowSelfSigned: true,\n              sslPinnedCertificates: []\n            }));\n          } catch (e) {\n            if (e && e.fingerprint256) {\n              err = new InvalidCertError(\"Self-signed SSL certificate: \".concat(e.fingerprint256), e.fingerprint256);\n            }\n          }\n        }\n        reject(err);\n      });\n      return function handleError(_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    const req = (isSecure ? https : http).request(url, opts, res => {\n      res.on('error', handleError);\n      _asyncToGenerator(function* () {\n        try {\n          resolve(yield handleRes(res));\n        } catch (error) {\n          reject(error);\n        }\n      })();\n    });\n    req.on('error', handleError);\n    const pinned = (_options$sslPinnedCer2 = options.sslPinnedCertificates) === null || _options$sslPinnedCer2 === void 0 ? void 0 : _options$sslPinnedCer2.map(i => compactFP(i));\n    const mfetchSecureConnect = socket => {\n      var _socket$getPeerCertif;\n      const fp256 = compactFP(((_socket$getPeerCertif = socket.getPeerCertificate()) === null || _socket$getPeerCertif === void 0 ? void 0 : _socket$getPeerCertif.fingerprint256) || '');\n      if (!fp256 && socket.isSessionReused()) return;\n      if (pinned.includes(fp256)) return;\n      req.emit('error', new InvalidCertError(\"Invalid SSL certificate: \".concat(fp256, \" Expected: \").concat(pinned), fp256));\n      return req.abort();\n    };\n    if (options.sslPinnedCertificates) {\n      req.on('socket', socket => {\n        const hasListeners = socket.listeners('secureConnect').map(i => (i.name || '').replace('bound ', '')).includes('mfetchSecureConnect');\n        if (hasListeners) return;\n        socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n      });\n    }\n    if (options.keepAlive) req.setNoDelay(true);\n    if (opts.body) req.write(opts.body);\n    req.end();\n  });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map(i => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method', 'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer', 'Transfer-Encoding', 'Upgrade', 'Via'].map(i => i.toLowerCase()));\nfunction fetchBrowser(_x3, _x4) {\n  return _fetchBrowser.apply(this, arguments);\n}\nfunction _fetchBrowser() {\n  _fetchBrowser = _asyncToGenerator(function* (url, _options) {\n    let options = _objectSpread(_objectSpread({}, DEFAULT_OPT), _options);\n    const headers = new Headers();\n    if (options.type === 'json') headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n      const auth = btoa(\"\".concat(parsed.username, \":\").concat(parsed.password));\n      headers.set('Authorization', \"Basic \".concat(auth));\n      parsed.username = '';\n      parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n      const name = k.toLowerCase();\n      if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n    }\n    let opts = {\n      headers,\n      redirect: options.redirect ? 'follow' : 'manual'\n    };\n    if (!options.referrer) opts.referrerPolicy = 'no-referrer';\n    if (options.cors) opts.mode = 'cors';\n    if (options.data) {\n      if (!options.method) opts.method = 'POST';\n      opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = yield fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(yield res.arrayBuffer()), options.type);\n    if (options.full) return {\n      headers: Object.fromEntries(res.headers.entries()),\n      status: res.status,\n      body\n    };\n    return body;\n  });\n  return _fetchBrowser.apply(this, arguments);\n}\nconst IS_NODE = !!(typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n  const fn = IS_NODE ? fetchNode : fetchBrowser;\n  return fn(url, options);\n}\nexports.default = fetchUrl;","map":null,"metadata":{},"sourceType":"script"}