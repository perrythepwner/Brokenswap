{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nexport default class TransportWebUSB extends Transport {\n  constructor(device, interfaceNumber) {\n    var _this;\n    super();\n    _this = this;\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.interfaceNumber = void 0;\n    this._disconnectEmitted = false;\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n    this.exchange = apdu => this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator(function* () {\n      const {\n        channel,\n        packetSize\n      } = _this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        yield _this.device.transferOut(endpointNumber, blocks[i]);\n      } // Read...\n\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = yield _this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    })).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static request() {\n    return _asyncToGenerator(function* () {\n      const device = yield requestLedgerDevice();\n      return TransportWebUSB.open(device);\n    })();\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n  static openConnected() {\n    return _asyncToGenerator(function* () {\n      const devices = yield getLedgerDevices();\n      if (devices.length === 0) return null;\n      return TransportWebUSB.open(devices[0]);\n    })();\n  }\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n\n  static open(device) {\n    return _asyncToGenerator(function* () {\n      yield device.open();\n      if (device.configuration === null) {\n        yield device.selectConfiguration(configurationValue);\n      }\n      yield gracefullyResetDevice(device);\n      const iface = device.configurations[0].interfaces.find(_ref2 => {\n        let {\n          alternates\n        } = _ref2;\n        return alternates.some(a => a.interfaceClass === 255);\n      });\n      if (!iface) {\n        throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n      }\n      const interfaceNumber = iface.interfaceNumber;\n      try {\n        yield device.claimInterface(interfaceNumber);\n      } catch (e) {\n        yield device.close();\n        throw new TransportInterfaceNotAvailable(e.message);\n      }\n      const transport = new TransportWebUSB(device, interfaceNumber);\n      const onDisconnect = e => {\n        if (device === e.device) {\n          // $FlowFixMe\n          navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n          transport._emitDisconnect(new DisconnectedDevice());\n        }\n      }; // $FlowFixMe\n\n      navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n      return transport;\n    })();\n  }\n\n  /**\n   * Release the transport device\n   */\n  close() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.exchangeBusyPromise;\n      yield _this2.device.releaseInterface(_this2.interfaceNumber);\n      yield gracefullyResetDevice(_this2.device);\n      yield _this2.device.close();\n    })();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n  setScrambleKey() {}\n}\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\nTransportWebUSB.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n  return {\n    unsubscribe\n  };\n};\nfunction gracefullyResetDevice(_x) {\n  return _gracefullyResetDevice.apply(this, arguments);\n}\nfunction _gracefullyResetDevice() {\n  _gracefullyResetDevice = _asyncToGenerator(function* (device) {\n    try {\n      yield device.reset();\n    } catch (err) {\n      console.warn(err);\n    }\n  });\n  return _gracefullyResetDevice.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["Transport","hidFraming","identifyUSBProductId","log","TransportOpenUserCancelled","TransportInterfaceNotAvailable","TransportWebUSBGestureRequired","DisconnectedDeviceDuringOperation","DisconnectedDevice","getLedgerDevices","getFirstLedgerDevice","requestLedgerDevice","isSupported","configurationValue","endpointNumber","TransportWebUSB","device","deviceModel","channel","Math","floor","random","packetSize","interfaceNumber","constructor","productId","list","listen","observer","unsubscribed","then","next","type","descriptor","complete","error","window","DOMException","code","message","unsubscribe","request","open","openConnected","devices","length","configuration","selectConfiguration","gracefullyResetDevice","iface","configurations","interfaces","find","alternates","some","a","interfaceClass","claimInterface","e","close","transport","onDisconnect","navigator","usb","removeEventListener","_emitDisconnect","addEventListener","_disconnectEmitted","emit","exchangeBusyPromise","releaseInterface","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","transferOut","result","acc","getReducedResult","r","transferIn","buffer","Buffer","from","data","reduceResponse","catch","includes","setScrambleKey","reset","err","console","warn"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}