{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */\nconst hasTerminator = nibbles => {\n  return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes) => {\n  for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {\n    bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];\n  }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = nibbles => {\n  let terminator = 0;\n  if ((0, exports.hasTerminator)(nibbles)) {\n    terminator = 1;\n    // Remove the terminator from the sequence\n    nibbles = nibbles.subarray(0, nibbles.length - 1);\n  }\n  const buf = new Uint8Array(nibbles.length / 2 + 1);\n  // Shift the terminator info into the first nibble of buf[0]\n  buf[0] = terminator << 5;\n  // If odd length, then add that flag into the first nibble and put the odd nibble to\n  // second part of buf[0] which otherwise will be left padded with a 0\n  if ((nibbles.length & 1) === 1) {\n    buf[0] |= 1 << 4;\n    buf[0] |= nibbles[0];\n    nibbles = nibbles.subarray(1);\n  }\n  // create bytes out of the rest even nibbles\n  (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n  return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = str => {\n  const l = str.length * 2 + 1;\n  const nibbles = new Uint8Array(l);\n  for (let i = 0; i < str.length; i++) {\n    const b = str[i];\n    nibbles[i * 2] = b / 16;\n    nibbles[i * 2 + 1] = b % 16;\n  }\n  // This will get removed from calling function if the first nibble\n  // indicates that terminator is not present\n  nibbles[l - 1] = 16;\n  return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = compact => {\n  if (compact.length === 0) {\n    return compact;\n  }\n  let base = (0, exports.bytesToNibbles)(compact);\n  // delete terminator flag if terminator flag was not in first nibble\n  if (base[0] < 2) {\n    base = base.subarray(0, base.length - 1);\n  }\n  // chop the terminator nibble and the even padding (if there is one)\n  // i.e.  chop 2 left nibbles when even else 1 when odd\n  const chop = 2 - (base[0] & 1);\n  return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles;\n/**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */\n//\n//\n// export const getPathTo = (tillBytes: number, key: Buffer) => {\n//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n//   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n//   hexNibbles[hexNibbles.length - 1] = 0\n//   const compactBytes = nibblesToCompactBytes(hexNibbles)\n//   return [Buffer.from(compactBytes)]\n// }","map":{"version":3,"sources":["../src/encoding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */\nconst hasTerminator = (nibbles) => {\n    return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes) => {\n    for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {\n        bytes[bi] = (nibbles[ni] << 4) | nibbles[ni + 1];\n    }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = (nibbles) => {\n    let terminator = 0;\n    if ((0, exports.hasTerminator)(nibbles)) {\n        terminator = 1;\n        // Remove the terminator from the sequence\n        nibbles = nibbles.subarray(0, nibbles.length - 1);\n    }\n    const buf = new Uint8Array(nibbles.length / 2 + 1);\n    // Shift the terminator info into the first nibble of buf[0]\n    buf[0] = terminator << 5;\n    // If odd length, then add that flag into the first nibble and put the odd nibble to\n    // second part of buf[0] which otherwise will be left padded with a 0\n    if ((nibbles.length & 1) === 1) {\n        buf[0] |= 1 << 4;\n        buf[0] |= nibbles[0];\n        nibbles = nibbles.subarray(1);\n    }\n    // create bytes out of the rest even nibbles\n    (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n    return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = (str) => {\n    const l = str.length * 2 + 1;\n    const nibbles = new Uint8Array(l);\n    for (let i = 0; i < str.length; i++) {\n        const b = str[i];\n        nibbles[i * 2] = b / 16;\n        nibbles[i * 2 + 1] = b % 16;\n    }\n    // This will get removed from calling function if the first nibble\n    // indicates that terminator is not present\n    nibbles[l - 1] = 16;\n    return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = (compact) => {\n    if (compact.length === 0) {\n        return compact;\n    }\n    let base = (0, exports.bytesToNibbles)(compact);\n    // delete terminator flag if terminator flag was not in first nibble\n    if (base[0] < 2) {\n        base = base.subarray(0, base.length - 1);\n    }\n    // chop the terminator nibble and the even padding (if there is one)\n    // i.e.  chop 2 left nibbles when even else 1 when odd\n    const chop = 2 - (base[0] & 1);\n    return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles;\n/**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */\n//\n//\n// export const getPathTo = (tillBytes: number, key: Buffer) => {\n//   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n//   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n//   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n//   hexNibbles[hexNibbles.length - 1] = 0\n//   const compactBytes = nibblesToCompactBytes(hexNibbles)\n//   return [Buffer.from(compactBytes)]\n// }\n//# sourceMappingURL=encoding.js.map"]},"metadata":{},"sourceType":"script"}