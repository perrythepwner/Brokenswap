{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useCelo}from'@celo/react-celo';import{parseBytes32String}from'@ethersproject/strings';import{currencyEquals,Token}from'@ubeswap/sdk';import{arrayify}from'ethers/lib/utils';import{useMemo}from'react';import{filterTokens}from'../components/SearchModal/filtering';import{useCombinedActiveList,useCombinedInactiveList}from'../state/lists/hooks';import{NEVER_RELOAD,useSingleCallResult}from'../state/multicall/hooks';import{useUserAddedTokens}from'../state/user/hooks';import{isAddress}from'../utils';import{useDefaultTokenList,useUnsupportedTokenList}from'./../state/lists/hooks';import{useBytes32TokenContract,useTokenContract}from'./useContract';// reduce token map into standard address <-> Token mapping, optionally include user added tokens\nfunction useTokensFromMap(tokenMap,includeUserAdded,chainIdOpt){const{network}=useCelo();const chainId=chainIdOpt||network.chainId;const userAddedTokens=useUserAddedTokens();return useMemo(()=>{if(!chainId||!tokenMap[chainId])return{};// reduce to just tokens\nconst mapWithoutUrls=Object.keys(tokenMap[chainId]).reduce((newMap,address)=>{newMap[address]=tokenMap[chainId][address].token;return newMap;},{});if(includeUserAdded){return userAddedTokens// reduce into all ALL_TOKENS filtered by the current chain\n.reduce((tokenMap,token)=>{tokenMap[token.address]=token;return tokenMap;},// must make a copy because reduce modifies the map, and we do not\n// want to make a copy in every iteration\n_objectSpread({},mapWithoutUrls));}return mapWithoutUrls;},[chainId,userAddedTokens,tokenMap,includeUserAdded]);}export function useDefaultTokens(){const defaultList=useDefaultTokenList();return useTokensFromMap(defaultList,false);}export function useAllTokens(chainId){const allTokens=useCombinedActiveList();return useTokensFromMap(allTokens,true,chainId);}export function useAllInactiveTokens(){// get inactive tokens\nconst inactiveTokensMap=useCombinedInactiveList();const inactiveTokens=useTokensFromMap(inactiveTokensMap,false);// filter out any token that are on active list\nconst activeTokensAddresses=Object.keys(useAllTokens());const filteredInactive=activeTokensAddresses?Object.keys(inactiveTokens).reduce((newMap,address)=>{if(!activeTokensAddresses.includes(address)){newMap[address]=inactiveTokens[address];}return newMap;},{}):inactiveTokens;return filteredInactive;}export function useUnsupportedTokens(){const unsupportedTokensMap=useUnsupportedTokenList();return useTokensFromMap(unsupportedTokensMap,false);}export function useIsTokenActive(token){const activeTokens=useAllTokens();if(!activeTokens||!token){return false;}return!!activeTokens[token.address];}// used to detect extra search results\nexport function useFoundOnInactiveList(searchQuery){const{network}=useCelo();const chainId=network.chainId;const inactiveTokens=useAllInactiveTokens();return useMemo(()=>{if(!chainId||searchQuery===''){return undefined;}else{const tokens=filterTokens(Object.values(inactiveTokens),searchQuery);return tokens;}},[chainId,inactiveTokens,searchQuery]);}// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency){const userAddedTokens=useUserAddedTokens();if(!currency){return false;}return!!userAddedTokens.find(token=>currencyEquals(currency,token));}// parse a name or symbol from a token response\nconst BYTES32_REGEX=/^0x[a-fA-F0-9]{64}$/;export function parseStringOrBytes32(str,bytes32,defaultValue){return str&&str.length>0?str:// need to check for proper bytes string and valid terminator\nbytes32&&BYTES32_REGEX.test(bytes32)&&arrayify(bytes32)[31]===0?parseBytes32String(bytes32):defaultValue;}// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress){const{network}=useCelo();const chainId=network.chainId;const tokens=useAllTokens();const address=isAddress(tokenAddress);const tokenContract=useTokenContract(address?address:undefined,false);const tokenContractBytes32=useBytes32TokenContract(address?address:undefined,false);const token=address?tokens[address]:undefined;const tokenName=useSingleCallResult(token?undefined:tokenContract,'name',undefined,NEVER_RELOAD);const tokenNameBytes32=useSingleCallResult(token?undefined:tokenContractBytes32,'name',undefined,NEVER_RELOAD);const symbol=useSingleCallResult(token?undefined:tokenContract,'symbol',undefined,NEVER_RELOAD);const symbolBytes32=useSingleCallResult(token?undefined:tokenContractBytes32,'symbol',undefined,NEVER_RELOAD);const decimals=useSingleCallResult(token?undefined:tokenContract,'decimals',undefined,NEVER_RELOAD);return useMemo(()=>{if(token)return token;if(!chainId||!address)return undefined;if(decimals.loading||symbol.loading||tokenName.loading)return null;if(decimals.result){var _symbol$result,_symbolBytes32$result,_tokenName$result,_tokenNameBytes32$res;return new Token(chainId,address,decimals.result[0],parseStringOrBytes32((_symbol$result=symbol.result)===null||_symbol$result===void 0?void 0:_symbol$result[0],(_symbolBytes32$result=symbolBytes32.result)===null||_symbolBytes32$result===void 0?void 0:_symbolBytes32$result[0],'UNKNOWN'),parseStringOrBytes32((_tokenName$result=tokenName.result)===null||_tokenName$result===void 0?void 0:_tokenName$result[0],(_tokenNameBytes32$res=tokenNameBytes32.result)===null||_tokenNameBytes32$res===void 0?void 0:_tokenNameBytes32$res[0],'Unknown Token'));}return undefined;},[address,chainId,decimals.loading,decimals.result,symbol.loading,symbol.result,symbolBytes32.result,token,tokenName.loading,tokenName.result,tokenNameBytes32.result]);}export function useCurrency(currencyId){const token=useToken(currencyId);return token;}","map":null,"metadata":{},"sourceType":"module"}