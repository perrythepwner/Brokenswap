{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * Array: ordered homogeneous collection\n */\nclass ArrayType extends composite_1.CompositeType {\n  constructor(elementType) {\n    super();\n    this.elementType = elementType;\n  }\n  defaultValue() {\n    return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);\n  }\n  // Proofs\n  getPropertyType() {\n    return this.elementType;\n  }\n  getPropertyGindex(prop) {\n    if (typeof prop !== \"number\") {\n      throw Error(\"Invalid array index: \".concat(prop));\n    }\n    const chunkIdx = Math.floor(prop / this.itemsPerChunk);\n    return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));\n  }\n  getIndexProperty(index) {\n    return index;\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    let length;\n    if (this.isList) {\n      if (!rootNode) {\n        throw new Error(\"List type requires tree argument to get leaves\");\n      }\n      length = this.tree_getLength(rootNode);\n    } else {\n      // Vectors don't need a rootNode to return length\n      length = this.tree_getLength(null);\n    }\n    const gindices = [];\n    if (composite_1.isCompositeType(this.elementType)) {\n      // Underlying elements exist one per chunk\n      // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n      const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));\n      const endGindex = startIndex + BigInt(length);\n      const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);\n      if (this.elementType.fixedSize === null) {\n        if (!rootNode) {\n          /* istanbul ignore next - unreachable code */\n          throw new Error(\"Array of variable size requires tree argument to get leaves\");\n        }\n        // variable-length elements must pass the underlying subtrees to determine the length\n        for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));\n        }\n      } else {\n        for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));\n        }\n      }\n    }\n    // Basic\n    else {\n      const chunkCount = Math.ceil(length / this.itemsPerChunk);\n      const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n      const endGindex = startIndex + BigInt(chunkCount);\n      for (let gindex = startIndex; gindex < endGindex; gindex++) {\n        gindices.push(gindex);\n      }\n    }\n    // include the length chunk\n    if (this.isList) {\n      gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps\n    // There are multiple tests that cover this path for all clases\n    return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);\n  }\n  toJson(value) {\n    return arrayBasic_1.value_toJsonArray(this.elementType, value, this);\n  }\n  clone(value) {\n    return arrayBasic_1.value_cloneArray(this.elementType, value);\n  }\n  equals(a, b) {\n    return arrayBasic_1.value_equals(this.elementType, a, b);\n  }\n}\nexports.ArrayType = ArrayType;","map":{"version":3,"sources":["../../src/type/array.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * Array: ordered homogeneous collection\n */\nclass ArrayType extends composite_1.CompositeType {\n    constructor(elementType) {\n        super();\n        this.elementType = elementType;\n    }\n    defaultValue() {\n        return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);\n    }\n    // Proofs\n    getPropertyType() {\n        return this.elementType;\n    }\n    getPropertyGindex(prop) {\n        if (typeof prop !== \"number\") {\n            throw Error(`Invalid array index: ${prop}`);\n        }\n        const chunkIdx = Math.floor(prop / this.itemsPerChunk);\n        return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));\n    }\n    getIndexProperty(index) {\n        return index;\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        let length;\n        if (this.isList) {\n            if (!rootNode) {\n                throw new Error(\"List type requires tree argument to get leaves\");\n            }\n            length = this.tree_getLength(rootNode);\n        }\n        else {\n            // Vectors don't need a rootNode to return length\n            length = this.tree_getLength(null);\n        }\n        const gindices = [];\n        if (composite_1.isCompositeType(this.elementType)) {\n            // Underlying elements exist one per chunk\n            // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n            const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));\n            const endGindex = startIndex + BigInt(length);\n            const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);\n            if (this.elementType.fixedSize === null) {\n                if (!rootNode) {\n                    /* istanbul ignore next - unreachable code */\n                    throw new Error(\"Array of variable size requires tree argument to get leaves\");\n                }\n                // variable-length elements must pass the underlying subtrees to determine the length\n                for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {\n                    gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));\n                }\n            }\n            else {\n                for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {\n                    gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));\n                }\n            }\n        }\n        // Basic\n        else {\n            const chunkCount = Math.ceil(length / this.itemsPerChunk);\n            const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n            const endGindex = startIndex + BigInt(chunkCount);\n            for (let gindex = startIndex; gindex < endGindex; gindex++) {\n                gindices.push(gindex);\n            }\n        }\n        // include the length chunk\n        if (this.isList) {\n            gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps\n        // There are multiple tests that cover this path for all clases\n        return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);\n    }\n    toJson(value) {\n        return arrayBasic_1.value_toJsonArray(this.elementType, value, this);\n    }\n    clone(value) {\n        return arrayBasic_1.value_cloneArray(this.elementType, value);\n    }\n    equals(a, b) {\n        return arrayBasic_1.value_equals(this.elementType, a, b);\n    }\n}\nexports.ArrayType = ArrayType;\n//# sourceMappingURL=array.js.map"]},"metadata":{},"sourceType":"script"}