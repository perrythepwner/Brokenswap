{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treePostProcessFromProofNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\nfunction treePostProcessFromProofNode(node, type) {\n  let bitstring = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n  if (currentDepth === 0) {\n    const nodePost = type.tree_fromProofNode(node);\n    if (nodePost.done) {\n      return nodePost.node;\n    } else {\n      node = nodePost.node;\n    }\n  }\n  const atTypeDepth = type.depth === currentDepth;\n  if (node.isLeaf()) {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      // If this type merkleized fits in a single chunk then this LeafNode includes all data\n      if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n        return childType.tree_fromProofNode(node).node;\n      }\n      // Witness node\n      else {\n        return node;\n      }\n    }\n    // LeafNode not at type depth is a witness or a length / selector nodes\n    else {\n      return node;\n    }\n  } else {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      if (!isCompositeType(childType)) {\n        throw Error(\"BranchNode does not map to CompositeType\");\n      }\n      const nodePost = childType.tree_fromProofNode(node);\n      // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n      if (nodePost.done) {\n        return nodePost.node;\n      } else {\n        return treePostProcessFromProofNode(nodePost.node, childType);\n      }\n    }\n    // BranchNode at not type depth, keep navigating\n    else {\n      const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n      const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n      if (leftNode === node.left && rightNode === node.right) {\n        return node;\n      } else {\n        return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n      }\n    }\n  }\n}\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\nfunction bitstringToIndex(bitstring) {\n  if (bitstring === \"\") return 0;\n  return parseInt(bitstring, 2);\n}","map":null,"metadata":{},"sourceType":"script"}