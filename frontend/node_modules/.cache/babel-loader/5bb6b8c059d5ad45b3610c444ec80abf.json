{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo,useConnectedSigner}from'@celo/react-celo';import{ChainId}from'@ubeswap/sdk';import{useCallback}from'react';import{useTransactionAdder}from'state/transactions/hooks';import{calculateGasMargin}from'utils';const estimateGas=/*#__PURE__*/function(){var _ref=_asyncToGenerator(function*(call){const{contract,methodName,args,value}=call;const fullArgs=value?[...args,{value}]:args;try{return yield contract.estimateGas[methodName](...fullArgs);}catch(gasError){console.debug('Gas estimate failed, trying eth_call to extract error',call);try{const result=yield contract.callStatic[methodName](...fullArgs);console.debug('Unexpected successful call after failed estimate gas',call,gasError,result);throw new Error('Unexpected issue with estimating the gas. Please try again.');}catch(callError){console.debug('Call threw error',call,callError);let errorMessage;switch(callError.reason){case'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':case'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':errorMessage='This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';break;default:errorMessage=\"The transaction cannot succeed due to error: \".concat(callError.reason,\". This is probably an issue with one of the tokens you are swapping.\");}throw new Error(errorMessage);}}});return function estimateGas(_x){return _ref.apply(this,arguments);};}();/**\n * Allows performing transactions.\n * @returns\n */export const useDoTransaction=()=>{const addTransaction=useTransactionAdder();const{network}=useCelo();const connectedSigner=useConnectedSigner();const chainId=network.chainId;return useCallback(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(function*(contractDisconnected,methodName,args){var _args$overrides;if(chainId===ChainId.BAKLAVA){throw new Error('baklava not supported');}if(!connectedSigner){throw new Error('no signer');}const contract=contractDisconnected.connect(connectedSigner);const call={contract,methodName,args:args.args,value:(_args$overrides=args.overrides)===null||_args$overrides===void 0?void 0:_args$overrides.value};const gasEstimate=yield estimateGas(call);try{let response;if(args.raw){response=yield connectedSigner.sendTransaction(args.raw);}else{response=yield contract[methodName](...args.args,_objectSpread({gasLimit:calculateGasMargin(gasEstimate)},args.overrides));}addTransaction(response,{summary:args.summary,approval:args.approval,claim:args.claim});return response;}catch(error){// if the user rejected the tx, pass this along\nif((error===null||error===void 0?void 0:error.code)===4001){throw new Error('Transaction rejected.');}else{// otherwise, the error was unexpected and we need to convey that\nconsole.error(\"Transaction failed\",error,methodName,args,call.value);throw new Error(\"Transaction failed: \".concat(error.message));}}});return function(_x2,_x3,_x4){return _ref2.apply(this,arguments);};}(),[addTransaction,chainId,connectedSigner]);};","map":null,"metadata":{},"sourceType":"module"}