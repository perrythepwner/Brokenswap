{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAsyncMiddleware = void 0;\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (req, res, next, end) {\n      // nextPromise is the key to the implementation\n      // it is resolved by the return handler passed to the\n      // \"next\" function\n      let resolveNextPromise;\n      const nextPromise = new Promise(resolve => {\n        resolveNextPromise = resolve;\n      });\n      let returnHandlerCallback = null;\n      let nextWasCalled = false;\n      // This will be called by the consumer's async middleware.\n      const asyncNext = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* () {\n          nextWasCalled = true;\n          // We pass a return handler to next(). When it is called by the engine,\n          // the consumer's async middleware will resume executing.\n          // eslint-disable-next-line node/callback-return\n          next(runReturnHandlersCallback => {\n            // This callback comes from JsonRpcEngine._runReturnHandlers\n            returnHandlerCallback = runReturnHandlersCallback;\n            resolveNextPromise();\n          });\n          yield nextPromise;\n        });\n        return function asyncNext() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      try {\n        yield asyncMiddleware(req, res, asyncNext);\n        if (nextWasCalled) {\n          yield nextPromise; // we must wait until the return handler is called\n          returnHandlerCallback(null);\n        } else {\n          end(null);\n        }\n      } catch (error) {\n        if (returnHandlerCallback) {\n          returnHandlerCallback(error);\n        } else {\n          end(error);\n        }\n      }\n    });\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nexports.createAsyncMiddleware = createAsyncMiddleware;","map":null,"metadata":{},"sourceType":"script"}