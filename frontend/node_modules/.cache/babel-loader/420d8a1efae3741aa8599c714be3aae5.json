{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitVector: ordered fixed-length collection of boolean values, with N bits\n * - Notation: `Bitvector[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitVectorType extends bitArray_2.BitArrayType {\n  constructor(lengthBits, opts) {\n    var _opts$typeName;\n    super();\n    this.lengthBits = lengthBits;\n    this.isList = false;\n    if (lengthBits === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"BitVector[\".concat(lengthBits, \"]\");\n    this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);\n    this.maxChunkCount = this.chunkCount;\n    this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);\n    this.fixedSize = Math.ceil(this.lengthBits / 8);\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n    // To cache mask for trailing zero bits validation\n    this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 0xff & 0xff << lengthBits % 8;\n  }\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);\n  }\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(this.lengthBits);\n  }\n  // Views: inherited from BitArrayType\n  // Serialization + deserialization\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return offset + this.fixedSize;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidLength(data.uint8Array, start, end);\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);\n  }\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n    return offset + this.fixedSize;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidLength(data.uint8Array, start, end);\n    return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);\n  }\n  tree_getByteLen() {\n    return this.fixedSize;\n  }\n  // Merkleization: inherited from BitArrayType\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n  assertValidLength(data, start, end) {\n    const size = end - start;\n    if (end - start !== this.fixedSize) {\n      throw Error(\"Invalid BitVector size \".concat(size, \" != \").concat(this.fixedSize));\n    }\n    // If lengthBits is not aligned to bytes, ensure trailing bits are zeroed\n    if (\n    // If zeroBitsMask == 0, then the BitVector uses full bytes only\n    this.zeroBitsMask > 0 &&\n    // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed\n    (data[end - 1] & this.zeroBitsMask) > 0) {\n      throw Error(\"BitVector: nonzero bits past length\");\n    }\n  }\n}\nexports.BitVectorType = BitVectorType;","map":{"version":3,"sources":["../../src/type/bitVector.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitVector: ordered fixed-length collection of boolean values, with N bits\n * - Notation: `Bitvector[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitVectorType extends bitArray_2.BitArrayType {\n    constructor(lengthBits, opts) {\n        super();\n        this.lengthBits = lengthBits;\n        this.isList = false;\n        if (lengthBits === 0)\n            throw Error(\"Vector length must be > 0\");\n        this.typeName = opts?.typeName ?? `BitVector[${lengthBits}]`;\n        this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);\n        this.maxChunkCount = this.chunkCount;\n        this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);\n        this.fixedSize = Math.ceil(this.lengthBits / 8);\n        this.minSize = this.fixedSize;\n        this.maxSize = this.fixedSize;\n        // To cache mask for trailing zero bits validation\n        this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 0xff & (0xff << lengthBits % 8);\n    }\n    static named(limitBits, opts) {\n        return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);\n    }\n    defaultValue() {\n        return bitArray_1.BitArray.fromBitLen(this.lengthBits);\n    }\n    // Views: inherited from BitArrayType\n    // Serialization + deserialization\n    value_serializedSize() {\n        return this.fixedSize;\n    }\n    value_serializeToBytes(output, offset, value) {\n        output.uint8Array.set(value.uint8Array, offset);\n        return offset + this.fixedSize;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        this.assertValidLength(data.uint8Array, start, end);\n        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n        return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);\n    }\n    tree_serializedSize() {\n        return this.fixedSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);\n        persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n        return offset + this.fixedSize;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        this.assertValidLength(data.uint8Array, start, end);\n        return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);\n    }\n    tree_getByteLen() {\n        return this.fixedSize;\n    }\n    // Merkleization: inherited from BitArrayType\n    // Proofs: inherited from BitArrayType\n    // JSON: inherited from BitArrayType\n    // Deserializer helpers\n    assertValidLength(data, start, end) {\n        const size = end - start;\n        if (end - start !== this.fixedSize) {\n            throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);\n        }\n        // If lengthBits is not aligned to bytes, ensure trailing bits are zeroed\n        if (\n        // If zeroBitsMask == 0, then the BitVector uses full bytes only\n        this.zeroBitsMask > 0 &&\n            // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed\n            (data[end - 1] & this.zeroBitsMask) > 0) {\n            throw Error(\"BitVector: nonzero bits past length\");\n        }\n    }\n}\nexports.BitVectorType = BitVectorType;\n//# sourceMappingURL=bitVector.js.map"]},"metadata":{},"sourceType":"script"}