{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{STAKING_REWARDS_INTERFACE}from'constants/abis/staking-rewards';import{UBE}from'constants/tokens';import useCurrentBlockTimestamp from'hooks/useCurrentBlockTimestamp';import{useMemo}from'react';import{useMultipleContractSingleData}from'state/multicall/hooks';import{INT_SECONDS_IN_WEEK}from'./../../constants/index';import{useStakingPools}from'./hooks';// Gets the staking info from the network for the active chain id\nexport default function useStakingInfo(pairToFilterBy,stakingAddress){const{network,address}=useCelo();const chainId=network.chainId;const ube=chainId?UBE[chainId]:undefined;// detect if staking is ended\nconst currentBlockTimestamp=useCurrentBlockTimestamp();const info=useStakingPools(pairToFilterBy,stakingAddress);// These are the staking pools\nconst rewardsAddresses=useMemo(()=>info.map(_ref=>{let{stakingRewardAddress}=_ref;return stakingRewardAddress;}),[info]);const accountArg=useMemo(()=>[address!==null&&address!==void 0?address:undefined],[address]);// get all the info from the staking rewards contracts\nconst balances=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'balanceOf',accountArg);const earnedAmounts=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'earned',accountArg);const totalSupplies=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'totalSupply');// tokens per second, constants\nconst rewardRates=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'rewardRate');const periodFinishes=useMultipleContractSingleData(rewardsAddresses,STAKING_REWARDS_INTERFACE,'periodFinish');return useMemo(()=>{if(!chainId||!ube)return[];return info.reduce((memo,_ref2,index)=>{let{stakingRewardAddress:rewardsAddress,poolInfo,tokens}=_ref2;// these two are dependent on account\nconst balanceState=balances[index];const earnedAmountState=earnedAmounts[index];// these get fetched regardless of account\nconst totalSupplyState=totalSupplies[index];const rewardRateState=rewardRates[index];const periodFinishState=periodFinishes[index];if(// these may be undefined if not logged in\n!(balanceState!==null&&balanceState!==void 0&&balanceState.loading)&&!(earnedAmountState!==null&&earnedAmountState!==void 0&&earnedAmountState.loading)&&// always need these\ntotalSupplyState&&!totalSupplyState.loading&&rewardRateState&&!rewardRateState.loading&&periodFinishState&&!periodFinishState.loading){var _balanceState$result$,_balanceState$result,_totalSupplyState$res,_poolInfo$nextPeriodR,_poolInfo$nextPeriodR2,_periodFinishState$re,_periodFinishState$re2,_rewardRateState$resu,_earnedAmountState$re,_earnedAmountState$re2;if(balanceState!==null&&balanceState!==void 0&&balanceState.error||earnedAmountState!==null&&earnedAmountState!==void 0&&earnedAmountState.error||totalSupplyState.error||rewardRateState.error||periodFinishState.error){console.error('Failed to load staking rewards info');return memo;}const rewardToken=poolInfo.rewardToken?new Token(chainId,poolInfo.rewardToken,18,poolInfo.rewardTokenSymbol):ube;// get the LP token\nconst liquidityToken=new Token(chainId,poolInfo.stakingToken,18,'ULP','Ubeswap LP Token');// check for account, if no account set to 0\nconst stakedAmount=new TokenAmount(liquidityToken,JSBI.BigInt((_balanceState$result$=balanceState===null||balanceState===void 0?void 0:(_balanceState$result=balanceState.result)===null||_balanceState$result===void 0?void 0:_balanceState$result[0])!==null&&_balanceState$result$!==void 0?_balanceState$result$:0));const totalStakedAmount=new TokenAmount(liquidityToken,JSBI.BigInt((_totalSupplyState$res=totalSupplyState.result)===null||_totalSupplyState$res===void 0?void 0:_totalSupplyState$res[0]));const nextPeriodRewards=new TokenAmount(ube,(_poolInfo$nextPeriodR=(_poolInfo$nextPeriodR2=poolInfo.nextPeriodRewards)===null||_poolInfo$nextPeriodR2===void 0?void 0:_poolInfo$nextPeriodR2.toString())!==null&&_poolInfo$nextPeriodR!==void 0?_poolInfo$nextPeriodR:'0');const getHypotheticalRewardRate=(stakedAmount,totalStakedAmount,totalRewardRates)=>{return[new TokenAmount(rewardToken,JSBI.greaterThan(totalStakedAmount.raw,JSBI.BigInt(0))?JSBI.divide(JSBI.multiply(totalRewardRates[0].raw,stakedAmount.raw),totalStakedAmount.raw):JSBI.BigInt(0))];};const periodFinishSeconds=(_periodFinishState$re=periodFinishState.result)===null||_periodFinishState$re===void 0?void 0:(_periodFinishState$re2=_periodFinishState$re[0])===null||_periodFinishState$re2===void 0?void 0:_periodFinishState$re2.toNumber();const periodFinishMs=periodFinishSeconds*1000;// compare period end timestamp vs current block timestamp (in seconds)\nconst active=periodFinishSeconds&&currentBlockTimestamp?periodFinishSeconds>currentBlockTimestamp.toNumber():false;const rewardsFinished=Math.floor(Date.now()/1000)-periodFinishSeconds>INT_SECONDS_IN_WEEK;const totalRewardRate=new TokenAmount(rewardToken,rewardsFinished?JSBI.BigInt(0):JSBI.BigInt((_rewardRateState$resu=rewardRateState.result)===null||_rewardRateState$resu===void 0?void 0:_rewardRateState$resu[0]));const individualRewardRate=getHypotheticalRewardRate(stakedAmount,totalStakedAmount,[totalRewardRate]);if(!tokens){return memo;}memo.push({stakingRewardAddress:rewardsAddress,stakingToken:totalStakedAmount.token,tokens,stakedAmount,totalStakedAmount,earnedAmounts:[new TokenAmount(rewardToken,JSBI.BigInt((_earnedAmountState$re=earnedAmountState===null||earnedAmountState===void 0?void 0:(_earnedAmountState$re2=earnedAmountState.result)===null||_earnedAmountState$re2===void 0?void 0:_earnedAmountState$re2[0])!==null&&_earnedAmountState$re!==void 0?_earnedAmountState$re:0))],rewardRates:individualRewardRate,totalRewardRates:[totalRewardRate],periodFinish:periodFinishMs>0?new Date(periodFinishMs):undefined,active,getHypotheticalRewardRate,nextPeriodRewards,poolInfo,rewardTokens:[rewardToken]});}return memo;},[]);},[balances,chainId,currentBlockTimestamp,earnedAmounts,info,periodFinishes,rewardRates,totalSupplies,ube]);}// `stakingAddress` is used to differentiate when there are two different farms with the same LP\nexport const usePairStakingInfo=(pairToFilterBy,stakingAddress)=>{var _useStakingInfo$;return(_useStakingInfo$=useStakingInfo(pairToFilterBy,stakingAddress)[0])!==null&&_useStakingInfo$!==void 0?_useStakingInfo$:undefined;};","map":null,"metadata":{},"sourceType":"module"}