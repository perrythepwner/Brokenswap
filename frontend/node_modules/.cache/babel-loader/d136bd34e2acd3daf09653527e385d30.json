{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;\n/** Globally cache this information. @see getUint8ByteToBitBooleanArray */\nconst uint8ByteToBitBooleanArrays = new Array(256);\n/**\n * BitArray may be represented as an array of bits or compressed into an array of bytes.\n *\n * **Array of bits**:\n * Require 8.87 bytes per bit, so for 512 bits = 4500 bytes.\n * Are 'faster' to iterate with native tooling but are as fast as array of bytes with precomputed caches.\n *\n * **Array of bytes**:\n * Require an average cost of Uint8Array in JS = 220 bytes for 32 bytes, so for 512 bits = 220 bytes.\n * With precomputed boolean arrays per bytes value are as fast to iterate as an array of bits above.\n *\n * This BitArray implementation will represent data as a Uint8Array since it's very cheap to deserialize and can be as\n * fast to iterate as a native array of booleans, precomputing boolean arrays (total memory cost of 16000 bytes).\n */\nclass BitArray {\n  constructor( /** Underlying BitArray Uint8Array data */\n  uint8Array, /** Immutable bitLen of this BitArray */\n  bitLen) {\n    this.uint8Array = uint8Array;\n    this.bitLen = bitLen;\n    if (uint8Array.length !== Math.ceil(bitLen / 8)) {\n      throw Error(\"BitArray uint8Array length does not match bitLen\");\n    }\n  }\n  /** Returns a zero'ed BitArray of `bitLen` */\n  static fromBitLen(bitLen) {\n    return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);\n  }\n  /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */\n  static fromSingleBit(bitLen, bitIndex) {\n    const bitArray = BitArray.fromBitLen(bitLen);\n    bitArray.set(bitIndex, true);\n    return bitArray;\n  }\n  /** Returns a BitArray from an array of booleans representation */\n  static fromBoolArray(bitBoolArr) {\n    const bitArray = BitArray.fromBitLen(bitBoolArr.length);\n    for (let i = 0; i < bitBoolArr.length; i++) {\n      if (bitBoolArr[i] === true) {\n        bitArray.set(i, true);\n      }\n    }\n    return bitArray;\n  }\n  clone() {\n    // TODO: Benchmark if Uint8Array.slice(0) is the fastest way to copy data here\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);\n  }\n  /**\n   * Get bit value at index `bitIndex`\n   */\n  get(bitIndex) {\n    const byteIdx = Math.floor(bitIndex / 8);\n    const bitInBit = bitIndex % 8;\n    const mask = 1 << bitInBit;\n    return (this.uint8Array[byteIdx] & mask) === mask;\n  }\n  /**\n   * Set bit value at index `bitIndex`\n   */\n  set(bitIndex, bit) {\n    if (bitIndex >= this.bitLen) {\n      throw Error(\"BitArray set bitIndex \".concat(bitIndex, \" beyond bitLen \").concat(this.bitLen));\n    }\n    const byteIdx = Math.floor(bitIndex / 8);\n    const bitInBit = bitIndex % 8;\n    const mask = 1 << bitInBit;\n    let byte = this.uint8Array[byteIdx];\n    if (bit) {\n      // For bit in byte, 1,0 OR 1 = 1\n      // byte 100110\n      // mask 010000\n      // res  110110\n      byte |= mask;\n      this.uint8Array[byteIdx] = byte;\n    } else {\n      // For bit in byte, 1,0 OR 1 = 0\n      if ((byte & mask) === mask) {\n        // byte 110110\n        // mask 010000\n        // res  100110\n        byte ^= mask;\n        this.uint8Array[byteIdx] = byte;\n      } else {\n        // Ok, bit is already 0\n      }\n    }\n  }\n  /** Merge two BitArray bitfields with OR. Must have the same bitLen */\n  mergeOrWith(bitArray2) {\n    if (bitArray2.bitLen !== this.bitLen) {\n      throw Error(\"Must merge BitArrays of same bitLen\");\n    }\n    // Merge bitFields\n    for (let i = 0; i < this.uint8Array.length; i++) {\n      this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];\n    }\n  }\n  /**\n   * Returns an array with the indexes which have a bit set to true\n   */\n  intersectValues(values) {\n    const yes = [];\n    if (values.length !== this.bitLen) {\n      throw Error(\"Must not intersect values of length \".concat(values.length, \" != bitLen \").concat(this.bitLen));\n    }\n    const fullByteLen = Math.floor(this.bitLen / 8);\n    const remainderBits = this.bitLen % 8;\n    // Iterate over each byte of bits\n    const bytes = this.uint8Array;\n    for (let iByte = 0; iByte < fullByteLen; iByte++) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit]) {\n          yes.push(values[iByte * 8 + iBit]);\n        }\n      }\n    }\n    if (remainderBits > 0) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < remainderBits; iBit++) {\n        if (booleansInByte[iBit]) {\n          yes.push(values[fullByteLen * 8 + iBit]);\n        }\n      }\n    }\n    return yes;\n  }\n  /**\n   * Returns the positions of all bits that are set to true\n   */\n  getTrueBitIndexes() {\n    const indexes = [];\n    // Iterate over each byte of bits\n    const bytes = this.uint8Array;\n    for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit]) {\n          indexes.push(iByte * 8 + iBit);\n        }\n      }\n    }\n    return indexes;\n  }\n  /**\n   * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.\n   * @returns\n   *  - number: if there's a single bit set, the number it the single bit set position\n   *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET\n   * @throws\n   *  - ERROR_MORE_THAN_ONE_BIT_SET\n   *  - ERROR_NO_BIT_SET\n   */\n  getSingleTrueBit() {\n    let index = null;\n    const bytes = this.uint8Array;\n    // Iterate over each byte of bits\n    for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n      // If it's exactly zero, there won't be any indexes, continue early\n      if (bytes[iByte] === 0) {\n        continue;\n      }\n      // Get the precomputed boolean array for this byte\n      const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n      // For each bit in the byte check participation and add to indexesSelected array\n      for (let iBit = 0; iBit < 8; iBit++) {\n        if (booleansInByte[iBit] === true) {\n          if (index !== null) {\n            // ERROR_MORE_THAN_ONE_BIT_SET\n            return null;\n          }\n          index = iByte * 8 + iBit;\n        }\n      }\n    }\n    if (index === null) {\n      // ERROR_NO_BIT_SET\n      return null;\n    } else {\n      return index;\n    }\n  }\n  toBoolArray() {\n    const bitBoolArr = new Array(this.bitLen);\n    for (let i = 0; i < this.bitLen; i++) {\n      bitBoolArr[i] = this.get(i);\n    }\n    return bitBoolArr;\n  }\n}\nexports.BitArray = BitArray;\n/**\n * Given a byte (0 -> 255), return a Array of boolean with length = 8, big endian.\n * Ex: 1 => [true false false false false false false false]\n *     5 => [true false true false false fase false false]\n */\nfunction getUint8ByteToBitBooleanArray(byte) {\n  if (!uint8ByteToBitBooleanArrays[byte]) {\n    uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);\n  }\n  return uint8ByteToBitBooleanArrays[byte];\n}\nexports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;\n/** @see getUint8ByteToBitBooleanArray */\nfunction computeUint8ByteToBitBooleanArray(byte) {\n  // this returns little endian\n  const binaryStr = byte.toString(2);\n  const binaryLength = binaryStr.length;\n  const bits = new Array(8);\n  for (let i = 0; i < 8; i++) {\n    bits[i] = i < binaryLength ?\n    //\n    binaryStr[binaryLength - i - 1] === \"1\" : false;\n  }\n  return bits;\n}","map":{"version":3,"sources":["../../src/value/bitArray.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getUint8ByteToBitBooleanArray = exports.BitArray = void 0;\n/** Globally cache this information. @see getUint8ByteToBitBooleanArray */\nconst uint8ByteToBitBooleanArrays = new Array(256);\n/**\n * BitArray may be represented as an array of bits or compressed into an array of bytes.\n *\n * **Array of bits**:\n * Require 8.87 bytes per bit, so for 512 bits = 4500 bytes.\n * Are 'faster' to iterate with native tooling but are as fast as array of bytes with precomputed caches.\n *\n * **Array of bytes**:\n * Require an average cost of Uint8Array in JS = 220 bytes for 32 bytes, so for 512 bits = 220 bytes.\n * With precomputed boolean arrays per bytes value are as fast to iterate as an array of bits above.\n *\n * This BitArray implementation will represent data as a Uint8Array since it's very cheap to deserialize and can be as\n * fast to iterate as a native array of booleans, precomputing boolean arrays (total memory cost of 16000 bytes).\n */\nclass BitArray {\n    constructor(\n    /** Underlying BitArray Uint8Array data */\n    uint8Array, \n    /** Immutable bitLen of this BitArray */\n    bitLen) {\n        this.uint8Array = uint8Array;\n        this.bitLen = bitLen;\n        if (uint8Array.length !== Math.ceil(bitLen / 8)) {\n            throw Error(\"BitArray uint8Array length does not match bitLen\");\n        }\n    }\n    /** Returns a zero'ed BitArray of `bitLen` */\n    static fromBitLen(bitLen) {\n        return new BitArray(new Uint8Array(Math.ceil(bitLen / 8)), bitLen);\n    }\n    /** Returns a BitArray of `bitLen` with a single bit set to true at position `bitIndex` */\n    static fromSingleBit(bitLen, bitIndex) {\n        const bitArray = BitArray.fromBitLen(bitLen);\n        bitArray.set(bitIndex, true);\n        return bitArray;\n    }\n    /** Returns a BitArray from an array of booleans representation */\n    static fromBoolArray(bitBoolArr) {\n        const bitArray = BitArray.fromBitLen(bitBoolArr.length);\n        for (let i = 0; i < bitBoolArr.length; i++) {\n            if (bitBoolArr[i] === true) {\n                bitArray.set(i, true);\n            }\n        }\n        return bitArray;\n    }\n    clone() {\n        // TODO: Benchmark if Uint8Array.slice(0) is the fastest way to copy data here\n        // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n        return new BitArray(Uint8Array.prototype.slice.call(this.uint8Array, 0), this.bitLen);\n    }\n    /**\n     * Get bit value at index `bitIndex`\n     */\n    get(bitIndex) {\n        const byteIdx = Math.floor(bitIndex / 8);\n        const bitInBit = bitIndex % 8;\n        const mask = 1 << bitInBit;\n        return (this.uint8Array[byteIdx] & mask) === mask;\n    }\n    /**\n     * Set bit value at index `bitIndex`\n     */\n    set(bitIndex, bit) {\n        if (bitIndex >= this.bitLen) {\n            throw Error(`BitArray set bitIndex ${bitIndex} beyond bitLen ${this.bitLen}`);\n        }\n        const byteIdx = Math.floor(bitIndex / 8);\n        const bitInBit = bitIndex % 8;\n        const mask = 1 << bitInBit;\n        let byte = this.uint8Array[byteIdx];\n        if (bit) {\n            // For bit in byte, 1,0 OR 1 = 1\n            // byte 100110\n            // mask 010000\n            // res  110110\n            byte |= mask;\n            this.uint8Array[byteIdx] = byte;\n        }\n        else {\n            // For bit in byte, 1,0 OR 1 = 0\n            if ((byte & mask) === mask) {\n                // byte 110110\n                // mask 010000\n                // res  100110\n                byte ^= mask;\n                this.uint8Array[byteIdx] = byte;\n            }\n            else {\n                // Ok, bit is already 0\n            }\n        }\n    }\n    /** Merge two BitArray bitfields with OR. Must have the same bitLen */\n    mergeOrWith(bitArray2) {\n        if (bitArray2.bitLen !== this.bitLen) {\n            throw Error(\"Must merge BitArrays of same bitLen\");\n        }\n        // Merge bitFields\n        for (let i = 0; i < this.uint8Array.length; i++) {\n            this.uint8Array[i] = this.uint8Array[i] | bitArray2.uint8Array[i];\n        }\n    }\n    /**\n     * Returns an array with the indexes which have a bit set to true\n     */\n    intersectValues(values) {\n        const yes = [];\n        if (values.length !== this.bitLen) {\n            throw Error(`Must not intersect values of length ${values.length} != bitLen ${this.bitLen}`);\n        }\n        const fullByteLen = Math.floor(this.bitLen / 8);\n        const remainderBits = this.bitLen % 8;\n        // Iterate over each byte of bits\n        const bytes = this.uint8Array;\n        for (let iByte = 0; iByte < fullByteLen; iByte++) {\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < 8; iBit++) {\n                if (booleansInByte[iBit]) {\n                    yes.push(values[iByte * 8 + iBit]);\n                }\n            }\n        }\n        if (remainderBits > 0) {\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[fullByteLen]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < remainderBits; iBit++) {\n                if (booleansInByte[iBit]) {\n                    yes.push(values[fullByteLen * 8 + iBit]);\n                }\n            }\n        }\n        return yes;\n    }\n    /**\n     * Returns the positions of all bits that are set to true\n     */\n    getTrueBitIndexes() {\n        const indexes = [];\n        // Iterate over each byte of bits\n        const bytes = this.uint8Array;\n        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < 8; iBit++) {\n                if (booleansInByte[iBit]) {\n                    indexes.push(iByte * 8 + iBit);\n                }\n            }\n        }\n        return indexes;\n    }\n    /**\n     * Return the position of a single bit set. If no bit set or more than 1 bit set, throws.\n     * @returns\n     *  - number: if there's a single bit set, the number it the single bit set position\n     *  - null: if ERROR_MORE_THAN_ONE_BIT_SET or ERROR_NO_BIT_SET\n     * @throws\n     *  - ERROR_MORE_THAN_ONE_BIT_SET\n     *  - ERROR_NO_BIT_SET\n     */\n    getSingleTrueBit() {\n        let index = null;\n        const bytes = this.uint8Array;\n        // Iterate over each byte of bits\n        for (let iByte = 0, byteLen = bytes.length; iByte < byteLen; iByte++) {\n            // If it's exactly zero, there won't be any indexes, continue early\n            if (bytes[iByte] === 0) {\n                continue;\n            }\n            // Get the precomputed boolean array for this byte\n            const booleansInByte = getUint8ByteToBitBooleanArray(bytes[iByte]);\n            // For each bit in the byte check participation and add to indexesSelected array\n            for (let iBit = 0; iBit < 8; iBit++) {\n                if (booleansInByte[iBit] === true) {\n                    if (index !== null) {\n                        // ERROR_MORE_THAN_ONE_BIT_SET\n                        return null;\n                    }\n                    index = iByte * 8 + iBit;\n                }\n            }\n        }\n        if (index === null) {\n            // ERROR_NO_BIT_SET\n            return null;\n        }\n        else {\n            return index;\n        }\n    }\n    toBoolArray() {\n        const bitBoolArr = new Array(this.bitLen);\n        for (let i = 0; i < this.bitLen; i++) {\n            bitBoolArr[i] = this.get(i);\n        }\n        return bitBoolArr;\n    }\n}\nexports.BitArray = BitArray;\n/**\n * Given a byte (0 -> 255), return a Array of boolean with length = 8, big endian.\n * Ex: 1 => [true false false false false false false false]\n *     5 => [true false true false false fase false false]\n */\nfunction getUint8ByteToBitBooleanArray(byte) {\n    if (!uint8ByteToBitBooleanArrays[byte]) {\n        uint8ByteToBitBooleanArrays[byte] = computeUint8ByteToBitBooleanArray(byte);\n    }\n    return uint8ByteToBitBooleanArrays[byte];\n}\nexports.getUint8ByteToBitBooleanArray = getUint8ByteToBitBooleanArray;\n/** @see getUint8ByteToBitBooleanArray */\nfunction computeUint8ByteToBitBooleanArray(byte) {\n    // this returns little endian\n    const binaryStr = byte.toString(2);\n    const binaryLength = binaryStr.length;\n    const bits = new Array(8);\n    for (let i = 0; i < 8; i++) {\n        bits[i] =\n            i < binaryLength\n                ? //\n                    binaryStr[binaryLength - i - 1] === \"1\"\n                : false;\n    }\n    return bits;\n}\n//# sourceMappingURL=bitArray.js.map"]},"metadata":{},"sourceType":"script"}