{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{ChainId}from'@celo/react-celo';import UBESWAP_TOKEN_LIST from'@ubeswap/default-token-list';import{Token}from'@ubeswap/sdk';import UNISWAP_TOKEN_LIST from'@uniswap/default-token-list';import{useMemo}from'react';import{useSelector}from'react-redux';import sortByListPriority from'utils/listSort';import{UNSUPPORTED_LIST_URLS}from'./../../constants/lists';/**\n * Token instances created from token info.\n */export class WrappedTokenInfo extends Token{constructor(tokenInfo,tags){super(tokenInfo.chainId,tokenInfo.address,tokenInfo.decimals,tokenInfo.symbol,tokenInfo.name);this.tokenInfo=void 0;this.tags=void 0;this.tokenInfo=tokenInfo;this.tags=tags;}get logoURI(){return this.tokenInfo.logoURI;}}/**\n * An empty result, useful as a default.\n */const EMPTY_LIST={[ChainId.Mainnet]:{},[ChainId.Alfajores]:{},[ChainId.Baklava]:{}};const listCache=typeof WeakMap!=='undefined'?new WeakMap():null;export function listToTokenMap(list){const result=listCache===null||listCache===void 0?void 0:listCache.get(list);if(result)return result;const map=list.tokens.reduce((tokenMap,tokenInfo)=>{var _tokenInfo$tags$map$f,_tokenInfo$tags,_tokenInfo$tags$map,_tokenMap$token$chain;const tags=(_tokenInfo$tags$map$f=(_tokenInfo$tags=tokenInfo.tags)===null||_tokenInfo$tags===void 0?void 0:(_tokenInfo$tags$map=_tokenInfo$tags.map(tagId=>{var _list$tags;if(!((_list$tags=list.tags)!==null&&_list$tags!==void 0&&_list$tags[tagId]))return undefined;return _objectSpread(_objectSpread({},list.tags[tagId]),{},{id:tagId});}))===null||_tokenInfo$tags$map===void 0?void 0:_tokenInfo$tags$map.filter(x=>Boolean(x)))!==null&&_tokenInfo$tags$map$f!==void 0?_tokenInfo$tags$map$f:[];const token=new WrappedTokenInfo(tokenInfo,tags);if(((_tokenMap$token$chain=tokenMap[token.chainId])===null||_tokenMap$token$chain===void 0?void 0:_tokenMap$token$chain[token.address])!==undefined)throw Error(\"Duplicate tokens found for \".concat(token.name));return _objectSpread(_objectSpread({},tokenMap),{},{[token.chainId]:_objectSpread(_objectSpread({},tokenMap[token.chainId]),{},{[token.address]:{token,list:list}})});},_objectSpread({},EMPTY_LIST));listCache===null||listCache===void 0?void 0:listCache.set(list,map);return map;}export function useAllLists(){return useSelector(state=>state.lists.byUrl);}function combineMaps(map1,map2){return{[ChainId.Mainnet]:_objectSpread(_objectSpread({},map1[ChainId.Mainnet]),map2[ChainId.Mainnet]),[ChainId.Alfajores]:_objectSpread(_objectSpread({},map1[ChainId.Alfajores]),map2[ChainId.Alfajores]),[ChainId.Baklava]:_objectSpread(_objectSpread({},map1[ChainId.Baklava]),map2[ChainId.Baklava])};}// merge tokens contained within lists from urls\nfunction useCombinedTokenMapFromUrls(urls){const lists=useAllLists();return useMemo(()=>{if(!urls)return EMPTY_LIST;return urls.slice()// sort by priority so top priority goes last\n.sort(sortByListPriority).reduce((allTokens,currentUrl)=>{var _lists$currentUrl;const current=(_lists$currentUrl=lists[currentUrl])===null||_lists$currentUrl===void 0?void 0:_lists$currentUrl.current;if(!current)return allTokens;try{const newTokens=Object.assign(listToTokenMap(current));return combineMaps(allTokens,newTokens);}catch(error){console.error('Could not show token list due to error',error);return allTokens;}},EMPTY_LIST);},[lists,urls]);}// filter out unsupported lists\nexport function useActiveListUrls(){var _useSelector;return(_useSelector=useSelector(state=>state.lists.activeListUrls))===null||_useSelector===void 0?void 0:_useSelector.filter(url=>!UNSUPPORTED_LIST_URLS.includes(url));}export function useInactiveListUrls(){const lists=useAllLists();const allActiveListUrls=useActiveListUrls();return Object.keys(lists).filter(url=>!(allActiveListUrls!==null&&allActiveListUrls!==void 0&&allActiveListUrls.includes(url))&&!UNSUPPORTED_LIST_URLS.includes(url));}// get all the tokens from active lists, combine with local default tokens\nexport function useCombinedActiveList(){const activeListUrls=useActiveListUrls();const activeTokens=useCombinedTokenMapFromUrls(activeListUrls);const defaultTokenMap=listToTokenMap(_objectSpread(_objectSpread({},UBESWAP_TOKEN_LIST),UNISWAP_TOKEN_LIST));return combineMaps(activeTokens,defaultTokenMap);}// all tokens from inactive lists\nexport function useCombinedInactiveList(){const allInactiveListUrls=useInactiveListUrls();return useCombinedTokenMapFromUrls(allInactiveListUrls);}// used to hide warnings on import for default tokens\nexport function useDefaultTokenList(){return _objectSpread(_objectSpread({},listToTokenMap(UBESWAP_TOKEN_LIST)),listToTokenMap(UNISWAP_TOKEN_LIST));}// list of tokens not supported on interface, used to show warnings and prevent swaps and adds\nexport function useUnsupportedTokenList(){// get any loaded unsupported tokens\nconst loadedUnsupportedListMap=useCombinedTokenMapFromUrls(UNSUPPORTED_LIST_URLS);// format into one token address map\nreturn loadedUnsupportedListMap;}export function useIsListActive(url){const activeListUrls=useActiveListUrls();return Boolean(activeListUrls===null||activeListUrls===void 0?void 0:activeListUrls.includes(url));}","map":null,"metadata":{},"sourceType":"module"}