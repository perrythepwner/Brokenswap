{"ast":null,"code":"import JSBI from 'jsbi';\nexport { default as JSBI } from 'jsbi';\nimport invariant from 'tiny-invariant';\nimport _Decimal from 'decimal.js-light';\nimport _Big from 'big.js';\nimport toFormat from 'toformat';\nimport { getAddress, getCreate2Address } from '@ethersproject/address';\nimport warning from 'tiny-warning';\nimport { keccak256, pack } from '@ethersproject/solidity';\nimport { Contract } from '@ethersproject/contracts';\nimport { getNetwork } from '@ethersproject/networks';\nimport { getDefaultProvider } from '@ethersproject/providers';\nimport IUniswapV2Pair from '@uniswap/v2-core/build/IUniswapV2Pair.json';\nvar _SOLIDITY_TYPE_MAXIMA, _CHAIN_INFO;\nvar ChainId;\n(function (ChainId) {\n  ChainId[ChainId[\"MAINNET\"] = 42220] = \"MAINNET\";\n  ChainId[ChainId[\"ALFAJORES\"] = 44787] = \"ALFAJORES\";\n  ChainId[ChainId[\"BAKLAVA\"] = 62320] = \"BAKLAVA\";\n})(ChainId || (ChainId = {}));\nvar TradeType;\n(function (TradeType) {\n  TradeType[TradeType[\"EXACT_INPUT\"] = 0] = \"EXACT_INPUT\";\n  TradeType[TradeType[\"EXACT_OUTPUT\"] = 1] = \"EXACT_OUTPUT\";\n})(TradeType || (TradeType = {}));\nvar Rounding;\n(function (Rounding) {\n  Rounding[Rounding[\"ROUND_DOWN\"] = 0] = \"ROUND_DOWN\";\n  Rounding[Rounding[\"ROUND_HALF_UP\"] = 1] = \"ROUND_HALF_UP\";\n  Rounding[Rounding[\"ROUND_UP\"] = 2] = \"ROUND_UP\";\n})(Rounding || (Rounding = {}));\nvar FACTORY_ADDRESS = '0x62d5b84bE28a183aBB507E125B384122D2C25fAE';\nvar INIT_CODE_HASH = '0xb3b8ff62960acea3a88039ebcf80699f15786f1b17cebd82802f7375827a339c';\nvar MINIMUM_LIQUIDITY = /*#__PURE__*/JSBI.BigInt(1000); // exports for internal consumption\n\nvar ZERO = /*#__PURE__*/JSBI.BigInt(0);\nvar ONE = /*#__PURE__*/JSBI.BigInt(1);\nvar TWO = /*#__PURE__*/JSBI.BigInt(2);\nvar THREE = /*#__PURE__*/JSBI.BigInt(3);\nvar FIVE = /*#__PURE__*/JSBI.BigInt(5);\nvar TEN = /*#__PURE__*/JSBI.BigInt(10);\nvar _100 = /*#__PURE__*/JSBI.BigInt(100);\nvar _997 = /*#__PURE__*/JSBI.BigInt(997);\nvar _1000 = /*#__PURE__*/JSBI.BigInt(1000);\nvar SolidityType;\n(function (SolidityType) {\n  SolidityType[\"uint8\"] = \"uint8\";\n  SolidityType[\"uint256\"] = \"uint256\";\n})(SolidityType || (SolidityType = {}));\nvar SOLIDITY_TYPE_MAXIMA = (_SOLIDITY_TYPE_MAXIMA = {}, _SOLIDITY_TYPE_MAXIMA[SolidityType.uint8] = /*#__PURE__*/JSBI.BigInt('0xff'), _SOLIDITY_TYPE_MAXIMA[SolidityType.uint256] = /*#__PURE__*/JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'), _SOLIDITY_TYPE_MAXIMA);\nvar CHAIN_INFO = (_CHAIN_INFO = {}, _CHAIN_INFO[ChainId.ALFAJORES] = {\n  name: 'Alfajores',\n  fornoURL: 'https://alfajores-forno.celo-testnet.org',\n  blockscoutURL: 'https://alfajores-blockscout.celo-testnet.org'\n}, _CHAIN_INFO[ChainId.BAKLAVA] = {\n  name: 'Baklava',\n  fornoURL: 'https://baklava-forno.celo-testnet.org',\n  blockscoutURL: 'https://baklava-blockscout.celo-testnet.org'\n}, _CHAIN_INFO[ChainId.MAINNET] = {\n  name: 'Mainnet',\n  fornoURL: 'https://forno.celo.org',\n  blockscoutURL: 'https://explorer.celo.org'\n}, _CHAIN_INFO);\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\nfunction validateSolidityTypeInstance(value, solidityType) {\n  !JSBI.greaterThanOrEqual(value, ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, value + \" is not a \" + solidityType + \".\") : invariant(false) : void 0;\n  !JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]) ? process.env.NODE_ENV !== \"production\" ? invariant(false, value + \" is not a \" + solidityType + \".\") : invariant(false) : void 0;\n} // warns if addresses are not checksummed\n\nfunction validateAndParseAddress(address) {\n  try {\n    var checksummedAddress = getAddress(address);\n    process.env.NODE_ENV !== \"production\" ? warning(address === checksummedAddress, address + \" is not checksummed.\") : void 0;\n    return checksummedAddress;\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? invariant(false, address + \" is not a valid address.\") : invariant(false);\n  }\n}\nfunction parseBigintIsh(bigintIsh) {\n  return bigintIsh instanceof JSBI ? bigintIsh : typeof bigintIsh === 'bigint' ? JSBI.BigInt(bigintIsh.toString()) : JSBI.BigInt(bigintIsh);\n} // mock the on-chain sqrt function\n\nfunction sqrt(y) {\n  validateSolidityTypeInstance(y, SolidityType.uint256);\n  var z = ZERO;\n  var x;\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y;\n    x = JSBI.add(JSBI.divide(y, TWO), ONE);\n    while (JSBI.lessThan(x, z)) {\n      z = x;\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO);\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE;\n  }\n  return z;\n} // given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\n\nfunction sortedInsert(items, add, maxSize, comparator) {\n  !(maxSize > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_SIZE_ZERO') : invariant(false) : void 0; // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n\n  !(items.length <= maxSize) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ITEMS_SIZE') : invariant(false) : void 0; // short circuit first item add\n\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    var isFull = items.length === maxSize; // short circuit if full and the additional item does not come before the last item\n\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n    var lo = 0,\n      hi = items.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}\n/**\r\n * Parses a Celo chain ID number into a ChainId enum instance.\r\n * @param chainId The chain ID as a number.\r\n */\n\nvar parseNetwork = function parseNetwork(chainId) {\n  if (!Object.values(ChainId).includes(chainId)) {\n    throw new Error(\"Unknown Celo chain ID: \" + chainId);\n  }\n  return chainId;\n};\nfunction getBlockscoutLink(chainId, data, type) {\n  var prefix = CHAIN_INFO[chainId].blockscoutURL;\n  switch (type) {\n    case 'transaction':\n      {\n        return prefix + \"/tx/\" + data;\n      }\n    case 'token':\n      {\n        return prefix + \"/tokens/\" + data;\n      }\n    case 'block':\n      {\n        return prefix + \"/blocks/\" + data;\n      }\n    case 'address':\n    default:\n      {\n        return prefix + \"/address/\" + data;\n      }\n  }\n}\nvar _toSignificantRoundin, _toFixedRounding;\nvar Decimal = /*#__PURE__*/toFormat(_Decimal);\nvar Big = /*#__PURE__*/toFormat(_Big);\nvar toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);\nvar toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);\nvar Fraction = /*#__PURE__*/function () {\n  function Fraction(numerator, denominator) {\n    if (denominator === void 0) {\n      denominator = ONE;\n    }\n    this.numerator = parseBigintIsh(numerator);\n    this.denominator = parseBigintIsh(denominator);\n  } // performs floor division\n\n  var _proto = Fraction.prototype;\n  _proto.invert = function invert() {\n    return new Fraction(this.denominator, this.numerator);\n  };\n  _proto.add = function add(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);\n    }\n    return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n  _proto.subtract = function subtract(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);\n    }\n    return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n  _proto.lessThan = function lessThan(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n  _proto.equalTo = function equalTo(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n  _proto.greaterThan = function greaterThan(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));\n  };\n  _proto.multiply = function multiply(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));\n  };\n  _proto.divide = function divide(other) {\n    var otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other));\n    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));\n  };\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n    !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== \"production\" ? invariant(false, significantDigits + \" is not an integer.\") : invariant(false) : void 0;\n    !(significantDigits > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, significantDigits + \" is not positive.\") : invariant(false) : void 0;\n    Decimal.set({\n      precision: significantDigits + 1,\n      rounding: toSignificantRounding[rounding]\n    });\n    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_HALF_UP;\n    }\n    !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== \"production\" ? invariant(false, decimalPlaces + \" is not an integer.\") : invariant(false) : void 0;\n    !(decimalPlaces >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, decimalPlaces + \" is negative.\") : invariant(false) : void 0;\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding];\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  };\n  _createClass(Fraction, [{\n    key: \"quotient\",\n    get: function get() {\n      return JSBI.divide(this.numerator, this.denominator);\n    } // remainder after floor division\n  }, {\n    key: \"remainder\",\n    get: function get() {\n      return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);\n    }\n  }]);\n  return Fraction;\n}();\nvar _100_PERCENT = /*#__PURE__*/new Fraction(_100);\nvar Percent = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Percent, _Fraction);\n  function Percent() {\n    return _Fraction.apply(this, arguments) || this;\n  }\n  var _proto = Percent.prototype;\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 5;\n    }\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 2;\n    }\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding);\n  };\n  return Percent;\n}(Fraction);\nvar _CELO, _cUSD, _cEUR, _cREAL;\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\n\nvar Token = /*#__PURE__*/function () {\n  /**\r\n   * Constructs an instance of the base class `Currency`.\r\n   * @param decimals decimals of the currency\r\n   * @param symbol symbol of the currency\r\n   * @param name of the currency\r\n   */\n  function Token(chainId, address, decimals, symbol, name) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8);\n    this.decimals = decimals;\n    this.symbol = symbol;\n    this.name = name;\n    this.chainId = chainId;\n    this.address = validateAndParseAddress(address);\n  }\n  /**\r\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n   * @param other other token to compare\r\n   */\n\n  var _proto = Token.prototype;\n  _proto.equals = function equals(other) {\n    // short circuit on reference equality\n    if (this === other) {\n      return true;\n    }\n    return this.chainId === other.chainId && this.address === other.address;\n  }\n  /**\r\n   * Returns true if the address of this token sorts before the address of the other token\r\n   * @param other other token to compare\r\n   * @throws if the tokens have the same address\r\n   * @throws if the tokens are on different chains\r\n   */;\n\n  _proto.sortsBefore = function sortsBefore(other) {\n    !(this.chainId === other.chainId) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;\n    !(this.address !== other.address) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ADDRESSES') : invariant(false) : void 0;\n    return this.address.toLowerCase() < other.address.toLowerCase();\n  };\n  return Token;\n}();\n/**\r\n * Compares two currencies for equality\r\n */\n\nfunction currencyEquals(currencyA, currencyB) {\n  return currencyA.equals(currencyB);\n}\nvar CELO = (_CELO = {}, _CELO[ChainId.MAINNET] = /*#__PURE__*/new Token(ChainId.MAINNET, '0x471EcE3750Da237f93B8E339c536989b8978a438', 18, 'CELO', 'Celo'), _CELO[ChainId.ALFAJORES] = /*#__PURE__*/new Token(ChainId.ALFAJORES, '0xF194afDf50B03e69Bd7D057c1Aa9e10c9954E4C9', 18, 'CELO', 'Celo'), _CELO[ChainId.BAKLAVA] = /*#__PURE__*/new Token(ChainId.BAKLAVA, '0x765DE816845861e75A25fCA122bb6898B8B1282a', 18, 'CELO', 'Celo'), _CELO);\nvar cUSD = (_cUSD = {}, _cUSD[ChainId.MAINNET] = /*#__PURE__*/new Token(ChainId.MAINNET, '0x765DE816845861e75A25fCA122bb6898B8B1282a', 18, 'cUSD', 'Celo Dollar'), _cUSD[ChainId.ALFAJORES] = /*#__PURE__*/new Token(ChainId.ALFAJORES, '0x874069Fa1Eb16D44d622F2e0Ca25eeA172369bC1', 18, 'cUSD', 'Celo Dollar'), _cUSD[ChainId.BAKLAVA] = /*#__PURE__*/new Token(ChainId.ALFAJORES, '0x765DE816845861e75A25fCA122bb6898B8B1282a', 18, 'cUSD', 'Celo Dollar'), _cUSD);\nvar cEUR = (_cEUR = {}, _cEUR[ChainId.MAINNET] = /*#__PURE__*/new Token(ChainId.MAINNET, '0xD8763CBa276a3738E6DE85b4b3bF5FDed6D6cA73', 18, 'cEUR', 'Celo Euro'), _cEUR[ChainId.ALFAJORES] = /*#__PURE__*/new Token(ChainId.ALFAJORES, '0x10c892A6EC43a53E45D0B916B4b7D383B1b78C0F', 18, 'cEUR', 'Celo Euro'), _cEUR[ChainId.BAKLAVA] = /*#__PURE__*/new Token(ChainId.BAKLAVA, '0xf9ecE301247aD2CE21894941830A2470f4E774ca', 18, 'cEUR', 'Celo Euro'), _cEUR);\nvar cREAL = (_cREAL = {}, _cREAL[ChainId.MAINNET] = /*#__PURE__*/new Token(ChainId.MAINNET, '0xe8537a3d056DA446677B9E9d6c5dB704EaAb4787', 18, 'cREAL', 'Celo Brazilian REAL'), _cREAL[ChainId.ALFAJORES] = /*#__PURE__*/new Token(ChainId.ALFAJORES, '0xE4D517785D091D3c54818832dB6094bcc2744545', 18, 'cREAL', 'Celo Brazilian REAL'), _cREAL);\nvar Big$1 = /*#__PURE__*/toFormat(_Big);\nvar CurrencyAmount = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(CurrencyAmount, _Fraction);\n\n  // amount _must_ be raw, i.e. in the native representation\n  function CurrencyAmount(currency, amount) {\n    var _this;\n    var parsedAmount = parseBigintIsh(amount);\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256);\n    _this = _Fraction.call(this, parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals))) || this;\n    _this.currency = currency;\n    return _this;\n  }\n  var _proto = CurrencyAmount.prototype;\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n    return _Fraction.prototype.toSignificant.call(this, significantDigits, format, rounding);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = this.currency.decimals;\n    }\n    if (rounding === void 0) {\n      rounding = Rounding.ROUND_DOWN;\n    }\n    !(decimalPlaces <= this.currency.decimals) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;\n    return _Fraction.prototype.toFixed.call(this, decimalPlaces, format, rounding);\n  };\n  _proto.toExact = function toExact(format) {\n    if (format === void 0) {\n      format = {\n        groupSeparator: ''\n      };\n    }\n    Big$1.DP = this.currency.decimals;\n    return new Big$1(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);\n  };\n  _createClass(CurrencyAmount, [{\n    key: \"raw\",\n    get: function get() {\n      return this.numerator;\n    }\n  }]);\n  return CurrencyAmount;\n}(Fraction);\nvar TokenAmount = /*#__PURE__*/function (_CurrencyAmount) {\n  _inheritsLoose(TokenAmount, _CurrencyAmount);\n\n  // amount _must_ be raw, i.e. in the native representation\n  function TokenAmount(token, amount) {\n    var _this2;\n    _this2 = _CurrencyAmount.call(this, token, amount) || this;\n    _this2.token = token;\n    return _this2;\n  }\n  var _proto2 = TokenAmount.prototype;\n  _proto2.add = function add(other) {\n    !this.token.equals(other.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw));\n  };\n  _proto2.subtract = function subtract(other) {\n    !this.token.equals(other.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw));\n  };\n  return TokenAmount;\n}(CurrencyAmount);\nvar Price = /*#__PURE__*/function (_Fraction) {\n  _inheritsLoose(Price, _Fraction);\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  function Price(baseCurrency, quoteCurrency, denominator, numerator) {\n    var _this;\n    _this = _Fraction.call(this, numerator, denominator) || this;\n    _this.baseCurrency = baseCurrency;\n    _this.quoteCurrency = quoteCurrency;\n    _this.scalar = new Fraction(JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals)));\n    return _this;\n  }\n  Price.fromRoute = function fromRoute(route) {\n    var prices = [];\n    for (var _iterator = _createForOfIteratorHelperLoose(route.pairs.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        i = _step$value[0],\n        pair = _step$value[1];\n      prices.push(route.path[i].equals(pair.token0) ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw) : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw));\n    }\n    return prices.slice(1).reduce(function (accumulator, currentValue) {\n      return accumulator.multiply(currentValue);\n    }, prices[0]);\n  };\n  var _proto = Price.prototype;\n  _proto.invert = function invert() {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);\n  };\n  _proto.multiply = function multiply(other) {\n    !currencyEquals(this.quoteCurrency, other.baseCurrency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    var fraction = _Fraction.prototype.multiply.call(this, other);\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);\n  } // performs floor division on overflow\n  ;\n\n  _proto.quote = function quote(currencyAmount) {\n    !currencyEquals(currencyAmount.currency, this.baseCurrency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return new TokenAmount(this.quoteCurrency, _Fraction.prototype.multiply.call(this, currencyAmount.raw).quotient);\n  };\n  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {\n    if (significantDigits === void 0) {\n      significantDigits = 6;\n    }\n    return this.adjusted.toSignificant(significantDigits, format, rounding);\n  };\n  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {\n    if (decimalPlaces === void 0) {\n      decimalPlaces = 4;\n    }\n    return this.adjusted.toFixed(decimalPlaces, format, rounding);\n  };\n  _createClass(Price, [{\n    key: \"raw\",\n    get: function get() {\n      return new Fraction(this.numerator, this.denominator);\n    }\n  }, {\n    key: \"adjusted\",\n    get: function get() {\n      return _Fraction.prototype.multiply.call(this, this.scalar);\n    }\n  }]);\n  return Price;\n}(Fraction);\n\n// see https://stackoverflow.com/a/41102306\nvar CAN_SET_PROTOTYPE = ('setPrototypeOf' in Object);\n/**\r\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\r\n * obtained by sending any amount of input.\r\n */\n\nvar InsufficientReservesError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(InsufficientReservesError, _Error);\n  function InsufficientReservesError() {\n    var _this;\n    _this = _Error.call(this) || this;\n    _this.isInsufficientReservesError = true;\n    _this.name = _this.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError ? this.constructor : void 0).prototype);\n    return _this;\n  }\n  return InsufficientReservesError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\r\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\r\n * than the price of a single unit of output after fees.\r\n */\n\nvar InsufficientInputAmountError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(InsufficientInputAmountError, _Error2);\n  function InsufficientInputAmountError() {\n    var _this2;\n    _this2 = _Error2.call(this) || this;\n    _this2.isInsufficientInputAmountError = true;\n    _this2.name = _this2.constructor.name;\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError ? this.constructor : void 0).prototype);\n    return _this2;\n  }\n  return InsufficientInputAmountError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar PAIR_ADDRESS_CACHE = {};\nvar Pair = /*#__PURE__*/function () {\n  function Pair(tokenAmountA, tokenAmountB) {\n    var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    this.liquidityToken = new Token(tokenAmounts[0].token.chainId, Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token), 18, 'UBE-V2', 'Ubeswap V2');\n    this.tokenAmounts = tokenAmounts;\n  }\n  Pair.getAddress = function getAddress(tokenA, tokenB) {\n    var _PAIR_ADDRESS_CACHE, _PAIR_ADDRESS_CACHE$t;\n    var tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]; // does safety checks\n\n    if (((_PAIR_ADDRESS_CACHE = PAIR_ADDRESS_CACHE) == null ? void 0 : (_PAIR_ADDRESS_CACHE$t = _PAIR_ADDRESS_CACHE[tokens[0].address]) == null ? void 0 : _PAIR_ADDRESS_CACHE$t[tokens[1].address]) === undefined) {\n      var _PAIR_ADDRESS_CACHE2, _extends2, _extends3;\n      PAIR_ADDRESS_CACHE = _extends({}, PAIR_ADDRESS_CACHE, (_extends3 = {}, _extends3[tokens[0].address] = _extends({}, (_PAIR_ADDRESS_CACHE2 = PAIR_ADDRESS_CACHE) == null ? void 0 : _PAIR_ADDRESS_CACHE2[tokens[0].address], (_extends2 = {}, _extends2[tokens[1].address] = getCreate2Address(FACTORY_ADDRESS, keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]), INIT_CODE_HASH), _extends2)), _extends3));\n    }\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address];\n  }\n  /**\r\n   * Returns true if the token is either token0 or token1\r\n   * @param token to check\r\n   */;\n\n  var _proto = Pair.prototype;\n  _proto.involvesToken = function involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n  /**\r\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\r\n   */;\n\n  /**\r\n   * Return the price of the given token in terms of the other token in the pair.\r\n   * @param token token to return price of\r\n   */\n  _proto.priceOf = function priceOf(token) {\n    !this.involvesToken(token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n  /**\r\n   * Returns the chain ID of the tokens in the pair.\r\n   */;\n\n  _proto.reserveOf = function reserveOf(token) {\n    !this.involvesToken(token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  };\n  _proto.getOutputAmount = function getOutputAmount(inputAmount) {\n    !this.involvesToken(inputAmount.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n    var inputReserve = this.reserveOf(inputAmount.token);\n    var outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    var inputAmountWithFee = JSBI.multiply(inputAmount.raw, _997);\n    var numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw);\n    var denominator = JSBI.add(JSBI.multiply(inputReserve.raw, _1000), inputAmountWithFee);\n    var outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n  _proto.getInputAmount = function getInputAmount(outputAmount) {\n    !this.involvesToken(outputAmount.token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO) || JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)) {\n      throw new InsufficientReservesError();\n    }\n    var outputReserve = this.reserveOf(outputAmount.token);\n    var inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    var numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), _1000);\n    var denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), _997);\n    var inputAmount = new TokenAmount(outputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  };\n  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    !totalSupply.token.equals(this.liquidityToken) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LIQUIDITY') : invariant(false) : void 0;\n    var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    !(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    var liquidity;\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY);\n    } else {\n      var amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw);\n      var amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw);\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return new TokenAmount(this.liquidityToken, liquidity);\n  };\n  _proto.getLiquidityValue = function getLiquidityValue(token, totalSupply, liquidity, feeOn, kLast) {\n    if (feeOn === void 0) {\n      feeOn = false;\n    }\n    !this.involvesToken(token) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOKEN') : invariant(false) : void 0;\n    !totalSupply.token.equals(this.liquidityToken) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TOTAL_SUPPLY') : invariant(false) : void 0;\n    !liquidity.token.equals(this.liquidityToken) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LIQUIDITY') : invariant(false) : void 0;\n    !JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LIQUIDITY') : invariant(false) : void 0;\n    var totalSupplyAdjusted;\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      !!!kLast ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'K_LAST') : invariant(false) : void 0;\n      var kLastParsed = parseBigintIsh(kLast);\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        var rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw));\n        var rootKLast = sqrt(kLastParsed);\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          var numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast));\n          var denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);\n          var feeLiquidity = JSBI.divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n    return new TokenAmount(token, JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw));\n  };\n  _createClass(Pair, [{\n    key: \"token0Price\",\n    get: function get() {\n      return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw);\n    }\n    /**\r\n     * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\r\n     */\n  }, {\n    key: \"token1Price\",\n    get: function get() {\n      return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw);\n    }\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return this.token0.chainId;\n    }\n  }, {\n    key: \"token0\",\n    get: function get() {\n      return this.tokenAmounts[0].token;\n    }\n  }, {\n    key: \"token1\",\n    get: function get() {\n      return this.tokenAmounts[1].token;\n    }\n  }, {\n    key: \"reserve0\",\n    get: function get() {\n      return this.tokenAmounts[0];\n    }\n  }, {\n    key: \"reserve1\",\n    get: function get() {\n      return this.tokenAmounts[1];\n    }\n  }]);\n  return Pair;\n}();\nvar Route = /*#__PURE__*/function () {\n  function Route(pairs, input, output) {\n    !(pairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PAIRS') : invariant(false) : void 0;\n    !pairs.every(function (pair) {\n      return pair.chainId === pairs[0].chainId;\n    }) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;\n    !(input instanceof Token && pairs[0].involvesToken(input)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INPUT') : invariant(false) : void 0;\n    !(typeof output === 'undefined' || output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;\n    var path = [input instanceof Token ? input : CELO[pairs[0].chainId]];\n    for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        i = _step$value[0],\n        pair = _step$value[1];\n      var currentInput = path[i];\n      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PATH') : invariant(false) : void 0;\n      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;\n      path.push(_output);\n    }\n    this.pairs = pairs;\n    this.path = path;\n    this.midPrice = Price.fromRoute(this);\n    this.input = input;\n    this.output = output != null ? output : path[path.length - 1];\n  }\n  _createClass(Route, [{\n    key: \"chainId\",\n    get: function get() {\n      return this.pairs[0].chainId;\n    }\n  }]);\n  return Route;\n}();\n\n/**\r\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\r\n * @param midPrice mid price before the trade\r\n * @param inputAmount the input amount of the trade\r\n * @param outputAmount the output amount of the trade\r\n */\n\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  var exactQuote = midPrice.raw.multiply(inputAmount.raw); // calculate slippage := (exactQuote - outputAmount) / exactQuote\n\n  var slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);\n  return new Percent(slippage.numerator, slippage.denominator);\n} // comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\n\nfunction inputOutputComparator(a, b) {\n  // must have same input and output token for comparison\n  !currencyEquals(a.inputAmount.currency, b.inputAmount.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INPUT_CURRENCY') : invariant(false) : void 0;\n  !currencyEquals(a.outputAmount.currency, b.outputAmount.currency) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OUTPUT_CURRENCY') : invariant(false) : void 0;\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    } // trade A requires less input than trade B, so A should come first\n\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n} // extension of the input output comparator that also considers other dimensions of the trade in ranking them\n\nfunction tradeComparator(a, b) {\n  var ioComp = inputOutputComparator(a, b);\n  if (ioComp !== 0) {\n    return ioComp;\n  } // consider lowest slippage next, since these are less likely to fail\n\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  } // finally consider the number of hops since each hop costs gas\n\n  return a.route.path.length - b.route.path.length;\n}\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\n\nvar Trade = /*#__PURE__*/function () {\n  function Trade(route, amount, tradeType) {\n    var amounts = new Array(route.path.length);\n    var nextPairs = new Array(route.pairs.length);\n    if (tradeType === TradeType.EXACT_INPUT) {\n      !currencyEquals(amount.currency, route.input) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INPUT') : invariant(false) : void 0;\n      amounts[0] = amount;\n      for (var i = 0; i < route.path.length - 1; i++) {\n        var pair = route.pairs[i];\n        var _pair$getOutputAmount = pair.getOutputAmount(amounts[i]),\n          outputAmount = _pair$getOutputAmount[0],\n          nextPair = _pair$getOutputAmount[1];\n        amounts[i + 1] = outputAmount;\n        nextPairs[i] = nextPair;\n      }\n    } else {\n      !currencyEquals(amount.currency, route.output) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OUTPUT') : invariant(false) : void 0;\n      amounts[amounts.length - 1] = amount;\n      for (var _i = route.path.length - 1; _i > 0; _i--) {\n        var _pair = route.pairs[_i - 1];\n        var _pair$getInputAmount = _pair.getInputAmount(amounts[_i]),\n          inputAmount = _pair$getInputAmount[0],\n          _nextPair = _pair$getInputAmount[1];\n        amounts[_i - 1] = inputAmount;\n        nextPairs[_i - 1] = _nextPair;\n      }\n    }\n    this.route = route;\n    this.tradeType = tradeType;\n    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : amounts[0];\n    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1];\n    this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.raw, this.outputAmount.raw);\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input));\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n  /**\r\n   * Constructs an exact in trade with the given amount in and route\r\n   * @param route route of the exact in trade\r\n   * @param amountIn the amount being passed in\r\n   */\n\n  Trade.exactIn = function exactIn(route, amountIn) {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT);\n  }\n  /**\r\n   * Constructs an exact out trade with the given amount out and route\r\n   * @param route route of the exact out trade\r\n   * @param amountOut the amount returned by the trade\r\n   */;\n\n  Trade.exactOut = function exactOut(route, amountOut) {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\n  }\n  /**\r\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */;\n\n  var _proto = Trade.prototype;\n  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    } else {\n      var slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;\n      return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut);\n    }\n  }\n  /**\r\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n   */;\n\n  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {\n    !!slippageTolerance.lessThan(ZERO) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'SLIPPAGE_TOLERANCE') : invariant(false) : void 0;\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    } else {\n      var slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;\n      return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn);\n    }\n  }\n  /**\r\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n   * amount to an output token, making at most `maxHops` hops.\r\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyAmountIn exact amount of input currency to spend\r\n   * @param currencyOut the desired currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */;\n\n  Trade.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp,\n  // used in recursion.\n  currentPairs, originalAmountIn, bestTrades) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$maxNumResults = _ref.maxNumResults,\n      maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults,\n      _ref$maxHops = _ref.maxHops,\n      maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n    if (originalAmountIn === void 0) {\n      originalAmountIn = currencyAmountIn;\n    }\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n    !(pairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PAIRS') : invariant(false) : void 0;\n    !(maxHops > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;\n    !(originalAmountIn === currencyAmountIn || currentPairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;\n    var chainId = currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : undefined;\n    !(chainId !== undefined) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n    var amountIn = currencyAmountIn;\n    var tokenOut = currencyOut;\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountOut = void 0;\n      try {\n        ;\n        var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);\n        amountOut = _pair$getOutputAmount2[0];\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue;\n        }\n        throw error;\n      } // we have arrived at the output token, so this is the final trade of one of the paths\n\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(bestTrades, new Trade(new Route([].concat(currentPairs, [pair]), originalAmountIn.currency, currencyOut), originalAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [].concat(currentPairs, [pair]), originalAmountIn, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n  /**\r\n   * similar to the above method but instead targets a fixed output amount\r\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n   * to an output token amount, making at most `maxHops` hops\r\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n   * the amount in among multiple routes.\r\n   * @param pairs the pairs to consider in finding the best trade\r\n   * @param currencyIn the currency to spend\r\n   * @param currencyAmountOut the exact amount of currency out\r\n   * @param maxNumResults maximum number of results to return\r\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n   * @param currentPairs used in recursion; the current list of pairs\r\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n   * @param bestTrades used in recursion; the current list of best trades\r\n   */;\n\n  Trade.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2,\n  // used in recursion.\n  currentPairs, originalAmountOut, bestTrades) {\n    var _ref2 = _temp2 === void 0 ? {} : _temp2,\n      _ref2$maxNumResults = _ref2.maxNumResults,\n      maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults,\n      _ref2$maxHops = _ref2.maxHops,\n      maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;\n    if (currentPairs === void 0) {\n      currentPairs = [];\n    }\n    if (originalAmountOut === void 0) {\n      originalAmountOut = currencyAmountOut;\n    }\n    if (bestTrades === void 0) {\n      bestTrades = [];\n    }\n    !(pairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'PAIRS') : invariant(false) : void 0;\n    !(maxHops > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'MAX_HOPS') : invariant(false) : void 0;\n    !(originalAmountOut === currencyAmountOut || currentPairs.length > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'INVALID_RECURSION') : invariant(false) : void 0;\n    var chainId = currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : undefined;\n    !(chainId !== undefined) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n    var amountOut = currencyAmountOut;\n    var tokenIn = currencyIn;\n    for (var i = 0; i < pairs.length; i++) {\n      var pair = pairs[i]; // pair irrelevant\n\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      var amountIn = void 0;\n      try {\n        ;\n        var _pair$getInputAmount2 = pair.getInputAmount(amountOut);\n        amountIn = _pair$getInputAmount2[0];\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue;\n        }\n        throw error;\n      } // we have arrived at the input token, so this is the first trade of one of the paths\n\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(bestTrades, new Trade(new Route([pair].concat(currentPairs), currencyIn, originalAmountOut.currency), originalAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {\n          maxNumResults: maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair].concat(currentPairs), originalAmountOut, bestTrades);\n      }\n    }\n    return bestTrades;\n  };\n  return Trade;\n}();\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\nvar runtime_1 = createCommonjsModule(function (module) {\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var runtime = function (exports) {\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var undefined$1; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n      return obj[key];\n    }\n    try {\n      // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n      define({}, \"\");\n    } catch (err) {\n      define = function define(obj, key, value) {\n        return obj[key] = value;\n      };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n      var generator = Object.create(protoGenerator.prototype);\n      var context = new Context(tryLocsList || []);\n\n      // The ._invoke method unifies the implementations of the .next,\n      // .throw, and .return methods.\n      generator._invoke = makeInvokeMethod(innerFn, self, context);\n      return generator;\n    }\n    exports.wrap = wrap;\n\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n      try {\n        return {\n          type: \"normal\",\n          arg: fn.call(obj, arg)\n        };\n      } catch (err) {\n        return {\n          type: \"throw\",\n          arg: err\n        };\n      }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    IteratorPrototype[iteratorSymbol] = function () {\n      return this;\n    };\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n      // This environment has a native %IteratorPrototype%; use it instead\n      // of the polyfill.\n      IteratorPrototype = NativeIteratorPrototype;\n    }\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n    GeneratorFunctionPrototype.constructor = GeneratorFunction;\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n      [\"next\", \"throw\", \"return\"].forEach(function (method) {\n        define(prototype, method, function (arg) {\n          return this._invoke(method, arg);\n        });\n      });\n    }\n    exports.isGeneratorFunction = function (genFun) {\n      var ctor = typeof genFun === \"function\" && genFun.constructor;\n      return ctor ? ctor === GeneratorFunction ||\n      // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function (genFun) {\n      if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n      } else {\n        genFun.__proto__ = GeneratorFunctionPrototype;\n        define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n      }\n      genFun.prototype = Object.create(Gp);\n      return genFun;\n    };\n\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function (arg) {\n      return {\n        __await: arg\n      };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n      function invoke(method, arg, resolve, reject) {\n        var record = tryCatch(generator[method], generator, arg);\n        if (record.type === \"throw\") {\n          reject(record.arg);\n        } else {\n          var result = record.arg;\n          var value = result.value;\n          if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n            return PromiseImpl.resolve(value.__await).then(function (value) {\n              invoke(\"next\", value, resolve, reject);\n            }, function (err) {\n              invoke(\"throw\", err, resolve, reject);\n            });\n          }\n          return PromiseImpl.resolve(value).then(function (unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration.\n            result.value = unwrapped;\n            resolve(result);\n          }, function (error) {\n            // If a rejected Promise was yielded, throw the rejection back\n            // into the async generator function so it can be handled there.\n            return invoke(\"throw\", error, resolve, reject);\n          });\n        }\n      }\n      var previousPromise;\n      function enqueue(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,\n        // Avoid propagating failures to Promises returned by later\n        // invocations of the iterator.\n        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n\n      // Define the unified helper method that is used to implement .next,\n      // .throw, and .return (see defineIteratorMethods).\n      this._invoke = enqueue;\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n      return this;\n    };\n    exports.AsyncIterator = AsyncIterator;\n\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n      if (PromiseImpl === void 0) PromiseImpl = Promise;\n      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function (result) {\n        return result.done ? result.value : iter.next();\n      });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n      var state = GenStateSuspendedStart;\n      return function invoke(method, arg) {\n        if (state === GenStateExecuting) {\n          throw new Error(\"Generator is already running\");\n        }\n        if (state === GenStateCompleted) {\n          if (method === \"throw\") {\n            throw arg;\n          }\n\n          // Be forgiving, per 25.3.3.3.3 of the spec:\n          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n          return doneResult();\n        }\n        context.method = method;\n        context.arg = arg;\n        while (true) {\n          var delegate = context.delegate;\n          if (delegate) {\n            var delegateResult = maybeInvokeDelegate(delegate, context);\n            if (delegateResult) {\n              if (delegateResult === ContinueSentinel) continue;\n              return delegateResult;\n            }\n          }\n          if (context.method === \"next\") {\n            // Setting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            context.sent = context._sent = context.arg;\n          } else if (context.method === \"throw\") {\n            if (state === GenStateSuspendedStart) {\n              state = GenStateCompleted;\n              throw context.arg;\n            }\n            context.dispatchException(context.arg);\n          } else if (context.method === \"return\") {\n            context.abrupt(\"return\", context.arg);\n          }\n          state = GenStateExecuting;\n          var record = tryCatch(innerFn, self, context);\n          if (record.type === \"normal\") {\n            // If an exception is thrown from innerFn, we leave state ===\n            // GenStateExecuting and loop back for another invocation.\n            state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n            if (record.arg === ContinueSentinel) {\n              continue;\n            }\n            return {\n              value: record.arg,\n              done: context.done\n            };\n          } else if (record.type === \"throw\") {\n            state = GenStateCompleted;\n            // Dispatch the exception by looping back around to the\n            // context.dispatchException(context.arg) call above.\n            context.method = \"throw\";\n            context.arg = record.arg;\n          }\n        }\n      };\n    }\n\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n      var method = delegate.iterator[context.method];\n      if (method === undefined$1) {\n        // A .throw or .return when the delegate iterator has no .throw\n        // method always terminates the yield* loop.\n        context.delegate = null;\n        if (context.method === \"throw\") {\n          // Note: [\"return\"] must be used for ES3 parsing compatibility.\n          if (delegate.iterator[\"return\"]) {\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            context.method = \"return\";\n            context.arg = undefined$1;\n            maybeInvokeDelegate(delegate, context);\n            if (context.method === \"throw\") {\n              // If maybeInvokeDelegate(context) changed context.method from\n              // \"return\" to \"throw\", let that override the TypeError below.\n              return ContinueSentinel;\n            }\n          }\n          context.method = \"throw\";\n          context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n        }\n        return ContinueSentinel;\n      }\n      var record = tryCatch(method, delegate.iterator, context.arg);\n      if (record.type === \"throw\") {\n        context.method = \"throw\";\n        context.arg = record.arg;\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      var info = record.arg;\n      if (!info) {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"iterator result is not an object\");\n        context.delegate = null;\n        return ContinueSentinel;\n      }\n      if (info.done) {\n        // Assign the result of the finished delegate to the temporary\n        // variable specified by delegate.resultName (see delegateYield).\n        context[delegate.resultName] = info.value;\n\n        // Resume execution at the desired location (see delegateYield).\n        context.next = delegate.nextLoc;\n\n        // If context.method was \"throw\" but the delegate handled the\n        // exception, let the outer generator proceed normally. If\n        // context.method was \"next\", forget context.arg since it has been\n        // \"consumed\" by the delegate iterator. If context.method was\n        // \"return\", allow the original .return call to continue in the\n        // outer generator.\n        if (context.method !== \"return\") {\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n      } else {\n        // Re-yield the result returned by the delegate method.\n        return info;\n      }\n\n      // The delegate iterator is finished, so forget it and continue with\n      // the outer generator.\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    Gp[iteratorSymbol] = function () {\n      return this;\n    };\n    Gp.toString = function () {\n      return \"[object Generator]\";\n    };\n    function pushTryEntry(locs) {\n      var entry = {\n        tryLoc: locs[0]\n      };\n      if (1 in locs) {\n        entry.catchLoc = locs[1];\n      }\n      if (2 in locs) {\n        entry.finallyLoc = locs[2];\n        entry.afterLoc = locs[3];\n      }\n      this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n      var record = entry.completion || {};\n      record.type = \"normal\";\n      delete record.arg;\n      entry.completion = record;\n    }\n    function Context(tryLocsList) {\n      // The root entry object (effectively a try statement without a catch\n      // or a finally block) gives us a place to store values thrown from\n      // locations where there is no enclosing try statement.\n      this.tryEntries = [{\n        tryLoc: \"root\"\n      }];\n      tryLocsList.forEach(pushTryEntry, this);\n      this.reset(true);\n    }\n    exports.keys = function (object) {\n      var keys = [];\n      for (var key in object) {\n        keys.push(key);\n      }\n      keys.reverse();\n\n      // Rather than returning an object with a next method, we keep\n      // things simple and return the next function itself.\n      return function next() {\n        while (keys.length) {\n          var key = keys.pop();\n          if (key in object) {\n            next.value = key;\n            next.done = false;\n            return next;\n          }\n        }\n\n        // To avoid creating an additional object, we just hang the .value\n        // and .done properties off the next function object itself. This\n        // also ensures that the minifier will not anonymize the function.\n        next.done = true;\n        return next;\n      };\n    };\n    function values(iterable) {\n      if (iterable) {\n        var iteratorMethod = iterable[iteratorSymbol];\n        if (iteratorMethod) {\n          return iteratorMethod.call(iterable);\n        }\n        if (typeof iterable.next === \"function\") {\n          return iterable;\n        }\n        if (!isNaN(iterable.length)) {\n          var i = -1,\n            next = function next() {\n              while (++i < iterable.length) {\n                if (hasOwn.call(iterable, i)) {\n                  next.value = iterable[i];\n                  next.done = false;\n                  return next;\n                }\n              }\n              next.value = undefined$1;\n              next.done = true;\n              return next;\n            };\n          return next.next = next;\n        }\n      }\n\n      // Return an iterator with no values.\n      return {\n        next: doneResult\n      };\n    }\n    exports.values = values;\n    function doneResult() {\n      return {\n        value: undefined$1,\n        done: true\n      };\n    }\n    Context.prototype = {\n      constructor: Context,\n      reset: function reset(skipTempReset) {\n        this.prev = 0;\n        this.next = 0;\n        // Resetting context._sent for legacy support of Babel's\n        // function.sent implementation.\n        this.sent = this._sent = undefined$1;\n        this.done = false;\n        this.delegate = null;\n        this.method = \"next\";\n        this.arg = undefined$1;\n        this.tryEntries.forEach(resetTryEntry);\n        if (!skipTempReset) {\n          for (var name in this) {\n            // Not sure about the optimal order of these conditions:\n            if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n              this[name] = undefined$1;\n            }\n          }\n        }\n      },\n      stop: function stop() {\n        this.done = true;\n        var rootEntry = this.tryEntries[0];\n        var rootRecord = rootEntry.completion;\n        if (rootRecord.type === \"throw\") {\n          throw rootRecord.arg;\n        }\n        return this.rval;\n      },\n      dispatchException: function dispatchException(exception) {\n        if (this.done) {\n          throw exception;\n        }\n        var context = this;\n        function handle(loc, caught) {\n          record.type = \"throw\";\n          record.arg = exception;\n          context.next = loc;\n          if (caught) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n          return !!caught;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          var record = entry.completion;\n          if (entry.tryLoc === \"root\") {\n            // Exception thrown outside of any try block that could handle\n            // it, so set the completion value of the entire function to\n            // throw the exception.\n            return handle(\"end\");\n          }\n          if (entry.tryLoc <= this.prev) {\n            var hasCatch = hasOwn.call(entry, \"catchLoc\");\n            var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n            if (hasCatch && hasFinally) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              } else if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else if (hasCatch) {\n              if (this.prev < entry.catchLoc) {\n                return handle(entry.catchLoc, true);\n              }\n            } else if (hasFinally) {\n              if (this.prev < entry.finallyLoc) {\n                return handle(entry.finallyLoc);\n              }\n            } else {\n              throw new Error(\"try statement without catch or finally\");\n            }\n          }\n        }\n      },\n      abrupt: function abrupt(type, arg) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n            var finallyEntry = entry;\n            break;\n          }\n        }\n        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n          // Ignore the finally entry if control is not jumping to a\n          // location outside the try/catch block.\n          finallyEntry = null;\n        }\n        var record = finallyEntry ? finallyEntry.completion : {};\n        record.type = type;\n        record.arg = arg;\n        if (finallyEntry) {\n          this.method = \"next\";\n          this.next = finallyEntry.finallyLoc;\n          return ContinueSentinel;\n        }\n        return this.complete(record);\n      },\n      complete: function complete(record, afterLoc) {\n        if (record.type === \"throw\") {\n          throw record.arg;\n        }\n        if (record.type === \"break\" || record.type === \"continue\") {\n          this.next = record.arg;\n        } else if (record.type === \"return\") {\n          this.rval = this.arg = record.arg;\n          this.method = \"return\";\n          this.next = \"end\";\n        } else if (record.type === \"normal\" && afterLoc) {\n          this.next = afterLoc;\n        }\n        return ContinueSentinel;\n      },\n      finish: function finish(finallyLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.finallyLoc === finallyLoc) {\n            this.complete(entry.completion, entry.afterLoc);\n            resetTryEntry(entry);\n            return ContinueSentinel;\n          }\n        }\n      },\n      \"catch\": function _catch(tryLoc) {\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var entry = this.tryEntries[i];\n          if (entry.tryLoc === tryLoc) {\n            var record = entry.completion;\n            if (record.type === \"throw\") {\n              var thrown = record.arg;\n              resetTryEntry(entry);\n            }\n            return thrown;\n          }\n        }\n\n        // The context.catch method must only be called with a location\n        // argument that corresponds to a known catch block.\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n        this.delegate = {\n          iterator: values(iterable),\n          resultName: resultName,\n          nextLoc: nextLoc\n        };\n        if (this.method === \"next\") {\n          // Deliberately forget the last sent value so that we don't\n          // accidentally pass it on to the delegate.\n          this.arg = undefined$1;\n        }\n        return ContinueSentinel;\n      }\n    };\n\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n  }(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports);\n  try {\n    regeneratorRuntime = runtime;\n  } catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n});\nvar ERC20 = [{\n  constant: true,\n  inputs: [],\n  name: \"decimals\",\n  outputs: [{\n    name: \"\",\n    type: \"uint8\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  constant: true,\n  inputs: [{\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar _TOKEN_DECIMALS_CACHE;\nvar TOKEN_DECIMALS_CACHE = (_TOKEN_DECIMALS_CACHE = {}, _TOKEN_DECIMALS_CACHE[ChainId.MAINNET] = {\n  '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n}, _TOKEN_DECIMALS_CACHE);\n/**\r\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\r\n */\n\nvar Fetcher = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function Fetcher() {}\n  /**\r\n   * Fetch information for a given token on the given chain, using the given ethers provider.\r\n   * @param chainId chain of the token\r\n   * @param address address of the token on the chain\r\n   * @param provider provider used to fetch the token\r\n   * @param symbol optional symbol of the token\r\n   * @param name optional name of the token\r\n   */\n\n  Fetcher.fetchTokenData = /*#__PURE__*/\n  function () {\n    var _fetchTokenData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(chainId, address, provider, symbol, name) {\n      var _TOKEN_DECIMALS_CACHE2, _TOKEN_DECIMALS_CACHE3;\n      var parsedDecimals;\n      return runtime_1.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (provider === void 0) {\n                provider = /*#__PURE__*/getDefaultProvider( /*#__PURE__*/getNetwork(chainId));\n              }\n              if (!(typeof ((_TOKEN_DECIMALS_CACHE2 = TOKEN_DECIMALS_CACHE) == null ? void 0 : (_TOKEN_DECIMALS_CACHE3 = _TOKEN_DECIMALS_CACHE2[chainId]) == null ? void 0 : _TOKEN_DECIMALS_CACHE3[address]) === 'number')) {\n                _context.next = 5;\n                break;\n              }\n              _context.t0 = TOKEN_DECIMALS_CACHE[chainId][address];\n              _context.next = 8;\n              break;\n            case 5:\n              _context.next = 7;\n              return new Contract(address, ERC20, provider).decimals().then(function (decimals) {\n                var _TOKEN_DECIMALS_CACHE4, _extends2, _extends3;\n                TOKEN_DECIMALS_CACHE = _extends({}, TOKEN_DECIMALS_CACHE, (_extends3 = {}, _extends3[chainId] = _extends({}, (_TOKEN_DECIMALS_CACHE4 = TOKEN_DECIMALS_CACHE) == null ? void 0 : _TOKEN_DECIMALS_CACHE4[chainId], (_extends2 = {}, _extends2[address] = decimals, _extends2)), _extends3));\n                return decimals;\n              });\n            case 7:\n              _context.t0 = _context.sent;\n            case 8:\n              parsedDecimals = _context.t0;\n              return _context.abrupt(\"return\", new Token(chainId, address, parsedDecimals, symbol, name));\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function fetchTokenData(_x, _x2, _x3, _x4, _x5) {\n      return _fetchTokenData.apply(this, arguments);\n    }\n    return fetchTokenData;\n  }()\n  /**\r\n   * Fetches information about a pair and constructs a pair from the given two tokens.\r\n   * @param tokenA first token\r\n   * @param tokenB second token\r\n   * @param provider the provider to use to fetch the data\r\n   */;\n\n  Fetcher.fetchPairData = /*#__PURE__*/\n  function () {\n    var _fetchPairData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(tokenA, tokenB, provider) {\n      var address, _yield$Contract$getRe, reserves0, reserves1, balances;\n      return runtime_1.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (provider === void 0) {\n                provider = /*#__PURE__*/getDefaultProvider( /*#__PURE__*/getNetwork(tokenA.chainId));\n              }\n              !(tokenA.chainId === tokenB.chainId) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;\n              address = Pair.getAddress(tokenA, tokenB);\n              _context2.next = 5;\n              return new Contract(address, IUniswapV2Pair.abi, provider).getReserves();\n            case 5:\n              _yield$Contract$getRe = _context2.sent;\n              reserves0 = _yield$Contract$getRe[0];\n              reserves1 = _yield$Contract$getRe[1];\n              balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0];\n              return _context2.abrupt(\"return\", new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1])));\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    function fetchPairData(_x6, _x7, _x8) {\n      return _fetchPairData.apply(this, arguments);\n    }\n    return fetchPairData;\n  }();\n  return Fetcher;\n}();\nfunction toHex(currencyAmount) {\n  return \"0x\" + currencyAmount.raw.toString(16);\n}\nvar ZERO_HEX = '0x0';\n/**\r\n * Represents the Ubeswap V2 Router, and has static methods for helping execute trades.\r\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\r\n   * Cannot be constructed.\r\n   */\n  function Router() {}\n  /**\r\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n   * @param trade to produce call parameters for\r\n   * @param options options for the call parameters\r\n   */\n\n  Router.swapCallParameters = function swapCallParameters(trade, options) {\n    // the router does not support both cgld in and out\n    !(!('ttl' in options) || options.ttl > 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'TTL') : invariant(false) : void 0;\n    var to = validateAndParseAddress(options.recipient);\n    var amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    var amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    var path = trade.route.path.map(function (token) {\n      return token.address;\n    });\n    var deadline = 'ttl' in options ? \"0x\" + (Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16) : \"0x\" + options.deadline.toString(16);\n    var useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    var methodName;\n    var args;\n    var value;\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'; // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\n        args = [amountIn, amountOut, path, to, deadline];\n        value = ZERO_HEX;\n        break;\n      case TradeType.EXACT_OUTPUT:\n        !!useFeeOnTransfer ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'EXACT_OUT_FOT') : invariant(false) : void 0;\n        methodName = 'swapTokensForExactTokens'; // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\n        args = [amountOut, amountIn, path, to, deadline];\n        value = ZERO_HEX;\n        break;\n    }\n    return {\n      methodName: methodName,\n      args: args,\n      value: value\n    };\n  };\n  return Router;\n}();\nexport { CELO, CHAIN_INFO, ChainId, FACTORY_ADDRESS, Fetcher, Fraction, INIT_CODE_HASH, InsufficientInputAmountError, InsufficientReservesError, MINIMUM_LIQUIDITY, Pair, Percent, Price, Rounding, Route, Router, Token, TokenAmount, Trade, TradeType, cEUR, cREAL, cUSD, currencyEquals, getBlockscoutLink, inputOutputComparator, parseNetwork, tradeComparator };","map":{"version":3,"sources":["../src/constants.ts","../src/utils.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/percent.ts","../src/entities/token.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/errors.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/trade.ts","../node_modules/regenerator-runtime/runtime.js","../src/fetcher.ts","../src/router.ts"],"names":["ChainId","TradeType","Rounding","FACTORY_ADDRESS","INIT_CODE_HASH","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","_997","_1000","SolidityType","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CHAIN_INFO","ALFAJORES","name","fornoURL","blockscoutURL","BAKLAVA","MAINNET","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","lessThanOrEqual","validateAndParseAddress","address","checksummedAddress","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","z","x","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","parseNetwork","chainId","Object","values","includes","Error","getBlockscoutLink","data","type","prefix","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","remainder","invert","other","otherParsed","equal","multiply","subtract","equalTo","toSignificant","significantDigits","format","groupSeparator","rounding","Number","isInteger","set","precision","quotient","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","_100_PERCENT","Percent","Token","decimals","symbol","equals","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","CELO","cUSD","cEUR","cREAL","CurrencyAmount","currency","amount","parsedAmount","exponentiate","toExact","TokenAmount","token","raw","Price","fromRoute","route","prices","i","pair","pairs","entries","path","token0","reserve0","reserve1","slice","reduce","accumulator","currentValue","baseCurrency","quoteCurrency","scalar","fraction","quote","currencyAmount","adjusted","CAN_SET_PROTOTYPE","InsufficientReservesError","constructor","setPrototypeOf","prototype","InsufficientInputAmountError","PAIR_ADDRESS_CACHE","Pair","tokenA","tokenB","tokens","undefined","getCreate2Address","keccak256","pack","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","involvesToken","token1","priceOf","token0Price","token1Price","reserveOf","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","input","output","every","currentInput","midPrice","computePriceImpact","exactQuote","slippage","inputOutputComparator","a","b","tradeComparator","ioComp","priceImpact","Trade","exactIn","amountIn","EXACT_INPUT","exactOut","amountOut","EXACT_OUTPUT","tradeType","amounts","Array","nextPairs","nextPair","executionPrice","nextMidPrice","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPairs","originalAmountIn","bestTrades","tokenOut","isInsufficientInputAmountError","pairsExcludingThisPair","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn","isInsufficientReservesError","TOKEN_DECIMALS_CACHE","Fetcher","fetchTokenData","provider","getDefaultProvider","getNetwork","parsedDecimals","Contract","ERC20","then","fetchPairData","reserves0","reserves1","IUniswapV2Pair","abi","getReserves","balances","toHex","ZERO_HEX","Router","swapCallParameters","trade","options","ttl","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","methodName","args"],"mappings":"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","sourcesContent":["import JSBI from 'jsbi'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | bigint | string\n\nexport enum ChainId {\n  MAINNET = 42220,\n  ALFAJORES = 44787,\n  BAKLAVA = 62320\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS = '0x62d5b84bE28a183aBB507E125B384122D2C25fAE'\n\nexport const INIT_CODE_HASH = '0xb3b8ff62960acea3a88039ebcf80699f15786f1b17cebd82802f7375827a339c'\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const _997 = JSBI.BigInt(997)\nexport const _1000 = JSBI.BigInt(1000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n\ninterface ChainInfo {\n  name: string\n  fornoURL: string\n  blockscoutURL: string\n}\n\nexport const CHAIN_INFO: { [K in ChainId]: ChainInfo } = {\n  [ChainId.ALFAJORES]: {\n    name: 'Alfajores',\n    fornoURL: 'https://alfajores-forno.celo-testnet.org',\n    blockscoutURL: 'https://alfajores-blockscout.celo-testnet.org'\n  },\n  [ChainId.BAKLAVA]: {\n    name: 'Baklava',\n    fornoURL: 'https://baklava-forno.celo-testnet.org',\n    blockscoutURL: 'https://baklava-blockscout.celo-testnet.org'\n  },\n  [ChainId.MAINNET]: {\n    name: 'Mainnet',\n    fornoURL: 'https://forno.celo.org',\n    blockscoutURL: 'https://explorer.celo.org'\n  }\n}\n","import { getAddress } from '@ethersproject/address'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { BigintIsh, ChainId, CHAIN_INFO, ONE, SolidityType, SOLIDITY_TYPE_MAXIMA, THREE, TWO, ZERO } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? JSBI.BigInt(bigintIsh.toString())\n    : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n\n/**\n * Parses a Celo chain ID number into a ChainId enum instance.\n * @param chainId The chain ID as a number.\n */\nexport const parseNetwork = (chainId: number): ChainId => {\n  if (!Object.values(ChainId).includes(chainId)) {\n    throw new Error(`Unknown Celo chain ID: ${chainId}`)\n  }\n  return chainId as ChainId\n}\n\nexport function getBlockscoutLink(\n  chainId: ChainId,\n  data: string,\n  type: 'transaction' | 'token' | 'address' | 'block'\n): string {\n  const prefix = CHAIN_INFO[chainId].blockscoutURL\n\n  switch (type) {\n    case 'transaction': {\n      return `${prefix}/tx/${data}`\n    }\n    case 'token': {\n      return `${prefix}/tokens/${data}`\n    }\n    case 'block': {\n      return `${prefix}/blocks/${data}`\n    }\n    case 'address':\n    default: {\n      return `${prefix}/address/${data}`\n    }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../utils'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { Rounding, _100 } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { ChainId, SolidityType } from '../constants'\nimport { validateAndParseAddress, validateSolidityTypeInstance } from '../utils'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token {\n  public readonly decimals: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  public readonly chainId: ChainId\n  public readonly address: string\n\n  /**\n   * Constructs an instance of the base class `Currency`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  public constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n\n    this.chainId = chainId\n    this.address = validateAndParseAddress(address)\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Token, currencyB: Token): boolean {\n  return currencyA.equals(currencyB)\n}\n\nexport const CELO = {\n  [ChainId.MAINNET]: new Token(ChainId.MAINNET, '0x471EcE3750Da237f93B8E339c536989b8978a438', 18, 'CELO', 'Celo'),\n  [ChainId.ALFAJORES]: new Token(ChainId.ALFAJORES, '0xF194afDf50B03e69Bd7D057c1Aa9e10c9954E4C9', 18, 'CELO', 'Celo'),\n  [ChainId.BAKLAVA]: new Token(ChainId.BAKLAVA, '0x765DE816845861e75A25fCA122bb6898B8B1282a', 18, 'CELO', 'Celo')\n}\n\nexport const cUSD = {\n  [ChainId.MAINNET]: new Token(\n    ChainId.MAINNET,\n    '0x765DE816845861e75A25fCA122bb6898B8B1282a',\n    18,\n    'cUSD',\n    'Celo Dollar'\n  ),\n  [ChainId.ALFAJORES]: new Token(\n    ChainId.ALFAJORES,\n    '0x874069Fa1Eb16D44d622F2e0Ca25eeA172369bC1',\n    18,\n    'cUSD',\n    'Celo Dollar'\n  ),\n  [ChainId.BAKLAVA]: new Token(\n    ChainId.ALFAJORES,\n    '0x765DE816845861e75A25fCA122bb6898B8B1282a',\n    18,\n    'cUSD',\n    'Celo Dollar'\n  )\n}\n\nexport const cEUR = {\n  [ChainId.MAINNET]: new Token(ChainId.MAINNET, '0xD8763CBa276a3738E6DE85b4b3bF5FDed6D6cA73', 18, 'cEUR', 'Celo Euro'),\n  [ChainId.ALFAJORES]: new Token(\n    ChainId.ALFAJORES,\n    '0x10c892A6EC43a53E45D0B916B4b7D383B1b78C0F',\n    18,\n    'cEUR',\n    'Celo Euro'\n  ),\n  [ChainId.BAKLAVA]: new Token(ChainId.BAKLAVA, '0xf9ecE301247aD2CE21894941830A2470f4E774ca', 18, 'cEUR', 'Celo Euro')\n}\n\nexport const cREAL = {\n  [ChainId.MAINNET]: new Token(ChainId.MAINNET, '0xe8537a3d056DA446677B9E9d6c5dB704EaAb4787', 18, 'cREAL', 'Celo Brazilian REAL'),\n  [ChainId.ALFAJORES]: new Token(\n    ChainId.ALFAJORES,\n    '0xE4D517785D091D3c54818832dB6094bcc2744545',\n    18,\n    'cREAL',\n    'Celo Brazilian REAL'\n  ),\n}\n","import _Big from 'big.js'\nimport JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport toFormat from 'toformat'\nimport { BigintIsh, Rounding, SolidityType, TEN } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\nimport { Token } from '../token'\nimport { Fraction } from './fraction'\n\nconst Big = toFormat(_Big)\n\nclass CurrencyAmount extends Fraction {\n  public readonly currency: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Token, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)))\n    this.currency = currency\n  }\n\n  public get raw(): JSBI {\n    return this.numerator\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n}\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\n  }\n}\n","import JSBI from 'jsbi'\nimport invariant from 'tiny-invariant'\nimport { BigintIsh, Rounding, TEN } from '../../constants'\nimport { Route } from '../route'\nimport { currencyEquals, Token } from '../token'\nimport { Fraction } from './fraction'\nimport { TokenAmount } from './tokenAmount'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Token // input i.e. denominator\n  public readonly quoteCurrency: Token // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  public static fromRoute(route: Route): Price {\n    const prices: Price[] = []\n    for (const [i, pair] of route.pairs.entries()) {\n      prices.push(\n        route.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw)\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Token, quoteCurrency: Token, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(currencyAmount: TokenAmount): TokenAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  _997,\n  _1000,\n  ChainId\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS,\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH\n          )\n        }\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      'UBE-V2',\n      'Ubeswap V2'\n    )\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, _997)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, _1000), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), _1000)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), _997)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { ChainId } from '../constants'\nimport { Price } from './fractions/price'\nimport { Pair } from './pair'\nimport { CELO, Token } from './token'\n\nexport class Route {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: Token\n  public readonly output: Token\n  public readonly midPrice: Price\n\n  public constructor(pairs: Pair[], input: Token, output?: Token) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(input instanceof Token && pairs[0].involvesToken(input), 'INPUT')\n    invariant(\n      typeof output === 'undefined' || (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : CELO[pairs[0].chainId]]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairs[0].chainId\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: TokenAmount, outputAmount: TokenAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput {\n  readonly inputAmount: TokenAmount\n  readonly outputAmount: TokenAmount\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: TokenAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: TokenAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: TokenAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: TokenAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: TokenAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = amount\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = amount\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : amounts[0]\n    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): TokenAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: TokenAmount,\n    currencyOut: Token,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: TokenAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n        ? currencyOut.chainId\n        : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = currencyAmountIn\n    const tokenOut = currencyOut\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Token,\n    currencyAmountOut: TokenAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: TokenAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n        ? currencyIn.chainId\n        : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = currencyAmountOut\n    const tokenIn = currencyIn\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { TokenAmount } from './entities/fractions/tokenAmount'\nimport { Pair } from './entities/pair'\nimport IUniswapV2Pair from '@uniswap/v2-core/build/IUniswapV2Pair.json'\nimport invariant from 'tiny-invariant'\nimport ERC20 from './abis/ERC20.json'\nimport { ChainId } from './constants'\nimport { Token } from './entities/token'\n\nlet TOKEN_DECIMALS_CACHE: { [chainId: number]: { [address: string]: number } } = {\n  [ChainId.MAINNET]: {\n    '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n  }\n}\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class Fetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * Fetch information for a given token on the given chain, using the given ethers provider.\n   * @param chainId chain of the token\n   * @param address address of the token on the chain\n   * @param provider provider used to fetch the token\n   * @param symbol optional symbol of the token\n   * @param name optional name of the token\n   */\n  public static async fetchTokenData(\n    chainId: ChainId,\n    address: string,\n    provider = getDefaultProvider(getNetwork(chainId)),\n    symbol?: string,\n    name?: string\n  ): Promise<Token> {\n    const parsedDecimals =\n      typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\n        ? TOKEN_DECIMALS_CACHE[chainId][address]\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\n            TOKEN_DECIMALS_CACHE = {\n              ...TOKEN_DECIMALS_CACHE,\n              [chainId]: {\n                ...TOKEN_DECIMALS_CACHE?.[chainId],\n                [address]: decimals\n              }\n            }\n            return decimals\n          })\n    return new Token(chainId, address, parsedDecimals, symbol, name)\n  }\n\n  /**\n   * Fetches information about a pair and constructs a pair from the given two tokens.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchPairData(\n    tokenA: Token,\n    tokenB: Token,\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\n  ): Promise<Pair> {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const address = Pair.getAddress(tokenA, tokenB)\n    const [reserves0, reserves1] = await new Contract(address, IUniswapV2Pair.abi, provider).getReserves()\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { TradeType } from './constants'\nimport { Percent, TokenAmount, Trade } from './entities'\nimport { validateAndParseAddress } from './utils'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Ubeswap V2 Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Ubeswap V2 Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: TokenAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Ubeswap V2 Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\n    // the router does not support both cgld in and out\n    invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map(token => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        methodName = useFeeOnTransfer\n          ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n          : 'swapExactTokensForTokens'\n        // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        args = [amountIn, amountOut, path, to, deadline]\n        value = ZERO_HEX\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        methodName = 'swapTokensForExactTokens'\n        // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        args = [amountOut, amountIn, path, to, deadline]\n        value = ZERO_HEX\n        break\n    }\n    return {\n      methodName,\n      args,\n      value\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}