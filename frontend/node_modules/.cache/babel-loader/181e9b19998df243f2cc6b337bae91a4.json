{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;\nconst gindex_1 = require(\"../gindex\");\n// Not currently in use, but simpler implementation useful for testing\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofGindices(gindex) {\n  const path = new Set();\n  const branch = new Set();\n  let g = gindex;\n  while (g > 1) {\n    path.add(g);\n    branch.add(gindex_1.gindexSibling(g));\n    g = gindex_1.gindexParent(g);\n  }\n  return {\n    path,\n    branch\n  };\n}\nexports.computeProofGindices = computeProofGindices;\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofBitstrings(gindex) {\n  const path = new Set();\n  const branch = new Set();\n  let g = gindex;\n  while (g.length > 1) {\n    path.add(g);\n    const lastBit = g[g.length - 1];\n    const parent = g.substring(0, g.length - 1);\n    branch.add(parent + (Number(lastBit) ^ 1));\n    g = parent;\n  }\n  return {\n    path,\n    branch\n  };\n}\nexports.computeProofBitstrings = computeProofBitstrings;\n/**\n * Sort generalized indices in-order\n * @param bitLength maximum bit length of generalized indices to sort\n */\nfunction sortInOrderBitstrings(gindices, bitLength) {\n  if (!gindices.length) {\n    return [];\n  }\n  return gindices.map(g => g.padEnd(bitLength)).sort().map(g => g.trim());\n}\nexports.sortInOrderBitstrings = sortInOrderBitstrings;\n/**\n * Sort generalized indices in decreasing order\n */\nfunction sortDecreasingBitstrings(gindices) {\n  if (!gindices.length) {\n    return [];\n  }\n  return gindices.sort((a, b) => {\n    if (a.length < b.length) {\n      return 1;\n    } else if (b.length < a.length) {\n      return -1;\n    }\n    let aPos0 = a.indexOf(\"0\");\n    let bPos0 = b.indexOf(\"0\");\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (aPos0 === -1) {\n        return -1;\n      } else if (bPos0 === -1) {\n        return 1;\n      }\n      if (aPos0 < bPos0) {\n        return 1;\n      } else if (bPos0 < aPos0) {\n        return -1;\n      }\n      aPos0 = a.indexOf(\"0\", aPos0 + 1);\n      bPos0 = b.indexOf(\"0\", bPos0 + 1);\n    }\n  });\n}\nexports.sortDecreasingBitstrings = sortDecreasingBitstrings;\n/**\n * Filter out parent generalized indices\n */\nfunction filterParentBitstrings(gindices) {\n  const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);\n  const filtered = [];\n  outer: for (let i = 0; i < sortedBitstrings.length; i++) {\n    const bsA = sortedBitstrings[i];\n    for (let j = i + 1; j < sortedBitstrings.length; j++) {\n      const bsB = sortedBitstrings[j];\n      if (bsB.startsWith(bsA)) {\n        continue outer;\n      }\n    }\n    filtered.push(bsA);\n  }\n  return filtered;\n}\nexports.filterParentBitstrings = filterParentBitstrings;\nvar SortOrder;\n(function (SortOrder) {\n  SortOrder[SortOrder[\"InOrder\"] = 0] = \"InOrder\";\n  SortOrder[SortOrder[\"Decreasing\"] = 1] = \"Decreasing\";\n  SortOrder[SortOrder[\"Unsorted\"] = 2] = \"Unsorted\";\n})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));\n/**\n * Return the set of generalized indices required for a multiproof\n * This may include all leaves and any necessary witnesses\n * @param gindices leaves to include in proof\n * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted\n */\nfunction computeMultiProofBitstrings(gindices) {\n  let includeLeaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SortOrder.InOrder;\n  const leaves = filterParentBitstrings(gindices);\n  // Maybe initialize the proof indices with the leaves\n  const proof = new Set(includeLeaves ? leaves : []);\n  const paths = new Set();\n  const branches = new Set();\n  // Collect all path indices and all branch indices\n  let maxBitLength = 1;\n  for (const gindex of leaves) {\n    if (gindex.length > maxBitLength) maxBitLength = gindex.length;\n    const {\n      path,\n      branch\n    } = computeProofBitstrings(gindex);\n    path.forEach(g => paths.add(g));\n    branch.forEach(g => branches.add(g));\n  }\n  // Remove all branches that are included in the paths\n  paths.forEach(g => branches.delete(g));\n  // Add all remaining branches to the leaves\n  branches.forEach(g => proof.add(g));\n  switch (sortOrder) {\n    case SortOrder.InOrder:\n      return sortInOrderBitstrings(Array.from(proof), maxBitLength);\n    case SortOrder.Decreasing:\n      return sortDecreasingBitstrings(Array.from(proof));\n    case SortOrder.Unsorted:\n      return Array.from(proof);\n  }\n}\nexports.computeMultiProofBitstrings = computeMultiProofBitstrings;","map":null,"metadata":{},"sourceType":"script"}