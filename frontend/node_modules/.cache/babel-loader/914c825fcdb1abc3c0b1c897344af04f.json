{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from \"react\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nvar EAGER_METHODS = [\"refetch\", \"reobserve\", \"fetchMore\", \"updateQuery\", \"startPolling\", \"subscribeToMore\"];\nexport function useLazyQuery(query, options) {\n  var _a;\n  var execOptionsRef = React.useRef();\n  var optionsRef = React.useRef();\n  var queryRef = React.useRef();\n  var merged = mergeOptions(options, execOptionsRef.current || {});\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n  optionsRef.current = merged;\n  queryRef.current = document;\n  var internalState = useInternalState(useApolloClient(options && options.client), document);\n  var useQueryResult = internalState.useQuery(__assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  }));\n  var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy || internalState.getDefaultFetchPolicy();\n  var result = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current\n  });\n  var eagerMethods = React.useMemo(function () {\n    var eagerMethods = {};\n    var _loop_1 = function _loop_1(key) {\n      var method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          internalState.forceUpdateState();\n        }\n        return method.apply(this, arguments);\n      };\n    };\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n      _loop_1(key);\n    }\n    return eagerMethods;\n  }, []);\n  Object.assign(result, eagerMethods);\n  var execute = React.useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = internalState.executeQuery(__assign(__assign({}, options), {\n      skip: false\n    })).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    });\n    promise.catch(function () {});\n    return promise;\n  }, []);\n  return [execute, result];\n}","map":{"version":3,"sources":["../../../src/react/hooks/useLazyQuery.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,KAAK,MAAM,OAAO;AAG9B,SAAS,YAAY,QAAQ,0BAA0B;AAQvD,SAAS,gBAAgB,QAAQ,eAAe;AAChD,SAAS,eAAe,QAAQ,sBAAsB;AAItD,IAAM,aAAa,GAAG,CACpB,SAAS,EACT,WAAW,EACX,WAAW,EACX,aAAa,EACb,cAAc,EACd,iBAAiB,CACT;AAEV,OAAM,SAAU,YAAY,CAI1B,KAA0D,EAC1D,OAAmE,EAAA;;EAEnE,IAAM,cAAc,GAClB,KAAK,CAAC,MAAM,CAAA,CAAwD;EACtE,IAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAA,CAA2C;EAC1E,IAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAA,CAE1B;EACH,IAAM,MAAM,GAAG,YAAY,CAAC,OAAO,EAAE,cAAc,CAAC,OAAO,IAAI,CAAA,CAAE,CAAC;EAClE,IAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,MAAM,KAAA,IAAA,IAAN,MAAM,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAN,MAAM,CAAE,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,KAAK;EAIvC,UAAU,CAAC,OAAO,GAAG,MAAM;EAC3B,QAAQ,CAAC,OAAO,GAAG,QAAQ;EAE3B,IAAM,aAAa,GAAG,gBAAgB,CACpC,eAAe,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,CAAC,EAC1C,QAAQ,CACT;EAED,IAAM,cAAc,GAAG,aAAa,CAAC,QAAQ,CAAA,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EACxC,MAAM,CAAA,EAAA;IACT,IAAI,EAAE,CAAC,cAAc,CAAC;EAAO,CAAA,CAAA,CAC7B;EAEF,IAAM,kBAAkB,GACtB,cAAc,CAAC,UAAU,CAAC,OAAO,CAAC,kBAAkB,IACpD,aAAa,CAAC,qBAAqB,CAAA,CAAE;EAEvC,IAAM,MAAM,GAAmC,MAAM,CAAC,MAAM,CAAC,cAAc,EAAE;IAC3E,MAAM,EAAE,CAAC,CAAC,cAAc,CAAC;GAC1B,CAAC;EAGF,IAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,YAAA;IACjC,IAAM,YAAY,GAAwB,CAAA,CAAE;mCACjC,GAAG,EAAA;MACZ,IAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC;MAC1B,YAAY,CAAC,GAAG,CAAC,GAAG,YAAA;QAClB,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE;UAC3B,cAAc,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;UAE5C,aAAa,CAAC,gBAAgB,CAAA,CAAE;QACjC;QACD,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC;MACtC,CAAC;;IATH,KAAkB,IAAA,EAAA,GAAA,CAAa,EAAb,eAAA,GAAA,aAAa,EAAb,EAAA,GAAA,eAAA,CAAA,MAAa,EAAb,EAAA,EAAa,EAAA;MAA1B,IAAM,GAAG,GAAA,eAAA,CAAA,EAAA,CAAA;cAAH,GAAG,CAAA;IAUb;IAED,OAAO,YAAY;EACrB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,YAAY,CAAC;EAEnC,IAAM,OAAO,GAAG,KAAK,CAAC,WAAW,CAC/B,UAAC,cAAc,EAAA;IACb,cAAc,CAAC,OAAO,GAAG,cAAc,GACpC,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EACM,cAAc,CAAA,EAAA;MACjB,WAAW,EAAE,cAAc,CAAC,WAAW,IAAI;IAAkB,CAAA,CAAA,GAE/D;MACE,WAAW,EAAE;KACd;IAEL,IAAM,OAAO,GAAG,YAAY,CAAC,UAAU,CAAC,OAAO,EAAA,QAAA,CAAA;MAC7C,KAAK,EAAE,QAAQ,CAAC;IAAO,CAAA,EACpB,cAAc,CAAC,OAAO,CAAA,CACzB;IAEF,IAAM,OAAO,GAAG,aAAa,CAC1B,YAAY,CAAA,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EAAM,OAAO,CAAA,EAAA;MAAE,IAAI,EAAE;IAAK,CAAA,CAAA,CAAG,CACzC,IAAI,CAAC,UAAC,WAAW,EAAA;MAAK,OAAA,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,YAAY,CAAC;IAAxC,CAAwC,CAAC;IAIlE,OAAO,CAAC,KAAK,CAAC,YAAA,CAAO,CAAC,CAAC;IAEvB,OAAO,OAAO;EAChB,CAAC,EACD,EAAE,CACH;EAED,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC;AAC1B","sourcesContent":["import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"react\";\n\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryResult,\n} from \"../types/types.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"subscribeToMore\",\n] as const;\n\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = merged;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current,\n  });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdateState();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current = executeOptions\n        ? {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = internalState\n        .executeQuery({ ...options, skip: false })\n        .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    []\n  );\n\n  return [execute, result];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}