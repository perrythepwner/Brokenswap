{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapAddressListDataOnto = exports.mapAddressListOnto = exports.findAddressIndex = exports.NULL_ADDRESS = exports.bufferToHex = exports.hexToBuffer = exports.isHexString = exports.getAddressChunks = exports.ensureLeading0x = exports.trimLeading0x = exports.normalizeAddressWith0x = exports.isNullAddress = exports.normalizeAddress = exports.eqAddress = void 0;\nvar HEX_REGEX = /^0x[0-9A-F]*$/i;\nvar eqAddress = function eqAddress(a, b) {\n  return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(b);\n};\nexports.eqAddress = eqAddress;\nvar normalizeAddress = function normalizeAddress(a) {\n  return (0, exports.trimLeading0x)(a).toLowerCase();\n};\nexports.normalizeAddress = normalizeAddress;\nvar isNullAddress = function isNullAddress(a) {\n  return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(exports.NULL_ADDRESS);\n};\nexports.isNullAddress = isNullAddress;\nvar normalizeAddressWith0x = function normalizeAddressWith0x(a) {\n  return (0, exports.ensureLeading0x)(a).toLowerCase();\n};\nexports.normalizeAddressWith0x = normalizeAddressWith0x;\nvar trimLeading0x = function trimLeading0x(input) {\n  return input.startsWith('0x') ? input.slice(2) : input;\n};\nexports.trimLeading0x = trimLeading0x;\nvar ensureLeading0x = function ensureLeading0x(input) {\n  return input.startsWith('0x') ? input : \"0x\".concat(input);\n};\nexports.ensureLeading0x = ensureLeading0x;\n// Turns '0xce10ce10ce10ce10ce10ce10ce10ce10ce10ce10'\n// into ['ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10']\nvar getAddressChunks = function getAddressChunks(input) {\n  return (0, exports.trimLeading0x)(input).match(/.{1,4}/g) || [];\n};\nexports.getAddressChunks = getAddressChunks;\nvar isHexString = function isHexString(input) {\n  return HEX_REGEX.test(input);\n};\nexports.isHexString = isHexString;\nvar hexToBuffer = function hexToBuffer(input) {\n  return Buffer.from((0, exports.trimLeading0x)(input), 'hex');\n};\nexports.hexToBuffer = hexToBuffer;\nvar bufferToHex = function bufferToHex(buf) {\n  return (0, exports.ensureLeading0x)(buf.toString('hex'));\n};\nexports.bufferToHex = bufferToHex;\nexports.NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar findAddressIndex = function findAddressIndex(address, addresses) {\n  return addresses.findIndex(function (x) {\n    return (0, exports.eqAddress)(x, address);\n  });\n};\nexports.findAddressIndex = findAddressIndex;\n// Returns an array of indices mapping the entries of oldAddress[] to newAddress[]\nvar mapAddressListOnto = function mapAddressListOnto(oldAddress, newAddress) {\n  var oldAddressIndex = oldAddress.map(function (x, index) {\n    return {\n      address: (0, exports.normalizeAddress)(x),\n      index: index\n    };\n  });\n  var newAddressIndex = newAddress.map(function (x, index) {\n    return {\n      address: (0, exports.normalizeAddress)(x),\n      index: index\n    };\n  });\n  oldAddressIndex.sort(function (a, b) {\n    return a.address.localeCompare(b.address);\n  });\n  newAddressIndex.sort(function (a, b) {\n    return a.address.localeCompare(b.address);\n  });\n  var res = __spreadArray([], Array(oldAddress.length).fill(-1), true);\n  for (var i = 0, j = 0; i < oldAddress.length && j < newAddress.length;) {\n    var cmp = oldAddressIndex[i].address.localeCompare(newAddressIndex[j].address);\n    if (cmp < 0) {\n      i++;\n    } else if (cmp > 0) {\n      j++;\n    } else {\n      // Address is present in both lists\n      res[oldAddressIndex[i].index] = newAddressIndex[j].index;\n      i++;\n      j++;\n    }\n  }\n  return res;\n};\nexports.mapAddressListOnto = mapAddressListOnto;\n// Returns data[] reordered by mapAddressListOnto(), and initiaValue for any entry of\n// oldAddress[] not present in newAddress[].\nfunction mapAddressListDataOnto(data, oldAddress, newAddress, initialValue) {\n  var res = __spreadArray([], Array(oldAddress.length).fill(initialValue), true);\n  if (data.length === 0) {\n    return res;\n  }\n  var addressIndexMap = (0, exports.mapAddressListOnto)(oldAddress, newAddress);\n  for (var i = 0; i < addressIndexMap.length; i++) {\n    if (addressIndexMap[i] >= 0) {\n      res[addressIndexMap[i]] = data[i];\n    }\n  }\n  return res;\n}\nexports.mapAddressListDataOnto = mapAddressListDataOnto;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapAddressListDataOnto = exports.mapAddressListOnto = exports.findAddressIndex = exports.NULL_ADDRESS = exports.bufferToHex = exports.hexToBuffer = exports.isHexString = exports.getAddressChunks = exports.ensureLeading0x = exports.trimLeading0x = exports.normalizeAddressWith0x = exports.isNullAddress = exports.normalizeAddress = exports.eqAddress = void 0;\nvar HEX_REGEX = /^0x[0-9A-F]*$/i;\nvar eqAddress = function (a, b) { return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(b); };\nexports.eqAddress = eqAddress;\nvar normalizeAddress = function (a) { return (0, exports.trimLeading0x)(a).toLowerCase(); };\nexports.normalizeAddress = normalizeAddress;\nvar isNullAddress = function (a) { return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(exports.NULL_ADDRESS); };\nexports.isNullAddress = isNullAddress;\nvar normalizeAddressWith0x = function (a) { return (0, exports.ensureLeading0x)(a).toLowerCase(); };\nexports.normalizeAddressWith0x = normalizeAddressWith0x;\nvar trimLeading0x = function (input) { return (input.startsWith('0x') ? input.slice(2) : input); };\nexports.trimLeading0x = trimLeading0x;\nvar ensureLeading0x = function (input) { return (input.startsWith('0x') ? input : \"0x\".concat(input)); };\nexports.ensureLeading0x = ensureLeading0x;\n// Turns '0xce10ce10ce10ce10ce10ce10ce10ce10ce10ce10'\n// into ['ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10']\nvar getAddressChunks = function (input) {\n    return (0, exports.trimLeading0x)(input).match(/.{1,4}/g) || [];\n};\nexports.getAddressChunks = getAddressChunks;\nvar isHexString = function (input) { return HEX_REGEX.test(input); };\nexports.isHexString = isHexString;\nvar hexToBuffer = function (input) { return Buffer.from((0, exports.trimLeading0x)(input), 'hex'); };\nexports.hexToBuffer = hexToBuffer;\nvar bufferToHex = function (buf) { return (0, exports.ensureLeading0x)(buf.toString('hex')); };\nexports.bufferToHex = bufferToHex;\nexports.NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar findAddressIndex = function (address, addresses) {\n    return addresses.findIndex(function (x) { return (0, exports.eqAddress)(x, address); });\n};\nexports.findAddressIndex = findAddressIndex;\n// Returns an array of indices mapping the entries of oldAddress[] to newAddress[]\nvar mapAddressListOnto = function (oldAddress, newAddress) {\n    var oldAddressIndex = oldAddress.map(function (x, index) { return ({ address: (0, exports.normalizeAddress)(x), index: index }); });\n    var newAddressIndex = newAddress.map(function (x, index) { return ({ address: (0, exports.normalizeAddress)(x), index: index }); });\n    oldAddressIndex.sort(function (a, b) { return a.address.localeCompare(b.address); });\n    newAddressIndex.sort(function (a, b) { return a.address.localeCompare(b.address); });\n    var res = __spreadArray([], Array(oldAddress.length).fill(-1), true);\n    for (var i = 0, j = 0; i < oldAddress.length && j < newAddress.length;) {\n        var cmp = oldAddressIndex[i].address.localeCompare(newAddressIndex[j].address);\n        if (cmp < 0) {\n            i++;\n        }\n        else if (cmp > 0) {\n            j++;\n        }\n        else {\n            // Address is present in both lists\n            res[oldAddressIndex[i].index] = newAddressIndex[j].index;\n            i++;\n            j++;\n        }\n    }\n    return res;\n};\nexports.mapAddressListOnto = mapAddressListOnto;\n// Returns data[] reordered by mapAddressListOnto(), and initiaValue for any entry of\n// oldAddress[] not present in newAddress[].\nfunction mapAddressListDataOnto(data, oldAddress, newAddress, initialValue) {\n    var res = __spreadArray([], Array(oldAddress.length).fill(initialValue), true);\n    if (data.length === 0) {\n        return res;\n    }\n    var addressIndexMap = (0, exports.mapAddressListOnto)(oldAddress, newAddress);\n    for (var i = 0; i < addressIndexMap.length; i++) {\n        if (addressIndexMap[i] >= 0) {\n            res[addressIndexMap[i]] = data[i];\n        }\n    }\n    return res;\n}\nexports.mapAddressListDataOnto = mapAddressListDataOnto;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}