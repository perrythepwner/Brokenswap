{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n// There's a matrix of Array-ish types that require a combination of this functions.\n// Regular class extends syntax doesn't work because it can only extend a single class.\n//\n// Type of array: List, Vector. Changes length property\n// Type of element: Basic, Composite. Changes merkelization if packing or not.\n// If Composite: Fixed len, Variable len. Changes the serialization requiring offsets.\n/**\n * SSZ Lists (variable-length arrays) include the length of the list in the tree\n * This length is always in the same index in the tree\n * ```\n *   1\n *  / \\\n * 2   3 // <-here\n * ```\n */\nfunction getLengthFromRootNode(node) {\n  // Length is represented as a Uint32 at the start of the chunk:\n  // 4 = 4 bytes in Uint32\n  // 0 = 0 offset bytes in Node's data\n  return node.right.getUint(4, 0);\n}\nexports.getLengthFromRootNode = getLengthFromRootNode;\nfunction getChunksNodeFromRootNode(node) {\n  return node.left;\n}\nexports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;\nfunction addLengthNode(chunksNode, length) {\n  return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));\n}\nexports.addLengthNode = addLengthNode;\nfunction setChunksNode(rootNode, chunksNode, newLength) {\n  const lengthNode = newLength !== undefined ?\n  // If newLength is set, create a new node for length\n  persistent_merkle_tree_1.LeafNode.fromUint32(newLength) :\n  // else re-use existing node\n  rootNode.right;\n  return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);\n}\nexports.setChunksNode = setChunksNode;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {\n  const elSize = elementType.byteLength;\n  for (let i = 0; i < length; i++) {\n    elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);\n  }\n  return offset + length * elSize;\n}\nexports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;\nfunction value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {\n  const elSize = elementType.byteLength;\n  // Vector + List length validation\n  const length = (end - start) / elSize;\n  assertValidArrayLength(length, arrayProps, true);\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    // TODO: If faster, consider skipping size check for uint types\n    values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);\n  }\n  return values;\n}\nexports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {\n  const size = elementType.byteLength * length;\n  const chunkCount = Math.ceil(size / 32);\n  const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);\n  persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);\n  return offset + size;\n}\nexports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;\n// List of basic elements will pack them in merkelized form\nfunction tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {\n  // Vector + List length validation\n  const length = (end - start) / elementType.byteLength;\n  assertValidArrayLength(length, arrayProps, true);\n  // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n  const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);\n  if (arrayProps.isList) {\n    return addLengthNode(chunksNode, length);\n  } else {\n    return chunksNode;\n  }\n}\nexports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_fromJsonArray(elementType, json, arrayProps) {\n  if (!Array.isArray(json)) {\n    throw Error(\"JSON is not an array\");\n  }\n  assertValidArrayLength(json.length, arrayProps);\n  const value = new Array(json.length);\n  for (let i = 0; i < json.length; i++) {\n    value[i] = elementType.fromJson(json[i]);\n  }\n  return value;\n}\nexports.value_fromJsonArray = value_fromJsonArray;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_toJsonArray(elementType, value, arrayProps) {\n  const length = arrayProps.isList ? value.length : arrayProps.length;\n  const json = new Array(length);\n  for (let i = 0; i < length; i++) {\n    json[i] = elementType.toJson(value[i]);\n  }\n  return json;\n}\nexports.value_toJsonArray = value_toJsonArray;\n/**\n * Clone recursively an array of basic or composite types\n */\nfunction value_cloneArray(elementType, value) {\n  const newValue = new Array(value.length);\n  for (let i = 0; i < value.length; i++) {\n    newValue[i] = elementType.clone(value[i]);\n  }\n  return newValue;\n}\nexports.value_cloneArray = value_cloneArray;\n/**\n * Check recursively if a type is structuraly equal. Returns early\n */\nfunction value_equals(elementType, a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (!elementType.equals(a[i], b[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.value_equals = value_equals;\nfunction value_defaultValueArray(elementType, length) {\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    values[i] = elementType.defaultValue();\n  }\n  return values;\n}\nexports.value_defaultValueArray = value_defaultValueArray;\n/**\n * @param checkNonDecimalLength Check that length is a multiple of element size.\n * Optional since it's not necessary in getOffsetsArrayComposite() fn.\n */\nfunction assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {\n  if (checkNonDecimalLength && length % 1 !== 0) {\n    throw Error(\"size not multiple of element fixedSize\");\n  }\n  // Vector + List length validation\n  if (arrayProps.isList) {\n    if (length > arrayProps.limit) {\n      throw new Error(\"Invalid list length \".concat(length, \" over limit \").concat(arrayProps.limit));\n    }\n  } else {\n    if (length !== arrayProps.length) {\n      throw new Error(\"Incorrect vector length \".concat(length, \" expected \").concat(arrayProps.length));\n    }\n  }\n}\nexports.assertValidArrayLength = assertValidArrayLength;","map":null,"metadata":{},"sourceType":"script"}