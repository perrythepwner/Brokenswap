{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { RELAYER_DEFAULT_PROTOCOL as ge, RELAYER_EVENTS as Z, VERIFY_SERVER as me, EXPIRER_EVENTS as we, PAIRING_EVENTS as ye, Store as k, Core as Se } from \"@walletconnect/core\";\nimport { pino as Ee, getDefaultLoggerOptions as Re, generateChildLogger as Ie, getLoggerContext as _e } from \"@walletconnect/logger\";\nimport { IEngine as Ne, ISignClient as qe } from \"@walletconnect/types\";\nimport { TYPE_1 as fe, createDelayedPromise as x, engineEvent as u, getInternalError as l, calcExpiry as _, isValidObject as z, getRequiredNamespacesFromNamespaces as ve, getSdkError as N, handleDeeplinkRedirect as Pe, isSessionCompatible as Oe, isBrowser as Ve, hashMessage as Y, isExpired as P, MemoryStore as $, isValidParams as E, isUndefined as D, isValidRelays as Te, isValidRequiredNamespaces as xe, isValidNamespaces as j, isConformingNamespaces as ee, isValidString as C, isValidErrorReason as De, isValidRelay as Ce, isValidController as Ae, isValidNamespacesChainId as se, isValidRequest as be, isValidNamespacesRequest as Le, isValidRequestExpiry as $e, isValidResponse as Ge, isValidEvent as Me, isValidNamespacesEvent as Ue, parseExpirerTarget as Qe, isValidId as Ke, getAppMetadata as ke } from \"@walletconnect/utils\";\nimport ze, { EventEmitter as Ye } from \"events\";\nimport { THIRTY_DAYS as je, SEVEN_DAYS as te, FIVE_MINUTES as y, ONE_DAY as O, THIRTY_SECONDS as ie, ONE_SECOND as Je, toMiliseconds as re } from \"@walletconnect/time\";\nimport { payloadId as Xe, isJsonRpcResult as q, isJsonRpcError as f, formatJsonRpcRequest as J, formatJsonRpcResult as Fe, formatJsonRpcError as He, isJsonRpcRequest as We, isJsonRpcResponse as Be } from \"@walletconnect/jsonrpc-utils\";\nconst X = \"wc\",\n  F = 2,\n  H = \"client\",\n  G = \"\".concat(X, \"@\").concat(F, \":\").concat(H, \":\"),\n  M = {\n    name: H,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Ze = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  es = {\n    database: \":memory:\"\n  },\n  W = \"WALLETCONNECT_DEEPLINK_CHOICE\",\n  ss = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  ts = \"history\",\n  is = \"0.3\",\n  ne = \"proposal\",\n  rs = je,\n  oe = \"Proposal expired\",\n  ae = \"session\",\n  A = te,\n  ce = \"engine\",\n  V = {\n    wc_sessionPropose: {\n      req: {\n        ttl: y,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: y,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: y,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: y,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: y,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: O,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: O,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: ie,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: ie,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  U = {\n    min: y,\n    max: te\n  },\n  I = {\n    idle: \"IDLE\",\n    active: \"ACTIVE\"\n  },\n  le = \"request\",\n  pe = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar ns = Object.defineProperty,\n  os = Object.defineProperties,\n  as = Object.getOwnPropertyDescriptors,\n  he = Object.getOwnPropertySymbols,\n  cs = Object.prototype.hasOwnProperty,\n  ls = Object.prototype.propertyIsEnumerable,\n  de = (m, r, e) => r in m ? ns(m, r, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : m[r] = e,\n  g = (m, r) => {\n    for (var e in r || (r = {})) cs.call(r, e) && de(m, e, r[e]);\n    if (he) for (var e of he(r)) ls.call(r, e) && de(m, e, r[e]);\n    return m;\n  },\n  b = (m, r) => os(m, as(r));\nclass ps extends Ne {\n  constructor(r) {\n    var _this;\n    (super(r), _this = this), this.name = ce, this.events = new ze(), this.initialized = !1, this.ignoredPayloadTypes = [fe], this.requestQueue = {\n      state: I.idle,\n      queue: []\n    }, this.sessionRequestQueue = {\n      state: I.idle,\n      queue: []\n    }, this.requestQueueDelay = Je, this.init = /*#__PURE__*/_asyncToGenerator(function* () {\n      _this.initialized || (yield _this.cleanup(), _this.registerRelayerEvents(), _this.registerExpirerEvents(), _this.registerPairingEvents(), _this.client.core.pairing.register({\n        methods: Object.keys(V)\n      }), _this.initialized = !0, setTimeout(() => {\n        _this.sessionRequestQueue.queue = _this.getPendingSessionRequests(), _this.processSessionRequestQueue();\n      }, re(_this.requestQueueDelay)));\n    }), this.connect = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized();\n        const s = b(g({}, e), {\n          requiredNamespaces: e.requiredNamespaces || {},\n          optionalNamespaces: e.optionalNamespaces || {}\n        });\n        yield _this.isValidConnect(s);\n        const {\n          pairingTopic: t,\n          requiredNamespaces: i,\n          optionalNamespaces: n,\n          sessionProperties: o,\n          relays: a\n        } = s;\n        let c = t,\n          p,\n          d = !1;\n        if (c && (d = _this.client.core.pairing.pairings.get(c).active), !c || !d) {\n          const {\n            topic: v,\n            uri: S\n          } = yield _this.client.core.pairing.create();\n          c = v, p = S;\n        }\n        const h = yield _this.client.core.crypto.generateKeyPair(),\n          R = g({\n            requiredNamespaces: i,\n            optionalNamespaces: n,\n            relays: a !== null && a !== void 0 ? a : [{\n              protocol: ge\n            }],\n            proposer: {\n              publicKey: h,\n              metadata: _this.client.metadata\n            }\n          }, o && {\n            sessionProperties: o\n          }),\n          {\n            reject: w,\n            resolve: T,\n            done: K\n          } = x(y, oe);\n        if (_this.events.once(u(\"session_connect\"), /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (_ref3) {\n            let {\n              error: v,\n              session: S\n            } = _ref3;\n            if (v) w(v);else if (S) {\n              S.self.publicKey = h;\n              const B = b(g({}, S), {\n                requiredNamespaces: S.requiredNamespaces,\n                optionalNamespaces: S.optionalNamespaces\n              });\n              yield _this.client.session.set(S.topic, B), yield _this.setExpiry(S.topic, S.expiry), c && (yield _this.client.core.pairing.updateMetadata({\n                topic: c,\n                metadata: S.peer.metadata\n              })), T(B);\n            }\n          });\n          return function (_x2) {\n            return _ref4.apply(this, arguments);\n          };\n        }()), !c) {\n          const {\n            message: v\n          } = l(\"NO_MATCHING_KEY\", \"connect() pairing topic: \".concat(c));\n          throw new Error(v);\n        }\n        const L = yield _this.sendRequest({\n            topic: c,\n            method: \"wc_sessionPropose\",\n            params: R\n          }),\n          ue = _(y);\n        return yield _this.setProposal(L, g({\n          id: L,\n          expiry: ue\n        }, R)), {\n          uri: p,\n          approval: K\n        };\n      });\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }(), this.pair = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (e) {\n        return yield _this.isInitialized(), yield _this.client.core.pairing.pair(e);\n      });\n      return function (_x3) {\n        return _ref5.apply(this, arguments);\n      };\n    }(), this.approve = /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidApprove(e);\n        const {\n            id: s,\n            relayProtocol: t,\n            namespaces: i,\n            sessionProperties: n\n          } = e,\n          o = _this.client.proposal.get(s);\n        let {\n          pairingTopic: a,\n          proposer: c,\n          requiredNamespaces: p,\n          optionalNamespaces: d\n        } = o;\n        a = a || \"\", z(p) || (p = ve(i, \"approve()\"));\n        const h = yield _this.client.core.crypto.generateKeyPair(),\n          R = c.publicKey,\n          w = yield _this.client.core.crypto.generateSharedKey(h, R);\n        a && s && (yield _this.client.core.pairing.updateMetadata({\n          topic: a,\n          metadata: c.metadata\n        }), yield _this.sendResult({\n          id: s,\n          topic: a,\n          result: {\n            relay: {\n              protocol: t !== null && t !== void 0 ? t : \"irn\"\n            },\n            responderPublicKey: h\n          }\n        }), yield _this.client.proposal.delete(s, N(\"USER_DISCONNECTED\")), yield _this.client.core.pairing.activate({\n          topic: a\n        }));\n        const T = g({\n          relay: {\n            protocol: t !== null && t !== void 0 ? t : \"irn\"\n          },\n          namespaces: i,\n          requiredNamespaces: p,\n          optionalNamespaces: d,\n          pairingTopic: a,\n          controller: {\n            publicKey: h,\n            metadata: _this.client.metadata\n          },\n          expiry: _(A)\n        }, n && {\n          sessionProperties: n\n        });\n        yield _this.client.core.relayer.subscribe(w), yield _this.sendRequest({\n          topic: w,\n          method: \"wc_sessionSettle\",\n          params: T,\n          throwOnFailedPublish: !0\n        });\n        const K = b(g({}, T), {\n          topic: w,\n          pairingTopic: a,\n          acknowledged: !1,\n          self: T.controller,\n          peer: {\n            publicKey: c.publicKey,\n            metadata: c.metadata\n          },\n          controller: h\n        });\n        return yield _this.client.session.set(w, K), yield _this.setExpiry(w, _(A)), {\n          topic: w,\n          acknowledged: () => new Promise(L => setTimeout(() => L(_this.client.session.get(w)), 500))\n        };\n      });\n      return function (_x4) {\n        return _ref6.apply(this, arguments);\n      };\n    }(), this.reject = /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidReject(e);\n        const {\n            id: s,\n            reason: t\n          } = e,\n          {\n            pairingTopic: i\n          } = _this.client.proposal.get(s);\n        i && (yield _this.sendError(s, i, t), yield _this.client.proposal.delete(s, N(\"USER_DISCONNECTED\")));\n      });\n      return function (_x5) {\n        return _ref7.apply(this, arguments);\n      };\n    }(), this.update = /*#__PURE__*/function () {\n      var _ref8 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidUpdate(e);\n        const {\n            topic: s,\n            namespaces: t\n          } = e,\n          i = yield _this.sendRequest({\n            topic: s,\n            method: \"wc_sessionUpdate\",\n            params: {\n              namespaces: t\n            }\n          }),\n          {\n            done: n,\n            resolve: o,\n            reject: a\n          } = x();\n        return _this.events.once(u(\"session_update\", i), _ref9 => {\n          let {\n            error: c\n          } = _ref9;\n          c ? a(c) : o();\n        }), yield _this.client.session.update(s, {\n          namespaces: t\n        }), {\n          acknowledged: n\n        };\n      });\n      return function (_x6) {\n        return _ref8.apply(this, arguments);\n      };\n    }(), this.extend = /*#__PURE__*/function () {\n      var _ref10 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidExtend(e);\n        const {\n            topic: s\n          } = e,\n          t = yield _this.sendRequest({\n            topic: s,\n            method: \"wc_sessionExtend\",\n            params: {}\n          }),\n          {\n            done: i,\n            resolve: n,\n            reject: o\n          } = x();\n        return _this.events.once(u(\"session_extend\", t), _ref11 => {\n          let {\n            error: a\n          } = _ref11;\n          a ? o(a) : n();\n        }), yield _this.setExpiry(s, _(A)), {\n          acknowledged: i\n        };\n      });\n      return function (_x7) {\n        return _ref10.apply(this, arguments);\n      };\n    }(), this.request = /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidRequest(e);\n        const {\n            chainId: s,\n            request: t,\n            topic: i,\n            expiry: n\n          } = e,\n          o = Xe(),\n          {\n            done: a,\n            resolve: c,\n            reject: p\n          } = x(n, \"Request expired. Please try again.\");\n        return _this.events.once(u(\"session_request\", o), _ref13 => {\n          let {\n            error: d,\n            result: h\n          } = _ref13;\n          d ? p(d) : c(h);\n        }), yield Promise.all([new Promise( /*#__PURE__*/function () {\n          var _ref14 = _asyncToGenerator(function* (d) {\n            yield _this.sendRequest({\n              clientRpcId: o,\n              topic: i,\n              method: \"wc_sessionRequest\",\n              params: {\n                request: t,\n                chainId: s\n              },\n              expiry: n,\n              throwOnFailedPublish: !0\n            }).catch(h => p(h)), _this.client.events.emit(\"session_request_sent\", {\n              topic: i,\n              request: t,\n              chainId: s,\n              id: o\n            }), d();\n          });\n          return function (_x9) {\n            return _ref14.apply(this, arguments);\n          };\n        }()), new Promise( /*#__PURE__*/function () {\n          var _ref15 = _asyncToGenerator(function* (d) {\n            const h = yield _this.client.core.storage.getItem(W);\n            Pe({\n              id: o,\n              topic: i,\n              wcDeepLink: h\n            }), d();\n          });\n          return function (_x10) {\n            return _ref15.apply(this, arguments);\n          };\n        }()), a()]).then(d => d[2]);\n      });\n      return function (_x8) {\n        return _ref12.apply(this, arguments);\n      };\n    }(), this.respond = /*#__PURE__*/function () {\n      var _ref16 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidRespond(e);\n        const {\n            topic: s,\n            response: t\n          } = e,\n          {\n            id: i\n          } = t;\n        q(t) ? yield _this.sendResult({\n          id: i,\n          topic: s,\n          result: t.result,\n          throwOnFailedPublish: !0\n        }) : f(t) && (yield _this.sendError(i, s, t.error)), _this.cleanupAfterResponse(e);\n      });\n      return function (_x11) {\n        return _ref16.apply(this, arguments);\n      };\n    }(), this.ping = /*#__PURE__*/function () {\n      var _ref17 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidPing(e);\n        const {\n          topic: s\n        } = e;\n        if (_this.client.session.keys.includes(s)) {\n          const t = yield _this.sendRequest({\n              topic: s,\n              method: \"wc_sessionPing\",\n              params: {}\n            }),\n            {\n              done: i,\n              resolve: n,\n              reject: o\n            } = x();\n          _this.events.once(u(\"session_ping\", t), _ref18 => {\n            let {\n              error: a\n            } = _ref18;\n            a ? o(a) : n();\n          }), yield i();\n        } else _this.client.core.pairing.pairings.keys.includes(s) && (yield _this.client.core.pairing.ping({\n          topic: s\n        }));\n      });\n      return function (_x12) {\n        return _ref17.apply(this, arguments);\n      };\n    }(), this.emit = /*#__PURE__*/function () {\n      var _ref19 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidEmit(e);\n        const {\n          topic: s,\n          event: t,\n          chainId: i\n        } = e;\n        yield _this.sendRequest({\n          topic: s,\n          method: \"wc_sessionEvent\",\n          params: {\n            event: t,\n            chainId: i\n          }\n        });\n      });\n      return function (_x13) {\n        return _ref19.apply(this, arguments);\n      };\n    }(), this.disconnect = /*#__PURE__*/function () {\n      var _ref20 = _asyncToGenerator(function* (e) {\n        yield _this.isInitialized(), yield _this.isValidDisconnect(e);\n        const {\n          topic: s\n        } = e;\n        _this.client.session.keys.includes(s) ? (yield _this.sendRequest({\n          topic: s,\n          method: \"wc_sessionDelete\",\n          params: N(\"USER_DISCONNECTED\"),\n          throwOnFailedPublish: !0\n        }), yield _this.deleteSession(s)) : yield _this.client.core.pairing.disconnect({\n          topic: s\n        });\n      });\n      return function (_x14) {\n        return _ref20.apply(this, arguments);\n      };\n    }(), this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => Oe(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = /*#__PURE__*/function () {\n      var _ref21 = _asyncToGenerator(function* (e) {\n        if (e.pairingTopic) try {\n          const s = _this.client.core.pairing.pairings.get(e.pairingTopic),\n            t = _this.client.core.pairing.pairings.getAll().filter(i => {\n              var n, o;\n              return ((n = i.peerMetadata) == null ? void 0 : n.url) && ((o = i.peerMetadata) == null ? void 0 : o.url) === e.peer.metadata.url && i.topic && i.topic !== s.topic;\n            });\n          if (t.length === 0) return;\n          _this.client.logger.info(\"Cleaning up \".concat(t.length, \" duplicate pairing(s)\")), yield Promise.all(t.map(i => _this.client.core.pairing.disconnect({\n            topic: i.topic\n          }))), _this.client.logger.info(\"Duplicate pairings clean up finished\");\n        } catch (s) {\n          _this.client.logger.error(s);\n        }\n      });\n      return function (_x15) {\n        return _ref21.apply(this, arguments);\n      };\n    }(), this.deleteSession = /*#__PURE__*/function () {\n      var _ref22 = _asyncToGenerator(function* (e, s) {\n        const {\n          self: t\n        } = _this.client.session.get(e);\n        yield _this.client.core.relayer.unsubscribe(e), _this.client.session.delete(e, N(\"USER_DISCONNECTED\")), _this.client.core.crypto.keychain.has(t.publicKey) && (yield _this.client.core.crypto.deleteKeyPair(t.publicKey)), _this.client.core.crypto.keychain.has(e) && (yield _this.client.core.crypto.deleteSymKey(e)), s || _this.client.core.expirer.del(e), _this.client.core.storage.removeItem(W).catch(i => _this.client.logger.warn(i));\n      });\n      return function (_x16, _x17) {\n        return _ref22.apply(this, arguments);\n      };\n    }(), this.deleteProposal = /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator(function* (e, s) {\n        yield Promise.all([_this.client.proposal.delete(e, N(\"USER_DISCONNECTED\")), s ? Promise.resolve() : _this.client.core.expirer.del(e)]);\n      });\n      return function (_x18, _x19) {\n        return _ref23.apply(this, arguments);\n      };\n    }(), this.deletePendingSessionRequest = /*#__PURE__*/function () {\n      var _ref24 = _asyncToGenerator(function* (e, s) {\n        let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        yield Promise.all([_this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : _this.client.core.expirer.del(e)]), _this.sessionRequestQueue.queue = _this.sessionRequestQueue.queue.filter(i => i.id !== e), t && (_this.sessionRequestQueue.state = I.idle);\n      });\n      return function (_x20, _x21) {\n        return _ref24.apply(this, arguments);\n      };\n    }(), this.setExpiry = /*#__PURE__*/function () {\n      var _ref25 = _asyncToGenerator(function* (e, s) {\n        _this.client.session.keys.includes(e) && (yield _this.client.session.update(e, {\n          expiry: s\n        })), _this.client.core.expirer.set(e, s);\n      });\n      return function (_x22, _x23) {\n        return _ref25.apply(this, arguments);\n      };\n    }(), this.setProposal = /*#__PURE__*/function () {\n      var _ref26 = _asyncToGenerator(function* (e, s) {\n        yield _this.client.proposal.set(e, s), _this.client.core.expirer.set(e, s.expiry);\n      });\n      return function (_x24, _x25) {\n        return _ref26.apply(this, arguments);\n      };\n    }(), this.setPendingSessionRequest = /*#__PURE__*/function () {\n      var _ref27 = _asyncToGenerator(function* (e) {\n        const s = V.wc_sessionRequest.req.ttl,\n          {\n            id: t,\n            topic: i,\n            params: n,\n            verifyContext: o\n          } = e;\n        yield _this.client.pendingRequest.set(t, {\n          id: t,\n          topic: i,\n          params: n,\n          verifyContext: o\n        }), s && _this.client.core.expirer.set(t, _(s));\n      });\n      return function (_x26) {\n        return _ref27.apply(this, arguments);\n      };\n    }(), this.sendRequest = /*#__PURE__*/function () {\n      var _ref28 = _asyncToGenerator(function* (e) {\n        const {\n            topic: s,\n            method: t,\n            params: i,\n            expiry: n,\n            relayRpcId: o,\n            clientRpcId: a,\n            throwOnFailedPublish: c\n          } = e,\n          p = J(t, i, a);\n        if (Ve() && pe.includes(t)) {\n          const R = Y(JSON.stringify(p));\n          _this.client.core.verify.register({\n            attestationId: R\n          });\n        }\n        const d = yield _this.client.core.crypto.encode(s, p),\n          h = V[t].req;\n        return n && (h.ttl = n), o && (h.id = o), _this.client.core.history.set(s, p), c ? (h.internal = b(g({}, h.internal), {\n          throwOnFailedPublish: !0\n        }), yield _this.client.core.relayer.publish(s, d, h)) : _this.client.core.relayer.publish(s, d, h).catch(R => _this.client.logger.error(R)), p.id;\n      });\n      return function (_x27) {\n        return _ref28.apply(this, arguments);\n      };\n    }(), this.sendResult = /*#__PURE__*/function () {\n      var _ref29 = _asyncToGenerator(function* (e) {\n        const {\n            id: s,\n            topic: t,\n            result: i,\n            throwOnFailedPublish: n\n          } = e,\n          o = Fe(s, i),\n          a = yield _this.client.core.crypto.encode(t, o),\n          c = yield _this.client.core.history.get(t, s),\n          p = V[c.request.method].res;\n        n ? (p.internal = b(g({}, p.internal), {\n          throwOnFailedPublish: !0\n        }), yield _this.client.core.relayer.publish(t, a, p)) : _this.client.core.relayer.publish(t, a, p).catch(d => _this.client.logger.error(d)), yield _this.client.core.history.resolve(o);\n      });\n      return function (_x28) {\n        return _ref29.apply(this, arguments);\n      };\n    }(), this.sendError = /*#__PURE__*/function () {\n      var _ref30 = _asyncToGenerator(function* (e, s, t) {\n        const i = He(e, t),\n          n = yield _this.client.core.crypto.encode(s, i),\n          o = yield _this.client.core.history.get(s, e),\n          a = V[o.request.method].res;\n        _this.client.core.relayer.publish(s, n, a), yield _this.client.core.history.resolve(i);\n      });\n      return function (_x29, _x30, _x31) {\n        return _ref30.apply(this, arguments);\n      };\n    }(), this.cleanup = /*#__PURE__*/_asyncToGenerator(function* () {\n      const e = [],\n        s = [];\n      _this.client.session.getAll().forEach(t => {\n        P(t.expiry) && e.push(t.topic);\n      }), _this.client.proposal.getAll().forEach(t => {\n        P(t.expiry) && s.push(t.id);\n      }), yield Promise.all([...e.map(t => _this.deleteSession(t)), ...s.map(t => _this.deleteProposal(t))]);\n    }), this.onRelayEventRequest = /*#__PURE__*/function () {\n      var _ref32 = _asyncToGenerator(function* (e) {\n        _this.requestQueue.queue.push(e), yield _this.processRequestsQueue();\n      });\n      return function (_x32) {\n        return _ref32.apply(this, arguments);\n      };\n    }(), this.processRequestsQueue = /*#__PURE__*/_asyncToGenerator(function* () {\n      if (_this.requestQueue.state === I.active) {\n        _this.client.logger.info(\"Request queue already active, skipping...\");\n        return;\n      }\n      for (_this.client.logger.info(\"Request queue starting with \".concat(_this.requestQueue.queue.length, \" requests\")); _this.requestQueue.queue.length > 0;) {\n        _this.requestQueue.state = I.active;\n        const e = _this.requestQueue.queue.shift();\n        if (e) try {\n          _this.processRequest(e), yield new Promise(s => setTimeout(s, 300));\n        } catch (s) {\n          _this.client.logger.warn(s);\n        }\n      }\n      _this.requestQueue.state = I.idle;\n    }), this.processRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(\"Unsupported request method \".concat(i));\n      }\n    }, this.onRelayEventResponse = /*#__PURE__*/function () {\n      var _ref34 = _asyncToGenerator(function* (e) {\n        const {\n            topic: s,\n            payload: t\n          } = e,\n          i = (yield _this.client.core.history.get(s, t.id)).request.method;\n        switch (i) {\n          case \"wc_sessionPropose\":\n            return _this.onSessionProposeResponse(s, t);\n          case \"wc_sessionSettle\":\n            return _this.onSessionSettleResponse(s, t);\n          case \"wc_sessionUpdate\":\n            return _this.onSessionUpdateResponse(s, t);\n          case \"wc_sessionExtend\":\n            return _this.onSessionExtendResponse(s, t);\n          case \"wc_sessionPing\":\n            return _this.onSessionPingResponse(s, t);\n          case \"wc_sessionRequest\":\n            return _this.onSessionRequestResponse(s, t);\n          default:\n            return _this.client.logger.info(\"Unsupported response method \".concat(i));\n        }\n      });\n      return function (_x33) {\n        return _ref34.apply(this, arguments);\n      };\n    }(), this.onRelayEventUnknownPayload = e => {\n      const {\n          topic: s\n        } = e,\n        {\n          message: t\n        } = l(\"MISSING_OR_INVALID\", \"Decoded payload on topic \".concat(s, \" is not identifiable as a JSON-RPC request or a response.\"));\n      throw new Error(t);\n    }, this.onSessionProposeRequest = /*#__PURE__*/function () {\n      var _ref35 = _asyncToGenerator(function* (e, s) {\n        const {\n          params: t,\n          id: i\n        } = s;\n        try {\n          _this.isValidConnect(g({}, s.params));\n          const n = _(y),\n            o = g({\n              id: i,\n              pairingTopic: e,\n              expiry: n\n            }, t);\n          yield _this.setProposal(i, o);\n          const a = Y(JSON.stringify(s)),\n            c = yield _this.getVerifyContext(a, o.proposer.metadata);\n          _this.client.events.emit(\"session_proposal\", {\n            id: i,\n            params: o,\n            verifyContext: c\n          });\n        } catch (n) {\n          yield _this.sendError(i, e, n), _this.client.logger.error(n);\n        }\n      });\n      return function (_x34, _x35) {\n        return _ref35.apply(this, arguments);\n      };\n    }(), this.onSessionProposeResponse = /*#__PURE__*/function () {\n      var _ref36 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t\n        } = s;\n        if (q(s)) {\n          const {\n            result: i\n          } = s;\n          _this.client.logger.trace({\n            type: \"method\",\n            method: \"onSessionProposeResponse\",\n            result: i\n          });\n          const n = _this.client.proposal.get(t);\n          _this.client.logger.trace({\n            type: \"method\",\n            method: \"onSessionProposeResponse\",\n            proposal: n\n          });\n          const o = n.proposer.publicKey;\n          _this.client.logger.trace({\n            type: \"method\",\n            method: \"onSessionProposeResponse\",\n            selfPublicKey: o\n          });\n          const a = i.responderPublicKey;\n          _this.client.logger.trace({\n            type: \"method\",\n            method: \"onSessionProposeResponse\",\n            peerPublicKey: a\n          });\n          const c = yield _this.client.core.crypto.generateSharedKey(o, a);\n          _this.client.logger.trace({\n            type: \"method\",\n            method: \"onSessionProposeResponse\",\n            sessionTopic: c\n          });\n          const p = yield _this.client.core.relayer.subscribe(c);\n          _this.client.logger.trace({\n            type: \"method\",\n            method: \"onSessionProposeResponse\",\n            subscriptionId: p\n          }), yield _this.client.core.pairing.activate({\n            topic: e\n          });\n        } else f(s) && (yield _this.client.proposal.delete(t, N(\"USER_DISCONNECTED\")), _this.events.emit(u(\"session_connect\"), {\n          error: s.error\n        }));\n      });\n      return function (_x36, _x37) {\n        return _ref36.apply(this, arguments);\n      };\n    }(), this.onSessionSettleRequest = /*#__PURE__*/function () {\n      var _ref37 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t,\n          params: i\n        } = s;\n        try {\n          _this.isValidSessionSettleRequest(i);\n          const {\n              relay: n,\n              controller: o,\n              expiry: a,\n              namespaces: c,\n              requiredNamespaces: p,\n              optionalNamespaces: d,\n              sessionProperties: h,\n              pairingTopic: R\n            } = s.params,\n            w = g({\n              topic: e,\n              relay: n,\n              expiry: a,\n              namespaces: c,\n              acknowledged: !0,\n              pairingTopic: R,\n              requiredNamespaces: p,\n              optionalNamespaces: d,\n              controller: o.publicKey,\n              self: {\n                publicKey: \"\",\n                metadata: _this.client.metadata\n              },\n              peer: {\n                publicKey: o.publicKey,\n                metadata: o.metadata\n              }\n            }, h && {\n              sessionProperties: h\n            });\n          yield _this.sendResult({\n            id: s.id,\n            topic: e,\n            result: !0\n          }), _this.events.emit(u(\"session_connect\"), {\n            session: w\n          }), _this.cleanupDuplicatePairings(w);\n        } catch (n) {\n          yield _this.sendError(t, e, n), _this.client.logger.error(n);\n        }\n      });\n      return function (_x38, _x39) {\n        return _ref37.apply(this, arguments);\n      };\n    }(), this.onSessionSettleResponse = /*#__PURE__*/function () {\n      var _ref38 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t\n        } = s;\n        q(s) ? (yield _this.client.session.update(e, {\n          acknowledged: !0\n        }), _this.events.emit(u(\"session_approve\", t), {})) : f(s) && (yield _this.client.session.delete(e, N(\"USER_DISCONNECTED\")), _this.events.emit(u(\"session_approve\", t), {\n          error: s.error\n        }));\n      });\n      return function (_x40, _x41) {\n        return _ref38.apply(this, arguments);\n      };\n    }(), this.onSessionUpdateRequest = /*#__PURE__*/function () {\n      var _ref39 = _asyncToGenerator(function* (e, s) {\n        const {\n          params: t,\n          id: i\n        } = s;\n        try {\n          const n = \"\".concat(e, \"_session_update\"),\n            o = $.get(n);\n          if (o && _this.isRequestOutOfSync(o, i)) {\n            _this.client.logger.info(\"Discarding out of sync request - \".concat(i));\n            return;\n          }\n          _this.isValidUpdate(g({\n            topic: e\n          }, t)), yield _this.client.session.update(e, {\n            namespaces: t.namespaces\n          }), yield _this.sendResult({\n            id: i,\n            topic: e,\n            result: !0\n          }), _this.client.events.emit(\"session_update\", {\n            id: i,\n            topic: e,\n            params: t\n          }), $.set(n, i);\n        } catch (n) {\n          yield _this.sendError(i, e, n), _this.client.logger.error(n);\n        }\n      });\n      return function (_x42, _x43) {\n        return _ref39.apply(this, arguments);\n      };\n    }(), this.isRequestOutOfSync = (e, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e.toString().slice(0, -3)), this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? this.events.emit(u(\"session_update\", t), {}) : f(s) && this.events.emit(u(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = /*#__PURE__*/function () {\n      var _ref40 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t\n        } = s;\n        try {\n          _this.isValidExtend({\n            topic: e\n          }), yield _this.setExpiry(e, _(A)), yield _this.sendResult({\n            id: t,\n            topic: e,\n            result: !0\n          }), _this.client.events.emit(\"session_extend\", {\n            id: t,\n            topic: e\n          });\n        } catch (i) {\n          yield _this.sendError(t, e, i), _this.client.logger.error(i);\n        }\n      });\n      return function (_x44, _x45) {\n        return _ref40.apply(this, arguments);\n      };\n    }(), this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? this.events.emit(u(\"session_extend\", t), {}) : f(s) && this.events.emit(u(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = /*#__PURE__*/function () {\n      var _ref41 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t\n        } = s;\n        try {\n          _this.isValidPing({\n            topic: e\n          }), yield _this.sendResult({\n            id: t,\n            topic: e,\n            result: !0\n          }), _this.client.events.emit(\"session_ping\", {\n            id: t,\n            topic: e\n          });\n        } catch (i) {\n          yield _this.sendError(t, e, i), _this.client.logger.error(i);\n        }\n      });\n      return function (_x46, _x47) {\n        return _ref41.apply(this, arguments);\n      };\n    }(), this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        q(s) ? this.events.emit(u(\"session_ping\", t), {}) : f(s) && this.events.emit(u(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = /*#__PURE__*/function () {\n      var _ref42 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t\n        } = s;\n        try {\n          _this.isValidDisconnect({\n            topic: e,\n            reason: s.params\n          }), yield Promise.all([new Promise(i => {\n            _this.client.core.relayer.once(Z.publish, /*#__PURE__*/_asyncToGenerator(function* () {\n              i(yield _this.deleteSession(e));\n            }));\n          }), _this.sendResult({\n            id: t,\n            topic: e,\n            result: !0\n          })]), _this.client.events.emit(\"session_delete\", {\n            id: t,\n            topic: e\n          });\n        } catch (i) {\n          _this.client.logger.error(i);\n        }\n      });\n      return function (_x48, _x49) {\n        return _ref42.apply(this, arguments);\n      };\n    }(), this.onSessionRequest = /*#__PURE__*/function () {\n      var _ref44 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t,\n          params: i\n        } = s;\n        try {\n          _this.isValidRequest(g({\n            topic: e\n          }, i));\n          const n = Y(JSON.stringify(J(\"wc_sessionRequest\", i, t))),\n            o = _this.client.session.get(e),\n            a = yield _this.getVerifyContext(n, o.peer.metadata),\n            c = {\n              id: t,\n              topic: e,\n              params: i,\n              verifyContext: a\n            };\n          yield _this.setPendingSessionRequest(c), _this.addSessionRequestToSessionRequestQueue(c), _this.processSessionRequestQueue();\n        } catch (n) {\n          yield _this.sendError(t, e, n), _this.client.logger.error(n);\n        }\n      });\n      return function (_x50, _x51) {\n        return _ref44.apply(this, arguments);\n      };\n    }(), this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      q(s) ? this.events.emit(u(\"session_request\", t), {\n        result: s.result\n      }) : f(s) && this.events.emit(u(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = /*#__PURE__*/function () {\n      var _ref45 = _asyncToGenerator(function* (e, s) {\n        const {\n          id: t,\n          params: i\n        } = s;\n        try {\n          const n = \"\".concat(e, \"_session_event_\").concat(i.event.name),\n            o = $.get(n);\n          if (o && _this.isRequestOutOfSync(o, t)) {\n            _this.client.logger.info(\"Discarding out of sync request - \".concat(t));\n            return;\n          }\n          _this.isValidEmit(g({\n            topic: e\n          }, i)), _this.client.events.emit(\"session_event\", {\n            id: t,\n            topic: e,\n            params: i\n          }), $.set(n, t);\n        } catch (n) {\n          yield _this.sendError(t, e, n), _this.client.logger.error(n);\n        }\n      });\n      return function (_x52, _x53) {\n        return _ref45.apply(this, arguments);\n      };\n    }(), this.addSessionRequestToSessionRequestQueue = e => {\n      this.sessionRequestQueue.queue.push(e);\n    }, this.cleanupAfterResponse = e => {\n      this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      }), setTimeout(() => {\n        this.sessionRequestQueue.state = I.idle, this.processSessionRequestQueue();\n      }, re(this.requestQueueDelay));\n    }, this.processSessionRequestQueue = () => {\n      if (this.sessionRequestQueue.state === I.active) {\n        this.client.logger.info(\"session request queue is already active.\");\n        return;\n      }\n      const e = this.sessionRequestQueue.queue[0];\n      if (!e) {\n        this.client.logger.info(\"session request queue is empty.\");\n        return;\n      }\n      try {\n        this.sessionRequestQueue.state = I.active, this.client.events.emit(\"session_request\", e);\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.onPairingCreated = e => {\n      if (e.active) return;\n      const s = this.client.proposal.getAll().find(t => t.pairingTopic === e.topic);\n      s && this.onSessionProposeRequest(e.topic, J(\"wc_sessionPropose\", {\n        requiredNamespaces: s.requiredNamespaces,\n        optionalNamespaces: s.optionalNamespaces,\n        relays: s.relays,\n        proposer: s.proposer\n      }, s.id));\n    }, this.isValidConnect = /*#__PURE__*/function () {\n      var _ref46 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"connect() params: \".concat(JSON.stringify(e)));\n          throw new Error(a);\n        }\n        const {\n          pairingTopic: s,\n          requiredNamespaces: t,\n          optionalNamespaces: i,\n          sessionProperties: n,\n          relays: o\n        } = e;\n        if (D(s) || (yield _this.isValidPairingTopic(s)), !Te(o, !0)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"connect() relays: \".concat(o));\n          throw new Error(a);\n        }\n        !D(t) && z(t) !== 0 && _this.validateNamespaces(t, \"requiredNamespaces\"), !D(i) && z(i) !== 0 && _this.validateNamespaces(i, \"optionalNamespaces\"), D(n) || _this.validateSessionProps(n, \"sessionProperties\");\n      });\n      return function (_x54) {\n        return _ref46.apply(this, arguments);\n      };\n    }(), this.validateNamespaces = (e, s) => {\n      const t = xe(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = /*#__PURE__*/function () {\n      var _ref47 = _asyncToGenerator(function* (e) {\n        if (!E(e)) throw new Error(l(\"MISSING_OR_INVALID\", \"approve() params: \".concat(e)).message);\n        const {\n          id: s,\n          namespaces: t,\n          relayProtocol: i,\n          sessionProperties: n\n        } = e;\n        yield _this.isValidProposalId(s);\n        const o = _this.client.proposal.get(s),\n          a = j(t, \"approve()\");\n        if (a) throw new Error(a.message);\n        const c = ee(o.requiredNamespaces, t, \"approve()\");\n        if (c) throw new Error(c.message);\n        if (!C(i, !0)) {\n          const {\n            message: p\n          } = l(\"MISSING_OR_INVALID\", \"approve() relayProtocol: \".concat(i));\n          throw new Error(p);\n        }\n        D(n) || _this.validateSessionProps(n, \"sessionProperties\");\n      });\n      return function (_x55) {\n        return _ref47.apply(this, arguments);\n      };\n    }(), this.isValidReject = /*#__PURE__*/function () {\n      var _ref48 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", \"reject() params: \".concat(e));\n          throw new Error(i);\n        }\n        const {\n          id: s,\n          reason: t\n        } = e;\n        if (yield _this.isValidProposalId(s), !De(t)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", \"reject() reason: \".concat(JSON.stringify(t)));\n          throw new Error(i);\n        }\n      });\n      return function (_x56) {\n        return _ref48.apply(this, arguments);\n      };\n    }(), this.isValidSessionSettleRequest = e => {\n      if (!E(e)) {\n        const {\n          message: c\n        } = l(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() params: \".concat(e));\n        throw new Error(c);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: n\n      } = e;\n      if (!Ce(s)) {\n        const {\n          message: c\n        } = l(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(c);\n      }\n      const o = Ae(t, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = j(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (P(n)) {\n        const {\n          message: c\n        } = l(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(c);\n      }\n    }, this.isValidUpdate = /*#__PURE__*/function () {\n      var _ref49 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"update() params: \".concat(e));\n          throw new Error(a);\n        }\n        const {\n          topic: s,\n          namespaces: t\n        } = e;\n        yield _this.isValidSessionTopic(s);\n        const i = _this.client.session.get(s),\n          n = j(t, \"update()\");\n        if (n) throw new Error(n.message);\n        const o = ee(i.requiredNamespaces, t, \"update()\");\n        if (o) throw new Error(o.message);\n      });\n      return function (_x57) {\n        return _ref49.apply(this, arguments);\n      };\n    }(), this.isValidExtend = /*#__PURE__*/function () {\n      var _ref50 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: t\n          } = l(\"MISSING_OR_INVALID\", \"extend() params: \".concat(e));\n          throw new Error(t);\n        }\n        const {\n          topic: s\n        } = e;\n        yield _this.isValidSessionTopic(s);\n      });\n      return function (_x58) {\n        return _ref50.apply(this, arguments);\n      };\n    }(), this.isValidRequest = /*#__PURE__*/function () {\n      var _ref51 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"request() params: \".concat(e));\n          throw new Error(a);\n        }\n        const {\n          topic: s,\n          request: t,\n          chainId: i,\n          expiry: n\n        } = e;\n        yield _this.isValidSessionTopic(s);\n        const {\n          namespaces: o\n        } = _this.client.session.get(s);\n        if (!se(o, i)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"request() chainId: \".concat(i));\n          throw new Error(a);\n        }\n        if (!be(t)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"request() \".concat(JSON.stringify(t)));\n          throw new Error(a);\n        }\n        if (!Le(o, i, t.method)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"request() method: \".concat(t.method));\n          throw new Error(a);\n        }\n        if (n && !$e(n, U)) {\n          const {\n            message: a\n          } = l(\"MISSING_OR_INVALID\", \"request() expiry: \".concat(n, \". Expiry must be a number (in seconds) between \").concat(U.min, \" and \").concat(U.max));\n          throw new Error(a);\n        }\n      });\n      return function (_x59) {\n        return _ref51.apply(this, arguments);\n      };\n    }(), this.isValidRespond = /*#__PURE__*/function () {\n      var _ref52 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", \"respond() params: \".concat(e));\n          throw new Error(i);\n        }\n        const {\n          topic: s,\n          response: t\n        } = e;\n        if (yield _this.isValidSessionTopic(s), !Ge(t)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", \"respond() response: \".concat(JSON.stringify(t)));\n          throw new Error(i);\n        }\n      });\n      return function (_x60) {\n        return _ref52.apply(this, arguments);\n      };\n    }(), this.isValidPing = /*#__PURE__*/function () {\n      var _ref53 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: t\n          } = l(\"MISSING_OR_INVALID\", \"ping() params: \".concat(e));\n          throw new Error(t);\n        }\n        const {\n          topic: s\n        } = e;\n        yield _this.isValidSessionOrPairingTopic(s);\n      });\n      return function (_x61) {\n        return _ref53.apply(this, arguments);\n      };\n    }(), this.isValidEmit = /*#__PURE__*/function () {\n      var _ref54 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: o\n          } = l(\"MISSING_OR_INVALID\", \"emit() params: \".concat(e));\n          throw new Error(o);\n        }\n        const {\n          topic: s,\n          event: t,\n          chainId: i\n        } = e;\n        yield _this.isValidSessionTopic(s);\n        const {\n          namespaces: n\n        } = _this.client.session.get(s);\n        if (!se(n, i)) {\n          const {\n            message: o\n          } = l(\"MISSING_OR_INVALID\", \"emit() chainId: \".concat(i));\n          throw new Error(o);\n        }\n        if (!Me(t)) {\n          const {\n            message: o\n          } = l(\"MISSING_OR_INVALID\", \"emit() event: \".concat(JSON.stringify(t)));\n          throw new Error(o);\n        }\n        if (!Ue(n, i, t.name)) {\n          const {\n            message: o\n          } = l(\"MISSING_OR_INVALID\", \"emit() event: \".concat(JSON.stringify(t)));\n          throw new Error(o);\n        }\n      });\n      return function (_x62) {\n        return _ref54.apply(this, arguments);\n      };\n    }(), this.isValidDisconnect = /*#__PURE__*/function () {\n      var _ref55 = _asyncToGenerator(function* (e) {\n        if (!E(e)) {\n          const {\n            message: t\n          } = l(\"MISSING_OR_INVALID\", \"disconnect() params: \".concat(e));\n          throw new Error(t);\n        }\n        const {\n          topic: s\n        } = e;\n        yield _this.isValidSessionOrPairingTopic(s);\n      });\n      return function (_x63) {\n        return _ref55.apply(this, arguments);\n      };\n    }(), this.getVerifyContext = /*#__PURE__*/function () {\n      var _ref56 = _asyncToGenerator(function* (e, s) {\n        const t = {\n          verified: {\n            verifyUrl: s.verifyUrl || me,\n            validation: \"UNKNOWN\",\n            origin: s.url || \"\"\n          }\n        };\n        try {\n          const i = yield _this.client.core.verify.resolve({\n            attestationId: e,\n            verifyUrl: s.verifyUrl\n          });\n          i && (t.verified.origin = i.origin, t.verified.isScam = i.isScam, t.verified.validation = i.origin === new URL(s.url).origin ? \"VALID\" : \"INVALID\");\n        } catch (i) {\n          _this.client.logger.info(i);\n        }\n        return _this.client.logger.info(\"Verify context: \".concat(JSON.stringify(t))), t;\n      });\n      return function (_x64, _x65) {\n        return _ref56.apply(this, arguments);\n      };\n    }(), this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!C(t, !1)) {\n          const {\n            message: i\n          } = l(\"MISSING_OR_INVALID\", \"\".concat(s, \" must be in Record<string, string> format. Received: \").concat(JSON.stringify(t)));\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.initialized) {\n        const {\n          message: r\n        } = l(\"NOT_INITIALIZED\", _this2.name);\n        throw new Error(r);\n      }\n      yield _this2.client.core.relayer.confirmOnlineStateOrThrow();\n    })();\n  }\n  registerRelayerEvents() {\n    var _this3 = this;\n    this.client.core.relayer.on(Z.message, /*#__PURE__*/function () {\n      var _ref57 = _asyncToGenerator(function* (r) {\n        const {\n          topic: e,\n          message: s\n        } = r;\n        if (_this3.ignoredPayloadTypes.includes(_this3.client.core.crypto.getPayloadType(s))) return;\n        const t = yield _this3.client.core.crypto.decode(e, s);\n        try {\n          We(t) ? (_this3.client.core.history.set(e, t), _this3.onRelayEventRequest({\n            topic: e,\n            payload: t\n          })) : Be(t) ? (yield _this3.client.core.history.resolve(t), yield _this3.onRelayEventResponse({\n            topic: e,\n            payload: t\n          }), _this3.client.core.history.delete(e, t.id)) : _this3.onRelayEventUnknownPayload({\n            topic: e,\n            payload: t\n          });\n        } catch (i) {\n          _this3.client.logger.error(i);\n        }\n      });\n      return function (_x66) {\n        return _ref57.apply(this, arguments);\n      };\n    }());\n  }\n  registerExpirerEvents() {\n    var _this4 = this;\n    this.client.core.expirer.on(we.expired, /*#__PURE__*/function () {\n      var _ref58 = _asyncToGenerator(function* (r) {\n        const {\n          topic: e,\n          id: s\n        } = Qe(r.target);\n        if (s && _this4.client.pendingRequest.keys.includes(s)) return yield _this4.deletePendingSessionRequest(s, l(\"EXPIRED\"), !0);\n        e ? _this4.client.session.keys.includes(e) && (yield _this4.deleteSession(e, !0), _this4.client.events.emit(\"session_expire\", {\n          topic: e\n        })) : s && (yield _this4.deleteProposal(s, !0), _this4.client.events.emit(\"proposal_expire\", {\n          id: s\n        }));\n      });\n      return function (_x67) {\n        return _ref58.apply(this, arguments);\n      };\n    }());\n  }\n  registerPairingEvents() {\n    this.client.core.pairing.events.on(ye.create, r => this.onPairingCreated(r));\n  }\n  isValidPairingTopic(r) {\n    if (!C(r, !1)) {\n      const {\n        message: e\n      } = l(\"MISSING_OR_INVALID\", \"pairing topic should be a string: \".concat(r));\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(r)) {\n      const {\n        message: e\n      } = l(\"NO_MATCHING_KEY\", \"pairing topic doesn't exist: \".concat(r));\n      throw new Error(e);\n    }\n    if (P(this.client.core.pairing.pairings.get(r).expiry)) {\n      const {\n        message: e\n      } = l(\"EXPIRED\", \"pairing topic: \".concat(r));\n      throw new Error(e);\n    }\n  }\n  isValidSessionTopic(r) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!C(r, !1)) {\n        const {\n          message: e\n        } = l(\"MISSING_OR_INVALID\", \"session topic should be a string: \".concat(r));\n        throw new Error(e);\n      }\n      if (!_this5.client.session.keys.includes(r)) {\n        const {\n          message: e\n        } = l(\"NO_MATCHING_KEY\", \"session topic doesn't exist: \".concat(r));\n        throw new Error(e);\n      }\n      if (P(_this5.client.session.get(r).expiry)) {\n        yield _this5.deleteSession(r);\n        const {\n          message: e\n        } = l(\"EXPIRED\", \"session topic: \".concat(r));\n        throw new Error(e);\n      }\n    })();\n  }\n  isValidSessionOrPairingTopic(r) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.client.session.keys.includes(r)) yield _this6.isValidSessionTopic(r);else if (_this6.client.core.pairing.pairings.keys.includes(r)) _this6.isValidPairingTopic(r);else if (C(r, !1)) {\n        const {\n          message: e\n        } = l(\"NO_MATCHING_KEY\", \"session or pairing topic doesn't exist: \".concat(r));\n        throw new Error(e);\n      } else {\n        const {\n          message: e\n        } = l(\"MISSING_OR_INVALID\", \"session or pairing topic should be a string: \".concat(r));\n        throw new Error(e);\n      }\n    })();\n  }\n  isValidProposalId(r) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!Ke(r)) {\n        const {\n          message: e\n        } = l(\"MISSING_OR_INVALID\", \"proposal id should be a number: \".concat(r));\n        throw new Error(e);\n      }\n      if (!_this7.client.proposal.keys.includes(r)) {\n        const {\n          message: e\n        } = l(\"NO_MATCHING_KEY\", \"proposal id doesn't exist: \".concat(r));\n        throw new Error(e);\n      }\n      if (P(_this7.client.proposal.get(r).expiry)) {\n        yield _this7.deleteProposal(r);\n        const {\n          message: e\n        } = l(\"EXPIRED\", \"proposal id: \".concat(r));\n        throw new Error(e);\n      }\n    })();\n  }\n}\nclass hs extends k {\n  constructor(r, e) {\n    super(r, e, ne, G), this.core = r, this.logger = e;\n  }\n}\nclass ds extends k {\n  constructor(r, e) {\n    super(r, e, ae, G), this.core = r, this.logger = e;\n  }\n}\nclass us extends k {\n  constructor(r, e) {\n    super(r, e, le, G, s => s.id), this.core = r, this.logger = e;\n  }\n}\nclass Q extends qe {\n  constructor(r) {\n    var _this8;\n    (super(r), _this8 = this), this.protocol = X, this.version = F, this.name = M.name, this.events = new Ye(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = /*#__PURE__*/function () {\n      var _ref59 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.connect(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x68) {\n        return _ref59.apply(this, arguments);\n      };\n    }(), this.pair = /*#__PURE__*/function () {\n      var _ref60 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.pair(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x69) {\n        return _ref60.apply(this, arguments);\n      };\n    }(), this.approve = /*#__PURE__*/function () {\n      var _ref61 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.approve(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x70) {\n        return _ref61.apply(this, arguments);\n      };\n    }(), this.reject = /*#__PURE__*/function () {\n      var _ref62 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.reject(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x71) {\n        return _ref62.apply(this, arguments);\n      };\n    }(), this.update = /*#__PURE__*/function () {\n      var _ref63 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.update(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x72) {\n        return _ref63.apply(this, arguments);\n      };\n    }(), this.extend = /*#__PURE__*/function () {\n      var _ref64 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.extend(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x73) {\n        return _ref64.apply(this, arguments);\n      };\n    }(), this.request = /*#__PURE__*/function () {\n      var _ref65 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.request(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x74) {\n        return _ref65.apply(this, arguments);\n      };\n    }(), this.respond = /*#__PURE__*/function () {\n      var _ref66 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.respond(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x75) {\n        return _ref66.apply(this, arguments);\n      };\n    }(), this.ping = /*#__PURE__*/function () {\n      var _ref67 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.ping(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x76) {\n        return _ref67.apply(this, arguments);\n      };\n    }(), this.emit = /*#__PURE__*/function () {\n      var _ref68 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.emit(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x77) {\n        return _ref68.apply(this, arguments);\n      };\n    }(), this.disconnect = /*#__PURE__*/function () {\n      var _ref69 = _asyncToGenerator(function* (s) {\n        try {\n          return yield _this8.engine.disconnect(s);\n        } catch (t) {\n          throw _this8.logger.error(t.message), t;\n        }\n      });\n      return function (_x78) {\n        return _ref69.apply(this, arguments);\n      };\n    }(), this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = (r === null || r === void 0 ? void 0 : r.name) || M.name, this.metadata = (r === null || r === void 0 ? void 0 : r.metadata) || ke();\n    const e = typeof (r === null || r === void 0 ? void 0 : r.logger) < \"u\" && typeof (r === null || r === void 0 ? void 0 : r.logger) != \"string\" ? r.logger : Ee(Re({\n      level: (r === null || r === void 0 ? void 0 : r.logger) || M.logger\n    }));\n    this.core = (r === null || r === void 0 ? void 0 : r.core) || new Se(r), this.logger = Ie(e, this.name), this.session = new ds(this.core, this.logger), this.proposal = new hs(this.core, this.logger), this.pendingRequest = new us(this.core, this.logger), this.engine = new ps(this);\n  }\n  static init(r) {\n    return _asyncToGenerator(function* () {\n      const e = new Q(r);\n      return yield e.initialize(), e;\n    })();\n  }\n  get context() {\n    return _e(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  initialize() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      _this9.logger.trace(\"Initialized\");\n      try {\n        yield _this9.core.start(), yield _this9.session.init(), yield _this9.proposal.init(), yield _this9.pendingRequest.init(), yield _this9.engine.init(), _this9.core.verify.init({\n          verifyUrl: _this9.metadata.verifyUrl\n        }), _this9.logger.info(\"SignClient Initialization Success\");\n      } catch (r) {\n        throw _this9.logger.info(\"SignClient Initialization Failure\"), _this9.logger.error(r.message), r;\n      }\n    })();\n  }\n}\nconst gs = Q;\nexport { ce as ENGINE_CONTEXT, I as ENGINE_QUEUE_STATES, V as ENGINE_RPC_OPTS, ts as HISTORY_CONTEXT, ss as HISTORY_EVENTS, is as HISTORY_STORAGE_VERSION, pe as METHODS_TO_VERIFY, ne as PROPOSAL_CONTEXT, rs as PROPOSAL_EXPIRY, oe as PROPOSAL_EXPIRY_MESSAGE, le as REQUEST_CONTEXT, ae as SESSION_CONTEXT, A as SESSION_EXPIRY, U as SESSION_REQUEST_EXPIRY_BOUNDARIES, H as SIGN_CLIENT_CONTEXT, M as SIGN_CLIENT_DEFAULT, Ze as SIGN_CLIENT_EVENTS, X as SIGN_CLIENT_PROTOCOL, es as SIGN_CLIENT_STORAGE_OPTIONS, G as SIGN_CLIENT_STORAGE_PREFIX, F as SIGN_CLIENT_VERSION, gs as SignClient, W as WALLETCONNECT_DEEPLINK_CHOICE, Q as default };","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["import{RELAYER_DEFAULT_PROTOCOL as ge,RELAYER_EVENTS as Z,VERIFY_SERVER as me,EXPIRER_EVENTS as we,PAIRING_EVENTS as ye,Store as k,Core as Se}from\"@walletconnect/core\";import{pino as Ee,getDefaultLoggerOptions as Re,generateChildLogger as Ie,getLoggerContext as _e}from\"@walletconnect/logger\";import{IEngine as Ne,ISignClient as qe}from\"@walletconnect/types\";import{TYPE_1 as fe,createDelayedPromise as x,engineEvent as u,getInternalError as l,calcExpiry as _,isValidObject as z,getRequiredNamespacesFromNamespaces as ve,getSdkError as N,handleDeeplinkRedirect as Pe,isSessionCompatible as Oe,isBrowser as Ve,hashMessage as Y,isExpired as P,MemoryStore as $,isValidParams as E,isUndefined as D,isValidRelays as Te,isValidRequiredNamespaces as xe,isValidNamespaces as j,isConformingNamespaces as ee,isValidString as C,isValidErrorReason as De,isValidRelay as Ce,isValidController as Ae,isValidNamespacesChainId as se,isValidRequest as be,isValidNamespacesRequest as Le,isValidRequestExpiry as $e,isValidResponse as Ge,isValidEvent as Me,isValidNamespacesEvent as Ue,parseExpirerTarget as Qe,isValidId as Ke,getAppMetadata as ke}from\"@walletconnect/utils\";import ze,{EventEmitter as Ye}from\"events\";import{THIRTY_DAYS as je,SEVEN_DAYS as te,FIVE_MINUTES as y,ONE_DAY as O,THIRTY_SECONDS as ie,ONE_SECOND as Je,toMiliseconds as re}from\"@walletconnect/time\";import{payloadId as Xe,isJsonRpcResult as q,isJsonRpcError as f,formatJsonRpcRequest as J,formatJsonRpcResult as Fe,formatJsonRpcError as He,isJsonRpcRequest as We,isJsonRpcResponse as Be}from\"@walletconnect/jsonrpc-utils\";const X=\"wc\",F=2,H=\"client\",G=`${X}@${F}:${H}:`,M={name:H,logger:\"error\",controller:!1,relayUrl:\"wss://relay.walletconnect.com\"},Ze={session_proposal:\"session_proposal\",session_update:\"session_update\",session_extend:\"session_extend\",session_ping:\"session_ping\",session_delete:\"session_delete\",session_expire:\"session_expire\",session_request:\"session_request\",session_request_sent:\"session_request_sent\",session_event:\"session_event\",proposal_expire:\"proposal_expire\"},es={database:\":memory:\"},W=\"WALLETCONNECT_DEEPLINK_CHOICE\",ss={created:\"history_created\",updated:\"history_updated\",deleted:\"history_deleted\",sync:\"history_sync\"},ts=\"history\",is=\"0.3\",ne=\"proposal\",rs=je,oe=\"Proposal expired\",ae=\"session\",A=te,ce=\"engine\",V={wc_sessionPropose:{req:{ttl:y,prompt:!0,tag:1100},res:{ttl:y,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:y,prompt:!1,tag:1102},res:{ttl:y,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:O,prompt:!1,tag:1104},res:{ttl:O,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:O,prompt:!1,tag:1106},res:{ttl:O,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:y,prompt:!0,tag:1108},res:{ttl:y,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:y,prompt:!0,tag:1110},res:{ttl:y,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:O,prompt:!1,tag:1112},res:{ttl:O,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:ie,prompt:!1,tag:1114},res:{ttl:ie,prompt:!1,tag:1115}}},U={min:y,max:te},I={idle:\"IDLE\",active:\"ACTIVE\"},le=\"request\",pe=[\"wc_sessionPropose\",\"wc_sessionRequest\",\"wc_authRequest\"];var ns=Object.defineProperty,os=Object.defineProperties,as=Object.getOwnPropertyDescriptors,he=Object.getOwnPropertySymbols,cs=Object.prototype.hasOwnProperty,ls=Object.prototype.propertyIsEnumerable,de=(m,r,e)=>r in m?ns(m,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[r]=e,g=(m,r)=>{for(var e in r||(r={}))cs.call(r,e)&&de(m,e,r[e]);if(he)for(var e of he(r))ls.call(r,e)&&de(m,e,r[e]);return m},b=(m,r)=>os(m,as(r));class ps extends Ne{constructor(r){super(r),this.name=ce,this.events=new ze,this.initialized=!1,this.ignoredPayloadTypes=[fe],this.requestQueue={state:I.idle,queue:[]},this.sessionRequestQueue={state:I.idle,queue:[]},this.requestQueueDelay=Je,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(V)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},re(this.requestQueueDelay)))},this.connect=async e=>{await this.isInitialized();const s=b(g({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:n,sessionProperties:o,relays:a}=s;let c=t,p,d=!1;if(c&&(d=this.client.core.pairing.pairings.get(c).active),!c||!d){const{topic:v,uri:S}=await this.client.core.pairing.create();c=v,p=S}const h=await this.client.core.crypto.generateKeyPair(),R=g({requiredNamespaces:i,optionalNamespaces:n,relays:a??[{protocol:ge}],proposer:{publicKey:h,metadata:this.client.metadata}},o&&{sessionProperties:o}),{reject:w,resolve:T,done:K}=x(y,oe);if(this.events.once(u(\"session_connect\"),async({error:v,session:S})=>{if(v)w(v);else if(S){S.self.publicKey=h;const B=b(g({},S),{requiredNamespaces:S.requiredNamespaces,optionalNamespaces:S.optionalNamespaces});await this.client.session.set(S.topic,B),await this.setExpiry(S.topic,S.expiry),c&&await this.client.core.pairing.updateMetadata({topic:c,metadata:S.peer.metadata}),T(B)}}),!c){const{message:v}=l(\"NO_MATCHING_KEY\",`connect() pairing topic: ${c}`);throw new Error(v)}const L=await this.sendRequest({topic:c,method:\"wc_sessionPropose\",params:R}),ue=_(y);return await this.setProposal(L,g({id:L,expiry:ue},R)),{uri:p,approval:K}},this.pair=async e=>(await this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{await this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i,sessionProperties:n}=e,o=this.client.proposal.get(s);let{pairingTopic:a,proposer:c,requiredNamespaces:p,optionalNamespaces:d}=o;a=a||\"\",z(p)||(p=ve(i,\"approve()\"));const h=await this.client.core.crypto.generateKeyPair(),R=c.publicKey,w=await this.client.core.crypto.generateSharedKey(h,R);a&&s&&(await this.client.core.pairing.updateMetadata({topic:a,metadata:c.metadata}),await this.sendResult({id:s,topic:a,result:{relay:{protocol:t??\"irn\"},responderPublicKey:h}}),await this.client.proposal.delete(s,N(\"USER_DISCONNECTED\")),await this.client.core.pairing.activate({topic:a}));const T=g({relay:{protocol:t??\"irn\"},namespaces:i,requiredNamespaces:p,optionalNamespaces:d,pairingTopic:a,controller:{publicKey:h,metadata:this.client.metadata},expiry:_(A)},n&&{sessionProperties:n});await this.client.core.relayer.subscribe(w),await this.sendRequest({topic:w,method:\"wc_sessionSettle\",params:T,throwOnFailedPublish:!0});const K=b(g({},T),{topic:w,pairingTopic:a,acknowledged:!1,self:T.controller,peer:{publicKey:c.publicKey,metadata:c.metadata},controller:h});return await this.client.session.set(w,K),await this.setExpiry(w,_(A)),{topic:w,acknowledged:()=>new Promise(L=>setTimeout(()=>L(this.client.session.get(w)),500))}},this.reject=async e=>{await this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,N(\"USER_DISCONNECTED\")))},this.update=async e=>{await this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest({topic:s,method:\"wc_sessionUpdate\",params:{namespaces:t}}),{done:n,resolve:o,reject:a}=x();return this.events.once(u(\"session_update\",i),({error:c})=>{c?a(c):o()}),await this.client.session.update(s,{namespaces:t}),{acknowledged:n}},this.extend=async e=>{await this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest({topic:s,method:\"wc_sessionExtend\",params:{}}),{done:i,resolve:n,reject:o}=x();return this.events.once(u(\"session_extend\",t),({error:a})=>{a?o(a):n()}),await this.setExpiry(s,_(A)),{acknowledged:i}},this.request=async e=>{await this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i,expiry:n}=e,o=Xe(),{done:a,resolve:c,reject:p}=x(n,\"Request expired. Please try again.\");return this.events.once(u(\"session_request\",o),({error:d,result:h})=>{d?p(d):c(h)}),await Promise.all([new Promise(async d=>{await this.sendRequest({clientRpcId:o,topic:i,method:\"wc_sessionRequest\",params:{request:t,chainId:s},expiry:n,throwOnFailedPublish:!0}).catch(h=>p(h)),this.client.events.emit(\"session_request_sent\",{topic:i,request:t,chainId:s,id:o}),d()}),new Promise(async d=>{const h=await this.client.core.storage.getItem(W);Pe({id:o,topic:i,wcDeepLink:h}),d()}),a()]).then(d=>d[2])},this.respond=async e=>{await this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;q(t)?await this.sendResult({id:i,topic:s,result:t.result,throwOnFailedPublish:!0}):f(t)&&await this.sendError(i,s,t.error),this.cleanupAfterResponse(e)},this.ping=async e=>{await this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest({topic:s,method:\"wc_sessionPing\",params:{}}),{done:i,resolve:n,reject:o}=x();this.events.once(u(\"session_ping\",t),({error:a})=>{a?o(a):n()}),await i()}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s})},this.emit=async e=>{await this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest({topic:s,method:\"wc_sessionEvent\",params:{event:t,chainId:i}})},this.disconnect=async e=>{await this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;this.client.session.keys.includes(s)?(await this.sendRequest({topic:s,method:\"wc_sessionDelete\",params:N(\"USER_DISCONNECTED\"),throwOnFailedPublish:!0}),await this.deleteSession(s)):await this.client.core.pairing.disconnect({topic:s})},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>Oe(s,e))),this.getPendingSessionRequests=()=>(this.isInitialized(),this.client.pendingRequest.getAll()),this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const s=this.client.core.pairing.pairings.get(e.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter(i=>{var n,o;return((n=i.peerMetadata)==null?void 0:n.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==s.topic});if(t.length===0)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info(\"Duplicate pairings clean up finished\")}catch(s){this.client.logger.error(s)}},this.deleteSession=async(e,s)=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),this.client.session.delete(e,N(\"USER_DISCONNECTED\")),this.client.core.crypto.keychain.has(t.publicKey)&&await this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.keychain.has(e)&&await this.client.core.crypto.deleteSymKey(e),s||this.client.core.expirer.del(e),this.client.core.storage.removeItem(W).catch(i=>this.client.logger.warn(i))},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,N(\"USER_DISCONNECTED\")),s?Promise.resolve():this.client.core.expirer.del(e)])},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)]),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(i=>i.id!==e),t&&(this.sessionRequestQueue.state=I.idle)},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s)},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,s.expiry)},this.setPendingSessionRequest=async e=>{const s=V.wc_sessionRequest.req.ttl,{id:t,topic:i,params:n,verifyContext:o}=e;await this.client.pendingRequest.set(t,{id:t,topic:i,params:n,verifyContext:o}),s&&this.client.core.expirer.set(t,_(s))},this.sendRequest=async e=>{const{topic:s,method:t,params:i,expiry:n,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:c}=e,p=J(t,i,a);if(Ve()&&pe.includes(t)){const R=Y(JSON.stringify(p));this.client.core.verify.register({attestationId:R})}const d=await this.client.core.crypto.encode(s,p),h=V[t].req;return n&&(h.ttl=n),o&&(h.id=o),this.client.core.history.set(s,p),c?(h.internal=b(g({},h.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,d,h)):this.client.core.relayer.publish(s,d,h).catch(R=>this.client.logger.error(R)),p.id},this.sendResult=async e=>{const{id:s,topic:t,result:i,throwOnFailedPublish:n}=e,o=Fe(s,i),a=await this.client.core.crypto.encode(t,o),c=await this.client.core.history.get(t,s),p=V[c.request.method].res;n?(p.internal=b(g({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,a,p)):this.client.core.relayer.publish(t,a,p).catch(d=>this.client.logger.error(d)),await this.client.core.history.resolve(o)},this.sendError=async(e,s,t)=>{const i=He(e,t),n=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=V[o.request.method].res;this.client.core.relayer.publish(s,n,a),await this.client.core.history.resolve(i)},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{P(t.expiry)&&e.push(t.topic)}),this.client.proposal.getAll().forEach(t=>{P(t.expiry)&&s.push(t.id)}),await Promise.all([...e.map(t=>this.deleteSession(t)),...s.map(t=>this.deleteProposal(t))])},this.onRelayEventRequest=async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===I.active){this.client.logger.info(\"Request queue already active, skipping...\");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=I.active;const e=this.requestQueue.queue.shift();if(e)try{this.processRequest(e),await new Promise(s=>setTimeout(s,300))}catch(s){this.client.logger.warn(s)}}this.requestQueue.state=I.idle},this.processRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case\"wc_sessionPropose\":return this.onSessionProposeRequest(s,t);case\"wc_sessionSettle\":return this.onSessionSettleRequest(s,t);case\"wc_sessionUpdate\":return this.onSessionUpdateRequest(s,t);case\"wc_sessionExtend\":return this.onSessionExtendRequest(s,t);case\"wc_sessionPing\":return this.onSessionPingRequest(s,t);case\"wc_sessionDelete\":return this.onSessionDeleteRequest(s,t);case\"wc_sessionRequest\":return this.onSessionRequest(s,t);case\"wc_sessionEvent\":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case\"wc_sessionPropose\":return this.onSessionProposeResponse(s,t);case\"wc_sessionSettle\":return this.onSessionSettleResponse(s,t);case\"wc_sessionUpdate\":return this.onSessionUpdateResponse(s,t);case\"wc_sessionExtend\":return this.onSessionExtendResponse(s,t);case\"wc_sessionPing\":return this.onSessionPingResponse(s,t);case\"wc_sessionRequest\":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:s}=e,{message:t}=l(\"MISSING_OR_INVALID\",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(t)},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(g({},s.params));const n=_(y),o=g({id:i,pairingTopic:e,expiry:n},t);await this.setProposal(i,o);const a=Y(JSON.stringify(s)),c=await this.getVerifyContext(a,o.proposer.metadata);this.client.events.emit(\"session_proposal\",{id:i,params:o,verifyContext:c})}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(q(s)){const{result:i}=s;this.client.logger.trace({type:\"method\",method:\"onSessionProposeResponse\",result:i});const n=this.client.proposal.get(t);this.client.logger.trace({type:\"method\",method:\"onSessionProposeResponse\",proposal:n});const o=n.proposer.publicKey;this.client.logger.trace({type:\"method\",method:\"onSessionProposeResponse\",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:\"method\",method:\"onSessionProposeResponse\",peerPublicKey:a});const c=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:\"method\",method:\"onSessionProposeResponse\",sessionTopic:c});const p=await this.client.core.relayer.subscribe(c);this.client.logger.trace({type:\"method\",method:\"onSessionProposeResponse\",subscriptionId:p}),await this.client.core.pairing.activate({topic:e})}else f(s)&&(await this.client.proposal.delete(t,N(\"USER_DISCONNECTED\")),this.events.emit(u(\"session_connect\"),{error:s.error}))},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:n,controller:o,expiry:a,namespaces:c,requiredNamespaces:p,optionalNamespaces:d,sessionProperties:h,pairingTopic:R}=s.params,w=g({topic:e,relay:n,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:R,requiredNamespaces:p,optionalNamespaces:d,controller:o.publicKey,self:{publicKey:\"\",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},h&&{sessionProperties:h});await this.sendResult({id:s.id,topic:e,result:!0}),this.events.emit(u(\"session_connect\"),{session:w}),this.cleanupDuplicatePairings(w)}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;q(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(u(\"session_approve\",t),{})):f(s)&&(await this.client.session.delete(e,N(\"USER_DISCONNECTED\")),this.events.emit(u(\"session_approve\",t),{error:s.error}))},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{const n=`${e}_session_update`,o=$.get(n);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidUpdate(g({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult({id:i,topic:e,result:!0}),this.client.events.emit(\"session_update\",{id:i,topic:e,params:t}),$.set(n,i)}catch(n){await this.sendError(i,e,n),this.client.logger.error(n)}},this.isRequestOutOfSync=(e,s)=>parseInt(s.toString().slice(0,-3))<=parseInt(e.toString().slice(0,-3)),this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;q(s)?this.events.emit(u(\"session_update\",t),{}):f(s)&&this.events.emit(u(\"session_update\",t),{error:s.error})},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,_(A)),await this.sendResult({id:t,topic:e,result:!0}),this.client.events.emit(\"session_extend\",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;q(s)?this.events.emit(u(\"session_extend\",t),{}):f(s)&&this.events.emit(u(\"session_extend\",t),{error:s.error})},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult({id:t,topic:e,result:!0}),this.client.events.emit(\"session_ping\",{id:t,topic:e})}catch(i){await this.sendError(t,e,i),this.client.logger.error(i)}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{q(s)?this.events.emit(u(\"session_ping\",t),{}):f(s)&&this.events.emit(u(\"session_ping\",t),{error:s.error})},500)},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await Promise.all([new Promise(i=>{this.client.core.relayer.once(Z.publish,async()=>{i(await this.deleteSession(e))})}),this.sendResult({id:t,topic:e,result:!0})]),this.client.events.emit(\"session_delete\",{id:t,topic:e})}catch(i){this.client.logger.error(i)}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(g({topic:e},i));const n=Y(JSON.stringify(J(\"wc_sessionRequest\",i,t))),o=this.client.session.get(e),a=await this.getVerifyContext(n,o.peer.metadata),c={id:t,topic:e,params:i,verifyContext:a};await this.setPendingSessionRequest(c),this.addSessionRequestToSessionRequestQueue(c),this.processSessionRequestQueue()}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;q(s)?this.events.emit(u(\"session_request\",t),{result:s.result}):f(s)&&this.events.emit(u(\"session_request\",t),{error:s.error})},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{const n=`${e}_session_event_${i.event.name}`,o=$.get(n);if(o&&this.isRequestOutOfSync(o,t)){this.client.logger.info(`Discarding out of sync request - ${t}`);return}this.isValidEmit(g({topic:e},i)),this.client.events.emit(\"session_event\",{id:t,topic:e,params:i}),$.set(n,t)}catch(n){await this.sendError(t,e,n),this.client.logger.error(n)}},this.addSessionRequestToSessionRequestQueue=e=>{this.sessionRequestQueue.queue.push(e)},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:\"fulfilled\",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=I.idle,this.processSessionRequestQueue()},re(this.requestQueueDelay))},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===I.active){this.client.logger.info(\"session request queue is already active.\");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info(\"session request queue is empty.\");return}try{this.sessionRequestQueue.state=I.active,this.client.events.emit(\"session_request\",e)}catch(s){this.client.logger.error(s)}},this.onPairingCreated=e=>{if(e.active)return;const s=this.client.proposal.getAll().find(t=>t.pairingTopic===e.topic);s&&this.onSessionProposeRequest(e.topic,J(\"wc_sessionPropose\",{requiredNamespaces:s.requiredNamespaces,optionalNamespaces:s.optionalNamespaces,relays:s.relays,proposer:s.proposer},s.id))},this.isValidConnect=async e=>{if(!E(e)){const{message:a}=l(\"MISSING_OR_INVALID\",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:s,requiredNamespaces:t,optionalNamespaces:i,sessionProperties:n,relays:o}=e;if(D(s)||await this.isValidPairingTopic(s),!Te(o,!0)){const{message:a}=l(\"MISSING_OR_INVALID\",`connect() relays: ${o}`);throw new Error(a)}!D(t)&&z(t)!==0&&this.validateNamespaces(t,\"requiredNamespaces\"),!D(i)&&z(i)!==0&&this.validateNamespaces(i,\"optionalNamespaces\"),D(n)||this.validateSessionProps(n,\"sessionProperties\")},this.validateNamespaces=(e,s)=>{const t=xe(e,\"connect()\",s);if(t)throw new Error(t.message)},this.isValidApprove=async e=>{if(!E(e))throw new Error(l(\"MISSING_OR_INVALID\",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i,sessionProperties:n}=e;await this.isValidProposalId(s);const o=this.client.proposal.get(s),a=j(t,\"approve()\");if(a)throw new Error(a.message);const c=ee(o.requiredNamespaces,t,\"approve()\");if(c)throw new Error(c.message);if(!C(i,!0)){const{message:p}=l(\"MISSING_OR_INVALID\",`approve() relayProtocol: ${i}`);throw new Error(p)}D(n)||this.validateSessionProps(n,\"sessionProperties\")},this.isValidReject=async e=>{if(!E(e)){const{message:i}=l(\"MISSING_OR_INVALID\",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!De(t)){const{message:i}=l(\"MISSING_OR_INVALID\",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!E(e)){const{message:c}=l(\"MISSING_OR_INVALID\",`onSessionSettleRequest() params: ${e}`);throw new Error(c)}const{relay:s,controller:t,namespaces:i,expiry:n}=e;if(!Ce(s)){const{message:c}=l(\"MISSING_OR_INVALID\",\"onSessionSettleRequest() relay protocol should be a string\");throw new Error(c)}const o=Ae(t,\"onSessionSettleRequest()\");if(o)throw new Error(o.message);const a=j(i,\"onSessionSettleRequest()\");if(a)throw new Error(a.message);if(P(n)){const{message:c}=l(\"EXPIRED\",\"onSessionSettleRequest()\");throw new Error(c)}},this.isValidUpdate=async e=>{if(!E(e)){const{message:a}=l(\"MISSING_OR_INVALID\",`update() params: ${e}`);throw new Error(a)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),n=j(t,\"update()\");if(n)throw new Error(n.message);const o=ee(i.requiredNamespaces,t,\"update()\");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!E(e)){const{message:t}=l(\"MISSING_OR_INVALID\",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s)},this.isValidRequest=async e=>{if(!E(e)){const{message:a}=l(\"MISSING_OR_INVALID\",`request() params: ${e}`);throw new Error(a)}const{topic:s,request:t,chainId:i,expiry:n}=e;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!se(o,i)){const{message:a}=l(\"MISSING_OR_INVALID\",`request() chainId: ${i}`);throw new Error(a)}if(!be(t)){const{message:a}=l(\"MISSING_OR_INVALID\",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!Le(o,i,t.method)){const{message:a}=l(\"MISSING_OR_INVALID\",`request() method: ${t.method}`);throw new Error(a)}if(n&&!$e(n,U)){const{message:a}=l(\"MISSING_OR_INVALID\",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);throw new Error(a)}},this.isValidRespond=async e=>{if(!E(e)){const{message:i}=l(\"MISSING_OR_INVALID\",`respond() params: ${e}`);throw new Error(i)}const{topic:s,response:t}=e;if(await this.isValidSessionTopic(s),!Ge(t)){const{message:i}=l(\"MISSING_OR_INVALID\",`respond() response: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidPing=async e=>{if(!E(e)){const{message:t}=l(\"MISSING_OR_INVALID\",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.isValidEmit=async e=>{if(!E(e)){const{message:o}=l(\"MISSING_OR_INVALID\",`emit() params: ${e}`);throw new Error(o)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:n}=this.client.session.get(s);if(!se(n,i)){const{message:o}=l(\"MISSING_OR_INVALID\",`emit() chainId: ${i}`);throw new Error(o)}if(!Me(t)){const{message:o}=l(\"MISSING_OR_INVALID\",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!Ue(n,i,t.name)){const{message:o}=l(\"MISSING_OR_INVALID\",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!E(e)){const{message:t}=l(\"MISSING_OR_INVALID\",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s)},this.getVerifyContext=async(e,s)=>{const t={verified:{verifyUrl:s.verifyUrl||me,validation:\"UNKNOWN\",origin:s.url||\"\"}};try{const i=await this.client.core.verify.resolve({attestationId:e,verifyUrl:s.verifyUrl});i&&(t.verified.origin=i.origin,t.verified.isScam=i.isScam,t.verified.validation=i.origin===new URL(s.url).origin?\"VALID\":\"INVALID\")}catch(i){this.client.logger.info(i)}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(e,s)=>{Object.values(e).forEach(t=>{if(!C(t,!1)){const{message:i}=l(\"MISSING_OR_INVALID\",`${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(i)}})}}async isInitialized(){if(!this.initialized){const{message:r}=l(\"NOT_INITIALIZED\",this.name);throw new Error(r)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(Z.message,async r=>{const{topic:e,message:s}=r;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);try{We(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):Be(t)?(await this.client.core.history.resolve(t),await this.onRelayEventResponse({topic:e,payload:t}),this.client.core.history.delete(e,t.id)):this.onRelayEventUnknownPayload({topic:e,payload:t})}catch(i){this.client.logger.error(i)}})}registerExpirerEvents(){this.client.core.expirer.on(we.expired,async r=>{const{topic:e,id:s}=Qe(r.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,l(\"EXPIRED\"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession(e,!0),this.client.events.emit(\"session_expire\",{topic:e})):s&&(await this.deleteProposal(s,!0),this.client.events.emit(\"proposal_expire\",{id:s}))})}registerPairingEvents(){this.client.core.pairing.events.on(ye.create,r=>this.onPairingCreated(r))}isValidPairingTopic(r){if(!C(r,!1)){const{message:e}=l(\"MISSING_OR_INVALID\",`pairing topic should be a string: ${r}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(r)){const{message:e}=l(\"NO_MATCHING_KEY\",`pairing topic doesn't exist: ${r}`);throw new Error(e)}if(P(this.client.core.pairing.pairings.get(r).expiry)){const{message:e}=l(\"EXPIRED\",`pairing topic: ${r}`);throw new Error(e)}}async isValidSessionTopic(r){if(!C(r,!1)){const{message:e}=l(\"MISSING_OR_INVALID\",`session topic should be a string: ${r}`);throw new Error(e)}if(!this.client.session.keys.includes(r)){const{message:e}=l(\"NO_MATCHING_KEY\",`session topic doesn't exist: ${r}`);throw new Error(e)}if(P(this.client.session.get(r).expiry)){await this.deleteSession(r);const{message:e}=l(\"EXPIRED\",`session topic: ${r}`);throw new Error(e)}}async isValidSessionOrPairingTopic(r){if(this.client.session.keys.includes(r))await this.isValidSessionTopic(r);else if(this.client.core.pairing.pairings.keys.includes(r))this.isValidPairingTopic(r);else if(C(r,!1)){const{message:e}=l(\"NO_MATCHING_KEY\",`session or pairing topic doesn't exist: ${r}`);throw new Error(e)}else{const{message:e}=l(\"MISSING_OR_INVALID\",`session or pairing topic should be a string: ${r}`);throw new Error(e)}}async isValidProposalId(r){if(!Ke(r)){const{message:e}=l(\"MISSING_OR_INVALID\",`proposal id should be a number: ${r}`);throw new Error(e)}if(!this.client.proposal.keys.includes(r)){const{message:e}=l(\"NO_MATCHING_KEY\",`proposal id doesn't exist: ${r}`);throw new Error(e)}if(P(this.client.proposal.get(r).expiry)){await this.deleteProposal(r);const{message:e}=l(\"EXPIRED\",`proposal id: ${r}`);throw new Error(e)}}}class hs extends k{constructor(r,e){super(r,e,ne,G),this.core=r,this.logger=e}}class ds extends k{constructor(r,e){super(r,e,ae,G),this.core=r,this.logger=e}}class us extends k{constructor(r,e){super(r,e,le,G,s=>s.id),this.core=r,this.logger=e}}class Q extends qe{constructor(r){super(r),this.protocol=X,this.version=F,this.name=M.name,this.events=new Ye,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=r?.name||M.name,this.metadata=r?.metadata||ke();const e=typeof r?.logger<\"u\"&&typeof r?.logger!=\"string\"?r.logger:Ee(Re({level:r?.logger||M.logger}));this.core=r?.core||new Se(r),this.logger=Ie(e,this.name),this.session=new ds(this.core,this.logger),this.proposal=new hs(this.core,this.logger),this.pendingRequest=new us(this.core,this.logger),this.engine=new ps(this)}static async init(r){const e=new Q(r);return await e.initialize(),e}get context(){return _e(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace(\"Initialized\");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info(\"SignClient Initialization Success\")}catch(r){throw this.logger.info(\"SignClient Initialization Failure\"),this.logger.error(r.message),r}}}const gs=Q;export{ce as ENGINE_CONTEXT,I as ENGINE_QUEUE_STATES,V as ENGINE_RPC_OPTS,ts as HISTORY_CONTEXT,ss as HISTORY_EVENTS,is as HISTORY_STORAGE_VERSION,pe as METHODS_TO_VERIFY,ne as PROPOSAL_CONTEXT,rs as PROPOSAL_EXPIRY,oe as PROPOSAL_EXPIRY_MESSAGE,le as REQUEST_CONTEXT,ae as SESSION_CONTEXT,A as SESSION_EXPIRY,U as SESSION_REQUEST_EXPIRY_BOUNDARIES,H as SIGN_CLIENT_CONTEXT,M as SIGN_CLIENT_DEFAULT,Ze as SIGN_CLIENT_EVENTS,X as SIGN_CLIENT_PROTOCOL,es as SIGN_CLIENT_STORAGE_OPTIONS,G as SIGN_CLIENT_STORAGE_PREFIX,F as SIGN_CLIENT_VERSION,gs as SignClient,W as WALLETCONNECT_DEEPLINK_CHOICE,Q as default};\n//# sourceMappingURL=index.es.js.map\n"]},"metadata":{},"sourceType":"module"}