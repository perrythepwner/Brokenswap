{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package hmac implements HMAC algorithm.\n */\nvar hash_1 = require(\"@stablelib/hash\");\nvar constant_time_1 = require(\"@stablelib/constant-time\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nvar HMAC = /** @class */function () {\n  /**\n   * Constructs a new HMAC with the given Hash and secret key.\n   */\n  function HMAC(hash, key) {\n    this._finished = false; // true if HMAC was finalized\n    // Initialize inner and outer hashes.\n    this._inner = new hash();\n    this._outer = new hash();\n    // Set block and digest sizes for this HMAC\n    // instance to values from the hash.\n    this.blockSize = this._outer.blockSize;\n    this.digestLength = this._outer.digestLength;\n    // Pad temporary stores a key (or its hash) padded with zeroes.\n    var pad = new Uint8Array(this.blockSize);\n    if (key.length > this.blockSize) {\n      // If key is bigger than hash block size, it must be\n      // hashed and this hash is used as a key instead.\n      this._inner.update(key).finish(pad).clean();\n    } else {\n      // Otherwise, copy the key into pad.\n      pad.set(key);\n    }\n    // Now two different keys are derived from padded key\n    // by xoring a different byte value to each.\n    // To make inner hash key, xor byte 0x36 into pad.\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    }\n    // Update inner hash with the result.\n    this._inner.update(pad);\n    // To make outer hash key, xor byte 0x5c into pad.\n    // But since we already xored 0x36 there, we must\n    // first undo this by xoring it again.\n    for (var i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    }\n    // Update outer hash with the result.\n    this._outer.update(pad);\n    // Save states of both hashes, so that we can quickly restore\n    // them later in reset() without the need to remember the actual\n    // key and perform this initialization again.\n    if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n      this._innerKeyedState = this._inner.saveState();\n      this._outerKeyedState = this._outer.saveState();\n    }\n    // Clean pad.\n    wipe_1.wipe(pad);\n  }\n  /**\n   * Returns HMAC state to the state initialized with key\n   * to make it possible to run HMAC over the other data with the same\n   * key without creating a new instance.\n   */\n  HMAC.prototype.reset = function () {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n    }\n    // Restore keyed states of inner and outer hashes.\n    this._inner.restoreState(this._innerKeyedState);\n    this._outer.restoreState(this._outerKeyedState);\n    this._finished = false;\n    return this;\n  };\n  /**\n   * Cleans HMAC state.\n   */\n  HMAC.prototype.clean = function () {\n    if (hash_1.isSerializableHash(this._inner)) {\n      this._inner.cleanSavedState(this._innerKeyedState);\n    }\n    if (hash_1.isSerializableHash(this._outer)) {\n      this._outer.cleanSavedState(this._outerKeyedState);\n    }\n    this._inner.clean();\n    this._outer.clean();\n  };\n  /**\n   * Updates state with provided data.\n   */\n  HMAC.prototype.update = function (data) {\n    this._inner.update(data);\n    return this;\n  };\n  /**\n   * Finalizes HMAC and puts the result in out.\n   */\n  HMAC.prototype.finish = function (out) {\n    if (this._finished) {\n      // If HMAC was finalized, outer hash is also finalized,\n      // so it produces the same digest it produced when it\n      // was finalized.\n      this._outer.finish(out);\n      return this;\n    }\n    // Finalize inner hash and store the result temporarily.\n    this._inner.finish(out);\n    // Update outer hash with digest of inner hash and and finalize it.\n    this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n    this._finished = true;\n    return this;\n  };\n  /**\n   * Returns the computed message authentication code.\n   */\n  HMAC.prototype.digest = function () {\n    var out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  };\n  /**\n   * Saves HMAC state.\n   * This function is needed for PBKDF2 optimization.\n   */\n  HMAC.prototype.saveState = function () {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n    }\n    return this._inner.saveState();\n  };\n  HMAC.prototype.restoreState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n      throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n    }\n    this._inner.restoreState(savedState);\n    this._outer.restoreState(this._outerKeyedState);\n    this._finished = false;\n    return this;\n  };\n  HMAC.prototype.cleanSavedState = function (savedState) {\n    if (!hash_1.isSerializableHash(this._inner)) {\n      throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n    }\n    this._inner.cleanSavedState(savedState);\n  };\n  return HMAC;\n}();\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nfunction hmac(hash, key, data) {\n  var h = new HMAC(hash, key);\n  h.update(data);\n  var digest = h.digest();\n  h.clean();\n  return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexports.equal = constant_time_1.equal;","map":{"version":3,"sources":["../hmac.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package hmac implements HMAC algorithm.\n */\nvar hash_1 = require(\"@stablelib/hash\");\nvar constant_time_1 = require(\"@stablelib/constant-time\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n *  HMAC implements hash-based message authentication algorithm.\n */\nvar HMAC = /** @class */ (function () {\n    /**\n     * Constructs a new HMAC with the given Hash and secret key.\n     */\n    function HMAC(hash, key) {\n        this._finished = false; // true if HMAC was finalized\n        // Initialize inner and outer hashes.\n        this._inner = new hash();\n        this._outer = new hash();\n        // Set block and digest sizes for this HMAC\n        // instance to values from the hash.\n        this.blockSize = this._outer.blockSize;\n        this.digestLength = this._outer.digestLength;\n        // Pad temporary stores a key (or its hash) padded with zeroes.\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            // If key is bigger than hash block size, it must be\n            // hashed and this hash is used as a key instead.\n            this._inner.update(key).finish(pad).clean();\n        }\n        else {\n            // Otherwise, copy the key into pad.\n            pad.set(key);\n        }\n        // Now two different keys are derived from padded key\n        // by xoring a different byte value to each.\n        // To make inner hash key, xor byte 0x36 into pad.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        // Update inner hash with the result.\n        this._inner.update(pad);\n        // To make outer hash key, xor byte 0x5c into pad.\n        // But since we already xored 0x36 there, we must\n        // first undo this by xoring it again.\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        // Update outer hash with the result.\n        this._outer.update(pad);\n        // Save states of both hashes, so that we can quickly restore\n        // them later in reset() without the need to remember the actual\n        // key and perform this initialization again.\n        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {\n            this._innerKeyedState = this._inner.saveState();\n            this._outerKeyedState = this._outer.saveState();\n        }\n        // Clean pad.\n        wipe_1.wipe(pad);\n    }\n    /**\n     * Returns HMAC state to the state initialized with key\n     * to make it possible to run HMAC over the other data with the same\n     * key without creating a new instance.\n     */\n    HMAC.prototype.reset = function () {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't reset() because hash doesn't implement restoreState()\");\n        }\n        // Restore keyed states of inner and outer hashes.\n        this._inner.restoreState(this._innerKeyedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    /**\n     * Cleans HMAC state.\n     */\n    HMAC.prototype.clean = function () {\n        if (hash_1.isSerializableHash(this._inner)) {\n            this._inner.cleanSavedState(this._innerKeyedState);\n        }\n        if (hash_1.isSerializableHash(this._outer)) {\n            this._outer.cleanSavedState(this._outerKeyedState);\n        }\n        this._inner.clean();\n        this._outer.clean();\n    };\n    /**\n     * Updates state with provided data.\n     */\n    HMAC.prototype.update = function (data) {\n        this._inner.update(data);\n        return this;\n    };\n    /**\n     * Finalizes HMAC and puts the result in out.\n     */\n    HMAC.prototype.finish = function (out) {\n        if (this._finished) {\n            // If HMAC was finalized, outer hash is also finalized,\n            // so it produces the same digest it produced when it\n            // was finalized.\n            this._outer.finish(out);\n            return this;\n        }\n        // Finalize inner hash and store the result temporarily.\n        this._inner.finish(out);\n        // Update outer hash with digest of inner hash and and finalize it.\n        this._outer.update(out.subarray(0, this.digestLength)).finish(out);\n        this._finished = true;\n        return this;\n    };\n    /**\n     * Returns the computed message authentication code.\n     */\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    /**\n     * Saves HMAC state.\n     * This function is needed for PBKDF2 optimization.\n     */\n    HMAC.prototype.saveState = function () {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't saveState() because hash doesn't implement it\");\n        }\n        return this._inner.saveState();\n    };\n    HMAC.prototype.restoreState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {\n            throw new Error(\"hmac: can't restoreState() because hash doesn't implement it\");\n        }\n        this._inner.restoreState(savedState);\n        this._outer.restoreState(this._outerKeyedState);\n        this._finished = false;\n        return this;\n    };\n    HMAC.prototype.cleanSavedState = function (savedState) {\n        if (!hash_1.isSerializableHash(this._inner)) {\n            throw new Error(\"hmac: can't cleanSavedState() because hash doesn't implement it\");\n        }\n        this._inner.cleanSavedState(savedState);\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n/**\n * Returns HMAC using the given hash constructor for the key over data.\n */\nfunction hmac(hash, key, data) {\n    var h = new HMAC(hash, key);\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n/**\n * Returns true if two HMAC digests are equal.\n * Uses constant-time comparison to avoid leaking timing information.\n *\n * Example:\n *\n *    const receivedDigest = ...\n *    const realDigest = hmac(SHA256, key, data);\n *    if (!equal(receivedDigest, realDigest)) {\n *        throw new Error(\"Authentication error\");\n *    }\n */\nexports.equal = constant_time_1.equal;\n//# sourceMappingURL=hmac.js.map"]},"metadata":{},"sourceType":"script"}