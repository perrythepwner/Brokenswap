{"ast":null,"code":"import _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\n\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nconst devices = {\n  blue: {\n    id: \"blue\",\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: _firwareVersion => 4 * 1024\n  },\n  nanoS: {\n    id: \"nanoS\",\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: firmwareVersion => semver.lt(semver.coerce(firmwareVersion), \"2.0.0\") ? 4 * 1024 : 2 * 1024\n  },\n  nanoX: {\n    id: \"nanoX\",\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: _firwareVersion => 4 * 1024,\n    bluetoothSpec: [{\n      // this is the legacy one (prototype version). we will eventually drop it.\n      serviceUuid: \"d973f2e0-b19e-11e2-9e96-0800200c9a66\",\n      notifyUuid: \"d973f2e1-b19e-11e2-9e96-0800200c9a66\",\n      writeUuid: \"d973f2e2-b19e-11e2-9e96-0800200c9a66\"\n    }, {\n      serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\"\n    }]\n  }\n};\nconst productMap = {\n  Blue: \"blue\",\n  \"Nano S\": \"nanoS\",\n  \"Nano X\": \"nanoX\"\n}; // $FlowFixMe\n\nconst devicesList = Object.values(devices);\n/**\n *\n */\n\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\n\nexport const getDeviceModel = id => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n/**\n *\n */\n\nexport const identifyUSBProductId = usbProductId => {\n  const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find(d => d.productIdMM === mm);\n  return deviceModel;\n};\nexport const identifyProductName = productName => {\n  const productId = productMap[productName];\n  const deviceModel = devicesList.find(d => d.id === productId);\n  return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (let id in devices) {\n  const deviceModel = devices[id];\n  const {\n    bluetoothSpec\n  } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = _objectSpread({\n        deviceModel\n      }, spec);\n    }\n  }\n}\n/**\n *\n */\n\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\n\nexport const getInfosForServiceUuid = uuid => serviceUuidToInfos[uuid.toLowerCase()];\n/**\n *\n */","map":{"version":3,"sources":["../src/index.js"],"names":["semver","IIGenericHID","IIKeyboardHID","IIU2F","IICCID","IIWebUSB","devices","blue","id","productName","productIdMM","legacyUsbProductId","usbOnly","memorySize","blockSize","getBlockSize","_firwareVersion","nanoS","firmwareVersion","lt","coerce","nanoX","bluetoothSpec","serviceUuid","notifyUuid","writeUuid","productMap","Blue","devicesList","Object","values","ledgerUSBVendorId","getDeviceModel","info","Error","identifyUSBProductId","usbProductId","legacy","find","d","mm","deviceModel","identifyProductName","productId","bluetoothServices","serviceUuidToInfos","i","length","spec","push","replace","getBluetoothServiceUuids","getInfosForServiceUuid","uuid","toLowerCase"],"mappings":"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","sourcesContent":["// @flow\n\nimport semver from \"semver\";\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\n\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nconst devices = {\n  blue: {\n    id: \"blue\",\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n  },\n  nanoS: {\n    id: \"nanoS\",\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: (firmwareVersion: string): number =>\n      semver.lt(semver.coerce(firmwareVersion), \"2.0.0\") ? 4 * 1024 : 2 * 1024,\n  },\n  nanoX: {\n    id: \"nanoX\",\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    blockSize: 4 * 1024,\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        // this is the legacy one (prototype version). we will eventually drop it.\n        serviceUuid: \"d973f2e0-b19e-11e2-9e96-0800200c9a66\",\n        notifyUuid: \"d973f2e1-b19e-11e2-9e96-0800200c9a66\",\n        writeUuid: \"d973f2e2-b19e-11e2-9e96-0800200c9a66\",\n      },\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: \"blue\",\n  \"Nano S\": \"nanoS\",\n  \"Nano X\": \"nanoX\",\n};\n\n// $FlowFixMe\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n *\n */\nexport const identifyUSBProductId = (usbProductId: number): ?DeviceModel => {\n  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find((d) => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (productName: string): ?DeviceModel => {\n  const productId = productMap[productName];\n  const deviceModel = devicesList.find((d) => d.id === productId);\n\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: {\n  [_: string]: BluetoothInfos,\n} = {};\n\nfor (let id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = { deviceModel, ...spec };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid: string): ?BluetoothInfos =>\n  serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport type DeviceModelId = $Keys<typeof devices>;\n\n/**\n *\n */\nexport type DeviceModel = {\n  id: DeviceModelId,\n  productName: string,\n  productIdMM: number,\n  legacyUsbProductId: number,\n  usbOnly: boolean,\n  memorySize: number,\n  // blockSize: number, // THIS FIELD IS DEPRECATED, use getBlockSize\n  getBlockSize: (firmwareVersion: string) => number,\n  bluetoothSpec?: Array<{\n    serviceUuid: string,\n    writeUuid: string,\n    notifyUuid: string,\n  }>,\n};\n\n/**\n *\n */\nexport type BluetoothInfos = {\n  deviceModel: DeviceModel,\n  serviceUuid: string,\n  writeUuid: string,\n  notifyUuid: string,\n};\n"]},"metadata":{},"sourceType":"module"}