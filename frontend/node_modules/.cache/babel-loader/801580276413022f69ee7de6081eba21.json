{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n// There's a matrix of Array-ish types that require a combination of this functions.\n// Regular class extends syntax doesn't work because it can only extend a single class.\n//\n// Type of array: List, Vector. Changes length property\n// Type of element: Basic, Composite. Changes merkelization if packing or not.\n// If Composite: Fixed len, Variable len. Changes the serialization requiring offsets.\n/**\n * SSZ Lists (variable-length arrays) include the length of the list in the tree\n * This length is always in the same index in the tree\n * ```\n *   1\n *  / \\\n * 2   3 // <-here\n * ```\n */\nfunction getLengthFromRootNode(node) {\n  // Length is represented as a Uint32 at the start of the chunk:\n  // 4 = 4 bytes in Uint32\n  // 0 = 0 offset bytes in Node's data\n  return node.right.getUint(4, 0);\n}\nexports.getLengthFromRootNode = getLengthFromRootNode;\nfunction getChunksNodeFromRootNode(node) {\n  return node.left;\n}\nexports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;\nfunction addLengthNode(chunksNode, length) {\n  return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));\n}\nexports.addLengthNode = addLengthNode;\nfunction setChunksNode(rootNode, chunksNode, newLength) {\n  const lengthNode = newLength !== undefined ?\n  // If newLength is set, create a new node for length\n  persistent_merkle_tree_1.LeafNode.fromUint32(newLength) :\n  // else re-use existing node\n  rootNode.right;\n  return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);\n}\nexports.setChunksNode = setChunksNode;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {\n  const elSize = elementType.byteLength;\n  for (let i = 0; i < length; i++) {\n    elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);\n  }\n  return offset + length * elSize;\n}\nexports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;\nfunction value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {\n  const elSize = elementType.byteLength;\n  // Vector + List length validation\n  const length = (end - start) / elSize;\n  assertValidArrayLength(length, arrayProps, true);\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    // TODO: If faster, consider skipping size check for uint types\n    values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);\n  }\n  return values;\n}\nexports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {\n  const size = elementType.byteLength * length;\n  const chunkCount = Math.ceil(size / 32);\n  const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);\n  persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);\n  return offset + size;\n}\nexports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;\n// List of basic elements will pack them in merkelized form\nfunction tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {\n  // Vector + List length validation\n  const length = (end - start) / elementType.byteLength;\n  assertValidArrayLength(length, arrayProps, true);\n  // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n  const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);\n  if (arrayProps.isList) {\n    return addLengthNode(chunksNode, length);\n  } else {\n    return chunksNode;\n  }\n}\nexports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_fromJsonArray(elementType, json, arrayProps) {\n  if (!Array.isArray(json)) {\n    throw Error(\"JSON is not an array\");\n  }\n  assertValidArrayLength(json.length, arrayProps);\n  const value = new Array(json.length);\n  for (let i = 0; i < json.length; i++) {\n    value[i] = elementType.fromJson(json[i]);\n  }\n  return value;\n}\nexports.value_fromJsonArray = value_fromJsonArray;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_toJsonArray(elementType, value, arrayProps) {\n  const length = arrayProps.isList ? value.length : arrayProps.length;\n  const json = new Array(length);\n  for (let i = 0; i < length; i++) {\n    json[i] = elementType.toJson(value[i]);\n  }\n  return json;\n}\nexports.value_toJsonArray = value_toJsonArray;\n/**\n * Clone recursively an array of basic or composite types\n */\nfunction value_cloneArray(elementType, value) {\n  const newValue = new Array(value.length);\n  for (let i = 0; i < value.length; i++) {\n    newValue[i] = elementType.clone(value[i]);\n  }\n  return newValue;\n}\nexports.value_cloneArray = value_cloneArray;\n/**\n * Check recursively if a type is structuraly equal. Returns early\n */\nfunction value_equals(elementType, a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (!elementType.equals(a[i], b[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.value_equals = value_equals;\nfunction value_defaultValueArray(elementType, length) {\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    values[i] = elementType.defaultValue();\n  }\n  return values;\n}\nexports.value_defaultValueArray = value_defaultValueArray;\n/**\n * @param checkNonDecimalLength Check that length is a multiple of element size.\n * Optional since it's not necessary in getOffsetsArrayComposite() fn.\n */\nfunction assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {\n  if (checkNonDecimalLength && length % 1 !== 0) {\n    throw Error(\"size not multiple of element fixedSize\");\n  }\n  // Vector + List length validation\n  if (arrayProps.isList) {\n    if (length > arrayProps.limit) {\n      throw new Error(\"Invalid list length \".concat(length, \" over limit \").concat(arrayProps.limit));\n    }\n  } else {\n    if (length !== arrayProps.length) {\n      throw new Error(\"Incorrect vector length \".concat(length, \" expected \").concat(arrayProps.length));\n    }\n  }\n}\nexports.assertValidArrayLength = assertValidArrayLength;","map":{"version":3,"sources":["../../src/type/arrayBasic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertValidArrayLength = exports.value_defaultValueArray = exports.value_equals = exports.value_cloneArray = exports.value_toJsonArray = exports.value_fromJsonArray = exports.tree_deserializeFromBytesArrayBasic = exports.tree_serializeToBytesArrayBasic = exports.value_deserializeFromBytesArrayBasic = exports.value_serializeToBytesArrayBasic = exports.setChunksNode = exports.addLengthNode = exports.getChunksNodeFromRootNode = exports.getLengthFromRootNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n// There's a matrix of Array-ish types that require a combination of this functions.\n// Regular class extends syntax doesn't work because it can only extend a single class.\n//\n// Type of array: List, Vector. Changes length property\n// Type of element: Basic, Composite. Changes merkelization if packing or not.\n// If Composite: Fixed len, Variable len. Changes the serialization requiring offsets.\n/**\n * SSZ Lists (variable-length arrays) include the length of the list in the tree\n * This length is always in the same index in the tree\n * ```\n *   1\n *  / \\\n * 2   3 // <-here\n * ```\n */\nfunction getLengthFromRootNode(node) {\n    // Length is represented as a Uint32 at the start of the chunk:\n    // 4 = 4 bytes in Uint32\n    // 0 = 0 offset bytes in Node's data\n    return node.right.getUint(4, 0);\n}\nexports.getLengthFromRootNode = getLengthFromRootNode;\nfunction getChunksNodeFromRootNode(node) {\n    return node.left;\n}\nexports.getChunksNodeFromRootNode = getChunksNodeFromRootNode;\nfunction addLengthNode(chunksNode, length) {\n    return new persistent_merkle_tree_1.BranchNode(chunksNode, persistent_merkle_tree_1.LeafNode.fromUint32(length));\n}\nexports.addLengthNode = addLengthNode;\nfunction setChunksNode(rootNode, chunksNode, newLength) {\n    const lengthNode = newLength !== undefined\n        ? // If newLength is set, create a new node for length\n            persistent_merkle_tree_1.LeafNode.fromUint32(newLength)\n        : // else re-use existing node\n            rootNode.right;\n    return new persistent_merkle_tree_1.BranchNode(chunksNode, lengthNode);\n}\nexports.setChunksNode = setChunksNode;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayBasic(elementType, length, output, offset, value) {\n    const elSize = elementType.byteLength;\n    for (let i = 0; i < length; i++) {\n        elementType.value_serializeToBytes(output, offset + i * elSize, value[i]);\n    }\n    return offset + length * elSize;\n}\nexports.value_serializeToBytesArrayBasic = value_serializeToBytesArrayBasic;\nfunction value_deserializeFromBytesArrayBasic(elementType, data, start, end, arrayProps) {\n    const elSize = elementType.byteLength;\n    // Vector + List length validation\n    const length = (end - start) / elSize;\n    assertValidArrayLength(length, arrayProps, true);\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n        // TODO: If faster, consider skipping size check for uint types\n        values[i] = elementType.value_deserializeFromBytes(data, start + i * elSize, start + (i + 1) * elSize);\n    }\n    return values;\n}\nexports.value_deserializeFromBytesArrayBasic = value_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayBasic(elementType, length, depth, output, offset, node) {\n    const size = elementType.byteLength * length;\n    const chunkCount = Math.ceil(size / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, chunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, size, nodes);\n    return offset + size;\n}\nexports.tree_serializeToBytesArrayBasic = tree_serializeToBytesArrayBasic;\n// List of basic elements will pack them in merkelized form\nfunction tree_deserializeFromBytesArrayBasic(elementType, chunkDepth, data, start, end, arrayProps) {\n    // Vector + List length validation\n    const length = (end - start) / elementType.byteLength;\n    assertValidArrayLength(length, arrayProps, true);\n    // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(chunkDepth, data.dataView, start, end);\n    if (arrayProps.isList) {\n        return addLengthNode(chunksNode, length);\n    }\n    else {\n        return chunksNode;\n    }\n}\nexports.tree_deserializeFromBytesArrayBasic = tree_deserializeFromBytesArrayBasic;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_fromJsonArray(elementType, json, arrayProps) {\n    if (!Array.isArray(json)) {\n        throw Error(\"JSON is not an array\");\n    }\n    assertValidArrayLength(json.length, arrayProps);\n    const value = new Array(json.length);\n    for (let i = 0; i < json.length; i++) {\n        value[i] = elementType.fromJson(json[i]);\n    }\n    return value;\n}\nexports.value_fromJsonArray = value_fromJsonArray;\n/**\n * @param length In List length = undefined, Vector length = fixed value\n */\nfunction value_toJsonArray(elementType, value, arrayProps) {\n    const length = arrayProps.isList ? value.length : arrayProps.length;\n    const json = new Array(length);\n    for (let i = 0; i < length; i++) {\n        json[i] = elementType.toJson(value[i]);\n    }\n    return json;\n}\nexports.value_toJsonArray = value_toJsonArray;\n/**\n * Clone recursively an array of basic or composite types\n */\nfunction value_cloneArray(elementType, value) {\n    const newValue = new Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n        newValue[i] = elementType.clone(value[i]);\n    }\n    return newValue;\n}\nexports.value_cloneArray = value_cloneArray;\n/**\n * Check recursively if a type is structuraly equal. Returns early\n */\nfunction value_equals(elementType, a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (!elementType.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.value_equals = value_equals;\nfunction value_defaultValueArray(elementType, length) {\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n        values[i] = elementType.defaultValue();\n    }\n    return values;\n}\nexports.value_defaultValueArray = value_defaultValueArray;\n/**\n * @param checkNonDecimalLength Check that length is a multiple of element size.\n * Optional since it's not necessary in getOffsetsArrayComposite() fn.\n */\nfunction assertValidArrayLength(length, arrayProps, checkNonDecimalLength) {\n    if (checkNonDecimalLength && length % 1 !== 0) {\n        throw Error(\"size not multiple of element fixedSize\");\n    }\n    // Vector + List length validation\n    if (arrayProps.isList) {\n        if (length > arrayProps.limit) {\n            throw new Error(`Invalid list length ${length} over limit ${arrayProps.limit}`);\n        }\n    }\n    else {\n        if (length !== arrayProps.length) {\n            throw new Error(`Incorrect vector length ${length} expected ${arrayProps.length}`);\n        }\n    }\n}\nexports.assertValidArrayLength = assertValidArrayLength;\n//# sourceMappingURL=arrayBasic.js.map"]},"metadata":{},"sourceType":"script"}