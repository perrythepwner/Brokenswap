{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inputSignFormatter = exports.inputAddressFormatter = exports.outputBigNumberFormatter = exports.outputLogFormatter = exports.hexToNumber = exports.outputBlockFormatter = exports.outputBlockHeaderFormatter = exports.inputBlockNumberFormatter = exports.inputDefaultBlockNumberFormatter = exports.outputCeloTxReceiptFormatter = exports.outputCeloTxFormatter = exports.inputCeloTxFormatter = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar address_2 = require(\"@celo/utils/lib/address\");\nvar solidity_1 = require(\"@celo/utils/lib/solidity\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar utf8_1 = require(\"utf8\");\n/**\n * Formats the input of a transaction and converts all values to HEX\n */\nfunction inputCeloTxFormatter(tx) {\n  var _a, _b, _c, _d;\n  tx.from = inputAddressFormatter((_a = tx.from) === null || _a === void 0 ? void 0 : _a.toString());\n  tx.to = inputAddressFormatter(tx.to);\n  tx.feeCurrency = inputAddressFormatter(tx.feeCurrency);\n  tx.gatewayFeeRecipient = inputAddressFormatter(tx.gatewayFeeRecipient);\n  if (tx.data) {\n    tx.data = (0, address_1.ensureLeading0x)(tx.data);\n  }\n  if (tx.data && !isHex(tx.data)) {\n    throw new Error('The data field must be HEX encoded data.');\n  }\n  tx.gas = numberToHex(tx.gas);\n  tx.gasPrice = numberToHex((_b = tx.gasPrice) === null || _b === void 0 ? void 0 : _b.toString());\n  tx.value = numberToHex((_c = tx.value) === null || _c === void 0 ? void 0 : _c.toString());\n  // @ts-ignore - nonce is defined as number, but uses as string (web3)\n  tx.nonce = numberToHex((_d = tx.nonce) === null || _d === void 0 ? void 0 : _d.toString());\n  tx.gatewayFee = numberToHex(tx.gatewayFee);\n  // @ts-ignore - prune undefines\n  Object.keys(tx).forEach(function (key) {\n    return tx[key] === undefined && delete tx[key];\n  });\n  return tx;\n}\nexports.inputCeloTxFormatter = inputCeloTxFormatter;\nfunction outputCeloTxFormatter(tx) {\n  if (tx.blockNumber !== null) {\n    tx.blockNumber = hexToNumber(tx.blockNumber);\n  }\n  if (tx.transactionIndex !== null) {\n    tx.transactionIndex = hexToNumber(tx.transactionIndex);\n  }\n  tx.nonce = hexToNumber(tx.nonce);\n  tx.gas = hexToNumber(tx.gas);\n  tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);\n  tx.value = outputBigNumberFormatter(tx.value);\n  tx.gatewayFee = outputBigNumberFormatter(tx.gatewayFee);\n  tx.to = tx.to && (0, address_2.isValidAddress)(tx.to) ?\n  // tx.to could be `0x0` or `null` while contract creation\n  tx.to = (0, address_2.toChecksumAddress)(tx.to) : null; // set to `null` if invalid address\n  if (tx.from) {\n    tx.from = (0, address_2.toChecksumAddress)(tx.from);\n  }\n  if (tx.feeCurrency) {\n    tx.feeCurrency = (0, address_2.toChecksumAddress)(tx.feeCurrency);\n  }\n  if (tx.gatewayFeeRecipient) {\n    tx.gatewayFeeRecipient = (0, address_2.toChecksumAddress)(tx.gatewayFeeRecipient);\n  }\n  return tx;\n}\nexports.outputCeloTxFormatter = outputCeloTxFormatter;\nfunction outputCeloTxReceiptFormatter(receipt) {\n  if (typeof receipt !== 'object') {\n    throw new Error('Received receipt is invalid: ' + receipt);\n  }\n  if (receipt.blockNumber !== null) {\n    receipt.blockNumber = hexToNumber(receipt.blockNumber);\n  }\n  if (receipt.transactionIndex !== null) {\n    receipt.transactionIndex = hexToNumber(receipt.transactionIndex);\n  }\n  receipt.cumulativeGasUsed = hexToNumber(receipt.cumulativeGasUsed);\n  receipt.gasUsed = hexToNumber(receipt.gasUsed);\n  if (Array.isArray(receipt.logs)) {\n    receipt.logs = receipt.logs.map(outputLogFormatter);\n  }\n  if (receipt.contractAddress) {\n    receipt.contractAddress = (0, address_2.toChecksumAddress)(receipt.contractAddress);\n  }\n  if (typeof receipt.status !== 'undefined' && receipt.status !== null) {\n    receipt.status = Boolean(parseInt((0, address_1.trimLeading0x)(receipt.status), 10));\n  }\n  return receipt;\n}\nexports.outputCeloTxReceiptFormatter = outputCeloTxReceiptFormatter;\nfunction inputDefaultBlockNumberFormatter(blockNumber) {\n  if (blockNumber == null) {\n    blockNumber = 'latest';\n  }\n  return inputBlockNumberFormatter(blockNumber);\n}\nexports.inputDefaultBlockNumberFormatter = inputDefaultBlockNumberFormatter;\nfunction inputBlockNumberFormatter(blockNumber) {\n  if (blockNumber == null) {\n    return undefined;\n  }\n  if (isPredefinedBlockNumber(blockNumber)) {\n    return blockNumber;\n  }\n  if (blockNumber === 'genesis') {\n    return '0x0';\n  }\n  return isHexStrict(blockNumber.toString()) ? blockNumber.toString().toLocaleLowerCase() : numberToHex(blockNumber.toString());\n}\nexports.inputBlockNumberFormatter = inputBlockNumberFormatter;\nfunction outputBlockHeaderFormatter(blockHeader) {\n  // transform to number\n  blockHeader.gasLimit = hexToNumber(blockHeader.gasLimit);\n  blockHeader.gasUsed = hexToNumber(blockHeader.gasUsed);\n  blockHeader.size = hexToNumber(blockHeader.size);\n  blockHeader.timestamp = hexToNumber(blockHeader.timestamp);\n  if (blockHeader.number !== null) {\n    blockHeader.number = hexToNumber(blockHeader.number);\n  }\n  if (blockHeader.miner) {\n    blockHeader.miner = (0, address_2.toChecksumAddress)(blockHeader.miner);\n  }\n  return blockHeader;\n}\nexports.outputBlockHeaderFormatter = outputBlockHeaderFormatter;\nfunction outputBlockFormatter(block) {\n  block = outputBlockHeaderFormatter(block);\n  if (block.difficulty) {\n    block.difficulty = outputBigNumberFormatter(block.difficulty);\n  }\n  if (block.totalDifficulty) {\n    block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);\n  }\n  if (Array.isArray(block.transactions)) {\n    block.transactions.forEach(function (item) {\n      if (typeof item !== 'string' && !(item instanceof String)) {\n        return outputCeloTxFormatter(item);\n      }\n    });\n  }\n  return block;\n}\nexports.outputBlockFormatter = outputBlockFormatter;\nfunction hexToNumber(hex) {\n  if (hex) {\n    return new bignumber_js_1.default(hex).toNumber();\n  }\n  return undefined;\n}\nexports.hexToNumber = hexToNumber;\nfunction outputLogFormatter(log) {\n  // generate a custom log id\n  if (typeof log.blockHash === 'string' && typeof log.transactionHash === 'string' && typeof log.logIndex === 'string') {\n    var shaId = (0, solidity_1.sha3)((0, address_1.trimLeading0x)(log.blockHash) + (0, address_1.trimLeading0x)(log.transactionHash) + (0, address_1.trimLeading0x)(log.logIndex));\n    log.id = 'log_' + (0, address_1.trimLeading0x)(shaId).substr(0, 8);\n  } else if (!log.id) {\n    log.id = null;\n  }\n  if (log.blockNumber !== null) {\n    log.blockNumber = hexToNumber(log.blockNumber);\n  }\n  if (log.transactionIndex !== null) {\n    log.transactionIndex = hexToNumber(log.transactionIndex);\n  }\n  if (log.logIndex !== null) {\n    log.logIndex = hexToNumber(log.logIndex);\n  }\n  if (log.address) {\n    log.address = (0, address_2.toChecksumAddress)(log.address);\n  }\n  return log;\n}\nexports.outputLogFormatter = outputLogFormatter;\nfunction outputBigNumberFormatter(hex) {\n  return new bignumber_js_1.default(hex).toString(10);\n}\nexports.outputBigNumberFormatter = outputBigNumberFormatter;\nfunction inputAddressFormatter(address) {\n  if (!address || address === '0x') {\n    return undefined;\n  }\n  if ((0, address_2.isValidAddress)(address)) {\n    return (0, address_1.ensureLeading0x)(address).toLocaleLowerCase();\n  }\n  throw new Error(\"Provided address \".concat(address, \" is invalid, the capitalization checksum test failed\"));\n}\nexports.inputAddressFormatter = inputAddressFormatter;\nfunction inputSignFormatter(data) {\n  return isHexStrict(data) ? data : utf8ToHex(data);\n}\nexports.inputSignFormatter = inputSignFormatter;\nfunction utf8ToHex(str) {\n  str = (0, utf8_1.encode)(str);\n  var hex = '';\n  // remove \\u0000 padding from either side\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  for (var i = 0; i < str.length; i++) {\n    var code = str.charCodeAt(i);\n    // if (code !== 0) {\n    var n = code.toString(16);\n    hex += n.length < 2 ? '0' + n : n;\n    // }\n  }\n\n  return (0, address_1.ensureLeading0x)(hex);\n}\nfunction isHex(hex) {\n  return /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n}\nfunction isHexStrict(hex) {\n  return /^(-)?0x[0-9a-f]*$/i.test(hex);\n}\nfunction numberToHex(value) {\n  if (value) {\n    var numberValue = new bignumber_js_1.default(value);\n    var result = (0, address_1.ensureLeading0x)(new bignumber_js_1.default(value).toString(16));\n    // Seen in web3, copied just in case\n    return numberValue.lt(new bignumber_js_1.default(0)) ? \"-\".concat(result) : result;\n  }\n  return undefined;\n}\nfunction isPredefinedBlockNumber(blockNumber) {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';\n}","map":null,"metadata":{},"sourceType":"script"}