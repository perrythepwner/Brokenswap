{"ast":null,"code":"var _wrapRegExp = require(\"/app/node_modules/@babel/runtime/helpers/wrapRegExp.js\").default;\nvar _asyncToGenerator = require(\"/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n/*! For license information please see web3.min.js.LICENSE.txt */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.Web3 = t() : e.Web3 = t();\n}(this, () => (() => {\n  var e = {\n      7256: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (Array.isArray(e)) {\n            const t = [];\n            let n = 0;\n            for (let i = 0; i < e.length; i++) {\n              const o = r(e[i]);\n              t.push(o), n += o.length;\n            }\n            return h(o(n, 192), ...t);\n          }\n          const t = g(e);\n          return 1 === t.length && t[0] < 128 ? t : h(o(t.length, 128), t);\n        }\n        function n(e, t, r) {\n          if (r > e.length) throw new Error(\"invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds\");\n          return e.slice(t, r);\n        }\n        function i(e) {\n          if (0 === e[0]) throw new Error(\"invalid RLP: extra zeros\");\n          return d(u(e));\n        }\n        function o(e, t) {\n          if (e < 56) return Uint8Array.from([e + t]);\n          const r = p(e),\n            n = p(t + 55 + r.length / 2);\n          return Uint8Array.from(l(n + r));\n        }\n        function s(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          if (null == e || 0 === e.length) return Uint8Array.from([]);\n          const r = a(g(e));\n          if (t) return r;\n          if (0 !== r.remainder.length) throw new Error(\"invalid RLP: remainder must be zero\");\n          return r.data;\n        }\n        function a(e) {\n          let t, r, o, s, c;\n          const u = [],\n            d = e[0];\n          if (d <= 127) return {\n            data: e.slice(0, 1),\n            remainder: e.slice(1)\n          };\n          if (d <= 183) {\n            if (t = d - 127, o = 128 === d ? Uint8Array.from([]) : n(e, 1, t), 2 === t && o[0] < 128) throw new Error(\"invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed\");\n            return {\n              data: o,\n              remainder: e.slice(t)\n            };\n          }\n          if (d <= 191) {\n            if (r = d - 182, e.length - 1 < r) throw new Error(\"invalid RLP: not enough bytes for string length\");\n            if (t = i(n(e, 1, r)), t <= 55) throw new Error(\"invalid RLP: expected string length to be greater than 55\");\n            return o = n(e, r, t + r), {\n              data: o,\n              remainder: e.slice(t + r)\n            };\n          }\n          if (d <= 247) {\n            for (t = d - 191, s = n(e, 1, t); s.length;) c = a(s), u.push(c.data), s = c.remainder;\n            return {\n              data: u,\n              remainder: e.slice(t)\n            };\n          }\n          {\n            if (r = d - 246, t = i(n(e, 1, r)), t < 56) throw new Error(\"invalid RLP: encoded list too short\");\n            const o = r + t;\n            if (o > e.length) throw new Error(\"invalid RLP: total length is larger than the data\");\n            for (s = n(e, r, o); s.length;) c = a(s), u.push(c.data), s = c.remainder;\n            return {\n              data: u,\n              remainder: e.slice(o)\n            };\n          }\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RLP = t.utils = t.decode = t.encode = void 0, t.encode = r, t.decode = s;\n        const c = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function u(e) {\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += c[e[r]];\n          return t;\n        }\n        function d(e) {\n          const t = Number.parseInt(e, 16);\n          if (Number.isNaN(t)) throw new Error(\"Invalid byte sequence\");\n          return t;\n        }\n        function l(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r;\n            t[r] = d(e.slice(n, n + 2));\n          }\n          return t;\n        }\n        function h() {\n          for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n            e[_key] = arguments[_key];\n          }\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const i = e[t];\n            r.set(i, n), n += i.length;\n          }\n          return r;\n        }\n        function f(e) {\n          return new TextEncoder().encode(e);\n        }\n        function p(e) {\n          if (e < 0) throw new Error(\"Invalid integer as argument, must be unsigned!\");\n          const t = e.toString(16);\n          return t.length % 2 ? \"0\".concat(t) : t;\n        }\n        function m(e) {\n          return e.length >= 2 && \"0\" === e[0] && \"x\" === e[1];\n        }\n        function g(e) {\n          if (e instanceof Uint8Array) return e;\n          if (\"string\" == typeof e) return m(e) ? l((t = \"string\" != typeof (r = e) ? r : m(r) ? r.slice(2) : r).length % 2 ? \"0\".concat(t) : t) : f(e);\n          var t, r;\n          if (\"number\" == typeof e || \"bigint\" == typeof e) return e ? l(p(e)) : Uint8Array.from([]);\n          if (null == e) return Uint8Array.from([]);\n          throw new Error(\"toBytes: received unsupported type \" + typeof e);\n        }\n        t.utils = {\n          bytesToHex: u,\n          concatBytes: h,\n          hexToBytes: l,\n          utf8ToBytes: f\n        }, t.RLP = {\n          encode: r,\n          decode: s\n        };\n      },\n      5887: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createCurve = t.getHash = void 0;\n        const n = r(1377),\n          i = r(64),\n          o = r(7851);\n        function s(e) {\n          return {\n            hash: e,\n            hmac: function hmac(t) {\n              for (var _len2 = arguments.length, r = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                r[_key2 - 1] = arguments[_key2];\n              }\n              return (0, n.hmac)(e, t, (0, i.concatBytes)(...r));\n            },\n            randomBytes: i.randomBytes\n          };\n        }\n        t.getHash = s, t.createCurve = function (e, t) {\n          const r = t => (0, o.weierstrass)(_objectSpread(_objectSpread({}, e), s(t)));\n          return Object.freeze(_objectSpread(_objectSpread({}, r(t)), {}, {\n            create: r\n          }));\n        };\n      },\n      1465: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateBasic = t.wNAF = void 0;\n        const n = r(9530),\n          i = r(4323),\n          o = BigInt(0),\n          s = BigInt(1);\n        t.wNAF = function (e, t) {\n          const r = (e, t) => {\n              const r = t.negate();\n              return e ? r : t;\n            },\n            n = e => ({\n              windows: Math.ceil(t / e) + 1,\n              windowSize: 2 ** (e - 1)\n            });\n          return {\n            constTimeNegate: r,\n            unsafeLadder(t, r) {\n              let n = e.ZERO,\n                i = t;\n              for (; r > o;) r & s && (n = n.add(i)), i = i.double(), r >>= s;\n              return n;\n            },\n            precomputeWindow(e, t) {\n              const {\n                  windows: r,\n                  windowSize: i\n                } = n(t),\n                o = [];\n              let s = e,\n                a = s;\n              for (let e = 0; e < r; e++) {\n                a = s, o.push(a);\n                for (let e = 1; e < i; e++) a = a.add(s), o.push(a);\n                s = a.double();\n              }\n              return o;\n            },\n            wNAF(t, i, o) {\n              const {\n                windows: a,\n                windowSize: c\n              } = n(t);\n              let u = e.ZERO,\n                d = e.BASE;\n              const l = BigInt(2 ** t - 1),\n                h = 2 ** t,\n                f = BigInt(t);\n              for (let e = 0; e < a; e++) {\n                const t = e * c;\n                let n = Number(o & l);\n                o >>= f, n > c && (n -= h, o += s);\n                const a = t,\n                  p = t + Math.abs(n) - 1,\n                  m = e % 2 != 0,\n                  g = n < 0;\n                0 === n ? d = d.add(r(m, i[a])) : u = u.add(r(g, i[p]));\n              }\n              return {\n                p: u,\n                f: d\n              };\n            },\n            wNAFCached(e, t, r, n) {\n              const i = e._WINDOW_SIZE || 1;\n              let o = t.get(e);\n              return o || (o = this.precomputeWindow(e, i), 1 !== i && t.set(e, n(o))), this.wNAF(i, o, r);\n            }\n          };\n        }, t.validateBasic = function (e) {\n          return (0, n.validateField)(e.Fp), (0, i.validateObject)(e, {\n            n: \"bigint\",\n            h: \"bigint\",\n            Gx: \"field\",\n            Gy: \"field\"\n          }, {\n            nBitLength: \"isSafeInteger\",\n            nByteLength: \"isSafeInteger\"\n          }), Object.freeze(_objectSpread(_objectSpread(_objectSpread({}, (0, n.nLength)(e.n, e.nBitLength)), e), {}, {\n            p: e.Fp.ORDER\n          }));\n        };\n      },\n      1322: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createHasher = t.isogenyMap = t.hash_to_field = t.expand_message_xof = t.expand_message_xmd = void 0;\n        const n = r(9530),\n          i = r(4323),\n          o = i.bytesToNumberBE;\n        function s(e, t) {\n          if (e < 0 || e >= 1 << 8 * t) throw new Error(\"bad I2OSP call: value=\".concat(e, \" length=\").concat(t));\n          const r = Array.from({\n            length: t\n          }).fill(0);\n          for (let n = t - 1; n >= 0; n--) r[n] = 255 & e, e >>>= 8;\n          return new Uint8Array(r);\n        }\n        function a(e, t) {\n          const r = new Uint8Array(e.length);\n          for (let n = 0; n < e.length; n++) r[n] = e[n] ^ t[n];\n          return r;\n        }\n        function c(e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n        }\n        function u(e) {\n          if (!Number.isSafeInteger(e)) throw new Error(\"number expected\");\n        }\n        function d(e, t, r, n) {\n          c(e), c(t), u(r), t.length > 255 && (t = n((0, i.concatBytes)((0, i.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), t)));\n          const {\n              outputLen: o,\n              blockLen: d\n            } = n,\n            l = Math.ceil(r / o);\n          if (l > 255) throw new Error(\"Invalid xmd length\");\n          const h = (0, i.concatBytes)(t, s(t.length, 1)),\n            f = s(0, d),\n            p = s(r, 2),\n            m = new Array(l),\n            g = n((0, i.concatBytes)(f, e, p, s(0, 1), h));\n          m[0] = n((0, i.concatBytes)(g, s(1, 1), h));\n          for (let e = 1; e <= l; e++) {\n            const t = [a(g, m[e - 1]), s(e + 1, 1), h];\n            m[e] = n((0, i.concatBytes)(...t));\n          }\n          return (0, i.concatBytes)(...m).slice(0, r);\n        }\n        function l(e, t, r, n, o) {\n          if (c(e), c(t), u(r), t.length > 255) {\n            const e = Math.ceil(2 * n / 8);\n            t = o.create({\n              dkLen: e\n            }).update((0, i.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(t).digest();\n          }\n          if (r > 65535 || t.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n          return o.create({\n            dkLen: r\n          }).update(e).update(s(r, 2)).update(t).update(s(t.length, 1)).digest();\n        }\n        function h(e, t, r) {\n          (0, i.validateObject)(r, {\n            DST: \"string\",\n            p: \"bigint\",\n            m: \"isSafeInteger\",\n            k: \"isSafeInteger\",\n            hash: \"hash\"\n          });\n          const {\n            p: s,\n            k: a,\n            m: h,\n            hash: f,\n            expand: p,\n            DST: m\n          } = r;\n          c(e), u(t);\n          const g = function (e) {\n              if (e instanceof Uint8Array) return e;\n              if (\"string\" == typeof e) return (0, i.utf8ToBytes)(e);\n              throw new Error(\"DST must be Uint8Array or string\");\n            }(m),\n            y = s.toString(2).length,\n            v = Math.ceil((y + a) / 8),\n            b = t * h * v;\n          let E;\n          if (\"xmd\" === p) E = d(e, g, b, f);else if (\"xof\" === p) E = l(e, g, b, a, f);else {\n            if (\"_internal_pass\" !== p) throw new Error('expand must be \"xmd\" or \"xof\"');\n            E = e;\n          }\n          const _ = new Array(t);\n          for (let e = 0; e < t; e++) {\n            const t = new Array(h);\n            for (let r = 0; r < h; r++) {\n              const i = v * (r + e * h),\n                a = E.subarray(i, i + v);\n              t[r] = (0, n.mod)(o(a), s);\n            }\n            _[e] = t;\n          }\n          return _;\n        }\n        t.expand_message_xmd = d, t.expand_message_xof = l, t.hash_to_field = h, t.isogenyMap = function (e, t) {\n          const r = t.map(e => Array.from(e).reverse());\n          return (t, n) => {\n            const [i, o, s, a] = r.map(r => r.reduce((r, n) => e.add(e.mul(r, t), n)));\n            return t = e.div(i, o), n = e.mul(n, e.div(s, a)), {\n              x: t,\n              y: n\n            };\n          };\n        }, t.createHasher = function (e, t, r) {\n          if (\"function\" != typeof t) throw new Error(\"mapToCurve() must be defined\");\n          return {\n            hashToCurve(n, i) {\n              const o = h(n, 2, _objectSpread(_objectSpread({}, r), {}, {\n                  DST: r.DST\n                }, i)),\n                s = e.fromAffine(t(o[0])),\n                a = e.fromAffine(t(o[1])),\n                c = s.add(a).clearCofactor();\n              return c.assertValidity(), c;\n            },\n            encodeToCurve(n, i) {\n              const o = h(n, 1, _objectSpread(_objectSpread({}, r), {}, {\n                  DST: r.encodeDST\n                }, i)),\n                s = e.fromAffine(t(o[0])).clearCofactor();\n              return s.assertValidity(), s;\n            }\n          };\n        };\n      },\n      9530: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hashToPrivateScalar = t.FpSqrtEven = t.FpSqrtOdd = t.Field = t.nLength = t.FpIsSquare = t.FpDiv = t.FpInvertBatch = t.FpPow = t.validateField = t.isNegativeLE = t.FpSqrt = t.tonelliShanks = t.invert = t.pow2 = t.pow = t.mod = void 0;\n        const n = r(4323),\n          i = BigInt(0),\n          o = BigInt(1),\n          s = BigInt(2),\n          a = BigInt(3),\n          c = BigInt(4),\n          u = BigInt(5),\n          d = BigInt(8);\n        function l(e, t) {\n          const r = e % t;\n          return r >= i ? r : t + r;\n        }\n        function h(e, t, r) {\n          if (r <= i || t < i) throw new Error(\"Expected power/modulo > 0\");\n          if (r === o) return i;\n          let n = o;\n          for (; t > i;) t & o && (n = n * e % r), e = e * e % r, t >>= o;\n          return n;\n        }\n        function f(e, t) {\n          if (e === i || t <= i) throw new Error(\"invert: expected positive integers, got n=\".concat(e, \" mod=\").concat(t));\n          let r = l(e, t),\n            n = t,\n            s = i,\n            a = o,\n            c = o,\n            u = i;\n          for (; r !== i;) {\n            const e = n / r,\n              t = n % r,\n              i = s - c * e,\n              o = a - u * e;\n            n = r, r = t, s = c, a = u, c = i, u = o;\n          }\n          if (n !== o) throw new Error(\"invert: does not exist\");\n          return l(s, t);\n        }\n        function p(e) {\n          const t = (e - o) / s;\n          let r, n, a;\n          for (r = e - o, n = 0; r % s === i; r /= s, n++);\n          for (a = s; a < e && h(a, t, e) !== e - o; a++);\n          if (1 === n) {\n            const t = (e + o) / c;\n            return function (e, r) {\n              const n = e.pow(r, t);\n              if (!e.eql(e.sqr(n), r)) throw new Error(\"Cannot find square root\");\n              return n;\n            };\n          }\n          const u = (r + o) / s;\n          return function (e, i) {\n            if (e.pow(i, t) === e.neg(e.ONE)) throw new Error(\"Cannot find square root\");\n            let s = n,\n              c = e.pow(e.mul(e.ONE, a), r),\n              d = e.pow(i, u),\n              l = e.pow(i, r);\n            for (; !e.eql(l, e.ONE);) {\n              if (e.eql(l, e.ZERO)) return e.ZERO;\n              let t = 1;\n              for (let r = e.sqr(l); t < s && !e.eql(r, e.ONE); t++) r = e.sqr(r);\n              const r = e.pow(c, o << BigInt(s - t - 1));\n              c = e.sqr(r), d = e.mul(d, r), l = e.mul(l, c), s = t;\n            }\n            return d;\n          };\n        }\n        function m(e) {\n          if (e % c === a) {\n            const t = (e + o) / c;\n            return function (e, r) {\n              const n = e.pow(r, t);\n              if (!e.eql(e.sqr(n), r)) throw new Error(\"Cannot find square root\");\n              return n;\n            };\n          }\n          if (e % d === u) {\n            const t = (e - u) / d;\n            return function (e, r) {\n              const n = e.mul(r, s),\n                i = e.pow(n, t),\n                o = e.mul(r, i),\n                a = e.mul(e.mul(o, s), i),\n                c = e.mul(o, e.sub(a, e.ONE));\n              if (!e.eql(e.sqr(c), r)) throw new Error(\"Cannot find square root\");\n              return c;\n            };\n          }\n          return p(e);\n        }\n        BigInt(9), BigInt(16), t.mod = l, t.pow = h, t.pow2 = function (e, t, r) {\n          let n = e;\n          for (; t-- > i;) n *= n, n %= r;\n          return n;\n        }, t.invert = f, t.tonelliShanks = p, t.FpSqrt = m, t.isNegativeLE = (e, t) => (l(e, t) & o) === o;\n        const g = [\"create\", \"isValid\", \"is0\", \"neg\", \"inv\", \"sqrt\", \"sqr\", \"eql\", \"add\", \"sub\", \"mul\", \"pow\", \"div\", \"addN\", \"subN\", \"mulN\", \"sqrN\"];\n        function y(e, t, r) {\n          if (r < i) throw new Error(\"Expected power > 0\");\n          if (r === i) return e.ONE;\n          if (r === o) return t;\n          let n = e.ONE,\n            s = t;\n          for (; r > i;) r & o && (n = e.mul(n, s)), s = e.sqr(s), r >>= o;\n          return n;\n        }\n        function v(e, t) {\n          const r = new Array(t.length),\n            n = t.reduce((t, n, i) => e.is0(n) ? t : (r[i] = t, e.mul(t, n)), e.ONE),\n            i = e.inv(n);\n          return t.reduceRight((t, n, i) => e.is0(n) ? t : (r[i] = e.mul(t, r[i]), e.mul(t, n)), i), r;\n        }\n        function b(e, t) {\n          const r = void 0 !== t ? t : e.toString(2).length;\n          return {\n            nBitLength: r,\n            nByteLength: Math.ceil(r / 8)\n          };\n        }\n        t.validateField = function (e) {\n          const t = g.reduce((e, t) => (e[t] = \"function\", e), {\n            ORDER: \"bigint\",\n            MASK: \"bigint\",\n            BYTES: \"isSafeInteger\",\n            BITS: \"isSafeInteger\"\n          });\n          return (0, n.validateObject)(e, t);\n        }, t.FpPow = y, t.FpInvertBatch = v, t.FpDiv = function (e, t, r) {\n          return e.mul(t, \"bigint\" == typeof r ? f(r, e.ORDER) : e.inv(r));\n        }, t.FpIsSquare = function (e) {\n          const t = (e.ORDER - o) / s;\n          return r => {\n            const n = e.pow(r, t);\n            return e.eql(n, e.ZERO) || e.eql(n, e.ONE);\n          };\n        }, t.nLength = b, t.Field = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          if (e <= i) throw new Error(\"Expected Fp ORDER > 0, got \".concat(e));\n          const {\n            nBitLength: a,\n            nByteLength: c\n          } = b(e, t);\n          if (c > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n          const u = m(e),\n            d = Object.freeze({\n              ORDER: e,\n              BITS: a,\n              BYTES: c,\n              MASK: (0, n.bitMask)(a),\n              ZERO: i,\n              ONE: o,\n              create: t => l(t, e),\n              isValid: t => {\n                if (\"bigint\" != typeof t) throw new Error(\"Invalid field element: expected bigint, got \" + typeof t);\n                return i <= t && t < e;\n              },\n              is0: e => e === i,\n              isOdd: e => (e & o) === o,\n              neg: t => l(-t, e),\n              eql: (e, t) => e === t,\n              sqr: t => l(t * t, e),\n              add: (t, r) => l(t + r, e),\n              sub: (t, r) => l(t - r, e),\n              mul: (t, r) => l(t * r, e),\n              pow: (e, t) => y(d, e, t),\n              div: (t, r) => l(t * f(r, e), e),\n              sqrN: e => e * e,\n              addN: (e, t) => e + t,\n              subN: (e, t) => e - t,\n              mulN: (e, t) => e * t,\n              inv: t => f(t, e),\n              sqrt: s.sqrt || (e => u(d, e)),\n              invertBatch: e => v(d, e),\n              cmov: (e, t, r) => r ? t : e,\n              toBytes: e => r ? (0, n.numberToBytesLE)(e, c) : (0, n.numberToBytesBE)(e, c),\n              fromBytes: e => {\n                if (e.length !== c) throw new Error(\"Fp.fromBytes: expected \".concat(c, \", got \").concat(e.length));\n                return r ? (0, n.bytesToNumberLE)(e) : (0, n.bytesToNumberBE)(e);\n              }\n            });\n          return Object.freeze(d);\n        }, t.FpSqrtOdd = function (e, t) {\n          if (!e.isOdd) throw new Error(\"Field doesn't have isOdd\");\n          const r = e.sqrt(t);\n          return e.isOdd(r) ? r : e.neg(r);\n        }, t.FpSqrtEven = function (e, t) {\n          if (!e.isOdd) throw new Error(\"Field doesn't have isOdd\");\n          const r = e.sqrt(t);\n          return e.isOdd(r) ? e.neg(r) : r;\n        }, t.hashToPrivateScalar = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          const i = (e = (0, n.ensureBytes)(\"privateHash\", e)).length,\n            s = b(t).nByteLength + 8;\n          if (s < 24 || i < s || i > 1024) throw new Error(\"hashToPrivateScalar: expected \".concat(s, \"-1024 bytes of input, got \").concat(i));\n          return l(r ? (0, n.bytesToNumberLE)(e) : (0, n.bytesToNumberBE)(e), t - o) + o;\n        };\n      },\n      4323: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateObject = t.createHmacDrbg = t.bitMask = t.bitSet = t.bitGet = t.bitLen = t.utf8ToBytes = t.equalBytes = t.concatBytes = t.ensureBytes = t.numberToVarBytesBE = t.numberToBytesLE = t.numberToBytesBE = t.bytesToNumberLE = t.bytesToNumberBE = t.hexToBytes = t.hexToNumber = t.numberToHexUnpadded = t.bytesToHex = void 0;\n        const r = BigInt(0),\n          n = BigInt(1),\n          i = BigInt(2),\n          o = e => e instanceof Uint8Array,\n          s = Array.from({\n            length: 256\n          }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function a(e) {\n          if (!o(e)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += s[e[r]];\n          return t;\n        }\n        function c(e) {\n          const t = e.toString(16);\n          return 1 & t.length ? \"0\".concat(t) : t;\n        }\n        function u(e) {\n          if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n          return BigInt(\"\" === e ? \"0\" : \"0x\".concat(e));\n        }\n        function d(e) {\n          if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hex string is invalid: unpadded \" + e.length);\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              i = e.slice(n, n + 2),\n              o = Number.parseInt(i, 16);\n            if (Number.isNaN(o) || o < 0) throw new Error(\"invalid byte sequence\");\n            t[r] = o;\n          }\n          return t;\n        }\n        function l() {\n          for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            e[_key3] = arguments[_key3];\n          }\n          const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0));\n          let r = 0;\n          return e.forEach(e => {\n            if (!o(e)) throw new Error(\"Uint8Array expected\");\n            t.set(e, r), r += e.length;\n          }), t;\n        }\n        t.bytesToHex = a, t.numberToHexUnpadded = c, t.hexToNumber = u, t.hexToBytes = d, t.bytesToNumberBE = function (e) {\n          return u(a(e));\n        }, t.bytesToNumberLE = function (e) {\n          if (!o(e)) throw new Error(\"Uint8Array expected\");\n          return u(a(Uint8Array.from(e).reverse()));\n        }, t.numberToBytesBE = (e, t) => d(e.toString(16).padStart(2 * t, \"0\")), t.numberToBytesLE = (e, r) => (0, t.numberToBytesBE)(e, r).reverse(), t.numberToVarBytesBE = e => d(c(e)), t.ensureBytes = function (e, t, r) {\n          let n;\n          if (\"string\" == typeof t) try {\n            n = d(t);\n          } catch (r) {\n            throw new Error(\"\".concat(e, \" must be valid hex string, got \\\"\").concat(t, \"\\\". Cause: \").concat(r));\n          } else {\n            if (!o(t)) throw new Error(\"\".concat(e, \" must be hex string or Uint8Array\"));\n            n = Uint8Array.from(t);\n          }\n          const i = n.length;\n          if (\"number\" == typeof r && i !== r) throw new Error(\"\".concat(e, \" expected \").concat(r, \" bytes, got \").concat(i));\n          return n;\n        }, t.concatBytes = l, t.equalBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.utf8ToBytes = function (e) {\n          if (\"string\" != typeof e) throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }, t.bitLen = function (e) {\n          let t;\n          for (t = 0; e > r; e >>= n, t += 1);\n          return t;\n        }, t.bitGet = (e, t) => e >> BigInt(t) & n, t.bitSet = (e, t, i) => e | (i ? n : r) << BigInt(t), t.bitMask = e => (i << BigInt(e - 1)) - n;\n        const h = e => new Uint8Array(e),\n          f = e => Uint8Array.from(e);\n        t.createHmacDrbg = function (e, t, r) {\n          if (\"number\" != typeof e || e < 2) throw new Error(\"hashLen must be a number\");\n          if (\"number\" != typeof t || t < 2) throw new Error(\"qByteLen must be a number\");\n          if (\"function\" != typeof r) throw new Error(\"hmacFn must be a function\");\n          let n = h(e),\n            i = h(e),\n            o = 0;\n          const s = () => {\n              n.fill(1), i.fill(0), o = 0;\n            },\n            a = function a() {\n              for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                e[_key4] = arguments[_key4];\n              }\n              return r(i, n, ...e);\n            },\n            c = function c() {\n              let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : h();\n              i = a(f([0]), e), n = a(), 0 !== e.length && (i = a(f([1]), e), n = a());\n            },\n            u = () => {\n              if (o++ >= 1e3) throw new Error(\"drbg: tried 1000 values\");\n              let e = 0;\n              const r = [];\n              for (; e < t;) {\n                n = a();\n                const t = n.slice();\n                r.push(t), e += n.length;\n              }\n              return l(...r);\n            };\n          return (e, t) => {\n            let r;\n            for (s(), c(e); !(r = t(u()));) c();\n            return s(), r;\n          };\n        };\n        const p = {\n          bigint: e => \"bigint\" == typeof e,\n          function: e => \"function\" == typeof e,\n          boolean: e => \"boolean\" == typeof e,\n          string: e => \"string\" == typeof e,\n          isSafeInteger: e => Number.isSafeInteger(e),\n          array: e => Array.isArray(e),\n          field: (e, t) => t.Fp.isValid(e),\n          hash: e => \"function\" == typeof e && Number.isSafeInteger(e.outputLen)\n        };\n        t.validateObject = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          const n = (t, r, n) => {\n            const i = p[r];\n            if (\"function\" != typeof i) throw new Error(\"Invalid validator \\\"\".concat(r, \"\\\", expected function\"));\n            const o = e[t];\n            if (!(n && void 0 === o || i(o, e))) throw new Error(\"Invalid param \".concat(String(t), \"=\").concat(o, \" (\").concat(typeof o, \"), expected \").concat(r));\n          };\n          for (const [e, r] of Object.entries(t)) n(e, r, !1);\n          for (const [e, t] of Object.entries(r)) n(e, t, !0);\n          return e;\n        };\n      },\n      7851: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.mapToCurveSimpleSWU = t.SWUFpSqrtRatio = t.weierstrass = t.weierstrassPoints = t.DER = void 0;\n        const n = r(9530),\n          i = r(4323),\n          o = r(4323),\n          s = r(1465),\n          {\n            bytesToNumberBE: a,\n            hexToBytes: c\n          } = i;\n        t.DER = {\n          Err: class extends Error {\n            constructor() {\n              let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n              super(e);\n            }\n          },\n          _parseInt(e) {\n            const {\n              Err: r\n            } = t.DER;\n            if (e.length < 2 || 2 !== e[0]) throw new r(\"Invalid signature integer tag\");\n            const n = e[1],\n              i = e.subarray(2, n + 2);\n            if (!n || i.length !== n) throw new r(\"Invalid signature integer: wrong length\");\n            if (128 & i[0]) throw new r(\"Invalid signature integer: negative\");\n            if (0 === i[0] && !(128 & i[1])) throw new r(\"Invalid signature integer: unnecessary leading zero\");\n            return {\n              d: a(i),\n              l: e.subarray(n + 2)\n            };\n          },\n          toSig(e) {\n            const {\n                Err: r\n              } = t.DER,\n              n = \"string\" == typeof e ? c(e) : e;\n            if (!(n instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n            let i = n.length;\n            if (i < 2 || 48 != n[0]) throw new r(\"Invalid signature tag\");\n            if (n[1] !== i - 2) throw new r(\"Invalid signature: incorrect length\");\n            const {\n                d: o,\n                l: s\n              } = t.DER._parseInt(n.subarray(2)),\n              {\n                d: a,\n                l: u\n              } = t.DER._parseInt(s);\n            if (u.length) throw new r(\"Invalid signature: left bytes after parsing\");\n            return {\n              r: o,\n              s: a\n            };\n          },\n          hexFromSig(e) {\n            const t = e => 8 & Number.parseInt(e[0], 16) ? \"00\" + e : e,\n              r = e => {\n                const t = e.toString(16);\n                return 1 & t.length ? \"0\".concat(t) : t;\n              },\n              n = t(r(e.s)),\n              i = t(r(e.r)),\n              o = n.length / 2,\n              s = i.length / 2,\n              a = r(o),\n              c = r(s);\n            return \"30\".concat(r(s + o + 4), \"02\").concat(c).concat(i, \"02\").concat(a).concat(n);\n          }\n        };\n        const u = BigInt(0),\n          d = BigInt(1),\n          l = BigInt(2),\n          h = BigInt(3),\n          f = BigInt(4);\n        function p(e) {\n          const t = function (e) {\n              const t = (0, s.validateBasic)(e);\n              i.validateObject(t, {\n                a: \"field\",\n                b: \"field\"\n              }, {\n                allowedPrivateKeyLengths: \"array\",\n                wrapPrivateKey: \"boolean\",\n                isTorsionFree: \"function\",\n                clearCofactor: \"function\",\n                allowInfinityPoint: \"boolean\",\n                fromBytes: \"function\",\n                toBytes: \"function\"\n              });\n              const {\n                endo: r,\n                Fp: n,\n                a: o\n              } = t;\n              if (r) {\n                if (!n.eql(o, n.ZERO)) throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n                if (\"object\" != typeof r || \"bigint\" != typeof r.beta || \"function\" != typeof r.splitScalar) throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n              }\n              return Object.freeze(_objectSpread({}, t));\n            }(e),\n            {\n              Fp: r\n            } = t,\n            a = t.toBytes || ((e, t, n) => {\n              const o = t.toAffine();\n              return i.concatBytes(Uint8Array.from([4]), r.toBytes(o.x), r.toBytes(o.y));\n            }),\n            c = t.fromBytes || (e => {\n              const t = e.subarray(1);\n              return {\n                x: r.fromBytes(t.subarray(0, r.BYTES)),\n                y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES))\n              };\n            });\n          function l(e) {\n            const {\n                a: n,\n                b: i\n              } = t,\n              o = r.sqr(e),\n              s = r.mul(o, e);\n            return r.add(r.add(s, r.mul(e, n)), i);\n          }\n          if (!r.eql(r.sqr(t.Gy), l(t.Gx))) throw new Error(\"bad generator point: equation left != right\");\n          function f(e) {\n            return \"bigint\" == typeof e && u < e && e < t.n;\n          }\n          function p(e) {\n            if (!f(e)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n          }\n          function m(e) {\n            const {\n              allowedPrivateKeyLengths: r,\n              nByteLength: s,\n              wrapPrivateKey: a,\n              n: c\n            } = t;\n            if (r && \"bigint\" != typeof e) {\n              if (e instanceof Uint8Array && (e = i.bytesToHex(e)), \"string\" != typeof e || !r.includes(e.length)) throw new Error(\"Invalid key\");\n              e = e.padStart(2 * s, \"0\");\n            }\n            let u;\n            try {\n              u = \"bigint\" == typeof e ? e : i.bytesToNumberBE((0, o.ensureBytes)(\"private key\", e, s));\n            } catch (t) {\n              throw new Error(\"private key must be \".concat(s, \" bytes, hex or bigint, not \").concat(typeof e));\n            }\n            return a && (u = n.mod(u, c)), p(u), u;\n          }\n          const g = new Map();\n          function y(e) {\n            if (!(e instanceof v)) throw new Error(\"ProjectivePoint expected\");\n          }\n          class v {\n            constructor(e, t, n) {\n              if (this.px = e, this.py = t, this.pz = n, null == e || !r.isValid(e)) throw new Error(\"x required\");\n              if (null == t || !r.isValid(t)) throw new Error(\"y required\");\n              if (null == n || !r.isValid(n)) throw new Error(\"z required\");\n            }\n            static fromAffine(e) {\n              const {\n                x: t,\n                y: n\n              } = e || {};\n              if (!e || !r.isValid(t) || !r.isValid(n)) throw new Error(\"invalid affine point\");\n              if (e instanceof v) throw new Error(\"projective point not allowed\");\n              const i = e => r.eql(e, r.ZERO);\n              return i(t) && i(n) ? v.ZERO : new v(t, n, r.ONE);\n            }\n            get x() {\n              return this.toAffine().x;\n            }\n            get y() {\n              return this.toAffine().y;\n            }\n            static normalizeZ(e) {\n              const t = r.invertBatch(e.map(e => e.pz));\n              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);\n            }\n            static fromHex(e) {\n              const t = v.fromAffine(c((0, o.ensureBytes)(\"pointHex\", e)));\n              return t.assertValidity(), t;\n            }\n            static fromPrivateKey(e) {\n              return v.BASE.multiply(m(e));\n            }\n            _setWindowSize(e) {\n              this._WINDOW_SIZE = e, g.delete(this);\n            }\n            assertValidity() {\n              if (this.is0()) {\n                if (t.allowInfinityPoint) return;\n                throw new Error(\"bad point: ZERO\");\n              }\n              const {\n                x: e,\n                y: n\n              } = this.toAffine();\n              if (!r.isValid(e) || !r.isValid(n)) throw new Error(\"bad point: x or y not FE\");\n              const i = r.sqr(n),\n                o = l(e);\n              if (!r.eql(i, o)) throw new Error(\"bad point: equation left != right\");\n              if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n            }\n            hasEvenY() {\n              const {\n                y: e\n              } = this.toAffine();\n              if (r.isOdd) return !r.isOdd(e);\n              throw new Error(\"Field doesn't support isOdd\");\n            }\n            equals(e) {\n              y(e);\n              const {\n                  px: t,\n                  py: n,\n                  pz: i\n                } = this,\n                {\n                  px: o,\n                  py: s,\n                  pz: a\n                } = e,\n                c = r.eql(r.mul(t, a), r.mul(o, i)),\n                u = r.eql(r.mul(n, a), r.mul(s, i));\n              return c && u;\n            }\n            negate() {\n              return new v(this.px, r.neg(this.py), this.pz);\n            }\n            double() {\n              const {\n                  a: e,\n                  b: n\n                } = t,\n                i = r.mul(n, h),\n                {\n                  px: o,\n                  py: s,\n                  pz: a\n                } = this;\n              let c = r.ZERO,\n                u = r.ZERO,\n                d = r.ZERO,\n                l = r.mul(o, o),\n                f = r.mul(s, s),\n                p = r.mul(a, a),\n                m = r.mul(o, s);\n              return m = r.add(m, m), d = r.mul(o, a), d = r.add(d, d), c = r.mul(e, d), u = r.mul(i, p), u = r.add(c, u), c = r.sub(f, u), u = r.add(f, u), u = r.mul(c, u), c = r.mul(m, c), d = r.mul(i, d), p = r.mul(e, p), m = r.sub(l, p), m = r.mul(e, m), m = r.add(m, d), d = r.add(l, l), l = r.add(d, l), l = r.add(l, p), l = r.mul(l, m), u = r.add(u, l), p = r.mul(s, a), p = r.add(p, p), l = r.mul(p, m), c = r.sub(c, l), d = r.mul(p, f), d = r.add(d, d), d = r.add(d, d), new v(c, u, d);\n            }\n            add(e) {\n              y(e);\n              const {\n                  px: n,\n                  py: i,\n                  pz: o\n                } = this,\n                {\n                  px: s,\n                  py: a,\n                  pz: c\n                } = e;\n              let u = r.ZERO,\n                d = r.ZERO,\n                l = r.ZERO;\n              const f = t.a,\n                p = r.mul(t.b, h);\n              let m = r.mul(n, s),\n                g = r.mul(i, a),\n                b = r.mul(o, c),\n                E = r.add(n, i),\n                _ = r.add(s, a);\n              E = r.mul(E, _), _ = r.add(m, g), E = r.sub(E, _), _ = r.add(n, o);\n              let A = r.add(s, c);\n              return _ = r.mul(_, A), A = r.add(m, b), _ = r.sub(_, A), A = r.add(i, o), u = r.add(a, c), A = r.mul(A, u), u = r.add(g, b), A = r.sub(A, u), l = r.mul(f, _), u = r.mul(p, b), l = r.add(u, l), u = r.sub(g, l), l = r.add(g, l), d = r.mul(u, l), g = r.add(m, m), g = r.add(g, m), b = r.mul(f, b), _ = r.mul(p, _), g = r.add(g, b), b = r.sub(m, b), b = r.mul(f, b), _ = r.add(_, b), m = r.mul(g, _), d = r.add(d, m), m = r.mul(A, _), u = r.mul(E, u), u = r.sub(u, m), m = r.mul(E, g), l = r.mul(A, l), l = r.add(l, m), new v(u, d, l);\n            }\n            subtract(e) {\n              return this.add(e.negate());\n            }\n            is0() {\n              return this.equals(v.ZERO);\n            }\n            wNAF(e) {\n              return E.wNAFCached(this, g, e, e => {\n                const t = r.invertBatch(e.map(e => e.pz));\n                return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);\n              });\n            }\n            multiplyUnsafe(e) {\n              const n = v.ZERO;\n              if (e === u) return n;\n              if (p(e), e === d) return this;\n              const {\n                endo: i\n              } = t;\n              if (!i) return E.unsafeLadder(this, e);\n              let {\n                  k1neg: o,\n                  k1: s,\n                  k2neg: a,\n                  k2: c\n                } = i.splitScalar(e),\n                l = n,\n                h = n,\n                f = this;\n              for (; s > u || c > u;) s & d && (l = l.add(f)), c & d && (h = h.add(f)), f = f.double(), s >>= d, c >>= d;\n              return o && (l = l.negate()), a && (h = h.negate()), h = new v(r.mul(h.px, i.beta), h.py, h.pz), l.add(h);\n            }\n            multiply(e) {\n              p(e);\n              let n,\n                i,\n                o = e;\n              const {\n                endo: s\n              } = t;\n              if (s) {\n                const {\n                  k1neg: e,\n                  k1: t,\n                  k2neg: a,\n                  k2: c\n                } = s.splitScalar(o);\n                let {\n                    p: u,\n                    f: d\n                  } = this.wNAF(t),\n                  {\n                    p: l,\n                    f: h\n                  } = this.wNAF(c);\n                u = E.constTimeNegate(e, u), l = E.constTimeNegate(a, l), l = new v(r.mul(l.px, s.beta), l.py, l.pz), n = u.add(l), i = d.add(h);\n              } else {\n                const {\n                  p: e,\n                  f: t\n                } = this.wNAF(o);\n                n = e, i = t;\n              }\n              return v.normalizeZ([n, i])[0];\n            }\n            multiplyAndAddUnsafe(e, t, r) {\n              const n = v.BASE,\n                i = (e, t) => t !== u && t !== d && e.equals(n) ? e.multiply(t) : e.multiplyUnsafe(t),\n                o = i(this, t).add(i(e, r));\n              return o.is0() ? void 0 : o;\n            }\n            toAffine(e) {\n              const {\n                  px: t,\n                  py: n,\n                  pz: i\n                } = this,\n                o = this.is0();\n              null == e && (e = o ? r.ONE : r.inv(i));\n              const s = r.mul(t, e),\n                a = r.mul(n, e),\n                c = r.mul(i, e);\n              if (o) return {\n                x: r.ZERO,\n                y: r.ZERO\n              };\n              if (!r.eql(c, r.ONE)) throw new Error(\"invZ was invalid\");\n              return {\n                x: s,\n                y: a\n              };\n            }\n            isTorsionFree() {\n              const {\n                h: e,\n                isTorsionFree: r\n              } = t;\n              if (e === d) return !0;\n              if (r) return r(v, this);\n              throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n            }\n            clearCofactor() {\n              const {\n                h: e,\n                clearCofactor: r\n              } = t;\n              return e === d ? this : r ? r(v, this) : this.multiplyUnsafe(t.h);\n            }\n            toRawBytes() {\n              let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n              return this.assertValidity(), a(v, this, e);\n            }\n            toHex() {\n              let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n              return i.bytesToHex(this.toRawBytes(e));\n            }\n          }\n          v.BASE = new v(t.Gx, t.Gy, r.ONE), v.ZERO = new v(r.ZERO, r.ONE, r.ZERO);\n          const b = t.nBitLength,\n            E = (0, s.wNAF)(v, t.endo ? Math.ceil(b / 2) : b);\n          return {\n            CURVE: t,\n            ProjectivePoint: v,\n            normPrivateKeyToScalar: m,\n            weierstrassEquation: l,\n            isWithinCurveOrder: f\n          };\n        }\n        function m(e, t) {\n          const r = e.ORDER;\n          let n = u;\n          for (let e = r - d; e % l === u; e /= l) n += d;\n          const i = n,\n            o = (r - d) / l ** i,\n            s = (o - d) / l,\n            a = l ** i - d,\n            c = l ** (i - d),\n            p = e.pow(t, o),\n            m = e.pow(t, (o + d) / l);\n          let g = (t, r) => {\n            let n = p,\n              o = e.pow(r, a),\n              u = e.sqr(o);\n            u = e.mul(u, r);\n            let h = e.mul(t, u);\n            h = e.pow(h, s), h = e.mul(h, o), o = e.mul(h, r), u = e.mul(h, t);\n            let f = e.mul(u, o);\n            h = e.pow(f, c);\n            let g = e.eql(h, e.ONE);\n            o = e.mul(u, m), h = e.mul(f, n), u = e.cmov(o, u, g), f = e.cmov(h, f, g);\n            for (let t = i; t > d; t--) {\n              let r = l ** (t - l),\n                i = e.pow(f, r);\n              const s = e.eql(i, e.ONE);\n              o = e.mul(u, n), n = e.mul(n, n), i = e.mul(f, n), u = e.cmov(o, u, s), f = e.cmov(i, f, s);\n            }\n            return {\n              isValid: g,\n              value: u\n            };\n          };\n          if (e.ORDER % f === h) {\n            const r = (e.ORDER - h) / f,\n              n = e.sqrt(e.neg(t));\n            g = (t, i) => {\n              let o = e.sqr(i);\n              const s = e.mul(t, i);\n              o = e.mul(o, s);\n              let a = e.pow(o, r);\n              a = e.mul(a, s);\n              const c = e.mul(a, n),\n                u = e.mul(e.sqr(a), i),\n                d = e.eql(u, t);\n              return {\n                isValid: d,\n                value: e.cmov(c, a, d)\n              };\n            };\n          }\n          return g;\n        }\n        t.weierstrassPoints = p, t.weierstrass = function (e) {\n          const r = function (e) {\n              const t = (0, s.validateBasic)(e);\n              return i.validateObject(t, {\n                hash: \"hash\",\n                hmac: \"function\",\n                randomBytes: \"function\"\n              }, {\n                bits2int: \"function\",\n                bits2int_modN: \"function\",\n                lowS: \"boolean\"\n              }), Object.freeze(_objectSpread({\n                lowS: !0\n              }, t));\n            }(e),\n            {\n              Fp: a,\n              n: c\n            } = r,\n            l = a.BYTES + 1,\n            h = 2 * a.BYTES + 1;\n          function f(e) {\n            return n.mod(e, c);\n          }\n          function m(e) {\n            return n.invert(e, c);\n          }\n          const {\n              ProjectivePoint: g,\n              normPrivateKeyToScalar: y,\n              weierstrassEquation: v,\n              isWithinCurveOrder: b\n            } = p(_objectSpread(_objectSpread({}, r), {}, {\n              toBytes(e, t, r) {\n                const n = t.toAffine(),\n                  o = a.toBytes(n.x),\n                  s = i.concatBytes;\n                return r ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o) : s(Uint8Array.from([4]), o, a.toBytes(n.y));\n              },\n              fromBytes(e) {\n                const t = e.length,\n                  r = e[0],\n                  n = e.subarray(1);\n                if (t !== l || 2 !== r && 3 !== r) {\n                  if (t === h && 4 === r) return {\n                    x: a.fromBytes(n.subarray(0, a.BYTES)),\n                    y: a.fromBytes(n.subarray(a.BYTES, 2 * a.BYTES))\n                  };\n                  throw new Error(\"Point of length \".concat(t, \" was invalid. Expected \").concat(l, \" compressed bytes or \").concat(h, \" uncompressed bytes\"));\n                }\n                {\n                  const e = i.bytesToNumberBE(n);\n                  if (!(u < (o = e) && o < a.ORDER)) throw new Error(\"Point is not on curve\");\n                  const t = v(e);\n                  let s = a.sqrt(t);\n                  return 1 == (1 & r) != ((s & d) === d) && (s = a.neg(s)), {\n                    x: e,\n                    y: s\n                  };\n                }\n                var o;\n              }\n            })),\n            E = e => i.bytesToHex(i.numberToBytesBE(e, r.nByteLength));\n          function _(e) {\n            return e > c >> d;\n          }\n          const A = (e, t, r) => i.bytesToNumberBE(e.slice(t, r));\n          class T {\n            constructor(e, t, r) {\n              this.r = e, this.s = t, this.recovery = r, this.assertValidity();\n            }\n            static fromCompact(e) {\n              const t = r.nByteLength;\n              return e = (0, o.ensureBytes)(\"compactSignature\", e, 2 * t), new T(A(e, 0, t), A(e, t, 2 * t));\n            }\n            static fromDER(e) {\n              const {\n                r,\n                s: n\n              } = t.DER.toSig((0, o.ensureBytes)(\"DER\", e));\n              return new T(r, n);\n            }\n            assertValidity() {\n              if (!b(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n              if (!b(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n            }\n            addRecoveryBit(e) {\n              return new T(this.r, this.s, e);\n            }\n            recoverPublicKey(e) {\n              const {\n                  r: t,\n                  s: n,\n                  recovery: i\n                } = this,\n                s = P((0, o.ensureBytes)(\"msgHash\", e));\n              if (null == i || ![0, 1, 2, 3].includes(i)) throw new Error(\"recovery id invalid\");\n              const c = 2 === i || 3 === i ? t + r.n : t;\n              if (c >= a.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n              const u = 0 == (1 & i) ? \"02\" : \"03\",\n                d = g.fromHex(u + E(c)),\n                l = m(c),\n                h = f(-s * l),\n                p = f(n * l),\n                y = g.BASE.multiplyAndAddUnsafe(d, h, p);\n              if (!y) throw new Error(\"point at infinify\");\n              return y.assertValidity(), y;\n            }\n            hasHighS() {\n              return _(this.s);\n            }\n            normalizeS() {\n              return this.hasHighS() ? new T(this.r, f(-this.s), this.recovery) : this;\n            }\n            toDERRawBytes() {\n              return i.hexToBytes(this.toDERHex());\n            }\n            toDERHex() {\n              return t.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n              });\n            }\n            toCompactRawBytes() {\n              return i.hexToBytes(this.toCompactHex());\n            }\n            toCompactHex() {\n              return E(this.r) + E(this.s);\n            }\n          }\n          const I = {\n            isValidPrivateKey(e) {\n              try {\n                return y(e), !0;\n              } catch (e) {\n                return !1;\n              }\n            },\n            normPrivateKeyToScalar: y,\n            randomPrivateKey: () => {\n              const e = r.randomBytes(a.BYTES + 8),\n                t = n.hashToPrivateScalar(e, c);\n              return i.numberToBytesBE(t, r.nByteLength);\n            },\n            precompute: function precompute() {\n              let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n              let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : g.BASE;\n              return t._setWindowSize(e), t.multiply(BigInt(3)), t;\n            }\n          };\n          function R(e) {\n            const t = e instanceof Uint8Array,\n              r = \"string\" == typeof e,\n              n = (t || r) && e.length;\n            return t ? n === l || n === h : r ? n === 2 * l || n === 2 * h : e instanceof g;\n          }\n          const w = r.bits2int || function (e) {\n              const t = i.bytesToNumberBE(e),\n                n = 8 * e.length - r.nBitLength;\n              return n > 0 ? t >> BigInt(n) : t;\n            },\n            P = r.bits2int_modN || function (e) {\n              return f(w(e));\n            },\n            x = i.bitMask(r.nBitLength);\n          function S(e) {\n            if (\"bigint\" != typeof e) throw new Error(\"bigint expected\");\n            if (!(u <= e && e < x)) throw new Error(\"bigint expected < 2^\".concat(r.nBitLength));\n            return i.numberToBytesBE(e, r.nByteLength);\n          }\n          const O = {\n              lowS: r.lowS,\n              prehash: !1\n            },\n            C = {\n              lowS: r.lowS,\n              prehash: !1\n            };\n          return g.BASE._setWindowSize(8), {\n            CURVE: r,\n            getPublicKey: function getPublicKey(e) {\n              let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n              return g.fromPrivateKey(e).toRawBytes(t);\n            },\n            getSharedSecret: function getSharedSecret(e, t) {\n              let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n              if (R(e)) throw new Error(\"first arg must be private key\");\n              if (!R(t)) throw new Error(\"second arg must be public key\");\n              return g.fromHex(t).multiply(y(e)).toRawBytes(r);\n            },\n            sign: function sign(e, t) {\n              let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : O;\n              const {\n                seed: s,\n                k2sig: c\n              } = function (e, t) {\n                let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : O;\n                if ([\"recovered\", \"canonical\"].some(e => e in n)) throw new Error(\"sign() legacy options not supported\");\n                const {\n                  hash: s,\n                  randomBytes: c\n                } = r;\n                let {\n                  lowS: l,\n                  prehash: h,\n                  extraEntropy: p\n                } = n;\n                null == l && (l = !0), e = (0, o.ensureBytes)(\"msgHash\", e), h && (e = (0, o.ensureBytes)(\"prehashed msgHash\", s(e)));\n                const v = P(e),\n                  E = y(t),\n                  A = [S(E), S(v)];\n                if (null != p) {\n                  const e = !0 === p ? c(a.BYTES) : p;\n                  A.push((0, o.ensureBytes)(\"extraEntropy\", e, a.BYTES));\n                }\n                const I = i.concatBytes(...A),\n                  R = v;\n                return {\n                  seed: I,\n                  k2sig: function k2sig(e) {\n                    const t = w(e);\n                    if (!b(t)) return;\n                    const r = m(t),\n                      n = g.BASE.multiply(t).toAffine(),\n                      i = f(n.x);\n                    if (i === u) return;\n                    const o = f(r * f(R + i * E));\n                    if (o === u) return;\n                    let s = (n.x === i ? 0 : 2) | Number(n.y & d),\n                      a = o;\n                    return l && _(o) && (a = function (e) {\n                      return _(e) ? f(-e) : e;\n                    }(o), s ^= 1), new T(i, a, s);\n                  }\n                };\n              }(e, t, n);\n              return i.createHmacDrbg(r.hash.outputLen, r.nByteLength, r.hmac)(s, c);\n            },\n            verify: function verify(e, n, i) {\n              var _g$BASE$multiplyAndAd;\n              let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : C;\n              const a = e;\n              if (n = (0, o.ensureBytes)(\"msgHash\", n), i = (0, o.ensureBytes)(\"publicKey\", i), \"strict\" in s) throw new Error(\"options.strict was renamed to lowS\");\n              const {\n                lowS: c,\n                prehash: u\n              } = s;\n              let d, l;\n              try {\n                if (\"string\" == typeof a || a instanceof Uint8Array) try {\n                  d = T.fromDER(a);\n                } catch (e) {\n                  if (!(e instanceof t.DER.Err)) throw e;\n                  d = T.fromCompact(a);\n                } else {\n                  if (\"object\" != typeof a || \"bigint\" != typeof a.r || \"bigint\" != typeof a.s) throw new Error(\"PARSE\");\n                  {\n                    const {\n                      r: e,\n                      s: t\n                    } = a;\n                    d = new T(e, t);\n                  }\n                }\n                l = g.fromHex(i);\n              } catch (e) {\n                if (\"PARSE\" === e.message) throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n                return !1;\n              }\n              if (c && d.hasHighS()) return !1;\n              u && (n = r.hash(n));\n              const {\n                  r: h,\n                  s: p\n                } = d,\n                y = P(n),\n                v = m(p),\n                b = f(y * v),\n                E = f(h * v),\n                _ = (_g$BASE$multiplyAndAd = g.BASE.multiplyAndAddUnsafe(l, b, E)) === null || _g$BASE$multiplyAndAd === void 0 ? void 0 : _g$BASE$multiplyAndAd.toAffine();\n              return !!_ && f(_.x) === h;\n            },\n            ProjectivePoint: g,\n            Signature: T,\n            utils: I\n          };\n        }, t.SWUFpSqrtRatio = m, t.mapToCurveSimpleSWU = function (e, t) {\n          if (n.validateField(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n          const r = m(e, t.Z);\n          if (!e.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n          return n => {\n            let i, o, s, a, c, u, d, l;\n            i = e.sqr(n), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), s = e.add(o, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), a = e.mul(a, t.A), o = e.sqr(s), u = e.sqr(a), c = e.mul(u, t.A), o = e.add(o, c), o = e.mul(o, s), u = e.mul(u, a), c = e.mul(u, t.B), o = e.add(o, c), d = e.mul(i, s);\n            const {\n              isValid: h,\n              value: f\n            } = r(o, u);\n            l = e.mul(i, n), l = e.mul(l, f), d = e.cmov(d, s, h), l = e.cmov(l, f, h);\n            const p = e.isOdd(n) === e.isOdd(l);\n            return l = e.cmov(e.neg(l), l, p), d = e.div(d, a), {\n              x: d,\n              y: l\n            };\n          };\n        };\n      },\n      8358: (e, t, r) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0;\n        const i = r(6053),\n          o = r(64),\n          s = r(9530),\n          a = r(7851),\n          c = r(4323),\n          u = r(1322),\n          d = r(5887),\n          l = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n          h = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n          f = BigInt(1),\n          p = BigInt(2),\n          m = (e, t) => (e + t / p) / t;\n        function g(e) {\n          const t = l,\n            r = BigInt(3),\n            n = BigInt(6),\n            i = BigInt(11),\n            o = BigInt(22),\n            a = BigInt(23),\n            c = BigInt(44),\n            u = BigInt(88),\n            d = e * e * e % t,\n            h = d * d * e % t,\n            f = (0, s.pow2)(h, r, t) * h % t,\n            m = (0, s.pow2)(f, r, t) * h % t,\n            g = (0, s.pow2)(m, p, t) * d % t,\n            v = (0, s.pow2)(g, i, t) * g % t,\n            b = (0, s.pow2)(v, o, t) * v % t,\n            E = (0, s.pow2)(b, c, t) * b % t,\n            _ = (0, s.pow2)(E, u, t) * E % t,\n            A = (0, s.pow2)(_, c, t) * b % t,\n            T = (0, s.pow2)(A, r, t) * h % t,\n            I = (0, s.pow2)(T, a, t) * v % t,\n            R = (0, s.pow2)(I, n, t) * d % t,\n            w = (0, s.pow2)(R, p, t);\n          if (!y.eql(y.sqr(w), e)) throw new Error(\"Cannot find square root\");\n          return w;\n        }\n        const y = (0, s.Field)(l, void 0, void 0, {\n          sqrt: g\n        });\n        t.secp256k1 = (0, d.createCurve)({\n          a: BigInt(0),\n          b: BigInt(7),\n          Fp: y,\n          n: h,\n          Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n          Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n          h: BigInt(1),\n          lowS: !0,\n          endo: {\n            beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n            splitScalar: e => {\n              const t = h,\n                r = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),\n                n = -f * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"),\n                i = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),\n                o = r,\n                a = BigInt(\"0x100000000000000000000000000000000\"),\n                c = m(o * e, t),\n                u = m(-n * e, t);\n              let d = (0, s.mod)(e - c * r - u * i, t),\n                l = (0, s.mod)(-c * n - u * o, t);\n              const p = d > a,\n                g = l > a;\n              if (p && (d = t - d), g && (l = t - l), d > a || l > a) throw new Error(\"splitScalar: Endomorphism failed, k=\" + e);\n              return {\n                k1neg: p,\n                k1: d,\n                k2neg: g,\n                k2: l\n              };\n            }\n          }\n        }, i.sha256);\n        const v = BigInt(0),\n          b = e => \"bigint\" == typeof e && v < e && e < l,\n          E = {};\n        function _(e) {\n          let r = E[e];\n          if (void 0 === r) {\n            const t = (0, i.sha256)(Uint8Array.from(e, e => e.charCodeAt(0)));\n            r = (0, c.concatBytes)(t, t), E[e] = r;\n          }\n          for (var _len5 = arguments.length, t = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n            t[_key5 - 1] = arguments[_key5];\n          }\n          return (0, i.sha256)((0, c.concatBytes)(r, ...t));\n        }\n        const A = e => e.toRawBytes(!0).slice(1),\n          T = e => (0, c.numberToBytesBE)(e, 32),\n          I = e => (0, s.mod)(e, l),\n          R = e => (0, s.mod)(e, h),\n          w = t.secp256k1.ProjectivePoint;\n        function P(e) {\n          let r = t.secp256k1.utils.normPrivateKeyToScalar(e),\n            n = w.fromPrivateKey(r);\n          return {\n            scalar: n.hasEvenY() ? r : R(-r),\n            bytes: A(n)\n          };\n        }\n        function x(e) {\n          if (!b(e)) throw new Error(\"bad x: need 0 < x < p\");\n          const t = I(e * e);\n          let r = g(I(t * e + BigInt(7)));\n          r % p !== v && (r = I(-r));\n          const n = new w(e, r, f);\n          return n.assertValidity(), n;\n        }\n        function S() {\n          for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n            e[_key6] = arguments[_key6];\n          }\n          return R((0, c.bytesToNumberBE)(_(\"BIP0340/challenge\", ...e)));\n        }\n        function O(e, t, r) {\n          const n = (0, c.ensureBytes)(\"signature\", e, 64),\n            i = (0, c.ensureBytes)(\"message\", t),\n            o = (0, c.ensureBytes)(\"publicKey\", r, 32);\n          try {\n            const e = x((0, c.bytesToNumberBE)(o)),\n              t = (0, c.bytesToNumberBE)(n.subarray(0, 32));\n            if (!b(t)) return !1;\n            const r = (0, c.bytesToNumberBE)(n.subarray(32, 64));\n            if (!(\"bigint\" == typeof (d = r) && v < d && d < h)) return !1;\n            const l = S(T(t), A(e), i),\n              f = (s = e, a = r, u = R(-l), w.BASE.multiplyAndAddUnsafe(s, a, u));\n            return !(!f || !f.hasEvenY() || f.toAffine().x !== t);\n          } catch (e) {\n            return !1;\n          }\n          var s, a, u, d;\n        }\n        t.schnorr = {\n          getPublicKey: function getPublicKey(e) {\n            return P(e).bytes;\n          },\n          sign: function sign(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, o.randomBytes)(32);\n            const n = (0, c.ensureBytes)(\"message\", e),\n              {\n                bytes: i,\n                scalar: s\n              } = P(t),\n              a = (0, c.ensureBytes)(\"auxRand\", r, 32),\n              u = T(s ^ (0, c.bytesToNumberBE)(_(\"BIP0340/aux\", a))),\n              d = _(\"BIP0340/nonce\", u, i, n),\n              l = R((0, c.bytesToNumberBE)(d));\n            if (l === v) throw new Error(\"sign failed: k is zero\");\n            const {\n                bytes: h,\n                scalar: f\n              } = P(l),\n              p = S(h, i, n),\n              m = new Uint8Array(64);\n            if (m.set(h, 0), m.set(T(R(f + p * s)), 32), !O(m, n, i)) throw new Error(\"sign: Invalid signature produced\");\n            return m;\n          },\n          verify: O,\n          utils: {\n            randomPrivateKey: t.secp256k1.utils.randomPrivateKey,\n            lift_x: x,\n            pointToBytes: A,\n            numberToBytesBE: c.numberToBytesBE,\n            bytesToNumberBE: c.bytesToNumberBE,\n            taggedHash: _,\n            mod: s.mod\n          }\n        };\n        const C = u.isogenyMap(y, [[\"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\", \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\", \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\", \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"], [\"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\", \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\", \"0x0000000000000000000000000000000000000000000000000000000000000001\"], [\"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\", \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\", \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\", \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"], [\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\", \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\", \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\", \"0x0000000000000000000000000000000000000000000000000000000000000001\"]].map(e => e.map(e => BigInt(e)))),\n          B = (0, a.mapToCurveSimpleSWU)(y, {\n            A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n            B: BigInt(\"1771\"),\n            Z: y.create(BigInt(\"-11\"))\n          });\n        n = u.createHasher(t.secp256k1.ProjectivePoint, e => {\n          const {\n            x: t,\n            y: r\n          } = B(y.create(e[0]));\n          return C(t, r);\n        }, {\n          DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n          encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n          p: y.ORDER,\n          m: 1,\n          k: 128,\n          expand: \"xmd\",\n          hash: i.sha256\n        }), t.hashToCurve = n.hashToCurve, t.encodeToCurve = n.encodeToCurve;\n      },\n      3525: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(\"Wrong positive integer: \".concat(e));\n        }\n        function n(e) {\n          if (\"boolean\" != typeof e) throw new Error(\"Expected boolean, not \".concat(e));\n        }\n        function i(e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n          for (var _len7 = arguments.length, t = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n            t[_key7 - 1] = arguments[_key7];\n          }\n          if (t.length > 0 && !t.includes(e.length)) throw new TypeError(\"Expected Uint8Array of length \".concat(t, \", not of length=\").concat(e.length));\n        }\n        function o(e) {\n          if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n          r(e.outputLen), r(e.blockLen);\n        }\n        function s(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n          if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n        }\n        function a(e, t) {\n          i(e);\n          const r = t.outputLen;\n          if (e.length < r) throw new Error(\"digestInto() expects output buffer of length at least \".concat(r));\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0, t.number = r, t.bool = n, t.bytes = i, t.hash = o, t.exists = s, t.output = a;\n        const c = {\n          number: r,\n          bool: n,\n          bytes: i,\n          hash: o,\n          exists: s,\n          output: a\n        };\n        t.default = c;\n      },\n      9350: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SHA2 = void 0;\n        const n = r(3525),\n          i = r(64);\n        class o extends i.Hash {\n          constructor(e, t, r, n) {\n            super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, i.createView)(this.buffer);\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                view: t,\n                buffer: r,\n                blockLen: o\n              } = this,\n              s = (e = (0, i.toBytes)(e)).length;\n            for (let n = 0; n < s;) {\n              const a = Math.min(o - this.pos, s - n);\n              if (a !== o) r.set(e.subarray(n, n + a), this.pos), this.pos += a, n += a, this.pos === o && (this.process(t, 0), this.pos = 0);else {\n                const t = (0, i.createView)(e);\n                for (; o <= s - n; n += o) this.process(t, n);\n              }\n            }\n            return this.length += e.length, this.roundClean(), this;\n          }\n          digestInto(e) {\n            n.default.exists(this), n.default.output(e, this), this.finished = !0;\n            const {\n              buffer: t,\n              view: r,\n              blockLen: o,\n              isLE: s\n            } = this;\n            let {\n              pos: a\n            } = this;\n            t[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > o - a && (this.process(r, 0), a = 0);\n            for (let e = a; e < o; e++) t[e] = 0;\n            !function (e, t, r, n) {\n              if (\"function\" == typeof e.setBigUint64) return e.setBigUint64(t, r, n);\n              const i = BigInt(32),\n                o = BigInt(4294967295),\n                s = Number(r >> i & o),\n                a = Number(r & o),\n                c = n ? 4 : 0,\n                u = n ? 0 : 4;\n              e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);\n            }(r, o - 8, BigInt(8 * this.length), s), this.process(r, 0);\n            const c = (0, i.createView)(e),\n              u = this.outputLen;\n            if (u % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n            const d = u / 4,\n              l = this.get();\n            if (d > l.length) throw new Error(\"_sha2: outputLen bigger than state\");\n            for (let e = 0; e < d; e++) c.setUint32(4 * e, l[e], s);\n          }\n          digest() {\n            const {\n              buffer: e,\n              outputLen: t\n            } = this;\n            this.digestInto(e);\n            const r = e.slice(0, t);\n            return this.destroy(), r;\n          }\n          _cloneInto(e) {\n            e || (e = new this.constructor()), e.set(...this.get());\n            const {\n              blockLen: t,\n              buffer: r,\n              length: n,\n              finished: i,\n              destroyed: o,\n              pos: s\n            } = this;\n            return e.length = n, e.pos = s, e.finished = i, e.destroyed = o, n % t && e.buffer.set(r), e;\n          }\n        }\n        t.SHA2 = o;\n      },\n      1655: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.add = t.toBig = t.split = t.fromBig = void 0;\n        const r = BigInt(2 ** 32 - 1),\n          n = BigInt(32);\n        function i(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          return t ? {\n            h: Number(e & r),\n            l: Number(e >> n & r)\n          } : {\n            h: 0 | Number(e >> n & r),\n            l: 0 | Number(e & r)\n          };\n        }\n        function o(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          let r = new Uint32Array(e.length),\n            n = new Uint32Array(e.length);\n          for (let o = 0; o < e.length; o++) {\n            const {\n              h: s,\n              l: a\n            } = i(e[o], t);\n            [r[o], n[o]] = [s, a];\n          }\n          return [r, n];\n        }\n        function s(e, t, r, n) {\n          const i = (t >>> 0) + (n >>> 0);\n          return {\n            h: e + r + (i / 2 ** 32 | 0) | 0,\n            l: 0 | i\n          };\n        }\n        t.fromBig = i, t.split = o, t.toBig = (e, t) => BigInt(e >>> 0) << n | BigInt(t >>> 0), t.add = s;\n        const a = {\n          fromBig: i,\n          split: o,\n          toBig: t.toBig,\n          shrSH: (e, t, r) => e >>> r,\n          shrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrSH: (e, t, r) => e >>> r | t << 32 - r,\n          rotrSL: (e, t, r) => e << 32 - r | t >>> r,\n          rotrBH: (e, t, r) => e << 64 - r | t >>> r - 32,\n          rotrBL: (e, t, r) => e >>> r - 32 | t << 64 - r,\n          rotr32H: (e, t) => t,\n          rotr32L: (e, t) => e,\n          rotlSH: (e, t, r) => e << r | t >>> 32 - r,\n          rotlSL: (e, t, r) => t << r | e >>> 32 - r,\n          rotlBH: (e, t, r) => t << r - 32 | e >>> 64 - r,\n          rotlBL: (e, t, r) => e << r - 32 | t >>> 64 - r,\n          add: s,\n          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),\n          add3H: (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0,\n          add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),\n          add4H: (e, t, r, n, i) => t + r + n + i + (e / 2 ** 32 | 0) | 0,\n          add5H: (e, t, r, n, i, o) => t + r + n + i + o + (e / 2 ** 32 | 0) | 0,\n          add5L: (e, t, r, n, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0)\n        };\n        t.default = a;\n      },\n      825: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = void 0, t.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n      },\n      1377: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hmac = void 0;\n        const n = r(3525),\n          i = r(64);\n        class o extends i.Hash {\n          constructor(e, t) {\n            super(), this.finished = !1, this.destroyed = !1, n.default.hash(e);\n            const r = (0, i.toBytes)(t);\n            if (this.iHash = e.create(), \"function\" != typeof this.iHash.update) throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n            const o = this.blockLen,\n              s = new Uint8Array(o);\n            s.set(r.length > o ? e.create().update(r).digest() : r);\n            for (let e = 0; e < s.length; e++) s[e] ^= 54;\n            this.iHash.update(s), this.oHash = e.create();\n            for (let e = 0; e < s.length; e++) s[e] ^= 106;\n            this.oHash.update(s), s.fill(0);\n          }\n          update(e) {\n            return n.default.exists(this), this.iHash.update(e), this;\n          }\n          digestInto(e) {\n            n.default.exists(this), n.default.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n          }\n          digest() {\n            const e = new Uint8Array(this.oHash.outputLen);\n            return this.digestInto(e), e;\n          }\n          _cloneInto(e) {\n            e || (e = Object.create(Object.getPrototypeOf(this), {}));\n            const {\n              oHash: t,\n              iHash: r,\n              finished: n,\n              destroyed: i,\n              blockLen: o,\n              outputLen: s\n            } = this;\n            return e.finished = n, e.destroyed = i, e.blockLen = o, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;\n          }\n          destroy() {\n            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n          }\n        }\n        t.hmac = (e, t, r) => new o(e, t).update(r).digest(), t.hmac.create = (e, t) => new o(e, t);\n      },\n      9179: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.pbkdf2Async = t.pbkdf2 = void 0;\n        const n = r(3525),\n          i = r(1377),\n          o = r(64);\n        function s(e, t, r, s) {\n          n.default.hash(e);\n          const a = (0, o.checkOpts)({\n              dkLen: 32,\n              asyncTick: 10\n            }, s),\n            {\n              c,\n              dkLen: u,\n              asyncTick: d\n            } = a;\n          if (n.default.number(c), n.default.number(u), n.default.number(d), c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n          const l = (0, o.toBytes)(t),\n            h = (0, o.toBytes)(r),\n            f = new Uint8Array(u),\n            p = i.hmac.create(e, l),\n            m = p._cloneInto().update(h);\n          return {\n            c,\n            dkLen: u,\n            asyncTick: d,\n            DK: f,\n            PRF: p,\n            PRFSalt: m\n          };\n        }\n        function a(e, t, r, n, i) {\n          return e.destroy(), t.destroy(), n && n.destroy(), i.fill(0), r;\n        }\n        t.pbkdf2 = function (e, t, r, n) {\n          const {\n            c: i,\n            dkLen: c,\n            DK: u,\n            PRF: d,\n            PRFSalt: l\n          } = s(e, t, r, n);\n          let h;\n          const f = new Uint8Array(4),\n            p = (0, o.createView)(f),\n            m = new Uint8Array(d.outputLen);\n          for (let e = 1, t = 0; t < c; e++, t += d.outputLen) {\n            const r = u.subarray(t, t + d.outputLen);\n            p.setInt32(0, e, !1), (h = l._cloneInto(h)).update(f).digestInto(m), r.set(m.subarray(0, r.length));\n            for (let e = 1; e < i; e++) {\n              d._cloneInto(h).update(m).digestInto(m);\n              for (let e = 0; e < r.length; e++) r[e] ^= m[e];\n            }\n          }\n          return a(d, l, u, h, m);\n        }, t.pbkdf2Async = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (e, t, r, n) {\n            const {\n              c: i,\n              dkLen: c,\n              asyncTick: u,\n              DK: d,\n              PRF: l,\n              PRFSalt: h\n            } = s(e, t, r, n);\n            let f;\n            const p = new Uint8Array(4),\n              m = (0, o.createView)(p),\n              g = new Uint8Array(l.outputLen);\n            for (let e = 1, t = 0; t < c; e++, t += l.outputLen) {\n              const r = d.subarray(t, t + l.outputLen);\n              m.setInt32(0, e, !1), (f = h._cloneInto(f)).update(p).digestInto(g), r.set(g.subarray(0, r.length)), yield (0, o.asyncLoop)(i - 1, u, e => {\n                l._cloneInto(f).update(g).digestInto(g);\n                for (let e = 0; e < r.length; e++) r[e] ^= g[e];\n              });\n            }\n            return a(l, h, d, f, g);\n          });\n          return function (_x, _x2, _x3, _x4) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n      },\n      2739: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.scryptAsync = t.scrypt = void 0;\n        const n = r(3525),\n          i = r(6053),\n          o = r(9179),\n          s = r(64),\n          a = (e, t) => e << t | e >>> 32 - t;\n        function c(e, t, r, n, i, o) {\n          let s = e[t++] ^ r[n++],\n            c = e[t++] ^ r[n++],\n            u = e[t++] ^ r[n++],\n            d = e[t++] ^ r[n++],\n            l = e[t++] ^ r[n++],\n            h = e[t++] ^ r[n++],\n            f = e[t++] ^ r[n++],\n            p = e[t++] ^ r[n++],\n            m = e[t++] ^ r[n++],\n            g = e[t++] ^ r[n++],\n            y = e[t++] ^ r[n++],\n            v = e[t++] ^ r[n++],\n            b = e[t++] ^ r[n++],\n            E = e[t++] ^ r[n++],\n            _ = e[t++] ^ r[n++],\n            A = e[t++] ^ r[n++],\n            T = s,\n            I = c,\n            R = u,\n            w = d,\n            P = l,\n            x = h,\n            S = f,\n            O = p,\n            C = m,\n            B = g,\n            N = y,\n            k = v,\n            M = b,\n            D = E,\n            L = _,\n            F = A;\n          for (let e = 0; e < 8; e += 2) P ^= a(T + M | 0, 7), C ^= a(P + T | 0, 9), M ^= a(C + P | 0, 13), T ^= a(M + C | 0, 18), B ^= a(x + I | 0, 7), D ^= a(B + x | 0, 9), I ^= a(D + B | 0, 13), x ^= a(I + D | 0, 18), L ^= a(N + S | 0, 7), R ^= a(L + N | 0, 9), S ^= a(R + L | 0, 13), N ^= a(S + R | 0, 18), w ^= a(F + k | 0, 7), O ^= a(w + F | 0, 9), k ^= a(O + w | 0, 13), F ^= a(k + O | 0, 18), I ^= a(T + w | 0, 7), R ^= a(I + T | 0, 9), w ^= a(R + I | 0, 13), T ^= a(w + R | 0, 18), S ^= a(x + P | 0, 7), O ^= a(S + x | 0, 9), P ^= a(O + S | 0, 13), x ^= a(P + O | 0, 18), k ^= a(N + B | 0, 7), C ^= a(k + N | 0, 9), B ^= a(C + k | 0, 13), N ^= a(B + C | 0, 18), M ^= a(F + L | 0, 7), D ^= a(M + F | 0, 9), L ^= a(D + M | 0, 13), F ^= a(L + D | 0, 18);\n          i[o++] = s + T | 0, i[o++] = c + I | 0, i[o++] = u + R | 0, i[o++] = d + w | 0, i[o++] = l + P | 0, i[o++] = h + x | 0, i[o++] = f + S | 0, i[o++] = p + O | 0, i[o++] = m + C | 0, i[o++] = g + B | 0, i[o++] = y + N | 0, i[o++] = v + k | 0, i[o++] = b + M | 0, i[o++] = E + D | 0, i[o++] = _ + L | 0, i[o++] = A + F | 0;\n        }\n        function u(e, t, r, n, i) {\n          let o = n + 0,\n            s = n + 16 * i;\n          for (let n = 0; n < 16; n++) r[s + n] = e[t + 16 * (2 * i - 1) + n];\n          for (let n = 0; n < i; n++, o += 16, t += 16) c(r, s, e, t, r, o), n > 0 && (s += 16), c(r, o, e, t += 16, r, s);\n        }\n        function d(e, t, r) {\n          const a = (0, s.checkOpts)({\n              dkLen: 32,\n              asyncTick: 10,\n              maxmem: 1073742848\n            }, r),\n            {\n              N: c,\n              r: u,\n              p: d,\n              dkLen: l,\n              asyncTick: h,\n              maxmem: f,\n              onProgress: p\n            } = a;\n          if (n.default.number(c), n.default.number(u), n.default.number(d), n.default.number(l), n.default.number(h), n.default.number(f), void 0 !== p && \"function\" != typeof p) throw new Error(\"progressCb should be function\");\n          const m = 128 * u,\n            g = m / 4;\n          if (c <= 1 || 0 != (c & c - 1) || c >= 2 ** (m / 8) || c > 2 ** 32) throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");\n          if (d < 0 || d > 137438953440 / m) throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");\n          if (l < 0 || l > 137438953440) throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");\n          const y = m * (c + d);\n          if (y > f) throw new Error(\"Scrypt: parameters too large, \".concat(y, \" (128 * r * (N + p)) > \").concat(f, \" (maxmem)\"));\n          const v = (0, o.pbkdf2)(i.sha256, e, t, {\n              c: 1,\n              dkLen: m * d\n            }),\n            b = (0, s.u32)(v),\n            E = (0, s.u32)(new Uint8Array(m * c)),\n            _ = (0, s.u32)(new Uint8Array(m));\n          let A = () => {};\n          if (p) {\n            const e = 2 * c * d,\n              t = Math.max(Math.floor(e / 1e4), 1);\n            let r = 0;\n            A = () => {\n              r++, !p || r % t && r !== e || p(r / e);\n            };\n          }\n          return {\n            N: c,\n            r: u,\n            p: d,\n            dkLen: l,\n            blockSize32: g,\n            V: E,\n            B32: b,\n            B: v,\n            tmp: _,\n            blockMixCb: A,\n            asyncTick: h\n          };\n        }\n        function l(e, t, r, n, s) {\n          const a = (0, o.pbkdf2)(i.sha256, e, r, {\n            c: 1,\n            dkLen: t\n          });\n          return r.fill(0), n.fill(0), s.fill(0), a;\n        }\n        t.scrypt = function (e, t, r) {\n          const {\n            N: n,\n            r: i,\n            p: o,\n            dkLen: s,\n            blockSize32: a,\n            V: c,\n            B32: h,\n            B: f,\n            tmp: p,\n            blockMixCb: m\n          } = d(e, t, r);\n          for (let e = 0; e < o; e++) {\n            const t = a * e;\n            for (let e = 0; e < a; e++) c[e] = h[t + e];\n            for (let e = 0, t = 0; e < n - 1; e++) u(c, t, c, t += a, i), m();\n            u(c, (n - 1) * a, h, t, i), m();\n            for (let e = 0; e < n; e++) {\n              const e = h[t + a - 16] % n;\n              for (let r = 0; r < a; r++) p[r] = h[t + r] ^ c[e * a + r];\n              u(p, 0, h, t, i), m();\n            }\n          }\n          return l(e, s, f, c, p);\n        }, t.scryptAsync = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (e, t, r) {\n            const {\n              N: n,\n              r: i,\n              p: o,\n              dkLen: a,\n              blockSize32: c,\n              V: h,\n              B32: f,\n              B: p,\n              tmp: m,\n              blockMixCb: g,\n              asyncTick: y\n            } = d(e, t, r);\n            for (let e = 0; e < o; e++) {\n              const t = c * e;\n              for (let e = 0; e < c; e++) h[e] = f[t + e];\n              let r = 0;\n              yield (0, s.asyncLoop)(n - 1, y, e => {\n                u(h, r, h, r += c, i), g();\n              }), u(h, (n - 1) * c, f, t, i), g(), yield (0, s.asyncLoop)(n, y, e => {\n                const r = f[t + c - 16] % n;\n                for (let e = 0; e < c; e++) m[e] = f[t + e] ^ h[r * c + e];\n                u(m, 0, f, t, i), g();\n              });\n            }\n            return l(e, a, p, h, m);\n          });\n          return function (_x5, _x6, _x7) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n      },\n      6053: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sha224 = t.sha256 = void 0;\n        const n = r(9350),\n          i = r(64),\n          o = (e, t, r) => e & t ^ e & r ^ t & r,\n          s = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),\n          a = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),\n          c = new Uint32Array(64);\n        class u extends n.SHA2 {\n          constructor() {\n            super(64, 32, 8, !1), this.A = 0 | a[0], this.B = 0 | a[1], this.C = 0 | a[2], this.D = 0 | a[3], this.E = 0 | a[4], this.F = 0 | a[5], this.G = 0 | a[6], this.H = 0 | a[7];\n          }\n          get() {\n            const {\n              A: e,\n              B: t,\n              C: r,\n              D: n,\n              E: i,\n              F: o,\n              G: s,\n              H: a\n            } = this;\n            return [e, t, r, n, i, o, s, a];\n          }\n          set(e, t, r, n, i, o, s, a) {\n            this.A = 0 | e, this.B = 0 | t, this.C = 0 | r, this.D = 0 | n, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a;\n          }\n          process(e, t) {\n            for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t, !1);\n            for (let e = 16; e < 64; e++) {\n              const t = c[e - 15],\n                r = c[e - 2],\n                n = (0, i.rotr)(t, 7) ^ (0, i.rotr)(t, 18) ^ t >>> 3,\n                o = (0, i.rotr)(r, 17) ^ (0, i.rotr)(r, 19) ^ r >>> 10;\n              c[e] = o + c[e - 7] + n + c[e - 16] | 0;\n            }\n            let {\n              A: r,\n              B: n,\n              C: a,\n              D: u,\n              E: d,\n              F: l,\n              G: h,\n              H: f\n            } = this;\n            for (let e = 0; e < 64; e++) {\n              const t = f + ((0, i.rotr)(d, 6) ^ (0, i.rotr)(d, 11) ^ (0, i.rotr)(d, 25)) + ((p = d) & l ^ ~p & h) + s[e] + c[e] | 0,\n                m = ((0, i.rotr)(r, 2) ^ (0, i.rotr)(r, 13) ^ (0, i.rotr)(r, 22)) + o(r, n, a) | 0;\n              f = h, h = l, l = d, d = u + t | 0, u = a, a = n, n = r, r = t + m | 0;\n            }\n            var p;\n            r = r + this.A | 0, n = n + this.B | 0, a = a + this.C | 0, u = u + this.D | 0, d = d + this.E | 0, l = l + this.F | 0, h = h + this.G | 0, f = f + this.H | 0, this.set(r, n, a, u, d, l, h, f);\n          }\n          roundClean() {\n            c.fill(0);\n          }\n          destroy() {\n            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n          }\n        }\n        class d extends u {\n          constructor() {\n            super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n          }\n        }\n        t.sha256 = (0, i.wrapConstructor)(() => new u()), t.sha224 = (0, i.wrapConstructor)(() => new d());\n      },\n      125: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.shake256 = t.shake128 = t.keccak_512 = t.keccak_384 = t.keccak_256 = t.keccak_224 = t.sha3_512 = t.sha3_384 = t.sha3_256 = t.sha3_224 = t.Keccak = t.keccakP = void 0;\n        const n = r(3525),\n          i = r(1655),\n          o = r(64),\n          [s, a, c] = [[], [], []],\n          u = BigInt(0),\n          d = BigInt(1),\n          l = BigInt(2),\n          h = BigInt(7),\n          f = BigInt(256),\n          p = BigInt(113);\n        for (let e = 0, t = d, r = 1, n = 0; e < 24; e++) {\n          [r, n] = [n, (2 * r + 3 * n) % 5], s.push(2 * (5 * n + r)), a.push((e + 1) * (e + 2) / 2 % 64);\n          let i = u;\n          for (let e = 0; e < 7; e++) t = (t << d ^ (t >> h) * p) % f, t & l && (i ^= d << (d << BigInt(e)) - d);\n          c.push(i);\n        }\n        const [m, g] = i.default.split(c, !0),\n          y = (e, t, r) => r > 32 ? i.default.rotlBH(e, t, r) : i.default.rotlSH(e, t, r),\n          v = (e, t, r) => r > 32 ? i.default.rotlBL(e, t, r) : i.default.rotlSL(e, t, r);\n        function b(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;\n          const r = new Uint32Array(10);\n          for (let n = 24 - t; n < 24; n++) {\n            for (let t = 0; t < 10; t++) r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];\n            for (let t = 0; t < 10; t += 2) {\n              const n = (t + 8) % 10,\n                i = (t + 2) % 10,\n                o = r[i],\n                s = r[i + 1],\n                a = y(o, s, 1) ^ r[n],\n                c = v(o, s, 1) ^ r[n + 1];\n              for (let r = 0; r < 50; r += 10) e[t + r] ^= a, e[t + r + 1] ^= c;\n            }\n            let t = e[2],\n              i = e[3];\n            for (let r = 0; r < 24; r++) {\n              const n = a[r],\n                o = y(t, i, n),\n                c = v(t, i, n),\n                u = s[r];\n              t = e[u], i = e[u + 1], e[u] = o, e[u + 1] = c;\n            }\n            for (let t = 0; t < 50; t += 10) {\n              for (let n = 0; n < 10; n++) r[n] = e[t + n];\n              for (let n = 0; n < 10; n++) e[t + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10];\n            }\n            e[0] ^= m[n], e[1] ^= g[n];\n          }\n          r.fill(0);\n        }\n        t.keccakP = b;\n        class E extends o.Hash {\n          constructor(e, t, r) {\n            let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n            let s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;\n            if (super(), this.blockLen = e, this.suffix = t, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, n.default.number(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n            this.state = new Uint8Array(200), this.state32 = (0, o.u32)(this.state);\n          }\n          keccak() {\n            b(this.state32, this.rounds), this.posOut = 0, this.pos = 0;\n          }\n          update(e) {\n            n.default.exists(this);\n            const {\n                blockLen: t,\n                state: r\n              } = this,\n              i = (e = (0, o.toBytes)(e)).length;\n            for (let n = 0; n < i;) {\n              const o = Math.min(t - this.pos, i - n);\n              for (let t = 0; t < o; t++) r[this.pos++] ^= e[n++];\n              this.pos === t && this.keccak();\n            }\n            return this;\n          }\n          finish() {\n            if (this.finished) return;\n            this.finished = !0;\n            const {\n              state: e,\n              suffix: t,\n              pos: r,\n              blockLen: n\n            } = this;\n            e[r] ^= t, 0 != (128 & t) && r === n - 1 && this.keccak(), e[n - 1] ^= 128, this.keccak();\n          }\n          writeInto(e) {\n            n.default.exists(this, !1), n.default.bytes(e), this.finish();\n            const t = this.state,\n              {\n                blockLen: r\n              } = this;\n            for (let n = 0, i = e.length; n < i;) {\n              this.posOut >= r && this.keccak();\n              const o = Math.min(r - this.posOut, i - n);\n              e.set(t.subarray(this.posOut, this.posOut + o), n), this.posOut += o, n += o;\n            }\n            return e;\n          }\n          xofInto(e) {\n            if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n            return this.writeInto(e);\n          }\n          xof(e) {\n            return n.default.number(e), this.xofInto(new Uint8Array(e));\n          }\n          digestInto(e) {\n            if (n.default.output(e, this), this.finished) throw new Error(\"digest() was already called\");\n            return this.writeInto(e), this.destroy(), e;\n          }\n          digest() {\n            return this.digestInto(new Uint8Array(this.outputLen));\n          }\n          destroy() {\n            this.destroyed = !0, this.state.fill(0);\n          }\n          _cloneInto(e) {\n            const {\n              blockLen: t,\n              suffix: r,\n              outputLen: n,\n              rounds: i,\n              enableXOF: o\n            } = this;\n            return e || (e = new E(t, r, n, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = r, e.outputLen = n, e.enableXOF = o, e.destroyed = this.destroyed, e;\n          }\n        }\n        t.Keccak = E;\n        const _ = (e, t, r) => (0, o.wrapConstructor)(() => new E(t, e, r));\n        t.sha3_224 = _(6, 144, 28), t.sha3_256 = _(6, 136, 32), t.sha3_384 = _(6, 104, 48), t.sha3_512 = _(6, 72, 64), t.keccak_224 = _(1, 144, 28), t.keccak_256 = _(1, 136, 32), t.keccak_384 = _(1, 104, 48), t.keccak_512 = _(1, 72, 64);\n        const A = (e, t, r) => (0, o.wrapConstructorWithOpts)(function () {\n          let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return new E(t, e, void 0 === n.dkLen ? r : n.dkLen, !0);\n        });\n        t.shake128 = A(31, 168, 16), t.shake256 = A(31, 136, 32);\n      },\n      2540: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sha384 = t.sha512_256 = t.sha512_224 = t.sha512 = t.SHA512 = void 0;\n        const n = r(9350),\n          i = r(1655),\n          o = r(64),\n          [s, a] = i.default.split([\"0x428a2f98d728ae22\", \"0x7137449123ef65cd\", \"0xb5c0fbcfec4d3b2f\", \"0xe9b5dba58189dbbc\", \"0x3956c25bf348b538\", \"0x59f111f1b605d019\", \"0x923f82a4af194f9b\", \"0xab1c5ed5da6d8118\", \"0xd807aa98a3030242\", \"0x12835b0145706fbe\", \"0x243185be4ee4b28c\", \"0x550c7dc3d5ffb4e2\", \"0x72be5d74f27b896f\", \"0x80deb1fe3b1696b1\", \"0x9bdc06a725c71235\", \"0xc19bf174cf692694\", \"0xe49b69c19ef14ad2\", \"0xefbe4786384f25e3\", \"0x0fc19dc68b8cd5b5\", \"0x240ca1cc77ac9c65\", \"0x2de92c6f592b0275\", \"0x4a7484aa6ea6e483\", \"0x5cb0a9dcbd41fbd4\", \"0x76f988da831153b5\", \"0x983e5152ee66dfab\", \"0xa831c66d2db43210\", \"0xb00327c898fb213f\", \"0xbf597fc7beef0ee4\", \"0xc6e00bf33da88fc2\", \"0xd5a79147930aa725\", \"0x06ca6351e003826f\", \"0x142929670a0e6e70\", \"0x27b70a8546d22ffc\", \"0x2e1b21385c26c926\", \"0x4d2c6dfc5ac42aed\", \"0x53380d139d95b3df\", \"0x650a73548baf63de\", \"0x766a0abb3c77b2a8\", \"0x81c2c92e47edaee6\", \"0x92722c851482353b\", \"0xa2bfe8a14cf10364\", \"0xa81a664bbc423001\", \"0xc24b8b70d0f89791\", \"0xc76c51a30654be30\", \"0xd192e819d6ef5218\", \"0xd69906245565a910\", \"0xf40e35855771202a\", \"0x106aa07032bbd1b8\", \"0x19a4c116b8d2d0c8\", \"0x1e376c085141ab53\", \"0x2748774cdf8eeb99\", \"0x34b0bcb5e19b48a8\", \"0x391c0cb3c5c95a63\", \"0x4ed8aa4ae3418acb\", \"0x5b9cca4f7763e373\", \"0x682e6ff3d6b2b8a3\", \"0x748f82ee5defb2fc\", \"0x78a5636f43172f60\", \"0x84c87814a1f0ab72\", \"0x8cc702081a6439ec\", \"0x90befffa23631e28\", \"0xa4506cebde82bde9\", \"0xbef9a3f7b2c67915\", \"0xc67178f2e372532b\", \"0xca273eceea26619c\", \"0xd186b8c721c0c207\", \"0xeada7dd6cde0eb1e\", \"0xf57d4f7fee6ed178\", \"0x06f067aa72176fba\", \"0x0a637dc5a2c898a6\", \"0x113f9804bef90dae\", \"0x1b710b35131c471b\", \"0x28db77f523047d84\", \"0x32caab7b40c72493\", \"0x3c9ebe0a15c9bebc\", \"0x431d67c49c100d4c\", \"0x4cc5d4becb3e42b6\", \"0x597f299cfc657e2a\", \"0x5fcb6fab3ad6faec\", \"0x6c44198c4a475817\"].map(e => BigInt(e))),\n          c = new Uint32Array(80),\n          u = new Uint32Array(80);\n        class d extends n.SHA2 {\n          constructor() {\n            super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n          }\n          get() {\n            const {\n              Ah: e,\n              Al: t,\n              Bh: r,\n              Bl: n,\n              Ch: i,\n              Cl: o,\n              Dh: s,\n              Dl: a,\n              Eh: c,\n              El: u,\n              Fh: d,\n              Fl: l,\n              Gh: h,\n              Gl: f,\n              Hh: p,\n              Hl: m\n            } = this;\n            return [e, t, r, n, i, o, s, a, c, u, d, l, h, f, p, m];\n          }\n          set(e, t, r, n, i, o, s, a, c, u, d, l, h, f, p, m) {\n            this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | r, this.Bl = 0 | n, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | c, this.El = 0 | u, this.Fh = 0 | d, this.Fl = 0 | l, this.Gh = 0 | h, this.Gl = 0 | f, this.Hh = 0 | p, this.Hl = 0 | m;\n          }\n          process(e, t) {\n            for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t), u[r] = e.getUint32(t += 4);\n            for (let e = 16; e < 80; e++) {\n              const t = 0 | c[e - 15],\n                r = 0 | u[e - 15],\n                n = i.default.rotrSH(t, r, 1) ^ i.default.rotrSH(t, r, 8) ^ i.default.shrSH(t, r, 7),\n                o = i.default.rotrSL(t, r, 1) ^ i.default.rotrSL(t, r, 8) ^ i.default.shrSL(t, r, 7),\n                s = 0 | c[e - 2],\n                a = 0 | u[e - 2],\n                d = i.default.rotrSH(s, a, 19) ^ i.default.rotrBH(s, a, 61) ^ i.default.shrSH(s, a, 6),\n                l = i.default.rotrSL(s, a, 19) ^ i.default.rotrBL(s, a, 61) ^ i.default.shrSL(s, a, 6),\n                h = i.default.add4L(o, l, u[e - 7], u[e - 16]),\n                f = i.default.add4H(h, n, d, c[e - 7], c[e - 16]);\n              c[e] = 0 | f, u[e] = 0 | h;\n            }\n            let {\n              Ah: r,\n              Al: n,\n              Bh: o,\n              Bl: d,\n              Ch: l,\n              Cl: h,\n              Dh: f,\n              Dl: p,\n              Eh: m,\n              El: g,\n              Fh: y,\n              Fl: v,\n              Gh: b,\n              Gl: E,\n              Hh: _,\n              Hl: A\n            } = this;\n            for (let e = 0; e < 80; e++) {\n              const t = i.default.rotrSH(m, g, 14) ^ i.default.rotrSH(m, g, 18) ^ i.default.rotrBH(m, g, 41),\n                T = i.default.rotrSL(m, g, 14) ^ i.default.rotrSL(m, g, 18) ^ i.default.rotrBL(m, g, 41),\n                I = m & y ^ ~m & b,\n                R = g & v ^ ~g & E,\n                w = i.default.add5L(A, T, R, a[e], u[e]),\n                P = i.default.add5H(w, _, t, I, s[e], c[e]),\n                x = 0 | w,\n                S = i.default.rotrSH(r, n, 28) ^ i.default.rotrBH(r, n, 34) ^ i.default.rotrBH(r, n, 39),\n                O = i.default.rotrSL(r, n, 28) ^ i.default.rotrBL(r, n, 34) ^ i.default.rotrBL(r, n, 39),\n                C = r & o ^ r & l ^ o & l,\n                B = n & d ^ n & h ^ d & h;\n              _ = 0 | b, A = 0 | E, b = 0 | y, E = 0 | v, y = 0 | m, v = 0 | g, ({\n                h: m,\n                l: g\n              } = i.default.add(0 | f, 0 | p, 0 | P, 0 | x)), f = 0 | l, p = 0 | h, l = 0 | o, h = 0 | d, o = 0 | r, d = 0 | n;\n              const N = i.default.add3L(x, O, B);\n              r = i.default.add3H(N, P, S, C), n = 0 | N;\n            }\n            ({\n              h: r,\n              l: n\n            } = i.default.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)), ({\n              h: o,\n              l: d\n            } = i.default.add(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | d)), ({\n              h: l,\n              l: h\n            } = i.default.add(0 | this.Ch, 0 | this.Cl, 0 | l, 0 | h)), ({\n              h: f,\n              l: p\n            } = i.default.add(0 | this.Dh, 0 | this.Dl, 0 | f, 0 | p)), ({\n              h: m,\n              l: g\n            } = i.default.add(0 | this.Eh, 0 | this.El, 0 | m, 0 | g)), ({\n              h: y,\n              l: v\n            } = i.default.add(0 | this.Fh, 0 | this.Fl, 0 | y, 0 | v)), ({\n              h: b,\n              l: E\n            } = i.default.add(0 | this.Gh, 0 | this.Gl, 0 | b, 0 | E)), ({\n              h: _,\n              l: A\n            } = i.default.add(0 | this.Hh, 0 | this.Hl, 0 | _, 0 | A)), this.set(r, n, o, d, l, h, f, p, m, g, y, v, b, E, _, A);\n          }\n          roundClean() {\n            c.fill(0), u.fill(0);\n          }\n          destroy() {\n            this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n          }\n        }\n        t.SHA512 = d;\n        class l extends d {\n          constructor() {\n            super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;\n          }\n        }\n        class h extends d {\n          constructor() {\n            super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;\n          }\n        }\n        class f extends d {\n          constructor() {\n            super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;\n          }\n        }\n        t.sha512 = (0, o.wrapConstructor)(() => new d()), t.sha512_224 = (0, o.wrapConstructor)(() => new l()), t.sha512_256 = (0, o.wrapConstructor)(() => new h()), t.sha384 = (0, o.wrapConstructor)(() => new f());\n      },\n      64: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomBytes = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n        const n = r(825);\n        if (t.u8 = e => new Uint8Array(e.buffer, e.byteOffset, e.byteLength), t.u32 = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), t.createView = e => new DataView(e.buffer, e.byteOffset, e.byteLength), t.rotr = (e, t) => e << 32 - t | e >>> t, t.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !t.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n        const i = Array.from({\n          length: 256\n        }, (e, t) => t.toString(16).padStart(2, \"0\"));\n        function o(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"utf8ToBytes expected string, got \" + typeof e);\n          return new TextEncoder().encode(e);\n        }\n        function s(e) {\n          if (\"string\" == typeof e && (e = o(e)), !(e instanceof Uint8Array)) throw new TypeError(\"Expected input type is Uint8Array (got \".concat(typeof e, \")\"));\n          return e;\n        }\n        t.bytesToHex = function (e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n          let t = \"\";\n          for (let r = 0; r < e.length; r++) t += i[e[r]];\n          return t;\n        }, t.hexToBytes = function (e) {\n          if (\"string\" != typeof e) throw new TypeError(\"hexToBytes: expected string, got \" + typeof e);\n          if (e.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n          const t = new Uint8Array(e.length / 2);\n          for (let r = 0; r < t.length; r++) {\n            const n = 2 * r,\n              i = e.slice(n, n + 2),\n              o = Number.parseInt(i, 16);\n            if (Number.isNaN(o) || o < 0) throw new Error(\"Invalid byte sequence\");\n            t[r] = o;\n          }\n          return t;\n        }, t.nextTick = /*#__PURE__*/_asyncToGenerator(function* () {}), t.asyncLoop = /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator(function* (e, r, n) {\n            let i = Date.now();\n            for (let o = 0; o < e; o++) {\n              n(o);\n              const e = Date.now() - i;\n              e >= 0 && e < r || (yield (0, t.nextTick)(), i += e);\n            }\n          });\n          return function (_x8, _x9, _x10) {\n            return _ref4.apply(this, arguments);\n          };\n        }(), t.utf8ToBytes = o, t.toBytes = s, t.concatBytes = function () {\n          for (var _len8 = arguments.length, e = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n            e[_key8] = arguments[_key8];\n          }\n          if (!e.every(e => e instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n          if (1 === e.length) return e[0];\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          for (let t = 0, n = 0; t < e.length; t++) {\n            const i = e[t];\n            r.set(i, n), n += i.length;\n          }\n          return r;\n        }, t.Hash = class {\n          clone() {\n            return this._cloneInto();\n          }\n        }, t.checkOpts = function (e, t) {\n          if (void 0 !== t && (\"object\" != typeof t || (r = t, \"[object Object]\" !== Object.prototype.toString.call(r) || r.constructor !== Object))) throw new TypeError(\"Options should be object or undefined\");\n          var r;\n          return Object.assign(e, t);\n        }, t.wrapConstructor = function (e) {\n          const t = t => e().update(s(t)).digest(),\n            r = e();\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;\n        }, t.wrapConstructorWithOpts = function (e) {\n          const t = (t, r) => e(r).update(s(t)).digest(),\n            r = e({});\n          return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = t => e(t), t;\n        }, t.randomBytes = function () {\n          let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n          if (n.crypto && \"function\" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(e));\n          throw new Error(\"crypto.getRandomValues must be defined\");\n        };\n      },\n      1238: (e, t) => {\n        var r;\n        r = function r(e) {\n          e.version = \"1.2.2\";\n          var t = function () {\n              for (var e = 0, t = new Array(256), r = 0; 256 != r; ++r) e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = r) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1, t[r] = e;\n              return \"undefined\" != typeof Int32Array ? new Int32Array(t) : t;\n            }(),\n            r = function (e) {\n              var t = 0,\n                r = 0,\n                n = 0,\n                i = \"undefined\" != typeof Int32Array ? new Int32Array(4096) : new Array(4096);\n              for (n = 0; 256 != n; ++n) i[n] = e[n];\n              for (n = 0; 256 != n; ++n) for (r = e[n], t = 256 + n; t < 4096; t += 256) r = i[t] = r >>> 8 ^ e[255 & r];\n              var o = [];\n              for (n = 1; 16 != n; ++n) o[n - 1] = \"undefined\" != typeof Int32Array ? i.subarray(256 * n, 256 * n + 256) : i.slice(256 * n, 256 * n + 256);\n              return o;\n            }(t),\n            n = r[0],\n            i = r[1],\n            o = r[2],\n            s = r[3],\n            a = r[4],\n            c = r[5],\n            u = r[6],\n            d = r[7],\n            l = r[8],\n            h = r[9],\n            f = r[10],\n            p = r[11],\n            m = r[12],\n            g = r[13],\n            y = r[14];\n          e.table = t, e.bstr = function (e, r) {\n            for (var n = -1 ^ r, i = 0, o = e.length; i < o;) n = n >>> 8 ^ t[255 & (n ^ e.charCodeAt(i++))];\n            return ~n;\n          }, e.buf = function (e, r) {\n            for (var v = -1 ^ r, b = e.length - 15, E = 0; E < b;) v = y[e[E++] ^ 255 & v] ^ g[e[E++] ^ v >> 8 & 255] ^ m[e[E++] ^ v >> 16 & 255] ^ p[e[E++] ^ v >>> 24] ^ f[e[E++]] ^ h[e[E++]] ^ l[e[E++]] ^ d[e[E++]] ^ u[e[E++]] ^ c[e[E++]] ^ a[e[E++]] ^ s[e[E++]] ^ o[e[E++]] ^ i[e[E++]] ^ n[e[E++]] ^ t[e[E++]];\n            for (b += 15; E < b;) v = v >>> 8 ^ t[255 & (v ^ e[E++])];\n            return ~v;\n          }, e.str = function (e, r) {\n            for (var n = -1 ^ r, i = 0, o = e.length, s = 0, a = 0; i < o;) (s = e.charCodeAt(i++)) < 128 ? n = n >>> 8 ^ t[255 & (n ^ s)] : s < 2048 ? n = (n = n >>> 8 ^ t[255 & (n ^ (192 | s >> 6 & 31))]) >>> 8 ^ t[255 & (n ^ (128 | 63 & s))] : s >= 55296 && s < 57344 ? (s = 64 + (1023 & s), a = 1023 & e.charCodeAt(i++), n = (n = (n = (n = n >>> 8 ^ t[255 & (n ^ (240 | s >> 8 & 7))]) >>> 8 ^ t[255 & (n ^ (128 | s >> 2 & 63))]) >>> 8 ^ t[255 & (n ^ (128 | a >> 6 & 15 | (3 & s) << 4))]) >>> 8 ^ t[255 & (n ^ (128 | 63 & a))]) : n = (n = (n = n >>> 8 ^ t[255 & (n ^ (224 | s >> 12 & 15))]) >>> 8 ^ t[255 & (n ^ (128 | s >> 6 & 63))]) >>> 8 ^ t[255 & (n ^ (128 | 63 & s))];\n            return ~n;\n          };\n        }, \"undefined\" == typeof DO_NOT_EXPORT_CRC ? r(t) : r({});\n      },\n      6279: (e, t, r) => {\n        var n = \"undefined\" != typeof globalThis && globalThis || \"undefined\" != typeof self && self || void 0 !== r.g && r.g,\n          i = function () {\n            function e() {\n              this.fetch = !1, this.DOMException = n.DOMException;\n            }\n            return e.prototype = n, new e();\n          }();\n        !function (e) {\n          !function (t) {\n            var r = void 0 !== e && e || \"undefined\" != typeof self && self || void 0 !== r && r,\n              n = (\"URLSearchParams\" in r),\n              i = \"Symbol\" in r && \"iterator\" in Symbol,\n              o = \"FileReader\" in r && \"Blob\" in r && function () {\n                try {\n                  return new Blob(), !0;\n                } catch (e) {\n                  return !1;\n                }\n              }(),\n              s = (\"FormData\" in r),\n              a = (\"ArrayBuffer\" in r);\n            if (a) var c = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"],\n              u = ArrayBuffer.isView || function (e) {\n                return e && c.indexOf(Object.prototype.toString.call(e)) > -1;\n              };\n            function d(e) {\n              if (\"string\" != typeof e && (e = String(e)), /[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(e) || \"\" === e) throw new TypeError('Invalid character in header field name: \"' + e + '\"');\n              return e.toLowerCase();\n            }\n            function l(e) {\n              return \"string\" != typeof e && (e = String(e)), e;\n            }\n            function h(e) {\n              var t = {\n                next: function next() {\n                  var t = e.shift();\n                  return {\n                    done: void 0 === t,\n                    value: t\n                  };\n                }\n              };\n              return i && (t[Symbol.iterator] = function () {\n                return t;\n              }), t;\n            }\n            function f(e) {\n              this.map = {}, e instanceof f ? e.forEach(function (e, t) {\n                this.append(t, e);\n              }, this) : Array.isArray(e) ? e.forEach(function (e) {\n                this.append(e[0], e[1]);\n              }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) {\n                this.append(t, e[t]);\n              }, this);\n            }\n            function p(e) {\n              if (e.bodyUsed) return Promise.reject(new TypeError(\"Already read\"));\n              e.bodyUsed = !0;\n            }\n            function m(e) {\n              return new Promise(function (t, r) {\n                e.onload = function () {\n                  t(e.result);\n                }, e.onerror = function () {\n                  r(e.error);\n                };\n              });\n            }\n            function g(e) {\n              var t = new FileReader(),\n                r = m(t);\n              return t.readAsArrayBuffer(e), r;\n            }\n            function y(e) {\n              if (e.slice) return e.slice(0);\n              var t = new Uint8Array(e.byteLength);\n              return t.set(new Uint8Array(e)), t.buffer;\n            }\n            function v() {\n              return this.bodyUsed = !1, this._initBody = function (e) {\n                var t;\n                this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? \"string\" == typeof e ? this._bodyText = e : o && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : s && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : n && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : a && o && (t = e) && DataView.prototype.isPrototypeOf(t) ? (this._bodyArrayBuffer = y(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a && (ArrayBuffer.prototype.isPrototypeOf(e) || u(e)) ? this._bodyArrayBuffer = y(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = \"\", this.headers.get(\"content-type\") || (\"string\" == typeof e ? this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\") : this._bodyBlob && this._bodyBlob.type ? this.headers.set(\"content-type\", this._bodyBlob.type) : n && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"));\n              }, o && (this.blob = function () {\n                var e = p(this);\n                if (e) return e;\n                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);\n                if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n                if (this._bodyFormData) throw new Error(\"could not read FormData body as blob\");\n                return Promise.resolve(new Blob([this._bodyText]));\n              }, this.arrayBuffer = function () {\n                return this._bodyArrayBuffer ? p(this) || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)) : this.blob().then(g);\n              }), this.text = function () {\n                var e,\n                  t,\n                  r,\n                  n = p(this);\n                if (n) return n;\n                if (this._bodyBlob) return e = this._bodyBlob, r = m(t = new FileReader()), t.readAsText(e), r;\n                if (this._bodyArrayBuffer) return Promise.resolve(function (e) {\n                  for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++) r[n] = String.fromCharCode(t[n]);\n                  return r.join(\"\");\n                }(this._bodyArrayBuffer));\n                if (this._bodyFormData) throw new Error(\"could not read FormData body as text\");\n                return Promise.resolve(this._bodyText);\n              }, s && (this.formData = function () {\n                return this.text().then(_);\n              }), this.json = function () {\n                return this.text().then(JSON.parse);\n              }, this;\n            }\n            f.prototype.append = function (e, t) {\n              e = d(e), t = l(t);\n              var r = this.map[e];\n              this.map[e] = r ? r + \", \" + t : t;\n            }, f.prototype.delete = function (e) {\n              delete this.map[d(e)];\n            }, f.prototype.get = function (e) {\n              return e = d(e), this.has(e) ? this.map[e] : null;\n            }, f.prototype.has = function (e) {\n              return this.map.hasOwnProperty(d(e));\n            }, f.prototype.set = function (e, t) {\n              this.map[d(e)] = l(t);\n            }, f.prototype.forEach = function (e, t) {\n              for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);\n            }, f.prototype.keys = function () {\n              var e = [];\n              return this.forEach(function (t, r) {\n                e.push(r);\n              }), h(e);\n            }, f.prototype.values = function () {\n              var e = [];\n              return this.forEach(function (t) {\n                e.push(t);\n              }), h(e);\n            }, f.prototype.entries = function () {\n              var e = [];\n              return this.forEach(function (t, r) {\n                e.push([r, t]);\n              }), h(e);\n            }, i && (f.prototype[Symbol.iterator] = f.prototype.entries);\n            var b = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"];\n            function E(e, t) {\n              if (!(this instanceof E)) throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n              var r,\n                n,\n                i = (t = t || {}).body;\n              if (e instanceof E) {\n                if (e.bodyUsed) throw new TypeError(\"Already read\");\n                this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new f(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, i || null == e._bodyInit || (i = e._bodyInit, e.bodyUsed = !0);\n              } else this.url = String(e);\n              if (this.credentials = t.credentials || this.credentials || \"same-origin\", !t.headers && this.headers || (this.headers = new f(t.headers)), this.method = (n = (r = t.method || this.method || \"GET\").toUpperCase(), b.indexOf(n) > -1 ? n : r), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (\"GET\" === this.method || \"HEAD\" === this.method) && i) throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n              if (this._initBody(i), !(\"GET\" !== this.method && \"HEAD\" !== this.method || \"no-store\" !== t.cache && \"no-cache\" !== t.cache)) {\n                var o = /([?&])_=[^&]*/;\n                o.test(this.url) ? this.url = this.url.replace(o, \"$1_=\" + new Date().getTime()) : this.url += (/\\?/.test(this.url) ? \"&\" : \"?\") + \"_=\" + new Date().getTime();\n              }\n            }\n            function _(e) {\n              var t = new FormData();\n              return e.trim().split(\"&\").forEach(function (e) {\n                if (e) {\n                  var r = e.split(\"=\"),\n                    n = r.shift().replace(/\\+/g, \" \"),\n                    i = r.join(\"=\").replace(/\\+/g, \" \");\n                  t.append(decodeURIComponent(n), decodeURIComponent(i));\n                }\n              }), t;\n            }\n            function A(e, t) {\n              if (!(this instanceof A)) throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.');\n              t || (t = {}), this.type = \"default\", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === t.statusText ? \"\" : \"\" + t.statusText, this.headers = new f(t.headers), this.url = t.url || \"\", this._initBody(e);\n            }\n            E.prototype.clone = function () {\n              return new E(this, {\n                body: this._bodyInit\n              });\n            }, v.call(E.prototype), v.call(A.prototype), A.prototype.clone = function () {\n              return new A(this._bodyInit, {\n                status: this.status,\n                statusText: this.statusText,\n                headers: new f(this.headers),\n                url: this.url\n              });\n            }, A.error = function () {\n              var e = new A(null, {\n                status: 0,\n                statusText: \"\"\n              });\n              return e.type = \"error\", e;\n            };\n            var T = [301, 302, 303, 307, 308];\n            A.redirect = function (e, t) {\n              if (-1 === T.indexOf(t)) throw new RangeError(\"Invalid status code\");\n              return new A(null, {\n                status: t,\n                headers: {\n                  location: e\n                }\n              });\n            }, t.DOMException = r.DOMException;\n            try {\n              new t.DOMException();\n            } catch (e) {\n              t.DOMException = function (e, t) {\n                this.message = e, this.name = t;\n                var r = Error(e);\n                this.stack = r.stack;\n              }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException;\n            }\n            function I(e, n) {\n              return new Promise(function (i, s) {\n                var c = new E(e, n);\n                if (c.signal && c.signal.aborted) return s(new t.DOMException(\"Aborted\", \"AbortError\"));\n                var u = new XMLHttpRequest();\n                function d() {\n                  u.abort();\n                }\n                u.onload = function () {\n                  var e,\n                    t,\n                    r = {\n                      status: u.status,\n                      statusText: u.statusText,\n                      headers: (e = u.getAllResponseHeaders() || \"\", t = new f(), e.replace(/\\r?\\n[\\t ]+/g, \" \").split(\"\\r\").map(function (e) {\n                        return 0 === e.indexOf(\"\\n\") ? e.substr(1, e.length) : e;\n                      }).forEach(function (e) {\n                        var r = e.split(\":\"),\n                          n = r.shift().trim();\n                        if (n) {\n                          var i = r.join(\":\").trim();\n                          t.append(n, i);\n                        }\n                      }), t)\n                    };\n                  r.url = \"responseURL\" in u ? u.responseURL : r.headers.get(\"X-Request-URL\");\n                  var n = \"response\" in u ? u.response : u.responseText;\n                  setTimeout(function () {\n                    i(new A(n, r));\n                  }, 0);\n                }, u.onerror = function () {\n                  setTimeout(function () {\n                    s(new TypeError(\"Network request failed\"));\n                  }, 0);\n                }, u.ontimeout = function () {\n                  setTimeout(function () {\n                    s(new TypeError(\"Network request failed\"));\n                  }, 0);\n                }, u.onabort = function () {\n                  setTimeout(function () {\n                    s(new t.DOMException(\"Aborted\", \"AbortError\"));\n                  }, 0);\n                }, u.open(c.method, function (e) {\n                  try {\n                    return \"\" === e && r.location.href ? r.location.href : e;\n                  } catch (t) {\n                    return e;\n                  }\n                }(c.url), !0), \"include\" === c.credentials ? u.withCredentials = !0 : \"omit\" === c.credentials && (u.withCredentials = !1), \"responseType\" in u && (o ? u.responseType = \"blob\" : a && c.headers.get(\"Content-Type\") && -1 !== c.headers.get(\"Content-Type\").indexOf(\"application/octet-stream\") && (u.responseType = \"arraybuffer\")), !n || \"object\" != typeof n.headers || n.headers instanceof f ? c.headers.forEach(function (e, t) {\n                  u.setRequestHeader(t, e);\n                }) : Object.getOwnPropertyNames(n.headers).forEach(function (e) {\n                  u.setRequestHeader(e, l(n.headers[e]));\n                }), c.signal && (c.signal.addEventListener(\"abort\", d), u.onreadystatechange = function () {\n                  4 === u.readyState && c.signal.removeEventListener(\"abort\", d);\n                }), u.send(void 0 === c._bodyInit ? null : c._bodyInit);\n              });\n            }\n            I.polyfill = !0, r.fetch || (r.fetch = I, r.Headers = f, r.Request = E, r.Response = A), t.Headers = f, t.Request = E, t.Response = A, t.fetch = I;\n          }({});\n        }(i), i.fetch.ponyfill = !0, delete i.fetch.polyfill;\n        var o = n.fetch ? n : i;\n        (t = o.fetch).default = o.fetch, t.fetch = o.fetch, t.Headers = o.Headers, t.Request = o.Request, t.Response = o.Response, e.exports = t;\n      },\n      2699: e => {\n        \"use strict\";\n\n        var t,\n          r = \"object\" == typeof Reflect ? Reflect : null,\n          n = r && \"function\" == typeof r.apply ? r.apply : function (e, t, r) {\n            return Function.prototype.apply.call(e, t, r);\n          };\n        t = r && \"function\" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function (e) {\n          return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));\n        } : function (e) {\n          return Object.getOwnPropertyNames(e);\n        };\n        var i = Number.isNaN || function (e) {\n          return e != e;\n        };\n        function o() {\n          o.init.call(this);\n        }\n        e.exports = o, e.exports.once = function (e, t) {\n          return new Promise(function (r, n) {\n            function i(r) {\n              e.removeListener(t, o), n(r);\n            }\n            function o() {\n              \"function\" == typeof e.removeListener && e.removeListener(\"error\", i), r([].slice.call(arguments));\n            }\n            m(e, t, o, {\n              once: !0\n            }), \"error\" !== t && function (e, t, r) {\n              \"function\" == typeof e.on && m(e, \"error\", t, {\n                once: !0\n              });\n            }(e, i);\n          });\n        }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;\n        var s = 10;\n        function a(e) {\n          if (\"function\" != typeof e) throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof e);\n        }\n        function c(e) {\n          return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners;\n        }\n        function u(e, t, r, n) {\n          var i, o, s, u;\n          if (a(r), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit(\"newListener\", t, r.listener ? r.listener : r), o = e._events), s = o[t]), void 0 === s) s = o[t] = r, ++e._eventsCount;else if (\"function\" == typeof s ? s = o[t] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), (i = c(e)) > 0 && s.length > i && !s.warned) {\n            s.warned = !0;\n            var d = new Error(\"Possible EventEmitter memory leak detected. \" + s.length + \" \" + String(t) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n            d.name = \"MaxListenersExceededWarning\", d.emitter = e, d.type = t, d.count = s.length, u = d, console && console.warn && console.warn(u);\n          }\n          return e;\n        }\n        function d() {\n          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n        }\n        function l(e, t, r) {\n          var n = {\n              fired: !1,\n              wrapFn: void 0,\n              target: e,\n              type: t,\n              listener: r\n            },\n            i = d.bind(n);\n          return i.listener = r, n.wrapFn = i, i;\n        }\n        function h(e, t, r) {\n          var n = e._events;\n          if (void 0 === n) return [];\n          var i = n[t];\n          return void 0 === i ? [] : \"function\" == typeof i ? r ? [i.listener || i] : [i] : r ? function (e) {\n            for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];\n            return t;\n          }(i) : p(i, i.length);\n        }\n        function f(e) {\n          var t = this._events;\n          if (void 0 !== t) {\n            var r = t[e];\n            if (\"function\" == typeof r) return 1;\n            if (void 0 !== r) return r.length;\n          }\n          return 0;\n        }\n        function p(e, t) {\n          for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];\n          return r;\n        }\n        function m(e, t, r, n) {\n          if (\"function\" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r);else {\n            if (\"function\" != typeof e.addEventListener) throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof e);\n            e.addEventListener(t, function i(o) {\n              n.once && e.removeEventListener(t, i), r(o);\n            });\n          }\n        }\n        Object.defineProperty(o, \"defaultMaxListeners\", {\n          enumerable: !0,\n          get: function get() {\n            return s;\n          },\n          set: function set(e) {\n            if (\"number\" != typeof e || e < 0 || i(e)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n            s = e;\n          }\n        }), o.init = function () {\n          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n        }, o.prototype.setMaxListeners = function (e) {\n          if (\"number\" != typeof e || e < 0 || i(e)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + e + \".\");\n          return this._maxListeners = e, this;\n        }, o.prototype.getMaxListeners = function () {\n          return c(this);\n        }, o.prototype.emit = function (e) {\n          for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);\n          var i = \"error\" === e,\n            o = this._events;\n          if (void 0 !== o) i = i && void 0 === o.error;else if (!i) return !1;\n          if (i) {\n            var s;\n            if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;\n            var a = new Error(\"Unhandled error.\" + (s ? \" (\" + s.message + \")\" : \"\"));\n            throw a.context = s, a;\n          }\n          var c = o[e];\n          if (void 0 === c) return !1;\n          if (\"function\" == typeof c) n(c, this, t);else {\n            var u = c.length,\n              d = p(c, u);\n            for (r = 0; r < u; ++r) n(d[r], this, t);\n          }\n          return !0;\n        }, o.prototype.addListener = function (e, t) {\n          return u(this, e, t, !1);\n        }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (e, t) {\n          return u(this, e, t, !0);\n        }, o.prototype.once = function (e, t) {\n          return a(t), this.on(e, l(this, e, t)), this;\n        }, o.prototype.prependOnceListener = function (e, t) {\n          return a(t), this.prependListener(e, l(this, e, t)), this;\n        }, o.prototype.removeListener = function (e, t) {\n          var r, n, i, o, s;\n          if (a(t), void 0 === (n = this._events)) return this;\n          if (void 0 === (r = n[e])) return this;\n          if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit(\"removeListener\", e, r.listener || t));else if (\"function\" != typeof r) {\n            for (i = -1, o = r.length - 1; o >= 0; o--) if (r[o] === t || r[o].listener === t) {\n              s = r[o].listener, i = o;\n              break;\n            }\n            if (i < 0) return this;\n            0 === i ? r.shift() : function (e, t) {\n              for (; t + 1 < e.length; t++) e[t] = e[t + 1];\n              e.pop();\n            }(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit(\"removeListener\", e, s || t);\n          }\n          return this;\n        }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (e) {\n          var t, r, n;\n          if (void 0 === (r = this._events)) return this;\n          if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;\n          if (0 === arguments.length) {\n            var i,\n              o = Object.keys(r);\n            for (n = 0; n < o.length; ++n) \"removeListener\" !== (i = o[n]) && this.removeAllListeners(i);\n            return this.removeAllListeners(\"removeListener\"), this._events = Object.create(null), this._eventsCount = 0, this;\n          }\n          if (\"function\" == typeof (t = r[e])) this.removeListener(e, t);else if (void 0 !== t) for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);\n          return this;\n        }, o.prototype.listeners = function (e) {\n          return h(this, e, !0);\n        }, o.prototype.rawListeners = function (e) {\n          return h(this, e, !1);\n        }, o.listenerCount = function (e, t) {\n          return \"function\" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t);\n        }, o.prototype.listenerCount = f, o.prototype.eventNames = function () {\n          return this._eventsCount > 0 ? t(this._events) : [];\n        };\n      },\n      7475: (e, t, r) => {\n        \"use strict\";\n\n        r.r(t), r.d(t, {\n          default: () => i\n        });\n        var n = null;\n        \"undefined\" != typeof WebSocket ? n = WebSocket : \"undefined\" != typeof MozWebSocket ? n = MozWebSocket : void 0 !== r.g ? n = r.g.WebSocket || r.g.MozWebSocket : \"undefined\" != typeof window ? n = window.WebSocket || window.MozWebSocket : \"undefined\" != typeof self && (n = self.WebSocket || self.MozWebSocket);\n        const i = n;\n      },\n      4406: e => {\n        var t,\n          r,\n          n = e.exports = {};\n        function i() {\n          throw new Error(\"setTimeout has not been defined\");\n        }\n        function o() {\n          throw new Error(\"clearTimeout has not been defined\");\n        }\n        function s(e) {\n          if (t === setTimeout) return setTimeout(e, 0);\n          if ((t === i || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);\n          try {\n            return t(e, 0);\n          } catch (r) {\n            try {\n              return t.call(null, e, 0);\n            } catch (r) {\n              return t.call(this, e, 0);\n            }\n          }\n        }\n        !function () {\n          try {\n            t = \"function\" == typeof setTimeout ? setTimeout : i;\n          } catch (e) {\n            t = i;\n          }\n          try {\n            r = \"function\" == typeof clearTimeout ? clearTimeout : o;\n          } catch (e) {\n            r = o;\n          }\n        }();\n        var a,\n          c = [],\n          u = !1,\n          d = -1;\n        function l() {\n          u && a && (u = !1, a.length ? c = a.concat(c) : d = -1, c.length && h());\n        }\n        function h() {\n          if (!u) {\n            var e = s(l);\n            u = !0;\n            for (var t = c.length; t;) {\n              for (a = c, c = []; ++d < t;) a && a[d].run();\n              d = -1, t = c.length;\n            }\n            a = null, u = !1, function (e) {\n              if (r === clearTimeout) return clearTimeout(e);\n              if ((r === o || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e);\n              try {\n                r(e);\n              } catch (t) {\n                try {\n                  return r.call(null, e);\n                } catch (t) {\n                  return r.call(this, e);\n                }\n              }\n            }(e);\n          }\n        }\n        function f(e, t) {\n          this.fun = e, this.array = t;\n        }\n        function p() {}\n        n.nextTick = function (e) {\n          var t = new Array(arguments.length - 1);\n          if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];\n          c.push(new f(e, t)), 1 !== c.length || u || s(h);\n        }, f.prototype.run = function () {\n          this.fun.apply(null, this.array);\n        }, n.title = \"browser\", n.browser = !0, n.env = {}, n.argv = [], n.version = \"\", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function (e) {\n          return [];\n        }, n.binding = function (e) {\n          throw new Error(\"process.binding is not supported\");\n        }, n.cwd = function () {\n          return \"/\";\n        }, n.chdir = function (e) {\n          throw new Error(\"process.chdir is not supported\");\n        }, n.umask = function () {\n          return 0;\n        };\n      },\n      6985: function _(e, t, r) {\n        var n = r(4406);\n        !function (e, t) {\n          \"use strict\";\n\n          if (!e.setImmediate) {\n            var r,\n              i,\n              o,\n              s,\n              a,\n              c = 1,\n              u = {},\n              d = !1,\n              l = e.document,\n              h = Object.getPrototypeOf && Object.getPrototypeOf(e);\n            h = h && h.setTimeout ? h : e, \"[object process]\" === {}.toString.call(e.process) ? r = function r(e) {\n              n.nextTick(function () {\n                p(e);\n              });\n            } : function () {\n              if (e.postMessage && !e.importScripts) {\n                var t = !0,\n                  r = e.onmessage;\n                return e.onmessage = function () {\n                  t = !1;\n                }, e.postMessage(\"\", \"*\"), e.onmessage = r, t;\n              }\n            }() ? (s = \"setImmediate$\" + Math.random() + \"$\", a = function a(t) {\n              t.source === e && \"string\" == typeof t.data && 0 === t.data.indexOf(s) && p(+t.data.slice(s.length));\n            }, e.addEventListener ? e.addEventListener(\"message\", a, !1) : e.attachEvent(\"onmessage\", a), r = function r(t) {\n              e.postMessage(s + t, \"*\");\n            }) : e.MessageChannel ? ((o = new MessageChannel()).port1.onmessage = function (e) {\n              p(e.data);\n            }, r = function r(e) {\n              o.port2.postMessage(e);\n            }) : l && \"onreadystatechange\" in l.createElement(\"script\") ? (i = l.documentElement, r = function r(e) {\n              var t = l.createElement(\"script\");\n              t.onreadystatechange = function () {\n                p(e), t.onreadystatechange = null, i.removeChild(t), t = null;\n              }, i.appendChild(t);\n            }) : r = function r(e) {\n              setTimeout(p, 0, e);\n            }, h.setImmediate = function (e) {\n              \"function\" != typeof e && (e = new Function(\"\" + e));\n              for (var t = new Array(arguments.length - 1), n = 0; n < t.length; n++) t[n] = arguments[n + 1];\n              var i = {\n                callback: e,\n                args: t\n              };\n              return u[c] = i, r(c), c++;\n            }, h.clearImmediate = f;\n          }\n          function f(e) {\n            delete u[e];\n          }\n          function p(e) {\n            if (d) setTimeout(p, 0, e);else {\n              var t = u[e];\n              if (t) {\n                d = !0;\n                try {\n                  !function (e) {\n                    var t = e.callback,\n                      r = e.args;\n                    switch (r.length) {\n                      case 0:\n                        t();\n                        break;\n                      case 1:\n                        t(r[0]);\n                        break;\n                      case 2:\n                        t(r[0], r[1]);\n                        break;\n                      case 3:\n                        t(r[0], r[1], r[2]);\n                        break;\n                      default:\n                        t.apply(void 0, r);\n                    }\n                  }(t);\n                } finally {\n                  f(e), d = !1;\n                }\n              }\n            }\n          }\n        }(\"undefined\" == typeof self ? void 0 === r.g ? this : r.g : self);\n      },\n      9937: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const n = r(8381);\n        t.default = {\n          encodeEventSignature: n.encodeEventSignature,\n          encodeFunctionCall: n.encodeFunctionCall,\n          encodeFunctionSignature: n.encodeFunctionSignature,\n          encodeParameter: n.encodeParameter,\n          encodeParameters: n.encodeParameters,\n          decodeParameter: n.decodeParameter,\n          decodeParameters: n.decodeParameters,\n          decodeLog: n.decodeLog\n        };\n      },\n      1186: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.initAccountsForContext = void 0;\n        const i = r(9970),\n          o = r(9634),\n          s = r(6637),\n          a = r(9247);\n        t.initAccountsForContext = e => {\n          const t = (t, r) => n(void 0, void 0, void 0, function* () {\n              const n = yield (0, s.prepareTransactionForSigning)(t, e),\n                c = (0, o.format)({\n                  format: \"bytes\"\n                }, r, i.ETH_DATA_FORMAT);\n              return (0, a.signTransaction)(n, c);\n            }),\n            r = e => {\n              const r = (0, a.privateKeyToAccount)(e);\n              return Object.assign(Object.assign({}, r), {\n                signTransaction: e => n(void 0, void 0, void 0, function* () {\n                  return t(e, r.privateKey);\n                })\n              });\n            },\n            c = (e, r, i) => n(void 0, void 0, void 0, function* () {\n              var o;\n              const s = yield (0, a.decrypt)(e, r, null === (o = null == i ? void 0 : i.nonStrict) || void 0 === o || o);\n              return Object.assign(Object.assign({}, s), {\n                signTransaction: e => n(void 0, void 0, void 0, function* () {\n                  return t(e, s.privateKey);\n                })\n              });\n            }),\n            u = () => {\n              const e = (0, a.create)();\n              return Object.assign(Object.assign({}, e), {\n                signTransaction: r => n(void 0, void 0, void 0, function* () {\n                  return t(r, e.privateKey);\n                })\n              });\n            },\n            d = new a.Wallet({\n              create: u,\n              privateKeyToAccount: r,\n              decrypt: c\n            });\n          return {\n            signTransaction: t,\n            create: u,\n            privateKeyToAccount: r,\n            decrypt: c,\n            recoverTransaction: a.recoverTransaction,\n            hashMessage: a.hashMessage,\n            sign: a.sign,\n            recover: a.recover,\n            encrypt: a.encrypt,\n            wallet: d\n          };\n        };\n      },\n      9913: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3PkgInfo = void 0, t.Web3PkgInfo = {\n          version: \"4.2.0\"\n        };\n      },\n      9375: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3 = void 0;\n        const a = r(6527),\n          c = r(6637),\n          u = s(r(3211)),\n          d = r(1698),\n          l = r(9910),\n          h = r(9757),\n          f = r(9820),\n          p = o(r(9634)),\n          m = r(9634),\n          g = r(5071),\n          y = s(r(9937)),\n          v = r(1186),\n          b = r(9913);\n        class E extends a.Web3Context {\n          constructor(e) {\n            var t;\n            ((0, m.isNullish)(e) || \"string\" == typeof e && \"\" === e.trim() || \"string\" != typeof e && !(0, a.isSupportedProvider)(e) && !e.provider) && console.warn(\"NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!\");\n            let r = {};\n            \"string\" == typeof e || (0, a.isSupportedProvider)(e) ? r.provider = e : r = e || {}, r.registeredSubscriptions = Object.assign(Object.assign({}, c.registeredSubscriptions), null !== (t = r.registeredSubscriptions) && void 0 !== t ? t : {}), super(r);\n            const n = (0, v.initAccountsForContext)(this);\n            this._wallet = n.wallet, this._accountProvider = n, this.utils = p;\n            const i = this;\n            class o extends u.default {\n              constructor(e, t, r) {\n                if (\"object\" == typeof t && \"object\" == typeof r) throw new g.InvalidMethodParamsError(\"Should not provide options at both 2nd and 3rd parameters\");\n                if ((0, m.isNullish)(t)) super(e, r, i.getContextObject());else if (\"object\" == typeof t) super(e, t, i.getContextObject());else {\n                  if (\"string\" != typeof t) throw new g.InvalidMethodParamsError();\n                  super(e, t, null != r ? r : {}, i.getContextObject());\n                }\n                super.subscribeToContextEvents(i);\n              }\n            }\n            const s = i.use(c.Web3Eth);\n            this.eth = Object.assign(s, {\n              ens: i.use(d.ENS, d.registryAddresses.main),\n              Iban: l.Iban,\n              net: i.use(f.Net),\n              personal: i.use(h.Personal),\n              Contract: o,\n              abi: y.default,\n              accounts: n\n            });\n          }\n        }\n        t.Web3 = E, E.version = b.Web3PkgInfo.version, E.utils = p, E.modules = {\n          Web3Eth: c.Web3Eth,\n          Iban: l.Iban,\n          Net: f.Net,\n          ENS: d.ENS,\n          Personal: h.Personal\n        }, t.default = E;\n      },\n      5809: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ZodError = t.quotelessJson = t.ZodIssueCode = void 0;\n        const n = r(3133);\n        t.ZodIssueCode = n.util.arrayToEnum([\"invalid_type\", \"invalid_literal\", \"custom\", \"invalid_union\", \"invalid_union_discriminator\", \"invalid_enum_value\", \"unrecognized_keys\", \"invalid_arguments\", \"invalid_return_type\", \"invalid_date\", \"invalid_string\", \"too_small\", \"too_big\", \"invalid_intersection_types\", \"not_multiple_of\", \"not_finite\"]), t.quotelessJson = e => JSON.stringify(e, null, 2).replace(/\"([^\"]+)\":/g, \"$1:\");\n        class i extends Error {\n          constructor(e) {\n            var _this;\n            (super(), _this = this), this.issues = [], this.addIssue = e => {\n              this.issues = [...this.issues, e];\n            }, this.addIssues = function () {\n              let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n              _this.issues = [..._this.issues, ...e];\n            };\n            const t = new.target.prototype;\n            Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = \"ZodError\", this.issues = e;\n          }\n          get errors() {\n            return this.issues;\n          }\n          format(e) {\n            const t = e || function (e) {\n                return e.message;\n              },\n              r = {\n                _errors: []\n              },\n              n = e => {\n                for (const i of e.issues) if (\"invalid_union\" === i.code) i.unionErrors.map(n);else if (\"invalid_return_type\" === i.code) n(i.returnTypeError);else if (\"invalid_arguments\" === i.code) n(i.argumentsError);else if (0 === i.path.length) r._errors.push(t(i));else {\n                  let e = r,\n                    n = 0;\n                  for (; n < i.path.length;) {\n                    const r = i.path[n];\n                    n === i.path.length - 1 ? (e[r] = e[r] || {\n                      _errors: []\n                    }, e[r]._errors.push(t(i))) : e[r] = e[r] || {\n                      _errors: []\n                    }, e = e[r], n++;\n                  }\n                }\n              };\n            return n(this), r;\n          }\n          toString() {\n            return this.message;\n          }\n          get message() {\n            return JSON.stringify(this.issues, n.util.jsonStringifyReplacer, 2);\n          }\n          get isEmpty() {\n            return 0 === this.issues.length;\n          }\n          flatten() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : e => e.message;\n            const t = {},\n              r = [];\n            for (const n of this.issues) n.path.length > 0 ? (t[n.path[0]] = t[n.path[0]] || [], t[n.path[0]].push(e(n))) : r.push(e(n));\n            return {\n              formErrors: r,\n              fieldErrors: t\n            };\n          }\n          get formErrors() {\n            return this.flatten();\n          }\n        }\n        t.ZodError = i, i.create = e => new i(e);\n      },\n      1909: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getErrorMap = t.setErrorMap = t.defaultErrorMap = void 0;\n        const i = n(r(6013));\n        t.defaultErrorMap = i.default;\n        let o = i.default;\n        t.setErrorMap = function (e) {\n          o = e;\n        }, t.getErrorMap = function () {\n          return o;\n        };\n      },\n      4474: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r), Object.defineProperty(e, n, {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            });\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), i(r(1909), t), i(r(4735), t), i(r(1832), t), i(r(3133), t), i(r(1176), t), i(r(5809), t);\n      },\n      3682: (e, t) => {\n        \"use strict\";\n\n        var r;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.errorUtil = void 0, (r = t.errorUtil || (t.errorUtil = {})).errToObj = e => \"string\" == typeof e ? {\n          message: e\n        } : e || {}, r.toString = e => \"string\" == typeof e ? e : null == e ? void 0 : e.message;\n      },\n      4735: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;\n        const i = r(1909),\n          o = n(r(6013));\n        t.makeIssue = e => {\n          const {\n              data: t,\n              path: r,\n              errorMaps: n,\n              issueData: i\n            } = e,\n            o = [...r, ...(i.path || [])],\n            s = _objectSpread(_objectSpread({}, i), {}, {\n              path: o\n            });\n          let a = \"\";\n          const c = n.filter(e => !!e).slice().reverse();\n          for (const e of c) a = e(s, {\n            data: t,\n            defaultError: a\n          }).message;\n          return _objectSpread(_objectSpread({}, i), {}, {\n            path: o,\n            message: i.message || a\n          });\n        }, t.EMPTY_PATH = [], t.addIssueToContext = function (e, r) {\n          const n = (0, t.makeIssue)({\n            issueData: r,\n            data: e.data,\n            path: e.path,\n            errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, (0, i.getErrorMap)(), o.default].filter(e => !!e)\n          });\n          e.common.issues.push(n);\n        };\n        class s {\n          constructor() {\n            this.value = \"valid\";\n          }\n          dirty() {\n            \"valid\" === this.value && (this.value = \"dirty\");\n          }\n          abort() {\n            \"aborted\" !== this.value && (this.value = \"aborted\");\n          }\n          static mergeArray(e, r) {\n            const n = [];\n            for (const i of r) {\n              if (\"aborted\" === i.status) return t.INVALID;\n              \"dirty\" === i.status && e.dirty(), n.push(i.value);\n            }\n            return {\n              status: e.value,\n              value: n\n            };\n          }\n          static mergeObjectAsync(e, t) {\n            return _asyncToGenerator(function* () {\n              const r = [];\n              for (const e of t) r.push({\n                key: yield e.key,\n                value: yield e.value\n              });\n              return s.mergeObjectSync(e, r);\n            })();\n          }\n          static mergeObjectSync(e, r) {\n            const n = {};\n            for (const i of r) {\n              const {\n                key: r,\n                value: o\n              } = i;\n              if (\"aborted\" === r.status) return t.INVALID;\n              if (\"aborted\" === o.status) return t.INVALID;\n              \"dirty\" === r.status && e.dirty(), \"dirty\" === o.status && e.dirty(), \"__proto__\" === r.value || void 0 === o.value && !i.alwaysSet || (n[r.value] = o.value);\n            }\n            return {\n              status: e.value,\n              value: n\n            };\n          }\n        }\n        t.ParseStatus = s, t.INVALID = Object.freeze({\n          status: \"aborted\"\n        }), t.DIRTY = e => ({\n          status: \"dirty\",\n          value: e\n        }), t.OK = e => ({\n          status: \"valid\",\n          value: e\n        }), t.isAborted = e => \"aborted\" === e.status, t.isDirty = e => \"dirty\" === e.status, t.isValid = e => \"valid\" === e.status, t.isAsync = e => \"undefined\" != typeof Promise && e instanceof Promise;\n      },\n      1832: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      3133: (e, t) => {\n        \"use strict\";\n\n        var r;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0, function (e) {\n          e.assertEqual = e => e, e.assertIs = function (e) {}, e.assertNever = function (e) {\n            throw new Error();\n          }, e.arrayToEnum = e => {\n            const t = {};\n            for (const r of e) t[r] = r;\n            return t;\n          }, e.getValidEnumValues = t => {\n            const r = e.objectKeys(t).filter(e => \"number\" != typeof t[t[e]]),\n              n = {};\n            for (const e of r) n[e] = t[e];\n            return e.objectValues(n);\n          }, e.objectValues = t => e.objectKeys(t).map(function (e) {\n            return t[e];\n          }), e.objectKeys = \"function\" == typeof Object.keys ? e => Object.keys(e) : e => {\n            const t = [];\n            for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && t.push(r);\n            return t;\n          }, e.find = (e, t) => {\n            for (const r of e) if (t(r)) return r;\n          }, e.isInteger = \"function\" == typeof Number.isInteger ? e => Number.isInteger(e) : e => \"number\" == typeof e && isFinite(e) && Math.floor(e) === e, e.joinValues = function (e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" | \";\n            return e.map(e => \"string\" == typeof e ? \"'\".concat(e, \"'\") : e).join(t);\n          }, e.jsonStringifyReplacer = (e, t) => \"bigint\" == typeof t ? t.toString() : t;\n        }(r = t.util || (t.util = {})), (t.objectUtil || (t.objectUtil = {})).mergeShapes = (e, t) => _objectSpread(_objectSpread({}, e), t), t.ZodParsedType = r.arrayToEnum([\"string\", \"nan\", \"number\", \"integer\", \"float\", \"boolean\", \"date\", \"bigint\", \"symbol\", \"function\", \"undefined\", \"null\", \"array\", \"object\", \"unknown\", \"promise\", \"void\", \"never\", \"map\", \"set\"]), t.getParsedType = e => {\n          switch (typeof e) {\n            case \"undefined\":\n              return t.ZodParsedType.undefined;\n            case \"string\":\n              return t.ZodParsedType.string;\n            case \"number\":\n              return isNaN(e) ? t.ZodParsedType.nan : t.ZodParsedType.number;\n            case \"boolean\":\n              return t.ZodParsedType.boolean;\n            case \"function\":\n              return t.ZodParsedType.function;\n            case \"bigint\":\n              return t.ZodParsedType.bigint;\n            case \"symbol\":\n              return t.ZodParsedType.symbol;\n            case \"object\":\n              return Array.isArray(e) ? t.ZodParsedType.array : null === e ? t.ZodParsedType.null : e.then && \"function\" == typeof e.then && e.catch && \"function\" == typeof e.catch ? t.ZodParsedType.promise : \"undefined\" != typeof Map && e instanceof Map ? t.ZodParsedType.map : \"undefined\" != typeof Set && e instanceof Set ? t.ZodParsedType.set : \"undefined\" != typeof Date && e instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;\n            default:\n              return t.ZodParsedType.unknown;\n          }\n        };\n      },\n      6750: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r), Object.defineProperty(e, n, {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            });\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.z = void 0;\n        const a = o(r(4474));\n        t.z = a, s(r(4474), t), t.default = a;\n      },\n      6013: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const n = r(3133),\n          i = r(5809);\n        t.default = (e, t) => {\n          let r;\n          switch (e.code) {\n            case i.ZodIssueCode.invalid_type:\n              r = e.received === n.ZodParsedType.undefined ? \"Required\" : \"Expected \".concat(e.expected, \", received \").concat(e.received);\n              break;\n            case i.ZodIssueCode.invalid_literal:\n              r = \"Invalid literal value, expected \".concat(JSON.stringify(e.expected, n.util.jsonStringifyReplacer));\n              break;\n            case i.ZodIssueCode.unrecognized_keys:\n              r = \"Unrecognized key(s) in object: \".concat(n.util.joinValues(e.keys, \", \"));\n              break;\n            case i.ZodIssueCode.invalid_union:\n              r = \"Invalid input\";\n              break;\n            case i.ZodIssueCode.invalid_union_discriminator:\n              r = \"Invalid discriminator value. Expected \".concat(n.util.joinValues(e.options));\n              break;\n            case i.ZodIssueCode.invalid_enum_value:\n              r = \"Invalid enum value. Expected \".concat(n.util.joinValues(e.options), \", received '\").concat(e.received, \"'\");\n              break;\n            case i.ZodIssueCode.invalid_arguments:\n              r = \"Invalid function arguments\";\n              break;\n            case i.ZodIssueCode.invalid_return_type:\n              r = \"Invalid function return type\";\n              break;\n            case i.ZodIssueCode.invalid_date:\n              r = \"Invalid date\";\n              break;\n            case i.ZodIssueCode.invalid_string:\n              \"object\" == typeof e.validation ? \"includes\" in e.validation ? (r = \"Invalid input: must include \\\"\".concat(e.validation.includes, \"\\\"\"), \"number\" == typeof e.validation.position && (r = \"\".concat(r, \" at one or more positions greater than or equal to \").concat(e.validation.position))) : \"startsWith\" in e.validation ? r = \"Invalid input: must start with \\\"\".concat(e.validation.startsWith, \"\\\"\") : \"endsWith\" in e.validation ? r = \"Invalid input: must end with \\\"\".concat(e.validation.endsWith, \"\\\"\") : n.util.assertNever(e.validation) : r = \"regex\" !== e.validation ? \"Invalid \".concat(e.validation) : \"Invalid\";\n              break;\n            case i.ZodIssueCode.too_small:\n              r = \"array\" === e.type ? \"Array must contain \".concat(e.exact ? \"exactly\" : e.inclusive ? \"at least\" : \"more than\", \" \").concat(e.minimum, \" element(s)\") : \"string\" === e.type ? \"String must contain \".concat(e.exact ? \"exactly\" : e.inclusive ? \"at least\" : \"over\", \" \").concat(e.minimum, \" character(s)\") : \"number\" === e.type ? \"Number must be \".concat(e.exact ? \"exactly equal to \" : e.inclusive ? \"greater than or equal to \" : \"greater than \").concat(e.minimum) : \"date\" === e.type ? \"Date must be \".concat(e.exact ? \"exactly equal to \" : e.inclusive ? \"greater than or equal to \" : \"greater than \").concat(new Date(Number(e.minimum))) : \"Invalid input\";\n              break;\n            case i.ZodIssueCode.too_big:\n              r = \"array\" === e.type ? \"Array must contain \".concat(e.exact ? \"exactly\" : e.inclusive ? \"at most\" : \"less than\", \" \").concat(e.maximum, \" element(s)\") : \"string\" === e.type ? \"String must contain \".concat(e.exact ? \"exactly\" : e.inclusive ? \"at most\" : \"under\", \" \").concat(e.maximum, \" character(s)\") : \"number\" === e.type ? \"Number must be \".concat(e.exact ? \"exactly\" : e.inclusive ? \"less than or equal to\" : \"less than\", \" \").concat(e.maximum) : \"bigint\" === e.type ? \"BigInt must be \".concat(e.exact ? \"exactly\" : e.inclusive ? \"less than or equal to\" : \"less than\", \" \").concat(e.maximum) : \"date\" === e.type ? \"Date must be \".concat(e.exact ? \"exactly\" : e.inclusive ? \"smaller than or equal to\" : \"smaller than\", \" \").concat(new Date(Number(e.maximum))) : \"Invalid input\";\n              break;\n            case i.ZodIssueCode.custom:\n              r = \"Invalid input\";\n              break;\n            case i.ZodIssueCode.invalid_intersection_types:\n              r = \"Intersection results could not be merged\";\n              break;\n            case i.ZodIssueCode.not_multiple_of:\n              r = \"Number must be a multiple of \".concat(e.multipleOf);\n              break;\n            case i.ZodIssueCode.not_finite:\n              r = \"Number must be finite\";\n              break;\n            default:\n              r = t.defaultError, n.util.assertNever(e);\n          }\n          return {\n            message: r\n          };\n        };\n      },\n      1176: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.date = t.boolean = t.bigint = t.array = t.any = t.coerce = t.ZodFirstPartyTypeKind = t.late = t.ZodSchema = t.Schema = t.custom = t.ZodReadonly = t.ZodPipeline = t.ZodBranded = t.BRAND = t.ZodNaN = t.ZodCatch = t.ZodDefault = t.ZodNullable = t.ZodOptional = t.ZodTransformer = t.ZodEffects = t.ZodPromise = t.ZodNativeEnum = t.ZodEnum = t.ZodLiteral = t.ZodLazy = t.ZodFunction = t.ZodSet = t.ZodMap = t.ZodRecord = t.ZodTuple = t.ZodIntersection = t.ZodDiscriminatedUnion = t.ZodUnion = t.ZodObject = t.ZodArray = t.ZodVoid = t.ZodNever = t.ZodUnknown = t.ZodAny = t.ZodNull = t.ZodUndefined = t.ZodSymbol = t.ZodDate = t.ZodBoolean = t.ZodBigInt = t.ZodNumber = t.ZodString = t.ZodType = void 0, t.NEVER = t.void = t.unknown = t.union = t.undefined = t.tuple = t.transformer = t.symbol = t.string = t.strictObject = t.set = t.record = t.promise = t.preprocess = t.pipeline = t.ostring = t.optional = t.onumber = t.oboolean = t.object = t.number = t.nullable = t.null = t.never = t.nativeEnum = t.nan = t.map = t.literal = t.lazy = t.intersection = t.instanceof = t.function = t.enum = t.effect = t.discriminatedUnion = void 0;\n        const n = r(1909),\n          i = r(3682),\n          o = r(4735),\n          s = r(3133),\n          a = r(5809);\n        class c {\n          constructor(e, t, r, n) {\n            this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = n;\n          }\n          get path() {\n            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n          }\n        }\n        const u = (e, t) => {\n          if ((0, o.isValid)(t)) return {\n            success: !0,\n            data: t.value\n          };\n          if (!e.common.issues.length) throw new Error(\"Validation failed but no issues detected.\");\n          return {\n            success: !1,\n            get error() {\n              if (this._error) return this._error;\n              const t = new a.ZodError(e.common.issues);\n              return this._error = t, this._error;\n            }\n          };\n        };\n        function d(e) {\n          if (!e) return {};\n          const {\n            errorMap: t,\n            invalid_type_error: r,\n            required_error: n,\n            description: i\n          } = e;\n          if (t && (r || n)) throw new Error('Can\\'t use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.');\n          return t ? {\n            errorMap: t,\n            description: i\n          } : {\n            errorMap: (e, t) => \"invalid_type\" !== e.code ? {\n              message: t.defaultError\n            } : void 0 === t.data ? {\n              message: null != n ? n : t.defaultError\n            } : {\n              message: null != r ? r : t.defaultError\n            },\n            description: i\n          };\n        }\n        class l {\n          constructor(e) {\n            this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);\n          }\n          get description() {\n            return this._def.description;\n          }\n          _getType(e) {\n            return (0, s.getParsedType)(e.data);\n          }\n          _getOrReturnCtx(e, t) {\n            return t || {\n              common: e.parent.common,\n              data: e.data,\n              parsedType: (0, s.getParsedType)(e.data),\n              schemaErrorMap: this._def.errorMap,\n              path: e.path,\n              parent: e.parent\n            };\n          }\n          _processInputParams(e) {\n            return {\n              status: new o.ParseStatus(),\n              ctx: {\n                common: e.parent.common,\n                data: e.data,\n                parsedType: (0, s.getParsedType)(e.data),\n                schemaErrorMap: this._def.errorMap,\n                path: e.path,\n                parent: e.parent\n              }\n            };\n          }\n          _parseSync(e) {\n            const t = this._parse(e);\n            if ((0, o.isAsync)(t)) throw new Error(\"Synchronous parse encountered promise.\");\n            return t;\n          }\n          _parseAsync(e) {\n            const t = this._parse(e);\n            return Promise.resolve(t);\n          }\n          parse(e, t) {\n            const r = this.safeParse(e, t);\n            if (r.success) return r.data;\n            throw r.error;\n          }\n          safeParse(e, t) {\n            var r;\n            const n = {\n                common: {\n                  issues: [],\n                  async: null !== (r = null == t ? void 0 : t.async) && void 0 !== r && r,\n                  contextualErrorMap: null == t ? void 0 : t.errorMap\n                },\n                path: (null == t ? void 0 : t.path) || [],\n                schemaErrorMap: this._def.errorMap,\n                parent: null,\n                data: e,\n                parsedType: (0, s.getParsedType)(e)\n              },\n              i = this._parseSync({\n                data: e,\n                path: n.path,\n                parent: n\n              });\n            return u(n, i);\n          }\n          parseAsync(e, t) {\n            var _this2 = this;\n            return _asyncToGenerator(function* () {\n              const r = yield _this2.safeParseAsync(e, t);\n              if (r.success) return r.data;\n              throw r.error;\n            })();\n          }\n          safeParseAsync(e, t) {\n            var _this3 = this;\n            return _asyncToGenerator(function* () {\n              const r = {\n                  common: {\n                    issues: [],\n                    contextualErrorMap: null == t ? void 0 : t.errorMap,\n                    async: !0\n                  },\n                  path: (null == t ? void 0 : t.path) || [],\n                  schemaErrorMap: _this3._def.errorMap,\n                  parent: null,\n                  data: e,\n                  parsedType: (0, s.getParsedType)(e)\n                },\n                n = _this3._parse({\n                  data: e,\n                  path: r.path,\n                  parent: r\n                }),\n                i = yield (0, o.isAsync)(n) ? n : Promise.resolve(n);\n              return u(r, i);\n            })();\n          }\n          refine(e, t) {\n            const r = e => \"string\" == typeof t || void 0 === t ? {\n              message: t\n            } : \"function\" == typeof t ? t(e) : t;\n            return this._refinement((t, n) => {\n              const i = e(t),\n                o = () => n.addIssue(_objectSpread({\n                  code: a.ZodIssueCode.custom\n                }, r(t)));\n              return \"undefined\" != typeof Promise && i instanceof Promise ? i.then(e => !!e || (o(), !1)) : !!i || (o(), !1);\n            });\n          }\n          refinement(e, t) {\n            return this._refinement((r, n) => !!e(r) || (n.addIssue(\"function\" == typeof t ? t(r, n) : t), !1));\n          }\n          _refinement(e) {\n            return new Y({\n              schema: this,\n              typeName: ae.ZodEffects,\n              effect: {\n                type: \"refinement\",\n                refinement: e\n              }\n            });\n          }\n          superRefine(e) {\n            return this._refinement(e);\n          }\n          optional() {\n            return $.create(this, this._def);\n          }\n          nullable() {\n            return ee.create(this, this._def);\n          }\n          nullish() {\n            return this.nullable().optional();\n          }\n          array() {\n            return N.create(this, this._def);\n          }\n          promise() {\n            return X.create(this, this._def);\n          }\n          or(e) {\n            return D.create([this, e], this._def);\n          }\n          and(e) {\n            return H.create(this, e, this._def);\n          }\n          transform(e) {\n            return new Y(_objectSpread(_objectSpread({}, d(this._def)), {}, {\n              schema: this,\n              typeName: ae.ZodEffects,\n              effect: {\n                type: \"transform\",\n                transform: e\n              }\n            }));\n          }\n          default(e) {\n            const t = \"function\" == typeof e ? e : () => e;\n            return new te(_objectSpread(_objectSpread({}, d(this._def)), {}, {\n              innerType: this,\n              defaultValue: t,\n              typeName: ae.ZodDefault\n            }));\n          }\n          brand() {\n            return new ie(_objectSpread({\n              typeName: ae.ZodBranded,\n              type: this\n            }, d(this._def)));\n          }\n          catch(e) {\n            const t = \"function\" == typeof e ? e : () => e;\n            return new re(_objectSpread(_objectSpread({}, d(this._def)), {}, {\n              innerType: this,\n              catchValue: t,\n              typeName: ae.ZodCatch\n            }));\n          }\n          describe(e) {\n            return new (0, this.constructor)(_objectSpread(_objectSpread({}, this._def), {}, {\n              description: e\n            }));\n          }\n          pipe(e) {\n            return oe.create(this, e);\n          }\n          readonly() {\n            return se.create(this);\n          }\n          isOptional() {\n            return this.safeParse(void 0).success;\n          }\n          isNullable() {\n            return this.safeParse(null).success;\n          }\n        }\n        t.ZodType = l, t.Schema = l, t.ZodSchema = l;\n        const h = /^c[^\\s-]{8,}$/i,\n          f = /^[a-z][a-z0-9]*$/,\n          p = /[0-9A-HJKMNP-TV-Z]{26}/,\n          m = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i,\n          g = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i,\n          y = /^((?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])|(?:[#\\*0-9\\u200D\\u20E3\\uFE0F]|\\uD83C[\\uDDE6-\\uDDFF\\uDFFB-\\uDFFF]|\\uD83E[\\uDDB0-\\uDDB3]|\\uDB40[\\uDC20-\\uDC7F]))+$/,\n          v = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,\n          b = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n        class E extends l {\n          constructor() {\n            super(...arguments), this._regex = (e, t, r) => this.refinement(t => e.test(t), _objectSpread({\n              validation: t,\n              code: a.ZodIssueCode.invalid_string\n            }, i.errorUtil.errToObj(r))), this.nonempty = e => this.min(1, i.errorUtil.errToObj(e)), this.trim = () => new E(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, {\n                kind: \"trim\"\n              }]\n            })), this.toLowerCase = () => new E(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, {\n                kind: \"toLowerCase\"\n              }]\n            })), this.toUpperCase = () => new E(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, {\n                kind: \"toUpperCase\"\n              }]\n            }));\n          }\n          _parse(e) {\n            if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== s.ZodParsedType.string) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.string,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            const t = new o.ParseStatus();\n            let r;\n            for (const u of this._def.checks) if (\"min\" === u.kind) e.data.length < u.value && (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              minimum: u.value,\n              type: \"string\",\n              inclusive: !0,\n              exact: !1,\n              message: u.message\n            }), t.dirty());else if (\"max\" === u.kind) e.data.length > u.value && (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              maximum: u.value,\n              type: \"string\",\n              inclusive: !0,\n              exact: !1,\n              message: u.message\n            }), t.dirty());else if (\"length\" === u.kind) {\n              const n = e.data.length > u.value,\n                i = e.data.length < u.value;\n              (n || i) && (r = this._getOrReturnCtx(e, r), n ? (0, o.addIssueToContext)(r, {\n                code: a.ZodIssueCode.too_big,\n                maximum: u.value,\n                type: \"string\",\n                inclusive: !0,\n                exact: !0,\n                message: u.message\n              }) : i && (0, o.addIssueToContext)(r, {\n                code: a.ZodIssueCode.too_small,\n                minimum: u.value,\n                type: \"string\",\n                inclusive: !0,\n                exact: !0,\n                message: u.message\n              }), t.dirty());\n            } else if (\"email\" === u.kind) g.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"email\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"emoji\" === u.kind) y.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"emoji\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"uuid\" === u.kind) m.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"uuid\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"cuid\" === u.kind) h.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"cuid\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"cuid2\" === u.kind) f.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"cuid2\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"ulid\" === u.kind) p.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"ulid\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty());else if (\"url\" === u.kind) try {\n              new URL(e.data);\n            } catch (n) {\n              r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n                validation: \"url\",\n                code: a.ZodIssueCode.invalid_string,\n                message: u.message\n              }), t.dirty();\n            } else \"regex\" === u.kind ? (u.regex.lastIndex = 0, u.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"regex\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty())) : \"trim\" === u.kind ? e.data = e.data.trim() : \"includes\" === u.kind ? e.data.includes(u.value, u.position) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: {\n                includes: u.value,\n                position: u.position\n              },\n              message: u.message\n            }), t.dirty()) : \"toLowerCase\" === u.kind ? e.data = e.data.toLowerCase() : \"toUpperCase\" === u.kind ? e.data = e.data.toUpperCase() : \"startsWith\" === u.kind ? e.data.startsWith(u.value) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: {\n                startsWith: u.value\n              },\n              message: u.message\n            }), t.dirty()) : \"endsWith\" === u.kind ? e.data.endsWith(u.value) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: {\n                endsWith: u.value\n              },\n              message: u.message\n            }), t.dirty()) : \"datetime\" === u.kind ? ((c = u).precision ? c.offset ? new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{\".concat(c.precision, \"}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$\")) : new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{\".concat(c.precision, \"}Z$\")) : 0 === c.precision ? c.offset ? new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$\") : new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$\") : c.offset ? new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$\") : new RegExp(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$\")).test(e.data) || (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_string,\n              validation: \"datetime\",\n              message: u.message\n            }), t.dirty()) : \"ip\" === u.kind ? (n = e.data, (\"v4\" !== (i = u.version) && i || !v.test(n)) && (\"v6\" !== i && i || !b.test(n)) && (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              validation: \"ip\",\n              code: a.ZodIssueCode.invalid_string,\n              message: u.message\n            }), t.dirty())) : s.util.assertNever(u);\n            var n, i, c;\n            return {\n              status: t.value,\n              value: e.data\n            };\n          }\n          _addCheck(e) {\n            return new E(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, e]\n            }));\n          }\n          email(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"email\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          url(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"url\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          emoji(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"emoji\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          uuid(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"uuid\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          cuid(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"cuid\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          cuid2(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"cuid2\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          ulid(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"ulid\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          ip(e) {\n            return this._addCheck(_objectSpread({\n              kind: \"ip\"\n            }, i.errorUtil.errToObj(e)));\n          }\n          datetime(e) {\n            var t;\n            return \"string\" == typeof e ? this._addCheck({\n              kind: \"datetime\",\n              precision: null,\n              offset: !1,\n              message: e\n            }) : this._addCheck(_objectSpread({\n              kind: \"datetime\",\n              precision: void 0 === (null == e ? void 0 : e.precision) ? null : null == e ? void 0 : e.precision,\n              offset: null !== (t = null == e ? void 0 : e.offset) && void 0 !== t && t\n            }, i.errorUtil.errToObj(null == e ? void 0 : e.message)));\n          }\n          regex(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"regex\",\n              regex: e\n            }, i.errorUtil.errToObj(t)));\n          }\n          includes(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"includes\",\n              value: e,\n              position: null == t ? void 0 : t.position\n            }, i.errorUtil.errToObj(null == t ? void 0 : t.message)));\n          }\n          startsWith(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"startsWith\",\n              value: e\n            }, i.errorUtil.errToObj(t)));\n          }\n          endsWith(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"endsWith\",\n              value: e\n            }, i.errorUtil.errToObj(t)));\n          }\n          min(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"min\",\n              value: e\n            }, i.errorUtil.errToObj(t)));\n          }\n          max(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"max\",\n              value: e\n            }, i.errorUtil.errToObj(t)));\n          }\n          length(e, t) {\n            return this._addCheck(_objectSpread({\n              kind: \"length\",\n              value: e\n            }, i.errorUtil.errToObj(t)));\n          }\n          get isDatetime() {\n            return !!this._def.checks.find(e => \"datetime\" === e.kind);\n          }\n          get isEmail() {\n            return !!this._def.checks.find(e => \"email\" === e.kind);\n          }\n          get isURL() {\n            return !!this._def.checks.find(e => \"url\" === e.kind);\n          }\n          get isEmoji() {\n            return !!this._def.checks.find(e => \"emoji\" === e.kind);\n          }\n          get isUUID() {\n            return !!this._def.checks.find(e => \"uuid\" === e.kind);\n          }\n          get isCUID() {\n            return !!this._def.checks.find(e => \"cuid\" === e.kind);\n          }\n          get isCUID2() {\n            return !!this._def.checks.find(e => \"cuid2\" === e.kind);\n          }\n          get isULID() {\n            return !!this._def.checks.find(e => \"ulid\" === e.kind);\n          }\n          get isIP() {\n            return !!this._def.checks.find(e => \"ip\" === e.kind);\n          }\n          get minLength() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return e;\n          }\n          get maxLength() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return e;\n          }\n        }\n        function _(e, t) {\n          const r = (e.toString().split(\".\")[1] || \"\").length,\n            n = (t.toString().split(\".\")[1] || \"\").length,\n            i = r > n ? r : n;\n          return parseInt(e.toFixed(i).replace(\".\", \"\")) % parseInt(t.toFixed(i).replace(\".\", \"\")) / Math.pow(10, i);\n        }\n        t.ZodString = E, E.create = e => {\n          var t;\n          return new E(_objectSpread({\n            checks: [],\n            typeName: ae.ZodString,\n            coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t\n          }, d(e)));\n        };\n        class A extends l {\n          constructor() {\n            super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n          }\n          _parse(e) {\n            if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== s.ZodParsedType.number) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.number,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            let t;\n            const r = new o.ParseStatus();\n            for (const n of this._def.checks) \"int\" === n.kind ? s.util.isInteger(e.data) || (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: \"integer\",\n              received: \"float\",\n              message: n.message\n            }), r.dirty()) : \"min\" === n.kind ? (n.inclusive ? e.data < n.value : e.data <= n.value) && (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_small,\n              minimum: n.value,\n              type: \"number\",\n              inclusive: n.inclusive,\n              exact: !1,\n              message: n.message\n            }), r.dirty()) : \"max\" === n.kind ? (n.inclusive ? e.data > n.value : e.data >= n.value) && (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_big,\n              maximum: n.value,\n              type: \"number\",\n              inclusive: n.inclusive,\n              exact: !1,\n              message: n.message\n            }), r.dirty()) : \"multipleOf\" === n.kind ? 0 !== _(e.data, n.value) && (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.not_multiple_of,\n              multipleOf: n.value,\n              message: n.message\n            }), r.dirty()) : \"finite\" === n.kind ? Number.isFinite(e.data) || (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.not_finite,\n              message: n.message\n            }), r.dirty()) : s.util.assertNever(n);\n            return {\n              status: r.value,\n              value: e.data\n            };\n          }\n          gte(e, t) {\n            return this.setLimit(\"min\", e, !0, i.errorUtil.toString(t));\n          }\n          gt(e, t) {\n            return this.setLimit(\"min\", e, !1, i.errorUtil.toString(t));\n          }\n          lte(e, t) {\n            return this.setLimit(\"max\", e, !0, i.errorUtil.toString(t));\n          }\n          lt(e, t) {\n            return this.setLimit(\"max\", e, !1, i.errorUtil.toString(t));\n          }\n          setLimit(e, t, r, n) {\n            return new A(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, {\n                kind: e,\n                value: t,\n                inclusive: r,\n                message: i.errorUtil.toString(n)\n              }]\n            }));\n          }\n          _addCheck(e) {\n            return new A(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, e]\n            }));\n          }\n          int(e) {\n            return this._addCheck({\n              kind: \"int\",\n              message: i.errorUtil.toString(e)\n            });\n          }\n          positive(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: 0,\n              inclusive: !1,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          negative(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: 0,\n              inclusive: !1,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          nonpositive(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: 0,\n              inclusive: !0,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          nonnegative(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: 0,\n              inclusive: !0,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          multipleOf(e, t) {\n            return this._addCheck({\n              kind: \"multipleOf\",\n              value: e,\n              message: i.errorUtil.toString(t)\n            });\n          }\n          finite(e) {\n            return this._addCheck({\n              kind: \"finite\",\n              message: i.errorUtil.toString(e)\n            });\n          }\n          safe(e) {\n            return this._addCheck({\n              kind: \"min\",\n              inclusive: !0,\n              value: Number.MIN_SAFE_INTEGER,\n              message: i.errorUtil.toString(e)\n            })._addCheck({\n              kind: \"max\",\n              inclusive: !0,\n              value: Number.MAX_SAFE_INTEGER,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          get minValue() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return e;\n          }\n          get maxValue() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return e;\n          }\n          get isInt() {\n            return !!this._def.checks.find(e => \"int\" === e.kind || \"multipleOf\" === e.kind && s.util.isInteger(e.value));\n          }\n          get isFinite() {\n            let e = null,\n              t = null;\n            for (const r of this._def.checks) {\n              if (\"finite\" === r.kind || \"int\" === r.kind || \"multipleOf\" === r.kind) return !0;\n              \"min\" === r.kind ? (null === t || r.value > t) && (t = r.value) : \"max\" === r.kind && (null === e || r.value < e) && (e = r.value);\n            }\n            return Number.isFinite(t) && Number.isFinite(e);\n          }\n        }\n        t.ZodNumber = A, A.create = e => new A(_objectSpread({\n          checks: [],\n          typeName: ae.ZodNumber,\n          coerce: (null == e ? void 0 : e.coerce) || !1\n        }, d(e)));\n        class T extends l {\n          constructor() {\n            super(...arguments), this.min = this.gte, this.max = this.lte;\n          }\n          _parse(e) {\n            if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== s.ZodParsedType.bigint) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.bigint,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            let t;\n            const r = new o.ParseStatus();\n            for (const n of this._def.checks) \"min\" === n.kind ? (n.inclusive ? e.data < n.value : e.data <= n.value) && (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_small,\n              type: \"bigint\",\n              minimum: n.value,\n              inclusive: n.inclusive,\n              message: n.message\n            }), r.dirty()) : \"max\" === n.kind ? (n.inclusive ? e.data > n.value : e.data >= n.value) && (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_big,\n              type: \"bigint\",\n              maximum: n.value,\n              inclusive: n.inclusive,\n              message: n.message\n            }), r.dirty()) : \"multipleOf\" === n.kind ? e.data % n.value !== BigInt(0) && (t = this._getOrReturnCtx(e, t), (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.not_multiple_of,\n              multipleOf: n.value,\n              message: n.message\n            }), r.dirty()) : s.util.assertNever(n);\n            return {\n              status: r.value,\n              value: e.data\n            };\n          }\n          gte(e, t) {\n            return this.setLimit(\"min\", e, !0, i.errorUtil.toString(t));\n          }\n          gt(e, t) {\n            return this.setLimit(\"min\", e, !1, i.errorUtil.toString(t));\n          }\n          lte(e, t) {\n            return this.setLimit(\"max\", e, !0, i.errorUtil.toString(t));\n          }\n          lt(e, t) {\n            return this.setLimit(\"max\", e, !1, i.errorUtil.toString(t));\n          }\n          setLimit(e, t, r, n) {\n            return new T(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, {\n                kind: e,\n                value: t,\n                inclusive: r,\n                message: i.errorUtil.toString(n)\n              }]\n            }));\n          }\n          _addCheck(e) {\n            return new T(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, e]\n            }));\n          }\n          positive(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: BigInt(0),\n              inclusive: !1,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          negative(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: BigInt(0),\n              inclusive: !1,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          nonpositive(e) {\n            return this._addCheck({\n              kind: \"max\",\n              value: BigInt(0),\n              inclusive: !0,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          nonnegative(e) {\n            return this._addCheck({\n              kind: \"min\",\n              value: BigInt(0),\n              inclusive: !0,\n              message: i.errorUtil.toString(e)\n            });\n          }\n          multipleOf(e, t) {\n            return this._addCheck({\n              kind: \"multipleOf\",\n              value: e,\n              message: i.errorUtil.toString(t)\n            });\n          }\n          get minValue() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return e;\n          }\n          get maxValue() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return e;\n          }\n        }\n        t.ZodBigInt = T, T.create = e => {\n          var t;\n          return new T(_objectSpread({\n            checks: [],\n            typeName: ae.ZodBigInt,\n            coerce: null !== (t = null == e ? void 0 : e.coerce) && void 0 !== t && t\n          }, d(e)));\n        };\n        class I extends l {\n          _parse(e) {\n            if (this._def.coerce && (e.data = Boolean(e.data)), this._getType(e) !== s.ZodParsedType.boolean) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.boolean,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodBoolean = I, I.create = e => new I(_objectSpread({\n          typeName: ae.ZodBoolean,\n          coerce: (null == e ? void 0 : e.coerce) || !1\n        }, d(e)));\n        class R extends l {\n          _parse(e) {\n            if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== s.ZodParsedType.date) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.date,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            if (isNaN(e.data.getTime())) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_date\n              }), o.INVALID;\n            }\n            const t = new o.ParseStatus();\n            let r;\n            for (const n of this._def.checks) \"min\" === n.kind ? e.data.getTime() < n.value && (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              message: n.message,\n              inclusive: !0,\n              exact: !1,\n              minimum: n.value,\n              type: \"date\"\n            }), t.dirty()) : \"max\" === n.kind ? e.data.getTime() > n.value && (r = this._getOrReturnCtx(e, r), (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              message: n.message,\n              inclusive: !0,\n              exact: !1,\n              maximum: n.value,\n              type: \"date\"\n            }), t.dirty()) : s.util.assertNever(n);\n            return {\n              status: t.value,\n              value: new Date(e.data.getTime())\n            };\n          }\n          _addCheck(e) {\n            return new R(_objectSpread(_objectSpread({}, this._def), {}, {\n              checks: [...this._def.checks, e]\n            }));\n          }\n          min(e, t) {\n            return this._addCheck({\n              kind: \"min\",\n              value: e.getTime(),\n              message: i.errorUtil.toString(t)\n            });\n          }\n          max(e, t) {\n            return this._addCheck({\n              kind: \"max\",\n              value: e.getTime(),\n              message: i.errorUtil.toString(t)\n            });\n          }\n          get minDate() {\n            let e = null;\n            for (const t of this._def.checks) \"min\" === t.kind && (null === e || t.value > e) && (e = t.value);\n            return null != e ? new Date(e) : null;\n          }\n          get maxDate() {\n            let e = null;\n            for (const t of this._def.checks) \"max\" === t.kind && (null === e || t.value < e) && (e = t.value);\n            return null != e ? new Date(e) : null;\n          }\n        }\n        t.ZodDate = R, R.create = e => new R(_objectSpread({\n          checks: [],\n          coerce: (null == e ? void 0 : e.coerce) || !1,\n          typeName: ae.ZodDate\n        }, d(e)));\n        class w extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.symbol) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.symbol,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodSymbol = w, w.create = e => new w(_objectSpread({\n          typeName: ae.ZodSymbol\n        }, d(e)));\n        class P extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.undefined) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.undefined,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodUndefined = P, P.create = e => new P(_objectSpread({\n          typeName: ae.ZodUndefined\n        }, d(e)));\n        class x extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.null) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.null,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodNull = x, x.create = e => new x(_objectSpread({\n          typeName: ae.ZodNull\n        }, d(e)));\n        class S extends l {\n          constructor() {\n            super(...arguments), this._any = !0;\n          }\n          _parse(e) {\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodAny = S, S.create = e => new S(_objectSpread({\n          typeName: ae.ZodAny\n        }, d(e)));\n        class O extends l {\n          constructor() {\n            super(...arguments), this._unknown = !0;\n          }\n          _parse(e) {\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodUnknown = O, O.create = e => new O(_objectSpread({\n          typeName: ae.ZodUnknown\n        }, d(e)));\n        class C extends l {\n          _parse(e) {\n            const t = this._getOrReturnCtx(e);\n            return (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.never,\n              received: t.parsedType\n            }), o.INVALID;\n          }\n        }\n        t.ZodNever = C, C.create = e => new C(_objectSpread({\n          typeName: ae.ZodNever\n        }, d(e)));\n        class B extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.undefined) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.void,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n        }\n        t.ZodVoid = B, B.create = e => new B(_objectSpread({\n          typeName: ae.ZodVoid\n        }, d(e)));\n        class N extends l {\n          _parse(e) {\n            const {\n                ctx: t,\n                status: r\n              } = this._processInputParams(e),\n              n = this._def;\n            if (t.parsedType !== s.ZodParsedType.array) return (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.array,\n              received: t.parsedType\n            }), o.INVALID;\n            if (null !== n.exactLength) {\n              const e = t.data.length > n.exactLength.value,\n                i = t.data.length < n.exactLength.value;\n              (e || i) && ((0, o.addIssueToContext)(t, {\n                code: e ? a.ZodIssueCode.too_big : a.ZodIssueCode.too_small,\n                minimum: i ? n.exactLength.value : void 0,\n                maximum: e ? n.exactLength.value : void 0,\n                type: \"array\",\n                inclusive: !0,\n                exact: !0,\n                message: n.exactLength.message\n              }), r.dirty());\n            }\n            if (null !== n.minLength && t.data.length < n.minLength.value && ((0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_small,\n              minimum: n.minLength.value,\n              type: \"array\",\n              inclusive: !0,\n              exact: !1,\n              message: n.minLength.message\n            }), r.dirty()), null !== n.maxLength && t.data.length > n.maxLength.value && ((0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.too_big,\n              maximum: n.maxLength.value,\n              type: \"array\",\n              inclusive: !0,\n              exact: !1,\n              message: n.maxLength.message\n            }), r.dirty()), t.common.async) return Promise.all([...t.data].map((e, r) => n.type._parseAsync(new c(t, e, t.path, r)))).then(e => o.ParseStatus.mergeArray(r, e));\n            const i = [...t.data].map((e, r) => n.type._parseSync(new c(t, e, t.path, r)));\n            return o.ParseStatus.mergeArray(r, i);\n          }\n          get element() {\n            return this._def.type;\n          }\n          min(e, t) {\n            return new N(_objectSpread(_objectSpread({}, this._def), {}, {\n              minLength: {\n                value: e,\n                message: i.errorUtil.toString(t)\n              }\n            }));\n          }\n          max(e, t) {\n            return new N(_objectSpread(_objectSpread({}, this._def), {}, {\n              maxLength: {\n                value: e,\n                message: i.errorUtil.toString(t)\n              }\n            }));\n          }\n          length(e, t) {\n            return new N(_objectSpread(_objectSpread({}, this._def), {}, {\n              exactLength: {\n                value: e,\n                message: i.errorUtil.toString(t)\n              }\n            }));\n          }\n          nonempty(e) {\n            return this.min(1, e);\n          }\n        }\n        function k(e) {\n          if (e instanceof M) {\n            const t = {};\n            for (const r in e.shape) {\n              const n = e.shape[r];\n              t[r] = $.create(k(n));\n            }\n            return new M(_objectSpread(_objectSpread({}, e._def), {}, {\n              shape: () => t\n            }));\n          }\n          return e instanceof N ? new N(_objectSpread(_objectSpread({}, e._def), {}, {\n            type: k(e.element)\n          })) : e instanceof $ ? $.create(k(e.unwrap())) : e instanceof ee ? ee.create(k(e.unwrap())) : e instanceof U ? U.create(e.items.map(e => k(e))) : e;\n        }\n        t.ZodArray = N, N.create = (e, t) => new N(_objectSpread({\n          type: e,\n          minLength: null,\n          maxLength: null,\n          exactLength: null,\n          typeName: ae.ZodArray\n        }, d(t)));\n        class M extends l {\n          constructor() {\n            super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n          }\n          _getCached() {\n            if (null !== this._cached) return this._cached;\n            const e = this._def.shape(),\n              t = s.util.objectKeys(e);\n            return this._cached = {\n              shape: e,\n              keys: t\n            };\n          }\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.object) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.object,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            const {\n                status: t,\n                ctx: r\n              } = this._processInputParams(e),\n              {\n                shape: n,\n                keys: i\n              } = this._getCached(),\n              u = [];\n            if (!(this._def.catchall instanceof C && \"strip\" === this._def.unknownKeys)) for (const e in r.data) i.includes(e) || u.push(e);\n            const d = [];\n            for (const e of i) {\n              const t = n[e],\n                i = r.data[e];\n              d.push({\n                key: {\n                  status: \"valid\",\n                  value: e\n                },\n                value: t._parse(new c(r, i, r.path, e)),\n                alwaysSet: e in r.data\n              });\n            }\n            if (this._def.catchall instanceof C) {\n              const e = this._def.unknownKeys;\n              if (\"passthrough\" === e) for (const e of u) d.push({\n                key: {\n                  status: \"valid\",\n                  value: e\n                },\n                value: {\n                  status: \"valid\",\n                  value: r.data[e]\n                }\n              });else if (\"strict\" === e) u.length > 0 && ((0, o.addIssueToContext)(r, {\n                code: a.ZodIssueCode.unrecognized_keys,\n                keys: u\n              }), t.dirty());else if (\"strip\" !== e) throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n            } else {\n              const e = this._def.catchall;\n              for (const t of u) {\n                const n = r.data[t];\n                d.push({\n                  key: {\n                    status: \"valid\",\n                    value: t\n                  },\n                  value: e._parse(new c(r, n, r.path, t)),\n                  alwaysSet: t in r.data\n                });\n              }\n            }\n            return r.common.async ? Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n              const e = [];\n              for (const t of d) {\n                const r = yield t.key;\n                e.push({\n                  key: r,\n                  value: yield t.value,\n                  alwaysSet: t.alwaysSet\n                });\n              }\n              return e;\n            })).then(e => o.ParseStatus.mergeObjectSync(t, e)) : o.ParseStatus.mergeObjectSync(t, d);\n          }\n          get shape() {\n            return this._def.shape();\n          }\n          strict(e) {\n            return i.errorUtil.errToObj, new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              unknownKeys: \"strict\"\n            }, void 0 !== e ? {\n              errorMap: (t, r) => {\n                var n, o, s, a;\n                const c = null !== (s = null === (o = (n = this._def).errorMap) || void 0 === o ? void 0 : o.call(n, t, r).message) && void 0 !== s ? s : r.defaultError;\n                return \"unrecognized_keys\" === t.code ? {\n                  message: null !== (a = i.errorUtil.errToObj(e).message) && void 0 !== a ? a : c\n                } : {\n                  message: c\n                };\n              }\n            } : {}));\n          }\n          strip() {\n            return new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              unknownKeys: \"strip\"\n            }));\n          }\n          passthrough() {\n            return new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              unknownKeys: \"passthrough\"\n            }));\n          }\n          extend(e) {\n            return new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              shape: () => _objectSpread(_objectSpread({}, this._def.shape()), e)\n            }));\n          }\n          merge(e) {\n            return new M({\n              unknownKeys: e._def.unknownKeys,\n              catchall: e._def.catchall,\n              shape: () => _objectSpread(_objectSpread({}, this._def.shape()), e._def.shape()),\n              typeName: ae.ZodObject\n            });\n          }\n          setKey(e, t) {\n            return this.augment({\n              [e]: t\n            });\n          }\n          catchall(e) {\n            return new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              catchall: e\n            }));\n          }\n          pick(e) {\n            const t = {};\n            return s.util.objectKeys(e).forEach(r => {\n              e[r] && this.shape[r] && (t[r] = this.shape[r]);\n            }), new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              shape: () => t\n            }));\n          }\n          omit(e) {\n            const t = {};\n            return s.util.objectKeys(this.shape).forEach(r => {\n              e[r] || (t[r] = this.shape[r]);\n            }), new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              shape: () => t\n            }));\n          }\n          deepPartial() {\n            return k(this);\n          }\n          partial(e) {\n            const t = {};\n            return s.util.objectKeys(this.shape).forEach(r => {\n              const n = this.shape[r];\n              e && !e[r] ? t[r] = n : t[r] = n.optional();\n            }), new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              shape: () => t\n            }));\n          }\n          required(e) {\n            const t = {};\n            return s.util.objectKeys(this.shape).forEach(r => {\n              if (e && !e[r]) t[r] = this.shape[r];else {\n                let e = this.shape[r];\n                for (; e instanceof $;) e = e._def.innerType;\n                t[r] = e;\n              }\n            }), new M(_objectSpread(_objectSpread({}, this._def), {}, {\n              shape: () => t\n            }));\n          }\n          keyof() {\n            return K(s.util.objectKeys(this.shape));\n          }\n        }\n        t.ZodObject = M, M.create = (e, t) => new M(_objectSpread({\n          shape: () => e,\n          unknownKeys: \"strip\",\n          catchall: C.create(),\n          typeName: ae.ZodObject\n        }, d(t))), M.strictCreate = (e, t) => new M(_objectSpread({\n          shape: () => e,\n          unknownKeys: \"strict\",\n          catchall: C.create(),\n          typeName: ae.ZodObject\n        }, d(t))), M.lazycreate = (e, t) => new M(_objectSpread({\n          shape: e,\n          unknownKeys: \"strip\",\n          catchall: C.create(),\n          typeName: ae.ZodObject\n        }, d(t)));\n        class D extends l {\n          _parse(e) {\n            const {\n                ctx: t\n              } = this._processInputParams(e),\n              r = this._def.options;\n            if (t.common.async) return Promise.all(r.map( /*#__PURE__*/function () {\n              var _ref6 = _asyncToGenerator(function* (e) {\n                const r = _objectSpread(_objectSpread({}, t), {}, {\n                  common: _objectSpread(_objectSpread({}, t.common), {}, {\n                    issues: []\n                  }),\n                  parent: null\n                });\n                return {\n                  result: yield e._parseAsync({\n                    data: t.data,\n                    path: t.path,\n                    parent: r\n                  }),\n                  ctx: r\n                };\n              });\n              return function (_x11) {\n                return _ref6.apply(this, arguments);\n              };\n            }())).then(function (e) {\n              for (const t of e) if (\"valid\" === t.result.status) return t.result;\n              for (const r of e) if (\"dirty\" === r.result.status) return t.common.issues.push(...r.ctx.common.issues), r.result;\n              const r = e.map(e => new a.ZodError(e.ctx.common.issues));\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_union,\n                unionErrors: r\n              }), o.INVALID;\n            });\n            {\n              let e;\n              const n = [];\n              for (const i of r) {\n                const r = _objectSpread(_objectSpread({}, t), {}, {\n                    common: _objectSpread(_objectSpread({}, t.common), {}, {\n                      issues: []\n                    }),\n                    parent: null\n                  }),\n                  o = i._parseSync({\n                    data: t.data,\n                    path: t.path,\n                    parent: r\n                  });\n                if (\"valid\" === o.status) return o;\n                \"dirty\" !== o.status || e || (e = {\n                  result: o,\n                  ctx: r\n                }), r.common.issues.length && n.push(r.common.issues);\n              }\n              if (e) return t.common.issues.push(...e.ctx.common.issues), e.result;\n              const i = n.map(e => new a.ZodError(e));\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_union,\n                unionErrors: i\n              }), o.INVALID;\n            }\n          }\n          get options() {\n            return this._def.options;\n          }\n        }\n        t.ZodUnion = D, D.create = (e, t) => new D(_objectSpread({\n          options: e,\n          typeName: ae.ZodUnion\n        }, d(t)));\n        const L = e => e instanceof q ? L(e.schema) : e instanceof Y ? L(e.innerType()) : e instanceof z ? [e.value] : e instanceof Q ? e.options : e instanceof J ? Object.keys(e.enum) : e instanceof te ? L(e._def.innerType) : e instanceof P ? [void 0] : e instanceof x ? [null] : null;\n        class F extends l {\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            if (t.parsedType !== s.ZodParsedType.object) return (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.object,\n              received: t.parsedType\n            }), o.INVALID;\n            const r = this.discriminator,\n              n = t.data[r],\n              i = this.optionsMap.get(n);\n            return i ? t.common.async ? i._parseAsync({\n              data: t.data,\n              path: t.path,\n              parent: t\n            }) : i._parseSync({\n              data: t.data,\n              path: t.path,\n              parent: t\n            }) : ((0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_union_discriminator,\n              options: Array.from(this.optionsMap.keys()),\n              path: [r]\n            }), o.INVALID);\n          }\n          get discriminator() {\n            return this._def.discriminator;\n          }\n          get options() {\n            return this._def.options;\n          }\n          get optionsMap() {\n            return this._def.optionsMap;\n          }\n          static create(e, t, r) {\n            const n = new Map();\n            for (const r of t) {\n              const t = L(r.shape[e]);\n              if (!t) throw new Error(\"A discriminator value for key `\".concat(e, \"` could not be extracted from all schema options\"));\n              for (const i of t) {\n                if (n.has(i)) throw new Error(\"Discriminator property \".concat(String(e), \" has duplicate value \").concat(String(i)));\n                n.set(i, r);\n              }\n            }\n            return new F(_objectSpread({\n              typeName: ae.ZodDiscriminatedUnion,\n              discriminator: e,\n              options: t,\n              optionsMap: n\n            }, d(r)));\n          }\n        }\n        function j(e, t) {\n          const r = (0, s.getParsedType)(e),\n            n = (0, s.getParsedType)(t);\n          if (e === t) return {\n            valid: !0,\n            data: e\n          };\n          if (r === s.ZodParsedType.object && n === s.ZodParsedType.object) {\n            const r = s.util.objectKeys(t),\n              n = s.util.objectKeys(e).filter(e => -1 !== r.indexOf(e)),\n              i = _objectSpread(_objectSpread({}, e), t);\n            for (const r of n) {\n              const n = j(e[r], t[r]);\n              if (!n.valid) return {\n                valid: !1\n              };\n              i[r] = n.data;\n            }\n            return {\n              valid: !0,\n              data: i\n            };\n          }\n          if (r === s.ZodParsedType.array && n === s.ZodParsedType.array) {\n            if (e.length !== t.length) return {\n              valid: !1\n            };\n            const r = [];\n            for (let n = 0; n < e.length; n++) {\n              const i = j(e[n], t[n]);\n              if (!i.valid) return {\n                valid: !1\n              };\n              r.push(i.data);\n            }\n            return {\n              valid: !0,\n              data: r\n            };\n          }\n          return r === s.ZodParsedType.date && n === s.ZodParsedType.date && +e == +t ? {\n            valid: !0,\n            data: e\n          } : {\n            valid: !1\n          };\n        }\n        t.ZodDiscriminatedUnion = F;\n        class H extends l {\n          _parse(e) {\n            const {\n                status: t,\n                ctx: r\n              } = this._processInputParams(e),\n              n = (e, n) => {\n                if ((0, o.isAborted)(e) || (0, o.isAborted)(n)) return o.INVALID;\n                const i = j(e.value, n.value);\n                return i.valid ? (((0, o.isDirty)(e) || (0, o.isDirty)(n)) && t.dirty(), {\n                  status: t.value,\n                  value: i.data\n                }) : ((0, o.addIssueToContext)(r, {\n                  code: a.ZodIssueCode.invalid_intersection_types\n                }), o.INVALID);\n              };\n            return r.common.async ? Promise.all([this._def.left._parseAsync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            }), this._def.right._parseAsync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            })]).then(_ref7 => {\n              let [e, t] = _ref7;\n              return n(e, t);\n            }) : n(this._def.left._parseSync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            }), this._def.right._parseSync({\n              data: r.data,\n              path: r.path,\n              parent: r\n            }));\n          }\n        }\n        t.ZodIntersection = H, H.create = (e, t, r) => new H(_objectSpread({\n          left: e,\n          right: t,\n          typeName: ae.ZodIntersection\n        }, d(r)));\n        class U extends l {\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.array) return (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.array,\n              received: r.parsedType\n            }), o.INVALID;\n            if (r.data.length < this._def.items.length) return (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              minimum: this._def.items.length,\n              inclusive: !0,\n              exact: !1,\n              type: \"array\"\n            }), o.INVALID;\n            !this._def.rest && r.data.length > this._def.items.length && ((0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              maximum: this._def.items.length,\n              inclusive: !0,\n              exact: !1,\n              type: \"array\"\n            }), t.dirty());\n            const n = [...r.data].map((e, t) => {\n              const n = this._def.items[t] || this._def.rest;\n              return n ? n._parse(new c(r, e, r.path, t)) : null;\n            }).filter(e => !!e);\n            return r.common.async ? Promise.all(n).then(e => o.ParseStatus.mergeArray(t, e)) : o.ParseStatus.mergeArray(t, n);\n          }\n          get items() {\n            return this._def.items;\n          }\n          rest(e) {\n            return new U(_objectSpread(_objectSpread({}, this._def), {}, {\n              rest: e\n            }));\n          }\n        }\n        t.ZodTuple = U, U.create = (e, t) => {\n          if (!Array.isArray(e)) throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n          return new U(_objectSpread({\n            items: e,\n            typeName: ae.ZodTuple,\n            rest: null\n          }, d(t)));\n        };\n        class G extends l {\n          get keySchema() {\n            return this._def.keyType;\n          }\n          get valueSchema() {\n            return this._def.valueType;\n          }\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.object) return (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.object,\n              received: r.parsedType\n            }), o.INVALID;\n            const n = [],\n              i = this._def.keyType,\n              u = this._def.valueType;\n            for (const e in r.data) n.push({\n              key: i._parse(new c(r, e, r.path, e)),\n              value: u._parse(new c(r, r.data[e], r.path, e))\n            });\n            return r.common.async ? o.ParseStatus.mergeObjectAsync(t, n) : o.ParseStatus.mergeObjectSync(t, n);\n          }\n          get element() {\n            return this._def.valueType;\n          }\n          static create(e, t, r) {\n            return new G(t instanceof l ? _objectSpread({\n              keyType: e,\n              valueType: t,\n              typeName: ae.ZodRecord\n            }, d(r)) : _objectSpread({\n              keyType: E.create(),\n              valueType: e,\n              typeName: ae.ZodRecord\n            }, d(t)));\n          }\n        }\n        t.ZodRecord = G;\n        class V extends l {\n          get keySchema() {\n            return this._def.keyType;\n          }\n          get valueSchema() {\n            return this._def.valueType;\n          }\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.map) return (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.map,\n              received: r.parsedType\n            }), o.INVALID;\n            const n = this._def.keyType,\n              i = this._def.valueType,\n              u = [...r.data.entries()].map((_ref8, o) => {\n                let [e, t] = _ref8;\n                return {\n                  key: n._parse(new c(r, e, r.path, [o, \"key\"])),\n                  value: i._parse(new c(r, t, r.path, [o, \"value\"]))\n                };\n              });\n            if (r.common.async) {\n              const e = new Map();\n              return Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n                for (const r of u) {\n                  const n = yield r.key,\n                    i = yield r.value;\n                  if (\"aborted\" === n.status || \"aborted\" === i.status) return o.INVALID;\n                  \"dirty\" !== n.status && \"dirty\" !== i.status || t.dirty(), e.set(n.value, i.value);\n                }\n                return {\n                  status: t.value,\n                  value: e\n                };\n              }));\n            }\n            {\n              const e = new Map();\n              for (const r of u) {\n                const n = r.key,\n                  i = r.value;\n                if (\"aborted\" === n.status || \"aborted\" === i.status) return o.INVALID;\n                \"dirty\" !== n.status && \"dirty\" !== i.status || t.dirty(), e.set(n.value, i.value);\n              }\n              return {\n                status: t.value,\n                value: e\n              };\n            }\n          }\n        }\n        t.ZodMap = V, V.create = (e, t, r) => new V(_objectSpread({\n          valueType: t,\n          keyType: e,\n          typeName: ae.ZodMap\n        }, d(r)));\n        class Z extends l {\n          _parse(e) {\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.parsedType !== s.ZodParsedType.set) return (0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.set,\n              received: r.parsedType\n            }), o.INVALID;\n            const n = this._def;\n            null !== n.minSize && r.data.size < n.minSize.value && ((0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_small,\n              minimum: n.minSize.value,\n              type: \"set\",\n              inclusive: !0,\n              exact: !1,\n              message: n.minSize.message\n            }), t.dirty()), null !== n.maxSize && r.data.size > n.maxSize.value && ((0, o.addIssueToContext)(r, {\n              code: a.ZodIssueCode.too_big,\n              maximum: n.maxSize.value,\n              type: \"set\",\n              inclusive: !0,\n              exact: !1,\n              message: n.maxSize.message\n            }), t.dirty());\n            const i = this._def.valueType;\n            function u(e) {\n              const r = new Set();\n              for (const n of e) {\n                if (\"aborted\" === n.status) return o.INVALID;\n                \"dirty\" === n.status && t.dirty(), r.add(n.value);\n              }\n              return {\n                status: t.value,\n                value: r\n              };\n            }\n            const d = [...r.data.values()].map((e, t) => i._parse(new c(r, e, r.path, t)));\n            return r.common.async ? Promise.all(d).then(e => u(e)) : u(d);\n          }\n          min(e, t) {\n            return new Z(_objectSpread(_objectSpread({}, this._def), {}, {\n              minSize: {\n                value: e,\n                message: i.errorUtil.toString(t)\n              }\n            }));\n          }\n          max(e, t) {\n            return new Z(_objectSpread(_objectSpread({}, this._def), {}, {\n              maxSize: {\n                value: e,\n                message: i.errorUtil.toString(t)\n              }\n            }));\n          }\n          size(e, t) {\n            return this.min(e, t).max(e, t);\n          }\n          nonempty(e) {\n            return this.min(1, e);\n          }\n        }\n        t.ZodSet = Z, Z.create = (e, t) => new Z(_objectSpread({\n          valueType: e,\n          minSize: null,\n          maxSize: null,\n          typeName: ae.ZodSet\n        }, d(t)));\n        class W extends l {\n          constructor() {\n            super(...arguments), this.validate = this.implement;\n          }\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            if (t.parsedType !== s.ZodParsedType.function) return (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.function,\n              received: t.parsedType\n            }), o.INVALID;\n            function r(e, r) {\n              return (0, o.makeIssue)({\n                data: e,\n                path: t.path,\n                errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, (0, n.getErrorMap)(), n.defaultErrorMap].filter(e => !!e),\n                issueData: {\n                  code: a.ZodIssueCode.invalid_arguments,\n                  argumentsError: r\n                }\n              });\n            }\n            function i(e, r) {\n              return (0, o.makeIssue)({\n                data: e,\n                path: t.path,\n                errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, (0, n.getErrorMap)(), n.defaultErrorMap].filter(e => !!e),\n                issueData: {\n                  code: a.ZodIssueCode.invalid_return_type,\n                  returnTypeError: r\n                }\n              });\n            }\n            const c = {\n                errorMap: t.common.contextualErrorMap\n              },\n              u = t.data;\n            if (this._def.returns instanceof X) {\n              const e = this;\n              return (0, o.OK)( /*#__PURE__*/_asyncToGenerator(function* () {\n                for (var _len9 = arguments.length, t = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n                  t[_key9] = arguments[_key9];\n                }\n                const n = new a.ZodError([]),\n                  o = yield e._def.args.parseAsync(t, c).catch(e => {\n                    throw n.addIssue(r(t, e)), n;\n                  }),\n                  s = yield Reflect.apply(u, this, o);\n                return yield e._def.returns._def.type.parseAsync(s, c).catch(e => {\n                  throw n.addIssue(i(s, e)), n;\n                });\n              }));\n            }\n            {\n              const e = this;\n              return (0, o.OK)(function () {\n                for (var _len10 = arguments.length, t = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n                  t[_key10] = arguments[_key10];\n                }\n                const n = e._def.args.safeParse(t, c);\n                if (!n.success) throw new a.ZodError([r(t, n.error)]);\n                const o = Reflect.apply(u, this, n.data),\n                  s = e._def.returns.safeParse(o, c);\n                if (!s.success) throw new a.ZodError([i(o, s.error)]);\n                return s.data;\n              });\n            }\n          }\n          parameters() {\n            return this._def.args;\n          }\n          returnType() {\n            return this._def.returns;\n          }\n          args() {\n            for (var _len11 = arguments.length, e = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n              e[_key11] = arguments[_key11];\n            }\n            return new W(_objectSpread(_objectSpread({}, this._def), {}, {\n              args: U.create(e).rest(O.create())\n            }));\n          }\n          returns(e) {\n            return new W(_objectSpread(_objectSpread({}, this._def), {}, {\n              returns: e\n            }));\n          }\n          implement(e) {\n            return this.parse(e);\n          }\n          strictImplement(e) {\n            return this.parse(e);\n          }\n          static create(e, t, r) {\n            return new W(_objectSpread({\n              args: e || U.create([]).rest(O.create()),\n              returns: t || O.create(),\n              typeName: ae.ZodFunction\n            }, d(r)));\n          }\n        }\n        t.ZodFunction = W;\n        class q extends l {\n          get schema() {\n            return this._def.getter();\n          }\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            return this._def.getter()._parse({\n              data: t.data,\n              path: t.path,\n              parent: t\n            });\n          }\n        }\n        t.ZodLazy = q, q.create = (e, t) => new q(_objectSpread({\n          getter: e,\n          typeName: ae.ZodLazy\n        }, d(t)));\n        class z extends l {\n          _parse(e) {\n            if (e.data !== this._def.value) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                received: t.data,\n                code: a.ZodIssueCode.invalid_literal,\n                expected: this._def.value\n              }), o.INVALID;\n            }\n            return {\n              status: \"valid\",\n              value: e.data\n            };\n          }\n          get value() {\n            return this._def.value;\n          }\n        }\n        function K(e, t) {\n          return new Q(_objectSpread({\n            values: e,\n            typeName: ae.ZodEnum\n          }, d(t)));\n        }\n        t.ZodLiteral = z, z.create = (e, t) => new z(_objectSpread({\n          value: e,\n          typeName: ae.ZodLiteral\n        }, d(t)));\n        class Q extends l {\n          _parse(e) {\n            if (\"string\" != typeof e.data) {\n              const t = this._getOrReturnCtx(e),\n                r = this._def.values;\n              return (0, o.addIssueToContext)(t, {\n                expected: s.util.joinValues(r),\n                received: t.parsedType,\n                code: a.ZodIssueCode.invalid_type\n              }), o.INVALID;\n            }\n            if (-1 === this._def.values.indexOf(e.data)) {\n              const t = this._getOrReturnCtx(e),\n                r = this._def.values;\n              return (0, o.addIssueToContext)(t, {\n                received: t.data,\n                code: a.ZodIssueCode.invalid_enum_value,\n                options: r\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n          get options() {\n            return this._def.values;\n          }\n          get enum() {\n            const e = {};\n            for (const t of this._def.values) e[t] = t;\n            return e;\n          }\n          get Values() {\n            const e = {};\n            for (const t of this._def.values) e[t] = t;\n            return e;\n          }\n          get Enum() {\n            const e = {};\n            for (const t of this._def.values) e[t] = t;\n            return e;\n          }\n          extract(e) {\n            return Q.create(e);\n          }\n          exclude(e) {\n            return Q.create(this.options.filter(t => !e.includes(t)));\n          }\n        }\n        t.ZodEnum = Q, Q.create = K;\n        class J extends l {\n          _parse(e) {\n            const t = s.util.getValidEnumValues(this._def.values),\n              r = this._getOrReturnCtx(e);\n            if (r.parsedType !== s.ZodParsedType.string && r.parsedType !== s.ZodParsedType.number) {\n              const e = s.util.objectValues(t);\n              return (0, o.addIssueToContext)(r, {\n                expected: s.util.joinValues(e),\n                received: r.parsedType,\n                code: a.ZodIssueCode.invalid_type\n              }), o.INVALID;\n            }\n            if (-1 === t.indexOf(e.data)) {\n              const e = s.util.objectValues(t);\n              return (0, o.addIssueToContext)(r, {\n                received: r.data,\n                code: a.ZodIssueCode.invalid_enum_value,\n                options: e\n              }), o.INVALID;\n            }\n            return (0, o.OK)(e.data);\n          }\n          get enum() {\n            return this._def.values;\n          }\n        }\n        t.ZodNativeEnum = J, J.create = (e, t) => new J(_objectSpread({\n          values: e,\n          typeName: ae.ZodNativeEnum\n        }, d(t)));\n        class X extends l {\n          unwrap() {\n            return this._def.type;\n          }\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            if (t.parsedType !== s.ZodParsedType.promise && !1 === t.common.async) return (0, o.addIssueToContext)(t, {\n              code: a.ZodIssueCode.invalid_type,\n              expected: s.ZodParsedType.promise,\n              received: t.parsedType\n            }), o.INVALID;\n            const r = t.parsedType === s.ZodParsedType.promise ? t.data : Promise.resolve(t.data);\n            return (0, o.OK)(r.then(e => this._def.type.parseAsync(e, {\n              path: t.path,\n              errorMap: t.common.contextualErrorMap\n            })));\n          }\n        }\n        t.ZodPromise = X, X.create = (e, t) => new X(_objectSpread({\n          type: e,\n          typeName: ae.ZodPromise\n        }, d(t)));\n        class Y extends l {\n          innerType() {\n            return this._def.schema;\n          }\n          sourceType() {\n            return this._def.schema._def.typeName === ae.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n          }\n          _parse(e) {\n            const {\n                status: t,\n                ctx: r\n              } = this._processInputParams(e),\n              n = this._def.effect || null,\n              i = {\n                addIssue: e => {\n                  (0, o.addIssueToContext)(r, e), e.fatal ? t.abort() : t.dirty();\n                },\n                get path() {\n                  return r.path;\n                }\n              };\n            if (i.addIssue = i.addIssue.bind(i), \"preprocess\" === n.type) {\n              const e = n.transform(r.data, i);\n              return r.common.issues.length ? {\n                status: \"dirty\",\n                value: r.data\n              } : r.common.async ? Promise.resolve(e).then(e => this._def.schema._parseAsync({\n                data: e,\n                path: r.path,\n                parent: r\n              })) : this._def.schema._parseSync({\n                data: e,\n                path: r.path,\n                parent: r\n              });\n            }\n            if (\"refinement\" === n.type) {\n              const e = e => {\n                const t = n.refinement(e, i);\n                if (r.common.async) return Promise.resolve(t);\n                if (t instanceof Promise) throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                return e;\n              };\n              if (!1 === r.common.async) {\n                const n = this._def.schema._parseSync({\n                  data: r.data,\n                  path: r.path,\n                  parent: r\n                });\n                return \"aborted\" === n.status ? o.INVALID : (\"dirty\" === n.status && t.dirty(), e(n.value), {\n                  status: t.value,\n                  value: n.value\n                });\n              }\n              return this._def.schema._parseAsync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              }).then(r => \"aborted\" === r.status ? o.INVALID : (\"dirty\" === r.status && t.dirty(), e(r.value).then(() => ({\n                status: t.value,\n                value: r.value\n              }))));\n            }\n            if (\"transform\" === n.type) {\n              if (!1 === r.common.async) {\n                const e = this._def.schema._parseSync({\n                  data: r.data,\n                  path: r.path,\n                  parent: r\n                });\n                if (!(0, o.isValid)(e)) return e;\n                const s = n.transform(e.value, i);\n                if (s instanceof Promise) throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n                return {\n                  status: t.value,\n                  value: s\n                };\n              }\n              return this._def.schema._parseAsync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              }).then(e => (0, o.isValid)(e) ? Promise.resolve(n.transform(e.value, i)).then(e => ({\n                status: t.value,\n                value: e\n              })) : e);\n            }\n            s.util.assertNever(n);\n          }\n        }\n        t.ZodEffects = Y, t.ZodTransformer = Y, Y.create = (e, t, r) => new Y(_objectSpread({\n          schema: e,\n          typeName: ae.ZodEffects,\n          effect: t\n        }, d(r))), Y.createWithPreprocess = (e, t, r) => new Y(_objectSpread({\n          schema: t,\n          effect: {\n            type: \"preprocess\",\n            transform: e\n          },\n          typeName: ae.ZodEffects\n        }, d(r)));\n        class $ extends l {\n          _parse(e) {\n            return this._getType(e) === s.ZodParsedType.undefined ? (0, o.OK)(void 0) : this._def.innerType._parse(e);\n          }\n          unwrap() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodOptional = $, $.create = (e, t) => new $(_objectSpread({\n          innerType: e,\n          typeName: ae.ZodOptional\n        }, d(t)));\n        class ee extends l {\n          _parse(e) {\n            return this._getType(e) === s.ZodParsedType.null ? (0, o.OK)(null) : this._def.innerType._parse(e);\n          }\n          unwrap() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodNullable = ee, ee.create = (e, t) => new ee(_objectSpread({\n          innerType: e,\n          typeName: ae.ZodNullable\n        }, d(t)));\n        class te extends l {\n          _parse(e) {\n            const {\n              ctx: t\n            } = this._processInputParams(e);\n            let r = t.data;\n            return t.parsedType === s.ZodParsedType.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({\n              data: r,\n              path: t.path,\n              parent: t\n            });\n          }\n          removeDefault() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodDefault = te, te.create = (e, t) => new te(_objectSpread({\n          innerType: e,\n          typeName: ae.ZodDefault,\n          defaultValue: \"function\" == typeof t.default ? t.default : () => t.default\n        }, d(t)));\n        class re extends l {\n          _parse(e) {\n            const {\n                ctx: t\n              } = this._processInputParams(e),\n              r = _objectSpread(_objectSpread({}, t), {}, {\n                common: _objectSpread(_objectSpread({}, t.common), {}, {\n                  issues: []\n                })\n              }),\n              n = this._def.innerType._parse({\n                data: r.data,\n                path: r.path,\n                parent: _objectSpread({}, r)\n              });\n            return (0, o.isAsync)(n) ? n.then(e => ({\n              status: \"valid\",\n              value: \"valid\" === e.status ? e.value : this._def.catchValue({\n                get error() {\n                  return new a.ZodError(r.common.issues);\n                },\n                input: r.data\n              })\n            })) : {\n              status: \"valid\",\n              value: \"valid\" === n.status ? n.value : this._def.catchValue({\n                get error() {\n                  return new a.ZodError(r.common.issues);\n                },\n                input: r.data\n              })\n            };\n          }\n          removeCatch() {\n            return this._def.innerType;\n          }\n        }\n        t.ZodCatch = re, re.create = (e, t) => new re(_objectSpread({\n          innerType: e,\n          typeName: ae.ZodCatch,\n          catchValue: \"function\" == typeof t.catch ? t.catch : () => t.catch\n        }, d(t)));\n        class ne extends l {\n          _parse(e) {\n            if (this._getType(e) !== s.ZodParsedType.nan) {\n              const t = this._getOrReturnCtx(e);\n              return (0, o.addIssueToContext)(t, {\n                code: a.ZodIssueCode.invalid_type,\n                expected: s.ZodParsedType.nan,\n                received: t.parsedType\n              }), o.INVALID;\n            }\n            return {\n              status: \"valid\",\n              value: e.data\n            };\n          }\n        }\n        t.ZodNaN = ne, ne.create = e => new ne(_objectSpread({\n          typeName: ae.ZodNaN\n        }, d(e))), t.BRAND = Symbol(\"zod_brand\");\n        class ie extends l {\n          _parse(e) {\n            const {\n                ctx: t\n              } = this._processInputParams(e),\n              r = t.data;\n            return this._def.type._parse({\n              data: r,\n              path: t.path,\n              parent: t\n            });\n          }\n          unwrap() {\n            return this._def.type;\n          }\n        }\n        t.ZodBranded = ie;\n        class oe extends l {\n          _parse(e) {\n            var _this4 = this;\n            const {\n              status: t,\n              ctx: r\n            } = this._processInputParams(e);\n            if (r.common.async) return _asyncToGenerator(function* () {\n              const e = yield _this4._def.in._parseAsync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              });\n              return \"aborted\" === e.status ? o.INVALID : \"dirty\" === e.status ? (t.dirty(), (0, o.DIRTY)(e.value)) : _this4._def.out._parseAsync({\n                data: e.value,\n                path: r.path,\n                parent: r\n              });\n            })();\n            {\n              const e = this._def.in._parseSync({\n                data: r.data,\n                path: r.path,\n                parent: r\n              });\n              return \"aborted\" === e.status ? o.INVALID : \"dirty\" === e.status ? (t.dirty(), {\n                status: \"dirty\",\n                value: e.value\n              }) : this._def.out._parseSync({\n                data: e.value,\n                path: r.path,\n                parent: r\n              });\n            }\n          }\n          static create(e, t) {\n            return new oe({\n              in: e,\n              out: t,\n              typeName: ae.ZodPipeline\n            });\n          }\n        }\n        t.ZodPipeline = oe;\n        class se extends l {\n          _parse(e) {\n            const t = this._def.innerType._parse(e);\n            return (0, o.isValid)(t) && (t.value = Object.freeze(t.value)), t;\n          }\n        }\n        var ae;\n        t.ZodReadonly = se, se.create = (e, t) => new se(_objectSpread({\n          innerType: e,\n          typeName: ae.ZodReadonly\n        }, d(t))), t.custom = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          let r = arguments.length > 2 ? arguments[2] : undefined;\n          return e ? S.create().superRefine((n, i) => {\n            var o, s;\n            if (!e(n)) {\n              const e = \"function\" == typeof t ? t(n) : \"string\" == typeof t ? {\n                  message: t\n                } : t,\n                a = null === (s = null !== (o = e.fatal) && void 0 !== o ? o : r) || void 0 === s || s,\n                c = \"string\" == typeof e ? {\n                  message: e\n                } : e;\n              i.addIssue(_objectSpread(_objectSpread({\n                code: \"custom\"\n              }, c), {}, {\n                fatal: a\n              }));\n            }\n          }) : S.create();\n        }, t.late = {\n          object: M.lazycreate\n        }, function (e) {\n          e.ZodString = \"ZodString\", e.ZodNumber = \"ZodNumber\", e.ZodNaN = \"ZodNaN\", e.ZodBigInt = \"ZodBigInt\", e.ZodBoolean = \"ZodBoolean\", e.ZodDate = \"ZodDate\", e.ZodSymbol = \"ZodSymbol\", e.ZodUndefined = \"ZodUndefined\", e.ZodNull = \"ZodNull\", e.ZodAny = \"ZodAny\", e.ZodUnknown = \"ZodUnknown\", e.ZodNever = \"ZodNever\", e.ZodVoid = \"ZodVoid\", e.ZodArray = \"ZodArray\", e.ZodObject = \"ZodObject\", e.ZodUnion = \"ZodUnion\", e.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", e.ZodIntersection = \"ZodIntersection\", e.ZodTuple = \"ZodTuple\", e.ZodRecord = \"ZodRecord\", e.ZodMap = \"ZodMap\", e.ZodSet = \"ZodSet\", e.ZodFunction = \"ZodFunction\", e.ZodLazy = \"ZodLazy\", e.ZodLiteral = \"ZodLiteral\", e.ZodEnum = \"ZodEnum\", e.ZodEffects = \"ZodEffects\", e.ZodNativeEnum = \"ZodNativeEnum\", e.ZodOptional = \"ZodOptional\", e.ZodNullable = \"ZodNullable\", e.ZodDefault = \"ZodDefault\", e.ZodCatch = \"ZodCatch\", e.ZodPromise = \"ZodPromise\", e.ZodBranded = \"ZodBranded\", e.ZodPipeline = \"ZodPipeline\", e.ZodReadonly = \"ZodReadonly\";\n        }(ae = t.ZodFirstPartyTypeKind || (t.ZodFirstPartyTypeKind = {})), t.instanceof = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            message: \"Input not instance of \".concat(e.name)\n          };\n          return (0, t.custom)(t => t instanceof e, r);\n        };\n        const ce = E.create;\n        t.string = ce;\n        const ue = A.create;\n        t.number = ue;\n        const de = ne.create;\n        t.nan = de;\n        const le = T.create;\n        t.bigint = le;\n        const he = I.create;\n        t.boolean = he;\n        const fe = R.create;\n        t.date = fe;\n        const pe = w.create;\n        t.symbol = pe;\n        const me = P.create;\n        t.undefined = me;\n        const ge = x.create;\n        t.null = ge;\n        const ye = S.create;\n        t.any = ye;\n        const ve = O.create;\n        t.unknown = ve;\n        const be = C.create;\n        t.never = be;\n        const Ee = B.create;\n        t.void = Ee;\n        const _e = N.create;\n        t.array = _e;\n        const Ae = M.create;\n        t.object = Ae;\n        const Te = M.strictCreate;\n        t.strictObject = Te;\n        const Ie = D.create;\n        t.union = Ie;\n        const Re = F.create;\n        t.discriminatedUnion = Re;\n        const we = H.create;\n        t.intersection = we;\n        const Pe = U.create;\n        t.tuple = Pe;\n        const xe = G.create;\n        t.record = xe;\n        const Se = V.create;\n        t.map = Se;\n        const Oe = Z.create;\n        t.set = Oe;\n        const Ce = W.create;\n        t.function = Ce;\n        const Be = q.create;\n        t.lazy = Be;\n        const Ne = z.create;\n        t.literal = Ne;\n        const ke = Q.create;\n        t.enum = ke;\n        const Me = J.create;\n        t.nativeEnum = Me;\n        const De = X.create;\n        t.promise = De;\n        const Le = Y.create;\n        t.effect = Le, t.transformer = Le;\n        const Fe = $.create;\n        t.optional = Fe;\n        const je = ee.create;\n        t.nullable = je;\n        const He = Y.createWithPreprocess;\n        t.preprocess = He;\n        const Ue = oe.create;\n        t.pipeline = Ue, t.ostring = () => ce().optional(), t.onumber = () => ue().optional(), t.oboolean = () => he().optional(), t.coerce = {\n          string: e => E.create(_objectSpread(_objectSpread({}, e), {}, {\n            coerce: !0\n          })),\n          number: e => A.create(_objectSpread(_objectSpread({}, e), {}, {\n            coerce: !0\n          })),\n          boolean: e => I.create(_objectSpread(_objectSpread({}, e), {}, {\n            coerce: !0\n          })),\n          bigint: e => T.create(_objectSpread(_objectSpread({}, e), {}, {\n            coerce: !0\n          })),\n          date: e => R.create(_objectSpread(_objectSpread({}, e), {}, {\n            coerce: !0\n          }))\n        }, t.NEVER = o.INVALID;\n      },\n      3072: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decrypt = t.encrypt = void 0;\n        const n = r(825),\n          i = r(6540),\n          o = {\n            web: n.crypto\n          };\n        function s(e, t, r) {\n          if (!r.startsWith(\"aes-\")) throw new Error(\"AES submodule doesn't support mode \".concat(r));\n          if (16 !== t.length) throw new Error(\"AES: wrong IV length\");\n          if (r.startsWith(\"aes-128\") && 16 !== e.length || r.startsWith(\"aes-256\") && 32 !== e.length) throw new Error(\"AES: wrong key length\");\n        }\n        function a(_x12, _x13, _x14) {\n          return _a.apply(this, arguments);\n        }\n        function _a() {\n          _a = _asyncToGenerator(function* (e, t, r) {\n            if (!o.web) throw new Error(\"Browser crypto not available.\");\n            let n;\n            if ([\"aes-128-cbc\", \"aes-256-cbc\"].includes(e) && (n = \"cbc\"), [\"aes-128-ctr\", \"aes-256-ctr\"].includes(e) && (n = \"ctr\"), !n) throw new Error(\"AES: unsupported mode\");\n            return [yield o.web.subtle.importKey(\"raw\", t, {\n              name: \"AES-\".concat(n.toUpperCase()),\n              length: 8 * t.length\n            }, !0, [\"encrypt\", \"decrypt\"]), {\n              name: \"aes-\".concat(n),\n              iv: r,\n              counter: r,\n              length: 128\n            }];\n          });\n          return _a.apply(this, arguments);\n        }\n        function c(_x15, _x16, _x17) {\n          return _c.apply(this, arguments);\n        }\n        function _c() {\n          _c = _asyncToGenerator(function* (e, t, r) {\n            let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"aes-128-ctr\";\n            let c = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n            if (s(t, r, n), o.web) {\n              const [i, s] = yield a(n, t, r),\n                u = yield o.web.subtle.encrypt(s, i, e);\n              let d = new Uint8Array(u);\n              return c || \"aes-cbc\" !== s.name || e.length % 16 || (d = d.slice(0, -16)), d;\n            }\n            if (o.node) {\n              const s = o.node.createCipheriv(n, t, r);\n              return s.setAutoPadding(c), (0, i.concatBytes)(s.update(e), s.final());\n            }\n            throw new Error(\"The environment doesn't have AES module\");\n          });\n          return _c.apply(this, arguments);\n        }\n        t.encrypt = c, t.decrypt = /*#__PURE__*/function () {\n          var _ref12 = _asyncToGenerator(function* (e, t, r) {\n            let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"aes-128-ctr\";\n            let u = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n            if (s(t, r, n), o.web) {\n              const [s, d] = yield a(n, t, r);\n              if (!u && \"aes-cbc\" === d.name) {\n                const o = yield function () {\n                  var _ref13 = _asyncToGenerator(function* (e, t, r, n) {\n                    const i = e.slice(-16);\n                    for (let e = 0; e < 16; e++) i[e] ^= 16 ^ r[e];\n                    return (yield c(i, t, r, n)).slice(0, 16);\n                  });\n                  return function (_x21, _x22, _x23, _x24) {\n                    return _ref13.apply(this, arguments);\n                  };\n                }()(e, t, r, n);\n                e = (0, i.concatBytes)(e, o);\n              }\n              const l = yield o.web.subtle.decrypt(d, s, e),\n                h = new Uint8Array(l);\n              if (\"aes-cbc\" === d.name) {\n                const o = yield c(h, t, r, n);\n                if (!(0, i.equalsBytes)(o, e)) throw new Error(\"AES: wrong padding\");\n              }\n              return h;\n            }\n            if (o.node) {\n              const s = o.node.createDecipheriv(n, t, r);\n              return s.setAutoPadding(u), (0, i.concatBytes)(s.update(e), s.final());\n            }\n            throw new Error(\"The environment doesn't have AES module\");\n          });\n          return function (_x18, _x19, _x20) {\n            return _ref12.apply(this, arguments);\n          };\n        }();\n      },\n      7423: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0;\n        const n = r(125),\n          i = r(6540);\n        t.keccak224 = (0, i.wrapHash)(n.keccak_224), t.keccak256 = (() => {\n          const e = (0, i.wrapHash)(n.keccak_256);\n          return e.create = n.keccak_256.create, e;\n        })(), t.keccak384 = (0, i.wrapHash)(n.keccak_384), t.keccak512 = (0, i.wrapHash)(n.keccak_512);\n      },\n      8109: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.pbkdf2Sync = t.pbkdf2 = void 0;\n        const n = r(9179),\n          i = r(6053),\n          o = r(2540),\n          s = r(6540);\n        t.pbkdf2 = /*#__PURE__*/function () {\n          var _ref14 = _asyncToGenerator(function* (e, t, r, a, c) {\n            if (![\"sha256\", \"sha512\"].includes(c)) throw new Error(\"Only sha256 and sha512 are supported\");\n            return (0, s.assertBytes)(e), (0, s.assertBytes)(t), (0, n.pbkdf2Async)(\"sha256\" === c ? i.sha256 : o.sha512, e, t, {\n              c: r,\n              dkLen: a\n            });\n          });\n          return function (_x25, _x26, _x27, _x28, _x29) {\n            return _ref14.apply(this, arguments);\n          };\n        }(), t.pbkdf2Sync = function (e, t, r, a, c) {\n          if (![\"sha256\", \"sha512\"].includes(c)) throw new Error(\"Only sha256 and sha512 are supported\");\n          return (0, s.assertBytes)(e), (0, s.assertBytes)(t), (0, n.pbkdf2)(\"sha256\" === c ? i.sha256 : o.sha512, e, t, {\n            c: r,\n            dkLen: a\n          });\n        };\n      },\n      7002: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.scryptSync = t.scrypt = void 0;\n        const n = r(2739),\n          i = r(6540);\n        t.scrypt = /*#__PURE__*/function () {\n          var _ref15 = _asyncToGenerator(function* (e, t, r, o, s, a, c) {\n            return (0, i.assertBytes)(e), (0, i.assertBytes)(t), (0, n.scryptAsync)(e, t, {\n              N: r,\n              r: s,\n              p: o,\n              dkLen: a,\n              onProgress: c\n            });\n          });\n          return function (_x30, _x31, _x32, _x33, _x34, _x35, _x36) {\n            return _ref15.apply(this, arguments);\n          };\n        }(), t.scryptSync = function (e, t, r, o, s, a, c) {\n          return (0, i.assertBytes)(e), (0, i.assertBytes)(t), (0, n.scrypt)(e, t, {\n            N: r,\n            r: s,\n            p: o,\n            dkLen: a,\n            onProgress: c\n          });\n        };\n      },\n      5473: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.secp256k1 = void 0;\n        var n = r(8358);\n        Object.defineProperty(t, \"secp256k1\", {\n          enumerable: !0,\n          get: function get() {\n            return n.secp256k1;\n          }\n        });\n      },\n      6540: function _(e, t, r) {\n        \"use strict\";\n\n        e = r.nmd(e);\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;\n        const i = n(r(3525)),\n          o = r(64),\n          s = i.default.bool;\n        t.assertBool = s;\n        const a = i.default.bytes;\n        t.assertBytes = a;\n        var c = r(64);\n        Object.defineProperty(t, \"bytesToHex\", {\n          enumerable: !0,\n          get: function get() {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"toHex\", {\n          enumerable: !0,\n          get: function get() {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"concatBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return c.concatBytes;\n          }\n        }), Object.defineProperty(t, \"createView\", {\n          enumerable: !0,\n          get: function get() {\n            return c.createView;\n          }\n        }), Object.defineProperty(t, \"utf8ToBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return c.utf8ToBytes;\n          }\n        }), t.bytesToUtf8 = function (e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"bytesToUtf8 expected Uint8Array, got \" + typeof e);\n          return new TextDecoder().decode(e);\n        }, t.hexToBytes = function (e) {\n          const t = e.startsWith(\"0x\") ? e.substring(2) : e;\n          return (0, o.hexToBytes)(t);\n        }, t.equalsBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.wrapHash = function (e) {\n          return t => (i.default.bytes(t), e(t));\n        }, t.crypto = (() => {\n          const t = \"object\" == typeof self && \"crypto\" in self ? self.crypto : void 0,\n            r = \"function\" == typeof e.require && e.require.bind(e);\n          return {\n            node: r && !t ? r(\"crypto\") : void 0,\n            web: t\n          };\n        })();\n      },\n      3687: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0;\n        const n = r(125),\n          i = r(5487);\n        t.keccak224 = (0, i.wrapHash)(n.keccak_224), t.keccak256 = (() => {\n          const e = (0, i.wrapHash)(n.keccak_256);\n          return e.create = n.keccak_256.create, e;\n        })(), t.keccak384 = (0, i.wrapHash)(n.keccak_384), t.keccak512 = (0, i.wrapHash)(n.keccak_512);\n      },\n      1341: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getRandomBytes = t.getRandomBytesSync = void 0;\n        const n = r(64);\n        t.getRandomBytesSync = function (e) {\n          return (0, n.randomBytes)(e);\n        }, t.getRandomBytes = /*#__PURE__*/function () {\n          var _ref16 = _asyncToGenerator(function* (e) {\n            return (0, n.randomBytes)(e);\n          });\n          return function (_x37) {\n            return _ref16.apply(this, arguments);\n          };\n        }();\n      },\n      5487: function _(e, t, r) {\n        \"use strict\";\n\n        e = r.nmd(e);\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;\n        const i = n(r(3525)),\n          o = r(64),\n          s = i.default.bool;\n        t.assertBool = s;\n        const a = i.default.bytes;\n        t.assertBytes = a;\n        var c = r(64);\n        Object.defineProperty(t, \"bytesToHex\", {\n          enumerable: !0,\n          get: function get() {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"toHex\", {\n          enumerable: !0,\n          get: function get() {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"concatBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return c.concatBytes;\n          }\n        }), Object.defineProperty(t, \"createView\", {\n          enumerable: !0,\n          get: function get() {\n            return c.createView;\n          }\n        }), Object.defineProperty(t, \"utf8ToBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return c.utf8ToBytes;\n          }\n        }), t.bytesToUtf8 = function (e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"bytesToUtf8 expected Uint8Array, got \" + typeof e);\n          return new TextDecoder().decode(e);\n        }, t.hexToBytes = function (e) {\n          const t = e.startsWith(\"0x\") ? e.substring(2) : e;\n          return (0, o.hexToBytes)(t);\n        }, t.equalsBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.wrapHash = function (e) {\n          return t => (i.default.bytes(t), e(t));\n        }, t.crypto = (() => {\n          const t = \"object\" == typeof self && \"crypto\" in self ? self.crypto : void 0,\n            r = \"function\" == typeof e.require && e.require.bind(e);\n          return {\n            node: r && !t ? r(\"crypto\") : void 0,\n            web: t\n          };\n        })();\n      },\n      4488: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0;\n        const n = r(125),\n          i = r(7737);\n        t.keccak224 = (0, i.wrapHash)(n.keccak_224), t.keccak256 = (() => {\n          const e = (0, i.wrapHash)(n.keccak_256);\n          return e.create = n.keccak_256.create, e;\n        })(), t.keccak384 = (0, i.wrapHash)(n.keccak_384), t.keccak512 = (0, i.wrapHash)(n.keccak_512);\n      },\n      7737: function _(e, t, r) {\n        \"use strict\";\n\n        e = r.nmd(e);\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.crypto = t.wrapHash = t.equalsBytes = t.hexToBytes = t.bytesToUtf8 = t.utf8ToBytes = t.createView = t.concatBytes = t.toHex = t.bytesToHex = t.assertBytes = t.assertBool = void 0;\n        const i = n(r(3525)),\n          o = r(64),\n          s = i.default.bool;\n        t.assertBool = s;\n        const a = i.default.bytes;\n        t.assertBytes = a;\n        var c = r(64);\n        Object.defineProperty(t, \"bytesToHex\", {\n          enumerable: !0,\n          get: function get() {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"toHex\", {\n          enumerable: !0,\n          get: function get() {\n            return c.bytesToHex;\n          }\n        }), Object.defineProperty(t, \"concatBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return c.concatBytes;\n          }\n        }), Object.defineProperty(t, \"createView\", {\n          enumerable: !0,\n          get: function get() {\n            return c.createView;\n          }\n        }), Object.defineProperty(t, \"utf8ToBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return c.utf8ToBytes;\n          }\n        }), t.bytesToUtf8 = function (e) {\n          if (!(e instanceof Uint8Array)) throw new TypeError(\"bytesToUtf8 expected Uint8Array, got \" + typeof e);\n          return new TextDecoder().decode(e);\n        }, t.hexToBytes = function (e) {\n          const t = e.startsWith(\"0x\") ? e.substring(2) : e;\n          return (0, o.hexToBytes)(t);\n        }, t.equalsBytes = function (e, t) {\n          if (e.length !== t.length) return !1;\n          for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n          return !0;\n        }, t.wrapHash = function (e) {\n          return t => (i.default.bytes(t), e(t));\n        }, t.crypto = (() => {\n          const t = \"object\" == typeof self && \"crypto\" in self ? self.crypto : void 0,\n            r = \"function\" == typeof e.require && e.require.bind(e);\n          return {\n            node: r && !t ? r(\"crypto\") : void 0,\n            web: t\n          };\n        })();\n      },\n      6608: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          return function (e) {\n            let t = 0;\n            return () => e[t++];\n          }(function (e) {\n            let t = 0;\n            function r() {\n              return e[t++] << 8 | e[t++];\n            }\n            let n = r(),\n              i = 1,\n              o = [0, 1];\n            for (let e = 1; e < n; e++) o.push(i += r());\n            let s = r(),\n              a = t;\n            t += s;\n            let c = 0,\n              u = 0;\n            function d() {\n              return 0 == c && (u = u << 8 | e[t++], c = 8), u >> --c & 1;\n            }\n            const l = 2 ** 31,\n              h = l >>> 1,\n              f = l - 1;\n            let p = 0;\n            for (let e = 0; e < 31; e++) p = p << 1 | d();\n            let m = [],\n              g = 0,\n              y = l;\n            for (;;) {\n              let e = Math.floor(((p - g + 1) * i - 1) / y),\n                t = 0,\n                r = n;\n              for (; r - t > 1;) {\n                let n = t + r >>> 1;\n                e < o[n] ? r = n : t = n;\n              }\n              if (0 == t) break;\n              m.push(t);\n              let s = g + Math.floor(y * o[t] / i),\n                a = g + Math.floor(y * o[t + 1] / i) - 1;\n              for (; 0 == ((s ^ a) & h);) p = p << 1 & f | d(), s = s << 1 & f, a = a << 1 & f | 1;\n              for (; s & ~a & 536870912;) p = p & h | p << 1 & f >>> 1 | d(), s = s << 1 ^ h, a = (a ^ h) << 1 | h | 1;\n              g = s, y = 1 + a - s;\n            }\n            let v = n - 4;\n            return m.map(t => {\n              switch (t - v) {\n                case 3:\n                  return v + 65792 + (e[a++] << 16 | e[a++] << 8 | e[a++]);\n                case 2:\n                  return v + 256 + (e[a++] << 8 | e[a++]);\n                case 1:\n                  return v + e[a++];\n                default:\n                  return t - 1;\n              }\n            });\n          }(function (e) {\n            let t = [];\n            [...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"].forEach((e, r) => t[e.charCodeAt(0)] = r);\n            let r = e.length,\n              n = new Uint8Array(6 * r >> 3);\n            for (let i = 0, o = 0, s = 0, a = 0; i < r; i++) a = a << 6 | t[e.charCodeAt(i)], s += 6, s >= 8 && (n[o++] = a >> (s -= 8));\n            return n;\n          }(e)));\n        }\n        function n(e) {\n          return 1 & e ? ~e >> 1 : e >> 1;\n        }\n        function i(e, t) {\n          let r = Array(e);\n          for (let i = 0, o = 0; i < e; i++) r[i] = o += n(t());\n          return r;\n        }\n        function o(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          let r = [];\n          for (;;) {\n            let n = e(),\n              i = e();\n            if (!i) break;\n            t += n;\n            for (let e = 0; e < i; e++) r.push(t + e);\n            t += i + 1;\n          }\n          return r;\n        }\n        function s(e) {\n          return c(() => {\n            let t = o(e);\n            if (t.length) return t;\n          });\n        }\n        function a(e) {\n          let t = [];\n          for (;;) {\n            let r = e();\n            if (0 == r) break;\n            t.push(d(r, e));\n          }\n          for (;;) {\n            let r = e() - 1;\n            if (r < 0) break;\n            t.push(l(r, e));\n          }\n          return t.flat();\n        }\n        function c(e) {\n          let t = [];\n          for (;;) {\n            let r = e(t.length);\n            if (!r) break;\n            t.push(r);\n          }\n          return t;\n        }\n        function u(e, t, r) {\n          let n = Array(e).fill().map(() => []);\n          for (let o = 0; o < t; o++) i(e, r).forEach((e, t) => n[t].push(e));\n          return n;\n        }\n        function d(e, t) {\n          let r = 1 + t(),\n            n = t(),\n            i = c(t);\n          return u(i.length, 1 + e, t).flatMap((e, t) => {\n            let [o, ...s] = e;\n            return Array(i[t]).fill().map((e, t) => {\n              let i = t * n;\n              return [o + t * r, s.map(e => e + i)];\n            });\n          });\n        }\n        function l(e, t) {\n          return u(1 + t(), 1 + e, t).map(e => [e[0], e.slice(1)]);\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        var h = r(\"AEIRrQh1DccBuQJ+APkBMQDiASoAnADQAHQAngBmANQAaACKAEQAgwBJAHcAOQA9ACoANQAmAGMAHgAvACgAJQAWACwAGQAjAB8ALwAVACgAEQAdAAkAHAARABgAFwA7ACcALAAtADcAEwApABAAHQAfABAAGAAeABsAFwAUBLoF3QEXE7k3ygXaALgArkYBbgCsCAPMAK6GNjY2NjFiAQ0ODBDyAAQHRgbrOAVeBV8APTI5B/a9GAUNz8gAFQPPBeelYALMCjYCjqgCht8/lW+QAsXSAoP5ASbmEADytAFIAjSUCkaWAOoA6QocAB7bwM8TEkSkBCJ+AQQCQBjED/IQBjDwDASIbgwDxAeuBzQAsgBwmO+snIYAYgaaAioG8AAiAEIMmhcCqgLKQiDWCMIwA7gCFAIA9zRyqgCohB8AHgQsAt4dASQAwBnUBQEQIFM+CZ4JjyUiIVbATOqDSQAaABMAHAAVclsAKAAVAE71HN89+gI5X8qc5jUKFyRfVAJfPfMAGgATABwAFXIgY0CeAMPyACIAQAzMFsKqAgHavwViBekC0KYCxLcCClMjpGwUehp0TPwAwhRuAugAEjQ0kBfQmAKBggETIgDEFG4C6AASNAFPUCyYTBEDLgIFMBDecB60Ad5KAHgyEn4COBYoAy4uwD5yAEDoAfwsAM4OqLwBImqIALgMAAwCAIraUAUi3HIeAKgu2AGoBgYGBgYrNAOiAG4BCiA+9Dd7BB8eALEBzgIoAgDmMhJ6OvpQtzOoLjVPBQAGAS4FYAVftr8FcDtkQhlBWEiee5pmZqH/EhoDzA4s+H4qBKpSAlpaAnwisi4BlqqsPGIDTB4EimgQANgCBrJGNioCBzACQGQAcgFoJngAiiQgAJwBUL4ALnAeAbbMAz40KEoEWgF2YAZsAmwA+FAeAzAIDABQSACyAABkAHoAMrwGDvr2IJSGBgAQKAAwALoiTgHYAeIOEjiXf4HvABEAGAA7AEQAPzp3gNrHEGYQYwgFTRBMc0EVEgKzD60L7BEcDNgq0tPfADSwB/IDWgfyA1oDWgfyB/IDWgfyA1oDWgNaA1ocEfAh2scQZg9PBHQFlQWSBN0IiiZQEYgHLwjZVBR0JRxOA0wBAyMsSSM7mjMSJUlME00KCAM2SWyufT8DTjGyVPyQqQPSMlY5cwgFHngSpwAxD3ojNbxOhXpOcacKUk+1tYZJaU5uAsU6rz//CigJmm/Cd1UGRBAeJ6gQ+gw2AbgBPg3wS9sE9AY+BMwfgBkcD9CVnwioLeAM8CbmLqSAXSP4KoYF8Ev3POALUFFrD1wLaAnmOmaBUQMkARAijgrgDTwIcBD2CsxuDegRSAc8A9hJnQCoBwQLFB04FbgmE2KvCww5egb+GvkLkiayEyx6/wXWGiQGUAEsGwIA0i7qhbNaNFwfT2IGBgsoI8oUq1AjDShAunhLGh4HGCWsApRDc0qKUTkeliH5PEANaS4WUX8H+DwIGVILhDyhRq5FERHVPpA9SyJMTC8EOIIsMieOCdIPiAy8fHUBXAkkCbQMdBM0ERo3yAg8BxwwlycnGAgkRphgnQT6ogP2E9QDDgVCCUQHFgO4HDATMRUsBRCBJ9oC9jbYLrYCklaDARoFzg8oH+IQU0fjDuwIngJoA4Yl7gAwFSQAGiKeCEZmAGKP21MILs4IympvI3cDahTqZBF2B5QOWgeqHDYVwhzkcMteDoYLKKayCV4BeAmcAWIE5ggMNV6MoyBEZ1aLWxieIGRBQl3/AjQMaBWiRMCHewKOD24SHgE4AXYHPA0EAnoR8BFuEJgI7oYHNbgz+zooBFIhhiAUCioDUmzRCyom/Az7bAGmEmUDDzRAd/FnrmC5JxgABxwyyEFjIfQLlU/QDJ8axBhFVDEZ5wfCA/Ya9iftQVoGAgOmBhY6UDPxBMALbAiOCUIATA6mGgfaGG0KdIzTATSOAbqcA1qUhgJykgY6Bw4Aag6KBXzoACACqgimAAgA0gNaADwCsAegABwAiEQBQAMqMgEk6AKSA5YINM4BmDIB9iwEHsYMGAD6Om5NAsO0AoBtZqUF4FsCkQJMOAFQKAQIUUpUA7J05ADeAE4GFuJKARiuTc4d5kYB4nIuAMoA/gAIOAcIRAHQAfZwALoBYgs0CaW2uAFQ7CwAhgAYbgHaAowA4AA4AIL0AVYAUAVc/AXWAlJMARQ0Gy5aZAG+AyIBNgEQAHwGzpCozAoiBHAH1gIQHhXkAu8xB7gEAyLiE9BCyAK94VgAMhkKOwqqCqlgXmM2CTR1PVMAER+rPso/UQVUO1Y7WztWO1s7VjtbO1Y7WztWO1sDmsLlwuUKb19IYe4MqQ3XRMs6TBPeYFRgNRPLLboUxBXRJVkZQBq/Jwgl51UMDwct1mYzCC80eBe/AEIpa4NEY4keMwpOHOpTlFT7LR4AtEulM7INrxsYREMFSnXwYi0WEQolAmSEAmJFXlCyAF43IwKh+gJomwJmDAKfhzgeDgJmPgJmKQRxBIIDfxYDfpU5CTl6GjmFOiYmAmwgAjI5OA0CbcoCbbHyjQI2akguAWoA4QDkAE0IB5sMkAEBDsUAELgCdzICdqVCAnlORgJ4vSBf3kWxRvYCfEICessCfQwCfPNIA0iAZicALhhJW0peGBpKzwLRBALQz0sqA4hSA4fpRMiRNQLypF0GAwOxS9FMMCgG0k1PTbICi0ICitvEHgogRmoIugKOOgKOX0OahAKO3AKOX3tRt1M4AA1S11SIApP+ApMPAOwAH1UhVbJV0wksHimYiTLkeGlFPjwCl6IC77VYJKsAXCgClpICln+fAKxZr1oMhFAAPgKWuAKWUVxHXNQCmc4CmWdczV0KHAKcnjnFOqACnBkCn54CnruNACASNC0SAp30Ap6VALhAYTdh8gKe1gKgcQGsAp6iIgKeUahjy2QqKC4CJ7ICJoECoP4CoE/aAqYyAqXRAqgCAIACp/Vof2i0AAZMah9q1AKs5gKssQKtagKtBQJXIAJV3wKx5NoDH1FsmgKywBACsusabONtZm1LYgMl0AK2Xz5CbpMDKUgCuGECuUoYArktenA5cOQCvRwDLbUDMhQCvotyBQMzdAK+HXMlc1ICw84CwwdzhXROOEh04wM8qgADPJ0DPcICxX8CxkoCxhOMAshsVALIRwLJUgLJMQJkoALd1Xh8ZHixeShL0wMYpmcFAmH3GfaVJ3sOXpVevhQCz24Cz28yTlbV9haiAMmwAs92ASztA04Vfk4IAtwqAtuNAtJSA1JfA1NiAQQDVY+AjEIDzhnwY0h4AoLRg5AC2soC2eGEE4RMpz8DhqgAMgNkEYZ0XPwAWALfaALeu3Z6AuIy7RcB8zMqAfSeAfLVigLr9gLpc3wCAur8AurnAPxKAbwC7owC65+WrZcGAu5CA4XjmHxw43GkAvMGAGwDjhmZlgL3FgORcQOSigL3mwL53AL4aZofmq6+OpshA52GAv79AR4APJ8fAJ+2AwWQA6ZtA6bcANTIAwZtoYuiCAwDDEwBIAEiB3AGZLxqCAC+BG7CFI4ethAAGng8ACYDNrIDxAwQA4yCAWYqJACM8gAkAOamCqKUCLoGIqbIBQCuBRjCBfAkREUEFn8Fbz5FRzJCKEK7X3gYX8MAlswFOQCQUyCbwDstYDkYutYONhjNGJDJ/QVeBV8FXgVfBWoFXwVeBV8FXgVfBV4FXwVeBV9NHAjejG4JCQkKa17wMgTQA7gGNsLCAMIErsIA7kcwFrkFTT5wPndCRkK9X3w+X+8AWBgzsgCNBcxyzAOm7kaBRC0qCzIdLj08fnTfccH4GckscAFy13U3HgVmBXHJyMm/CNZQYgcHBwqDXoSSxQA6P4gAChbYBuy0KgwAjMoSAwgUAOVsJEQrJlFCuELDSD8qXy5gPS4/KgnIRAUKSz9KPn8+iD53PngCkELDUElCX9JVVnFUETNyWzYCcQASdSZf5zpBIgluogppKjJDJC1CskLDMswIzANf0BUmNRAPEAMGAQYpfqTfcUE0UR7JssmzCWzI0tMKZ0FmD+wQqhgAk5QkTEIsG7BtQM4/Cjo/Sj53QkYcDhEkU05zYjM0Wui8GQqE9CQyQkYcZA9REBU6W0pJPgs7SpwzCogiNEJGG/wPWikqHzc4BwyPaPBlCnhk0GASYDQqdQZKYCBACSIlYLoNCXIXbFVgVBgIBQZk7mAcYJxghGC6YFJgmG8WHga8FdxcsLxhC0MdsgHCMtTICSYcByMKJQGAAnMBNjecWYcCAZEKv04hAOsqdJUR0RQErU3xAaICjqNWBUdmAP4ARBEHOx1egRKsEysmwbZOAFYTOwMAHBO+NVsC2RJLbBEiAN9VBnwEESVhADgAvQKhLgsWdrIgAWIBjQoDA+D0FgaxBlEGwAAky1ywYRC7aBOQCy1GDsIBwgEpCU4DYQUvLy8nJSYoMxktDSgTlABbAnVel1CcCHUmBA94TgHadRbVWCcgsLdN8QcYBVNmAP4ARBEHgQYNK3MRjhKsPzc0zrZdFBIAZsMSAGpKblAoIiLGADgAvQKhLi1CFdUClxiCAVDCWM90eY7epaIO/KAVRBvzEuASDQ8iAwHOCUEQmgwXMhM9EgBCALrVAQkAqwDoAJuRNgAbAGIbzTVzfTEUyAIXCUIrStroIyUSG4QCggTIEbHxcwA+QDQOrT8u1agjB8IQABBBLtUYIAB9suEjD8IhThzUqHclAUQqZiMC8qAPBFPz6x9sDMMNAQhDCkUABccLRAJSDcIIww1DLtWoMQrDCUMPkhroBCIOwgyYCCILwhZCAKcQwgsFGKd74wA7cgtCDEMAAq0JwwUi1/UMBQ110QaCAAfCEmIYEsMBCADxCAAAexViDRbSG/x2F8IYQgAuwgLyqMIAHsICXCcxhgABwgAC6hVDFcIr8qPCz6hCCgKlJ1IAAmIA5+QZwqViFb/LAPsaggioBRH/dwDfwqfCGOIBGsKjknl5BwKpoooAEsINGxIAA5oAbcINAAvCp0IIGkICwQionNEPAgfHqUIFAOGCL71txQNPAAPyABXCAAcCAAnCAGmSABrCAA7CCRjCjnAWAgABYgAOcgAuUiUABsIAF8IIKAANUQC6wi0AA8IADqIq8gCyYQAcIgAbwgAB8gqoAAXNCxwV4gAHogBCwgEJAGnCAAuCAB3CAAjCCagABdEAbqYZ3ACYCCgABdEAAUIAB+IAHaIIKAAGoQAJggAbMgBtIgDmwocACGIACEIAFMIDAGkCCSgABtEA45IACUILqA7L+2YAB0IAbqNATwBOAArCCwADQgAJtAM+AAciABmCAAISpwIACiIACkIACgKn8gbCAAkiAAMSABBCBwAUQgARcgAPkgAN8gANwgAZEg0WIgAVQgBuoha6AcIAwQATQgBpMhEA4VIAAkIABFkAF4IFIgAG1wAYwgQlAYIvWQBATAC2DwcUDHkALzF3AasMCGUCcyoTBgQQDnZSc2YxkCYFhxsFaTQ9A6gKuwYI3wAdAwIKdQF9eU5ZGygDVgIcRQEzBgp6TcSCWYFHADAAOAgAAgAAAFoR4gCClzMBMgB97BQYOU0IUQBeDAAIVwEOkdMAf0IEJ6wAYQDdHACcbz4mkgDUcrgA1tsBHQ/JfHoiH10kENgBj5eyKVpaVE8ZQ8mQAAAAhiM+RzAy5xieVgB5ATAsNylJIBYDN1wE/sz1AFJs4wBxAngCRhGBOs54NTXcAgEMFxkmCxsOsrMAAAMCBAICABnRAgAqAQAFBQUFBQUEBAQEBAQDBAUGBwgDBAQEBAMBASEAigCNAJI8AOcAuADZAKFDAL8ArwCqAKUA6wCjANcAoADkAQUBAADEAH4AXwDPANEBAADbAO8AjQCmAS4A5wDcANkKAAgOMTrZ2dnZu8Xh0tXTSDccAU8BWTRMAVcBZgFlAVgBSVBISm0SAVAaDA8KOT0SDQAmEyosLjE9Pz9CQkJDRBNFBSNWVlZWWFhXWC5ZWlxbWyJiZmZlZ2Ypa211dHd3d3d3d3l5eXl5eXl5eXl5e3t8e3phAEPxAEgAmQB3ADEAZfcAjQBWAFYANgJz7gCKAAT39wBjAJLxAJ4ATgBhAGP+/q8AhACEAGgAVQCwACMAtQCCAj0CQAD7AOYA/QD9AOcA/gDoAOgA5wDlAC4CeAFQAT8BPQFTAT0BPQE9ATgBNwE3ATcBGwFXFgAwDwcAAFIeER0KHB0VAI0AlQClAFAAaR8CMAB1AG4AlgMSAyQxAx5IRU4wAJACTgDGAlYCoQC/ApMCkwKTApMCkwKTAogCkwKTApMCkwKTApMCkgKSApUCnQKUApMCkwKRApECkQKQAnIB0QKUApoCkwKTApIbfhACAPsKA5oCXgI3HAFRFToC3RYPMBgBSzwYUpYBeKlBAWZeAQIDPEwBAwCWMB4flnEAMGcAcAA1AJADm8yS8LWLYQzBMhXJARgIpNx7MQsEKmEBuQDkhYeGhYeFiImJhYqNi4WMj42HjomPiZCFkYWShZORlIWVhZaJl4WYhZmFmoWbipyPnYmehQCJK6cAigRCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAqgOOANBYANYCEwD9YQD9ASAA/QD7APsA/AD72wOLKmzFAP0A+wD7APwA+yMAkGEA/QCQASAA/QCQAvMA/QCQ2wOLKmzFIwD+YQEgAP0A/QD7APsA/AD7AP4A+wD7APwA+9sDiypsxSMAkGEBIAD9AJAA/QCQAvMA/QCQ2wOLKmzFIwJKAT0CUQFAAlLIA6UC8wOl2wOLKmzFIwCQYQEgA6UAkAOlAJAC8wOlAJDbA4sqbMUjBDcAkAQ4AJANlDh0JwEzAJAHRXUKKgEEAM1hCQBbYQAFGjkJAJAJRN8AUAkAkAkAnW0/6mOd3brkH5dB9mNQ/eNThoJ1CP8EZzy46pMulzRpOAZDJDXL2yXaVtAh1MxM82zfnsL/FXSaOaxJlgv345IW0Dfon3fzkx0WByY6wfCroENsWq/bORcfBvtlWbGzP5ju+gqE1DjyFssbkkSeqLAdrCkLOfItA7XNe1PctDPFKoNd/aZ6IQq6JTB6IrDBZ5/nJIbTHMeaaIWRoDvc42ORs9KtvcQWZd+Nv1D2C/hrzaOrFUjpItLWRI4x3GmzQqZbVH5LoCEJpk3hzt1pmM7bPitwOPG8gTKLVFszSrDZyLmfq8LkwkSUhIQlN4nFJUEhU2N7NBTOGk4Y2q9A2M7ps8jcevOKfycp9u3DyCe9hCt7i5HV8U5pm5LnVnKnyzbIyAN/LU4aqT3JK+e9JsdusAsUCgAuCnc4IwbgPBg4EPGOv5gR8D+96c8fLb09f7L6ON2k+Zxe/Y0AYoZIZ8yuu1At7f70iuSFoFmyPpwDU/4lQ+mHkFmq/CwtE7A979KNdD8zaHSx4HoxWsM8vl+2brNxN0QtIUvOfNGAYyv1R5DaM1JAR0C+Ugp6/cNq4pUDyDPKJjFeP4/L1TBoOJak3PVlmDCi/1oF8k1mnzTCz15BdAvmFjQrjide74m2NW1NG/qRrzhbNwwejlhnPfRn4mIfYmXzj5Fbu3C2TUpnYg+djp65dxZJ8XhwUqJ8JYrrR4WtrHKdKjz0i77K+QitukOAZSfFIwvBr1GKYpSukYTqF4gNtgaNDqh78ZDH4Qerglo3VpTLT0wOglaX6bDNhfs04jHVcMfCHwIb+y5bAaBvh2RARFYEjxjr1xTfU09JEjdY1vfcPrPVmnBBSDPj9TcZ1V/Dz8fvy0WLWZM0JPbRL0hLSPeVoC8hgQIGaeE6AYVZnnqm62/wt00pDl5Nw/nDo+bF1tC4qo5DryXVn8ffL3kuT51e+VcBTGiibvP+vqX50dppfxyNORSr48S5WXV8fzcsgjRQH6zjl+nuUYFVloiEnZOPDpHD/7ILh3JuFCdvAi2ANXYXjTDA5Up6YLihbc7d+dBlI9+mdgr8m8+3/Dp26W/Jssn7b9/pOEP4i+/9TsPI9m2NfNKwEI35mqKV+HpZ+W69Y8sM/sIA9Ltvhd+evQTUUfSkYxki28/CBT0cT96HrlrSrE+V9RzhskX0CsDsCfHffBVybkxmHOFOgaUurWNQ2AcZbi1WjkZzYArWZBHFd1SYwtqQ0DIZt7OV40ewQxCr/LgxAc8dLJeAJFseWJq9XiOp21hLv/HhsFbYbg3zCR8JmonZjhuKYrS/KJc30vnOL2CM+GfogNWug2DstZPzauCNeeD8zlP8wxPyfLHYQB/J+wQE3aDpXH/5tdIQpLn3JXNJYZFiXInGB7FqxRxHYJ/re/lHprE5sngUMm11uOIA3bbtkk06I8DYxuwPD+e4sAeNfor0DkWmiCQFiNptkmiD2xGO1kIKGr/Tuu4bHe6z2NaS7Ih0c+Gpv+QbLY9ea122BXNSitM41sxUSlnWl+uJBIFoLqt66v/VfGIQos2lzhOOLDuScVxcyrqH3/FI4vaYB0b8gFHLXtxyX/9JpUCYNwlLZ1v5CeB99l0F795R5wl5UHRq1OYyKqsoIY07wJz2CT0TOf5/JRBPtJIIk5pOJ60SHayS9kMSKbI3fLLYztsY3B4MlSyoEfc9gL4yJVrPo+OGGunCK4p15UbCArJP/PQgUWDW4l+2P/tCqRRy2flIZL/nVeY/vyAfILUM5qEGfcFXXXrAit7skwDEFnD7mL1ATtyrz7HcodhzP7gShFhazIPm7X0+mTCeSWfrOr5WcvJfip19JRRLfXjuQpQjcNCuXo8kqkxQ68ukJQoxlnfjevc0WcKnGpUvyY54eJTS1IRWDqfHANukJLw56ts5yS6Nea7IrL6/78aKmZsch4Q694ujxgx5+0PhlGpzWimajpvkBOOUQlHLkJorzqu4e768L9nJtZWYturb7dsBxjzlNhd/gZcBuRgIUSdgZjg7Rx+f/zLcs4mAa3qDbJNUQVNbSg+dm0L3KH1uhesTPaErVYjZ8Isvfr+zfiX3DT0PlaOv+hdGvLUIlKSEcYHPMs0NtTGzyqMe74yciNFdAVZVzol/XtLsEqivKqfW7zWTCNCvZkPnnBlMv3UHW5RNNEJfuyR3MvYH/9E6gcts5GAwKIgCaBQ+V2Eh9O0IJkxFksPI1V9obqDKCpmPM55mLd+VQgRqgD+9XvsUxjbh/AXXPxOpc0FXFyJzc85aa1VQZa90LAWR4oinrBaOBr8DymCpFbdXMTn7Cv18S0hMR7T/o5VkRqN1g1/dvaDdZsRArO3bopkfee4efLF+hyVdcX4u3aNGTkWvLRafW+sXPktA1lla4UkSB7uJIULfxy/RAflk2miyw9xq9uVGgCNzqCv4iX+AUchfMkZdEgRZ9TZ+1CPTH2jXjMXjFl/+bEPzSjM7zPKKWhyZUgQG1lpp+DNz+Zz+85kD59q99U5R4B3vuI9WenCWqroy2U2Ruq6I+di5N/v9SmYnqJ5H1HLWCbIg6iVrn3s2gFBVFhrc1zzNqoFe275K3Jy1T0Mc5yeE1iRwO2b1L/j/S8jyvGDz6B3NMFEHErGHMM2+oJ5LobazyWEitdgMjQnsd0cjYrCqRpx8idpfwRq6hz/LleX6obpuJh/AGIu4sxD35hwkIEr5ShH8xro7tTDYK1GPHGylK6rp7NCG0lMr7YqwziMUBwXv0zPW667f3/IRLJRD7mkuwUP6mpkxyVjNlcBiAX12r//+WTuzWxsue7bsjRp7xFjpR2tRLqGHLvjYt3TpeybR82K61iLn+pOSWDfUv/HU8ecBtML+Gbz0v9vmlxSgZeBBzbGeP1KSqsH14ZM2kibgDhbS21hIALSOYFCE9LY+2CNvtzT2QuSJMiKP3zwvvs+/JkDwTg0jHVE0XH//U0nu5HKQtCL2KGDQYUgT7qIMVN/OoWqEz1oeG4wG7InZg47NE7rfHB2i7rkpYCUzaPfVtDYgTEPNpa8gXHI2Pp8A6YB8OYHkXDZMMcOL3rJD0Hxk+mRlsSJ12/7T52IcFst5zRc7uDJtQTXBdm9GvsvyXcBbMfKXWqsDSeEnFyPUXZGTafti4a0it8SN1qXxzBmzj+gVZ/FojNy+x73AuuqtJ/oaMZF6m5kbW6ItpfnUT/BrQunS+gLjTTUz0d8jTMpAfFQ40RQi9uM5qdFYzqk85hqSH1zsPOhiO5CN+hNZvL/RIs7m7LyLDuV80ZtyHHqVEngTVPBctHQhmcPjM30m1veDmHCXEpjybWAbgj3TqLUPNazzdHgxYmNuT7trWFcGOi7iTeL5YeK2yp2H98yoLN+skqhffZI/5n/ivceo44wJRY8bzC6DGwdgkMOulYhzW5m6OKyK2Mg+E3YE19L8ngE08TdAuNu0mIzd6kw0i03zzm4oqfVSZjZyxXnBhvt0v89EmnArya/UvHQrdQxBDAJagK2y+OqgBqzQ4FnUeiKfb7HFoUvFSknWhwq58TpBlVRZ0B0A7QWz7X4GLHcbdh5kFI/PKJ91OEh/kmnMEdh+Z23myFH8sXjR/KaHttrpz80N+bl0HM17RX48UjUWslrYHYW7oiHVgcGqTBoTrqK4JYwTTArFO1/APJ8DnEYf+wD92Dw15a9wrPxyJA88yYcv9RypzXLKAWmMuE0KAtIGjfKx1GbRQIq0AkttuRpBO7p4SGrTZuAOat3hTxXEcIKh3HgC1d88K7bz1+Jsi+y7tL/7zc0ZxCBB3hSxvP90GkUp1Lm2wuESafZyFy4Opir+o3gMWtDSuLF3LRHXTUGkKQtvARnwam8BuKv8Q2fHH/cEwPCQd3dhzgri8eTezRsQoGz6ha+S4E7ZzDB/LXwl04vA70NeVsf5rmv1TLvcQSNIBk3U6Qh6Bm+0905B91hopTLnTJRWZkUmbckEw0woG81azyw6LZaBL5Qx2HPvd3LHGLpN6mPZlto50NwW2zFOkgoPKV1gr142teD9aok2HNkPMepl3NIi78ShnAlJCzjZplteUoqz0+iUEOym1LZGGFHMBkc6/5f+sRCCFZZW6KrEby64o/ZfefQAPP6b5ko2fuujIv7uonIKXN6XiJsZmcOeGxteQ+b/ope3Z1HFeXYoW1AJrU/OiCpsyQP1Pr1BdQKFzS0oYnLCAweSnIh7qMFMRBMY7BcnJ5oskUbbRNiosqMzCYUAZPbo8tjCCsCBm5SoGcTHBMXcE+yQpl/OfBkcTw3oa4X7V+ohEh/Zkcv0cqc8sY40IsOW6lLiIrvYND/exZbRlOMgaHvb/QQKaY0k6Aamee2o3LVARCbIP4RoSd7u3CXkG+Iz6iFLfsN38F9xU4n3ueeVgiRs3jw70SMWu1QzDdiLsKtU1qvaLhv7dUbnLimdqYG+pa2aRZ8A6Q9JSr3yTs1MiAvfFHPQJTiqpI/hVUMmL6gPj6eL7lH0IkLCNcaogBA0TGfO0wO6ddf8Fju0L3YbRrWe8J3IewsNBCbpC2b6etQRJnSGLuWDiFoBez9hJHw6+bMQQGQS8YV/kzQ5AFHEqPaMgOjyR5zaHtlOBI4mjo8gdNItHUHQ7Bzq/E/xV1B+L0uoRcLIEj4hcv0yWQTwWLHzoFrvEZPygABpc4rnVjhfcBw5wOvaVVtgiG5qjklrTY1ZaXHkasyVYBd+lgo6zEHMumfK8XR2eD0cVn5w8l1uxGz2ACwtFob/CTV/TUx1kCKp+QROanLrNBiSPTxAf1eOFE+JifgAJ+pyrFqS/0wKlPWUVKlB2Bhu1Ggx2cvfdiR49VIsgBNnE75pf5lpFaQuz8+VPreUd/HLlW8kDSr25AnETsVRrOycLBPYD9/j/7Z0KKdOjtrM71AT+VsjD3D97aUDP5WrHp1DWghsk/lS/hp2VMwo0eqoEerLL/4/SlmyjStwWVDqF6jHC89niCwr1tMSe8GxeC9wjzMKmE7ZtdHOWqqc1OoTI24eVQc++crbyxSU4TxiB+vWoaAUpYQxZ06KKIPq6EvN/rN4DZ0/tQWYVqZ3FTIftPBfIuOWX3PonIKTUArpSvfmQRpkWD00wc3AQS98i4ZYaUbI+DGv90tuEKRjb2ocfdddC21YGUATYQmzelz7JqWBAQqKrWYdWEJlfPeRFZHtUm2MaISZsoOvURowxJKveGRegmBiKZ3d1cMFioJL33RoIKT0eDeK8FH/ybAhZU5TQIsWYmjyeT7EOLL5xZuRPf4qRIo6bbLtFOV6SX60fR8Smys/u1D5DjkmHJyr/woVAvBP2dxGo9gH1LgIm8XlFF1KSYvfj+0w7aTEfoFpcO+Jv3Ssbv8wwkED5JEC+jdln2dzToPNRtWiPbRb8f8G4aZX1j/2Vdbu7jM3gAVD5BKR+yJaOwLtwJodwjWu5di47tnNs9ahpnCUzVMObQfbTqMNs64MGANlgyihKjhwZ6p1Jsnro0/SfkOk6wx+HgUB6Mz9cUiF7KrJkhxnOVjCCcqPZglIojIRoDtkd2AkLNZC88GdP2qZV/1N6PBAe+fpgWZ36oHnewQ8CHdXcxbwQVjOn8U3qD9+e7FzWpg135vgdEMZ9fH5agDnNzdjKFZQ4tDsJs/S6Lk8FqjFJpHMjaRU6FI/DBDM0g+RRkxNoUvm14JAn5dgd6aVHt1aMkSXiJVenbm2FfrIEaFKHtm1erv1BJ5056ULL8AMGLmHav4yxg6F6n5oBq7bdP6zEr6f+QTDJ/KE1XfoG24JvVk2GL7Fb+me27otVFnq1e/2wEuqv6X+2zLQuJQszy5YJi/M5888fMy34L6z8ykD5sCHgzliAoAtEeoaFmnPT63kOYrZWspxYzqQBu/QKNyQ8e4QwKJUCVazmIUp6/zpLA3bWH2ch7QZN0rzWGxMRl3K1osWeETxL95TZSG/atM8LB9B92/71+g9UGWDPfD+lu/KdOQ85rocuHe91/gHA/iprG9PZ2juX49kaRxZ+1/sB3Ck35eWYBFsmCl0wC4QZWX5c5QMuSAEz1CJj0JWArSReV4D/vrgLw+EyhBB6aA4+B34PdlDaTLpm9q9Pkl+bzVWrSO+7uVrIECzsvk8RcmfmNSJretRcoI7ZcIfAqwciU9nJ8O4u1EgkcMOzC/MM2l6OYZRrGcqXCitp4LPXruVPzeD402JGV9grZyz9wJolMLC/YCcWs9CjiWv+DNRLaoSgD5M8T4PzmG8cXYM4jPo5SG1wY3QK/4wzVPrc33wI+AcGI//yXgvyBjocGrl768DMaYCGglwIit4r6t6ulwhwHJ4KeV3VHjspXXG4DIlDR2HNFvPaqkBViIvr433qZPuUINp6oi1LyVVC+EE1j6+wab8uPMeAo6e9uWYequvZynhnYazrvrDQJVkK3KZRoSR5BHi6vOC+AVCujMiQ1GVzGDZ4RFv8jFm7z5CU0iPH2JeXqUzqaKKP4P7osPkcIL99Y7fP3l+TzeFXO2kSpLIJW51oEY8DRIhqexGnxj0nmtGOseStuViIE2mJge45LENf77xjuI7egRNpzthNiajnuqikg0aQS1JqlIZf+hwSUlOp8BEQ0y3xiTOJkohBP3eyYiPDlZpFY88EWOpp4+hC/tQdhrQ56h2VJ2XA6vhPAbj+wH6iA2XYuTvRV25N8wNPQuA0Vzzem2ADZPFK2vr8l0I3GTV3fUN4S6FFYygW2Pu98f+lsgPf67rwVCbgMFAACW3P10GbxnK3SNuNK+VlPRiL7U3dK1o3spH/MFfDkgXuXjxDTxJrYctqHdwUg4rhUCNA13lGjuhJDatpFb/mExsBWS46aLFtROqVm8xQNPXK6A2rRfazJSWpIyh+FMmorXPXYnHQ7YLOmD4B5QTI8rzp7OomiarnaFs5syYjQ0ucc7g1/JzT446IFlDtpUL7DP9bLRCLJryUvi5R71/qX7ycqRSwunQ7+tfJz44Na3aJNszaMEZ/BV4iOGopabYdmvAPe+kIdGCNq5Q8fg8Ld0VNNXV0ZiiGej7zSA+pexy6wKC5k4rZa0k+qaN8bKq3oJWMQCSGaK7PrwMvA8t8BZTzjDqXcFTAIeRtl0SdlGSuAziVXItFcgAkeqwuNsbsrUZFcU6KUZLmvG415kHa0AwMFW2cNSUvPR0U9iCPh0nyslT92B5slYXiDWeSXvxHXItvjI8z5KCIVTIHqGZsbDBTr7WdHzcUAI1ipR86H3o0p2wPhfp7xg9oWOxWIK4a5BWdaV9OAPc0XuvlbwitCVtZDzZxGhIOl77ZgrRYR7LZQFE+Ih23hW3gI914ekkjgbKCi2bsqSAvij6GGj5p+k6evQtJp3qVh9vg+jiJvFCGcKBCITMWpqHZNKfE6IT0dKntS0rhu0DB5D9qIS0/RboNLsx2DlRMlx1QIBeBpHJNKdCL9uWM9eS7RJXKNOpraULtutuJYOl0apdE4LxfsyRSZb6fJkd51SHrI7lLB4vEg4fifJ1dqcWSeY4DgcyjrUcymK+gd3o+qj+3gHKWlLVdMUr3IeF8aClYBq+eeCV9Y7n1Ye8yL7rEvxY7jAlLwucKQ51pu59N8we8XwrbXPChBHXP4LnD3kDwQ85w1DKghtwvpO609fZOrPq8Q7GOOAjHhfR5VqvpoFne8oMHbCrWb1L0IdATo+h1PFeLLI8wc+FEyftLvskCdOtxKfAx3IEJXzBfWTKq5viKP/uu99dxnEpoNJhRtjSZGwOTWr7Ys44++P58O+nkYxd1Gcqm8G3Gh7AHSCxiPNyJWijI/lECrKrAXgBqkRShvdkd7IfoqUlziFDiglx+jdHnmRVmGnk3p/3n78M/HkzFUGZOS07cPnPn9jAnBWl4qDrB1ECf9idIKOdkJTKcZ690nuLW2yDsqwNpgrlT+wx2gv+Engha74lfVqbwqS15FRwuFDfq3bVCZcPy78TL2pH/DOdHeL9MFAtyybQNwHaO781rnJZAhR4M+AYWoSoa0EjQ99xivreM+FKwd7Jp/FC2vvvcq1z3RnRau/BM5KGkBPBSUBOzTNdfaJS/PWTDb1jRSgn2MuY3pVZbY9peHBVI3Ce/u70hg4f7MCVeAjYJfzTkDVLuB6jyjZs5Kko3u39ozgLK4LuwSbUrNIU5cl6Bs3De62AE084XRsm64Gs5W1ofxsWIZ9cYl8PNa5zQHl9ls5aiIKN0rHIIzBnLr03Kle2qq+n/gLDAzvF89vdZCvUFEHRoi9n33O3i49UWyeHP+ZAeRf+psM867nfqON092zE4Pj7AbLtvIUFJFr1y9Le0CL2flc7LUqbgGzOw4/q3vA/cJO5JeI8S+8bc1Y7pqYSzoEWSFn5G7EoPHTGHPMU6SeLKEeli+i8dHY3lWxSrIOU2y0TNo1SeRYewhVx05OXeVDf0xhHNckqp0arRk+bgToeSaHbVZ5nj3IH3m2oayt3sXY78qSPcDpc/5C7VXDRj6bROvvBG5JCsKl/yeMPAUn1flMsmr/FaFdb7gVUXnhLa+/Ilj87PpCC6rILQ6wkIP1ywEg0PztSEzbsJoRwQzDaxkiTN27YDnsy/YKfe6jKcqZWs64skzUAHIt+nXxju0dUVtbCSDAUXYw78Yd4bJKuYU8gbzLzgL4XIUC2HcPIVCUYvM7cybOBFVBdeGR4cOVB7QbGnohTRpiPrGqi1a8QXFBYqENawROuR43OG8dl+Jx4TpwAoi2kkPXW7b/ARSs4DO/z4H6oTIUpN3+/K6Iuc49C4/Uf1NxQTEE91VP8RnLKTpxjywMe2VxM1l4YGXSFY80HUAKIdqczBnnLMPklFV8mrr5hFDypn5TAT00ruU6AjDPNvncoVzX4ac6wAzTwrNH7oz1XLH1wzjQs5k7hcNLbznXQGB7M+rXxKtZXPrz1Ar+OxYGDkJvElknZsHD/IcxRd7ujmmLYpDDbverynroCnSKVQWEGjHL57PaI/WokvhYRpPMk4ni2EUhjDuIF+IU2R0fs40i+66bw8sz8OzyC2eFAxxicd2n5Juta2eWa9KtObD7xLmPvtK+8cjQt+NLjcZCTt+Ss9p1od0bklVgaIV1qJbWxUOr6iUzLDzFefYxAtyRcBr53IaDB25n60KQdhroQWMUpuWSUpELSFxiu4vgQeRoEZe78/ua3TlrszB8sLVZoecnV9YMYz+HkZA/pLqbFhzurB52Wl/WEM6sVk4q04OnzWZFi76JkcGgeeUyYUIwhCDMdIfTUdD4wQpYm3LBw0sp33CVK2q305jeyzgGnBzSMXjesm4XjcEhhrjPSLtwqqoaFCqD5DlHYhoTVafWtBUQXoNfDk19IFxq8sImCcqgMhOToIZUO2530aasY908dMX2nTMFjgv+lapdI8k/e0a7pFw6X3Tgf0m99bbCpOzVgRu2Dw/13CehVfFj+8BeKP6SZV4g/qiX42NWP568PzMajFm2ANmKtHjEIAIc2hc1iecBR9elGP4LmAQwAVmZT8kWc7JSY0ag583ch/Z16krGrjn2YdIaa22egy4/niU6m0WAG3K/yP65cfL//CP+JzcnoLHQFb/KJQeBrEbR1/IKo+YOFXWIQ8ghNxYdMwa49NeXzFqFOIXTmk3w/v5KneS8sGHiPGACh0DE9a1uLAochB79g3IqYObhlswemMucZnAE7dBkp5OAfToa5gHFbIPcec0fVWEOOLftQXsuffyv3wo1LWDDm+SyNMWgSEWtjMyYkjLjTkUtmj7DQlfbpHf38lDvoEN9d2ALxnWCjph4jvfEIRbHvltKbvE2BiYlz45mnJPeFrwZcBny3k0/pyXNrSbEIWvvZw14Y0Fqy4tba1Fu0yNNYaf47jfnz7VCCxKsrJz5oz3F8jXUdQqFu+gDq6EzvKDipXf/3NmcsCC74VB3OgHPgN7W9cU54pjGFDMfifl3m5Vhy21uk1U2nYCrddrifkpwGLYmLSSQAAjC6M3yB1fc6KHpgDnMXh2bYX2ns+Qma+DBgyCkZ0TqZK8Mp2Sryx7HdMM74X9hrwYhQbwlK+zgATAXRzQyS+hK4OTnP17/cyJ2WzY6DChYWGJYXGCnEdMswF5VTYQdSyTpdLXYuh+x2Qr7DR3H2x+YdP0qsLAzYJIWKwrrKkpBgWCmgNCn5t+QbWqf/LoLuvjgDFLtMoxNK5axIA9kammelvwh5ZI52ktrEm/OVEESPQPZGHAIhP7oWDBnGnuzG45XOTpZWsxwNO4UiyxH8riTvQq4JVq5GwX3yqVCbSR0ef/gVYDgiYaiD2EAAxuEPKyXTp/HhL96eVTpaDqFEoV2x1PP/UMcs/XqeGc1gZQG1ot6YxaIEWHanYavH9YdLFjlyU5yrYALVg/sxBjT39oD+BIXvf4LTbvvvpX3srxckEX1XAM9s2uajUTlpPq32mcx4T+sibdQEHQV2WmgwMhbYovh7WWTPfLF03ZbV5a+ElsSIyH6kgJ8+D6aN/6f+ZstkZOYZYx9GbagcrEqwNblz0iZ9NTyvIAeNn3Oup7rtyD4wVE0PoqcnR/LoSK1s1esmOGPjs3zHB8xW4iL8IrhqAJfsWNBYW9TGR11C3KZJaN7MP4O5Ykmpvw94hHzVmsYA68RQdFYfPlFOgCNBoSdy5ODcv11l9bLs135M4okEc4/e8hQczcz2PWipIVSBxa/5sr9xyTFbjG4xm8f4LmrAhD1uEDGrFDl/6X7Nw7/WZPW7fZJGYN8eZ68Td5KGfJyKjD+pTysvTi+8Q8R0L9wKAxAUrYswdvAuiNeenxSplQZjYTxbcH/wP97fOY215SozY3UDRhv7lomztURB2O2UriTX3oAiTKoInkHQietZyhBQ9wMTVHgMrxOP5T/0gN14eFTz0m2D6/iJMbXYGHdIkKEGV2Voa8k/hVNvAVAZKrDEXthUxotwYkYysTDk8j27XEVy+4a30jopuAp5+/xWYb0ne6lwKZwR3j6kDXroOOtrHqWlkJHSWLoPEQJQo/ARzR8UBZSckmeBPn3gJwY62Zo2dyy1AyRRDQBFAJKH9KX+7auP8U8XDo7mMSzq5ZxmaJ5bLpNg4ZM7938SAjMHcu1yB4+lkHnVLnIp86AOPgigH+ZFDRq1QuKWK3pK5JkLDJdakj176NCbjXDASt1h/t1p+GHyKbAoevHSnHuPfoBmQ3nJrDjOhPfwVYi8V5r0KB8BsrfFu8BvhYCbNrvCVnd4Q8RktqIR/ZilioC6g3++L7PHzuXa8NFSF5zd+ISzGLTjrfaKXsBFCkkK0ksSDbl91yXUghMFOskQBeUoo7o3wuIsE29goRIORuJ4b1jSumvR0gR8B21iyW1G4FqHkZOlWz9zq5FnaJX1WbeAxe2DfGSAnw4cqDwg3LFalk6eH89Sdc41Fr6voEa0hfwdkb54yOM7WevDugT1FRzEqdg9zZZ44ZAKGH3ZyqFve3SE4UDN6tLmIFTdIwMrtYRXWBQDB7vvqOuYj7cN31av64+jg/g1uce+am3TOl0cUUL6s0l35FJ9p8vJcG+G8lAFqC0pdmd/aaWYpqDLvB5LEasLMgbPN2N+Wvkh6HYxPOrZEfoxQX/67AzcWOR0K3eYGOgQhyWL7cwKGlxmY/E2b8CKi6Ssgok+7B+zTtq/DXmaDAHRnwbwvCDJ9pITO5RQgBuprEWT0avZv7QjbzITYD8Fzgy4TSYG3z9tLso0Z7MfgHDLKU+kHrzxWkBPwJRydKMXG4AaCA7mlAmjzpNhGOrMGZGZlHSjPbmO5jPd/lKBrViZ0BaXMmqaFOwA/f03O04qQX6MSVA37+SA5Pne/KP7caLJKuOCJXoXpzArUrYesMVc/RXnOv03YrwKgPlR2SjpqIycyulmodZBy6gVc1jA9y6lJqWgR6SY6tc24sVcYuh2GaTeikYJnhr2d6BiL3oLx8M8wuJBdI3FRVIIAx4XougScOw2xWgwUoSYKeLUHc310kVBzSE/vFeHAjlUil8KZftctMgwGjwrhMbjDbK4rB32fTe9jnsqijdp5kOwkD9+klel+lNh3joAFQ\");\n        const f = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\n        function p(e) {\n          return \"{\".concat(function (e) {\n            return e.toString(16).toUpperCase().padStart(2, \"0\");\n          }(e), \"}\");\n        }\n        function m(e) {\n          let t = [];\n          for (let r = 0, n = e.length; r < n;) {\n            let n = e.codePointAt(r);\n            r += n < 65536 ? 1 : 2, t.push(n);\n          }\n          return t;\n        }\n        function g(e) {\n          let t = e.length;\n          if (t < 4096) return String.fromCodePoint(...e);\n          let r = [];\n          for (let n = 0; n < t;) r.push(String.fromCodePoint(...e.slice(n, n += 4096)));\n          return r.join(\"\");\n        }\n        function y(e, t) {\n          let r = e.length,\n            n = r - t.length;\n          for (let i = 0; 0 == n && i < r; i++) n = e[i] - t[i];\n          return n;\n        }\n        var v = r(\"AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g\");\n        function b(e) {\n          return e >> 24 & 255;\n        }\n        function E(e) {\n          return 16777215 & e;\n        }\n        const _ = new Map(s(v).flatMap((e, t) => e.map(e => [e, t + 1 << 24]))),\n          A = new Set(o(v)),\n          T = new Map(),\n          I = new Map();\n        for (let [e, t] of a(v)) {\n          if (!A.has(e) && 2 == t.length) {\n            let [r, n] = t,\n              i = I.get(r);\n            i || (i = new Map(), I.set(r, i)), i.set(n, e);\n          }\n          T.set(e, t.reverse());\n        }\n        const R = 44032,\n          w = 4352,\n          P = 4449,\n          x = 4519;\n        function S(e) {\n          return e >= R && e < 55204;\n        }\n        function O(e, t) {\n          if (e >= w && e < 4371 && t >= P && t < 4470) return R + 588 * (e - w) + 28 * (t - P);\n          if (S(e) && t > x && t < 4547 && (e - R) % 28 == 0) return e + (t - x);\n          {\n            let r = I.get(e);\n            return r && (r = r.get(t), r) ? r : -1;\n          }\n        }\n        function C(e) {\n          let t = [],\n            r = [],\n            n = !1;\n          function i(e) {\n            let r = _.get(e);\n            r && (n = !0, e |= r), t.push(e);\n          }\n          for (let n of e) for (;;) {\n            if (n < 128) t.push(n);else if (S(n)) {\n              let e = n - R,\n                t = e % 588 / 28 | 0,\n                r = e % 28;\n              i(w + (e / 588 | 0)), i(P + t), r > 0 && i(x + r);\n            } else {\n              let e = T.get(n);\n              e ? r.push(...e) : i(n);\n            }\n            if (!r.length) break;\n            n = r.pop();\n          }\n          if (n && t.length > 1) {\n            let e = b(t[0]);\n            for (let r = 1; r < t.length; r++) {\n              let n = b(t[r]);\n              if (0 == n || e <= n) {\n                e = n;\n                continue;\n              }\n              let i = r - 1;\n              for (;;) {\n                let r = t[i + 1];\n                if (t[i + 1] = t[i], t[i] = r, !i) break;\n                if (e = b(t[--i]), e <= n) break;\n              }\n              e = b(t[r]);\n            }\n          }\n          return t;\n        }\n        function B(e) {\n          return C(e).map(E);\n        }\n        function N(e) {\n          return function (e) {\n            let t = [],\n              r = [],\n              n = -1,\n              i = 0;\n            for (let o of e) {\n              let e = b(o),\n                s = E(o);\n              if (-1 == n) 0 == e ? n = s : t.push(s);else if (i > 0 && i >= e) 0 == e ? (t.push(n, ...r), r.length = 0, n = s) : r.push(s), i = e;else {\n                let o = O(n, s);\n                o >= 0 ? n = o : 0 == i && 0 == e ? (t.push(n), n = s) : (r.push(s), i = e);\n              }\n            }\n            return n >= 0 && t.push(n, ...r), t;\n          }(C(e));\n        }\n        const k = 65039,\n          M = \".\";\n        function D() {\n          return new Set(o(h));\n        }\n        const L = new Map(a(h)),\n          F = D(),\n          j = D(),\n          H = D(),\n          U = D(),\n          G = s(h);\n        function V() {\n          return new Set([o(h).map(e => G[e]), o(h)].flat(2));\n        }\n        const Z = h(),\n          W = c(e => {\n            let t = c(h).map(e => e + 96);\n            if (t.length) {\n              let r = e >= Z;\n              t[0] -= 32, t = g(t), r && (t = \"Restricted[\".concat(t, \"]\"));\n              let n = V(),\n                i = V(),\n                o = [...n, ...i].sort((e, t) => e - t);\n              return {\n                N: t,\n                P: n,\n                M: h() - 1,\n                R: r,\n                V: new Set(o)\n              };\n            }\n          }),\n          q = D(),\n          z = new Map();\n        [...q, ...D()].sort((e, t) => e - t).map((e, t, r) => {\n          let n = h(),\n            i = r[t] = n ? r[t - n] : {\n              V: [],\n              M: new Map()\n            };\n          i.V.push(e), q.has(e) || z.set(e, i);\n        });\n        for (let {\n          V: e,\n          M: t\n        } of new Set(z.values())) {\n          let r = [];\n          for (let t of e) {\n            let e = W.filter(e => e.V.has(t)),\n              n = r.find(_ref17 => {\n                let {\n                  G: t\n                } = _ref17;\n                return e.some(e => t.has(e));\n              });\n            n || (n = {\n              G: new Set(),\n              V: []\n            }, r.push(n)), n.V.push(t), e.forEach(e => n.G.add(e));\n          }\n          let n = r.flatMap(_ref18 => {\n            let {\n              G: e\n            } = _ref18;\n            return [...e];\n          });\n          for (let {\n            G: e,\n            V: i\n          } of r) {\n            let r = new Set(n.filter(t => !e.has(t)));\n            for (let e of i) t.set(e, r);\n          }\n        }\n        let K = new Set(),\n          Q = new Set();\n        for (let e of W) for (let t of e.V) (K.has(t) ? Q : K).add(t);\n        for (let e of K) z.has(e) || Q.has(e) || z.set(e, 1);\n        const J = new Set([...K, ...B(K)]),\n          X = o(h),\n          Y = function e(t) {\n            let r = c(() => {\n                let t = o(h).map(e => X[e]);\n                if (t.length) return e(t);\n              }).sort((e, t) => t.Q.size - e.Q.size),\n              n = h(),\n              i = n % 3;\n            n = n / 3 | 0;\n            let s = 1 & n;\n            return n >>= 1, {\n              B: r,\n              V: i,\n              F: s,\n              S: 1 & n,\n              C: 2 & n,\n              Q: new Set(t)\n            };\n          }([]);\n        class $ extends Array {\n          get is_emoji() {\n            return !0;\n          }\n        }\n        function ee(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : p;\n          let r = [];\n          ne(e[0]) && r.push(\"◌\");\n          let n = 0,\n            i = e.length;\n          for (let o = 0; o < i; o++) {\n            let i = e[o];\n            ie(i) && (r.push(g(e.slice(n, o))), r.push(t(i)), n = o + 1);\n          }\n          return r.push(g(e.slice(n, i))), r.join(\"\");\n        }\n        function te(e) {\n          return (ie(e) ? \"\" : \"\\\"\".concat(ee([e]), \"\\\" \")) + p(e);\n        }\n        function re(e) {\n          for (let t = e.lastIndexOf(95); t > 0;) if (95 !== e[--t]) throw new Error(\"underscore allowed only at start\");\n        }\n        function ne(e) {\n          return j.has(e);\n        }\n        function ie(e) {\n          return H.has(e);\n        }\n        function oe(e, t) {\n          let r = 0;\n          return e.split(M).map(e => {\n            let n,\n              i = m(e),\n              o = {\n                input: i,\n                offset: r\n              };\n            r += i.length + 1;\n            try {\n              let e,\n                r = o.tokens = de(i, N),\n                s = r.length;\n              if (!s) throw new Error(\"empty label\");\n              {\n                let i = r[0],\n                  a = s > 1 || i.is_emoji;\n                if (!a && i.every(e => e < 128)) n = i, re(n), function (e) {\n                  if (e.length >= 4 && 45 == e[2] && 45 == e[3]) throw new Error(\"invalid label extension\");\n                }(n), e = \"ASCII\";else if (a && (o.emoji = !0, i = r.flatMap(e => e.is_emoji ? [] : e)), n = r.flatMap(e => !t && e.is_emoji ? le(e) : e), re(n), i.length) {\n                  if (j.has(n[0])) throw ue(\"leading combining mark\");\n                  for (let e = 1; e < s; e++) {\n                    let t = r[e];\n                    if (!t.is_emoji && j.has(t[0])) throw ue(\"emoji + combining mark: \\\"\".concat(g(r[e - 1]), \" + \").concat(ee([t[0]]), \"\\\"\"));\n                  }\n                  !function (e) {\n                    let t = e[0],\n                      r = f.get(t);\n                    if (r) throw ue(\"leading \".concat(r));\n                    let n = e.length,\n                      i = -1;\n                    for (let o = 1; o < n; o++) {\n                      t = e[o];\n                      let n = f.get(t);\n                      if (n) {\n                        if (i == o) throw ue(\"\".concat(r, \" + \").concat(n));\n                        i = o + 1, r = n;\n                      }\n                    }\n                    if (i == n) throw ue(\"trailing \".concat(r));\n                  }(n);\n                  let t = [...new Set(i)],\n                    [o] = function (e) {\n                      let t = W;\n                      for (let r of e) {\n                        let e = t.filter(e => e.V.has(r));\n                        if (!e.length) throw t === W ? ae(r) : ce(t[0], r);\n                        if (t = e, 1 == e.length) break;\n                      }\n                      return t;\n                    }(t);\n                  !function (e, t) {\n                    let {\n                      V: r,\n                      M: n\n                    } = e;\n                    for (let n of t) if (!r.has(n)) throw ce(e, n);\n                    if (n >= 0) for (let r = 1, i = B(t).length; r < i; r++) if (j.has(t[r])) {\n                      let o = r + 1;\n                      for (; o < i && j.has(t[o]);) o++;\n                      if (o - r > n) throw new Error(\"too many combining marks: \".concat(e.N, \" \\\"\").concat(g(t.slice(r - 1, o)), \"\\\" (\").concat(o - r, \"/\").concat(n, \")\"));\n                      r = o;\n                    }\n                  }(o, i), function (e, t) {\n                    let r,\n                      n = [];\n                    for (let e of t) {\n                      let t = z.get(e);\n                      if (1 === t) return;\n                      if (t) {\n                        let n = t.M.get(e);\n                        if (r = r ? r.filter(e => n.has(e)) : [...n], !r.length) return;\n                      } else n.push(e);\n                    }\n                    if (r) for (let t of r) if (n.every(e => t.V.has(e))) throw new Error(\"whole-script confusable: \".concat(e.N, \"/\").concat(t.N));\n                  }(o, t), e = o.N;\n                } else e = \"Emoji\";\n              }\n              o.type = e;\n            } catch (e) {\n              o.error = e;\n            }\n            return o.output = n, o;\n          });\n        }\n        function se(e) {\n          return e.map(_ref19 => {\n            let {\n              input: t,\n              error: r,\n              output: n\n            } = _ref19;\n            if (r) {\n              let n = r.message;\n              throw new Error(1 == e.length ? n : \"Invalid label \\\"\".concat(ee(t), \"\\\": \").concat(n));\n            }\n            return g(n);\n          }).join(M);\n        }\n        function ae(e) {\n          return new Error(\"disallowed character: \".concat(te(e)));\n        }\n        function ce(e, t) {\n          let r = te(t),\n            n = W.find(e => e.P.has(t));\n          return n && (r = \"\".concat(n.N, \" \").concat(r)), new Error(\"illegal mixture: \".concat(e.N, \" + \").concat(r));\n        }\n        function ue(e) {\n          return new Error(\"illegal placement: \".concat(e));\n        }\n        function de(e, t) {\n          let r = [],\n            n = [];\n          for (e = e.slice().reverse(); e.length;) {\n            let i = he(e);\n            if (i) n.length && (r.push(t(n)), n = []), r.push(i);else {\n              let t = e.pop();\n              if (J.has(t)) n.push(t);else {\n                let e = L.get(t);\n                if (e) n.push(...e);else if (!F.has(t)) throw ae(t);\n              }\n            }\n          }\n          return n.length && r.push(t(n)), r;\n        }\n        function le(e) {\n          return e.filter(e => e != k);\n        }\n        function he(e, t) {\n          let r,\n            n,\n            i = Y,\n            o = [],\n            s = e.length;\n          for (t && (t.length = 0); s;) {\n            let a = e[--s];\n            if (i = i.B.find(e => e.Q.has(a)), !i) break;\n            if (i.S) n = a;else if (i.C && a === n) break;\n            o.push(a), i.F && (o.push(k), s > 0 && e[s - 1] == k && s--), i.V && (r = fe(o, i), t && t.push(...e.slice(s).reverse()), e.length = s);\n          }\n          return r;\n        }\n        function fe(e, t) {\n          let r = $.from(e);\n          return 2 == t.V && r.splice(1, 1), r;\n        }\n        const pe = \"valid\",\n          me = \"mapped\",\n          ge = \"ignored\";\n        function ye(e) {\n          return e == pe || e == me;\n        }\n        function ve(e) {\n          return e.some(e => U.has(e));\n        }\n        function be(e) {\n          for (let t = 0; t < e.length; t++) if (e[t].type == pe) {\n            let r = t + 1;\n            for (; r < e.length && e[r].type == pe;) r++;\n            e.splice(t, r - t, {\n              type: pe,\n              cps: e.slice(t, r).flatMap(e => e.cps)\n            });\n          }\n          return e;\n        }\n        t.ens_beautify = function (e) {\n          let t = oe(e, !0);\n          for (let {\n            type: e,\n            output: r,\n            error: n\n          } of t) if (!n && \"Greek\" !== e) {\n            let e = 0;\n            for (;;) {\n              let t = r.indexOf(958, e);\n              if (t < 0) break;\n              r[t] = 926, e = t + 1;\n            }\n          }\n          return se(t);\n        }, t.ens_emoji = function () {\n          let e = [];\n          return function t(r, n, i) {\n            if (r.S) i = n[n.length - 1];else if (r.C && i === n[n.length - 1]) return;\n            r.F && n.push(k), r.V && e.push(fe(n, r));\n            for (let e of r.B) for (let r of e.Q) t(e, [...n, r], i);\n          }(Y, []), e.sort(y);\n        }, t.ens_normalize = function (e) {\n          return se(oe(e));\n        }, t.ens_normalize_fragment = function (e, t) {\n          let r = t ? B : N;\n          return e.split(M).map(e => g(de(m(e), r).flatMap(e => e.is_emoji ? le(e) : e))).join(M);\n        }, t.ens_split = oe, t.ens_tokenize = function e(t) {\n          let {\n            nf: r = !0\n          } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          let n = m(t).reverse(),\n            i = [],\n            o = [];\n          for (; n.length;) {\n            let e = he(n, i);\n            if (e) o.push({\n              type: \"emoji\",\n              emoji: e,\n              input: i.slice(),\n              cps: le(e)\n            });else {\n              let e = n.pop();\n              if (46 == e) o.push({\n                type: \"stop\",\n                cp: e\n              });else if (J.has(e)) o.push({\n                type: pe,\n                cps: [e]\n              });else if (F.has(e)) o.push({\n                type: ge,\n                cp: e\n              });else {\n                let t = L.get(e);\n                t ? o.push({\n                  type: me,\n                  cp: e,\n                  cps: t.slice()\n                }) : o.push({\n                  type: \"disallowed\",\n                  cp: e\n                });\n              }\n            }\n          }\n          if (r) for (let t = 0, r = -1; t < o.length; t++) {\n            let n = o[t];\n            if (ye(n.type)) {\n              if (ve(n.cps)) {\n                let n = t + 1;\n                for (let e = n; e < o.length; e++) {\n                  let {\n                    type: t,\n                    cps: r\n                  } = o[e];\n                  if (ye(t)) {\n                    if (!ve(r)) break;\n                    n = e + 1;\n                  } else if (t !== ge) break;\n                }\n                r < 0 && (r = t);\n                let i = o.slice(r, n),\n                  s = i.flatMap(e => ye(e.type) ? e.cps : []),\n                  a = N(s);\n                y(a, s) ? (o.splice(r, n - r, {\n                  type: \"nfc\",\n                  input: s,\n                  cps: a,\n                  tokens0: be(i),\n                  tokens: e(g(a), {\n                    nf: !1\n                  })\n                }), t = r) : t = n - 1, r = -1;\n              } else r = t;\n            } else n.type !== ge && (r = -1);\n          }\n          return be(o);\n        }, t.is_combining_mark = ne, t.nfc = N, t.nfd = B, t.safe_str_from_cps = ee, t.should_escape = ie;\n      },\n      1732: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.outputSyncingFormatter = t.outputPostFormatter = t.inputPostFormatter = t.outputBlockFormatter = t.outputTransactionReceiptFormatter = t.outputLogFormatter = t.inputLogFormatter = t.inputTopicFormatter = t.outputTransactionFormatter = t.inputSignFormatter = t.inputTransactionFormatter = t.inputCallFormatter = t.txInputOptionsFormatter = t.inputAddressFormatter = t.inputDefaultBlockNumberFormatter = t.inputBlockNumberFormatter = t.outputBigIntegerFormatter = t.outputProofFormatter = t.inputStorageKeysFormatter = void 0;\n        const n = r(5071),\n          i = r(9910),\n          o = r(9970),\n          s = r(9634),\n          a = r(7345);\n        t.inputStorageKeysFormatter = e => e.map(e => (0, s.numberToHex)(e)), t.outputProofFormatter = e => ({\n          address: (0, s.toChecksumAddress)(e.address),\n          nonce: (0, s.hexToNumberString)(e.nonce),\n          balance: (0, s.hexToNumberString)(e.balance)\n        }), t.outputBigIntegerFormatter = e => (0, s.toNumber)(e), t.inputBlockNumberFormatter = e => {\n          if (!(0, a.isNullish)(e)) return \"string\" == typeof e && (0, a.isBlockTag)(e) ? e : \"genesis\" === e ? \"0x0\" : \"string\" == typeof e && (0, s.isHexStrict)(e) ? e.toLowerCase() : (0, s.numberToHex)(e);\n        }, t.inputDefaultBlockNumberFormatter = (e, r) => e ? (0, t.inputBlockNumberFormatter)(e) : (0, t.inputBlockNumberFormatter)(r), t.inputAddressFormatter = e => {\n          if (i.Iban.isValid(e) && i.Iban.isDirect(e)) return new i.Iban(e).toAddress().toLowerCase();\n          if ((0, s.isAddress)(e)) return \"0x\".concat(e.toLowerCase().replace(\"0x\", \"\"));\n          throw new n.FormatterError(\"Provided address \".concat(e, \" is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.\"));\n        }, t.txInputOptionsFormatter = e => {\n          var r;\n          const i = Object.assign({}, e);\n          if (e.to && (i.to = (0, t.inputAddressFormatter)(e.to)), e.data && e.input) throw new n.FormatterError('You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.');\n          if (!e.input && e.data && (i.input = e.data, delete i.data), e.input && !e.input.startsWith(\"0x\") && (i.input = \"0x\".concat(e.input)), i.input && !(0, s.isHexStrict)(i.input)) throw new n.FormatterError(\"The input field must be HEX encoded data.\");\n          return (e.gas || e.gasLimit) && (i.gas = (0, s.toNumber)(null !== (r = e.gas) && void 0 !== r ? r : e.gasLimit)), (e.maxPriorityFeePerGas || e.maxFeePerGas) && delete i.gasPrice, [\"gasPrice\", \"gas\", \"value\", \"maxPriorityFeePerGas\", \"maxFeePerGas\", \"nonce\", \"chainId\"].filter(e => !(0, a.isNullish)(i[e])).forEach(e => {\n            i[e] = (0, s.numberToHex)(i[e]);\n          }), i;\n        }, t.inputCallFormatter = (e, r) => {\n          var n;\n          const i = (0, t.txInputOptionsFormatter)(e),\n            o = null !== (n = i.from) && void 0 !== n ? n : r;\n          return o && (i.from = (0, t.inputAddressFormatter)(o)), i;\n        }, t.inputTransactionFormatter = (e, r) => {\n          var i;\n          const o = (0, t.txInputOptionsFormatter)(e);\n          if (\"number\" != typeof o.from && (!o.from || \"object\" != typeof o.from)) {\n            if (o.from = null !== (i = o.from) && void 0 !== i ? i : r, !e.from && \"number\" != typeof e.from) throw new n.FormatterError('The send transactions \"from\" field must be defined!');\n            o.from = (0, t.inputAddressFormatter)(e.from);\n          }\n          return o;\n        }, t.inputSignFormatter = e => (0, s.isHexStrict)(e) ? e : (0, s.utf8ToHex)(e), t.outputTransactionFormatter = e => {\n          const r = Object.assign({}, e);\n          return e.blockNumber && (r.blockNumber = (0, s.hexToNumber)(e.blockNumber)), e.transactionIndex && (r.transactionIndex = (0, s.hexToNumber)(e.transactionIndex)), r.nonce = (0, s.hexToNumber)(e.nonce), r.gas = (0, s.hexToNumber)(e.gas), e.gasPrice && (r.gasPrice = (0, t.outputBigIntegerFormatter)(e.gasPrice)), e.maxFeePerGas && (r.maxFeePerGas = (0, t.outputBigIntegerFormatter)(e.maxFeePerGas)), e.maxPriorityFeePerGas && (r.maxPriorityFeePerGas = (0, t.outputBigIntegerFormatter)(e.maxPriorityFeePerGas)), e.type && (r.type = (0, s.hexToNumber)(e.type)), r.value = (0, t.outputBigIntegerFormatter)(e.value), e.to && (0, s.isAddress)(e.to) ? r.to = (0, s.toChecksumAddress)(e.to) : r.to = void 0, e.from && (r.from = (0, s.toChecksumAddress)(e.from)), r;\n        }, t.inputTopicFormatter = e => {\n          if ((0, a.isNullish)(e)) return null;\n          const t = String(e);\n          return (0, a.isHex)(t) ? t : (0, s.fromUtf8)(t);\n        }, t.inputLogFormatter = e => {\n          var r;\n          const n = (0, a.isNullish)(e) ? {} : (0, s.mergeDeep)({}, e);\n          return (0, a.isNullish)(n.fromBlock) && (n.fromBlock = o.BlockTags.LATEST), n.fromBlock = (0, t.inputBlockNumberFormatter)(n.fromBlock), (0, a.isNullish)(n.toBlock) || (n.toBlock = (0, t.inputBlockNumberFormatter)(n.toBlock)), n.topics = null !== (r = n.topics) && void 0 !== r ? r : [], n.topics = n.topics.map(e => Array.isArray(e) ? e.map(t.inputTopicFormatter) : (0, t.inputTopicFormatter)(e)), n.address && (n.address = Array.isArray(n.address) ? n.address.map(e => (0, t.inputAddressFormatter)(e)) : (0, t.inputAddressFormatter)(n.address)), n;\n        }, t.outputLogFormatter = e => {\n          const t = Object.assign({}, e),\n            r = \"string\" == typeof e.logIndex ? e.logIndex : (0, s.numberToHex)(e.logIndex);\n          if (\"string\" == typeof e.blockHash && \"string\" == typeof e.transactionHash) {\n            const n = (0, s.sha3Raw)(\"\".concat(e.blockHash.replace(\"0x\", \"\")).concat(e.transactionHash.replace(\"0x\", \"\")).concat(r.replace(\"0x\", \"\")));\n            t.id = \"log_\".concat(n.replace(\"0x\", \"\").slice(0, 8));\n          } else e.id || (t.id = void 0);\n          return e.blockNumber && (0, s.isHexStrict)(e.blockNumber) && (t.blockNumber = (0, s.hexToNumber)(e.blockNumber)), e.transactionIndex && (0, s.isHexStrict)(e.transactionIndex) && (t.transactionIndex = (0, s.hexToNumber)(e.transactionIndex)), e.logIndex && (0, s.isHexStrict)(e.logIndex) && (t.logIndex = (0, s.hexToNumber)(e.logIndex)), e.address && (t.address = (0, s.toChecksumAddress)(e.address)), t;\n        }, t.outputTransactionReceiptFormatter = e => {\n          if (\"object\" != typeof e) throw new n.FormatterError(\"Received receipt is invalid: \".concat(String(e)));\n          const r = Object.assign({}, e);\n          return e.blockNumber && (r.blockNumber = (0, s.hexToNumber)(e.blockNumber)), e.transactionIndex && (r.transactionIndex = (0, s.hexToNumber)(e.transactionIndex)), r.cumulativeGasUsed = (0, s.hexToNumber)(e.cumulativeGasUsed), r.gasUsed = (0, s.hexToNumber)(e.gasUsed), e.logs && Array.isArray(e.logs) && (r.logs = e.logs.map(t.outputLogFormatter)), e.effectiveGasPrice && (r.effectiveGasPrice = (0, s.hexToNumber)(e.effectiveGasPrice)), e.contractAddress && (r.contractAddress = (0, s.toChecksumAddress)(e.contractAddress)), e.status && (r.status = Boolean(parseInt(e.status, 10))), r;\n        }, t.outputBlockFormatter = e => {\n          const r = Object.assign({}, e);\n          return r.gasLimit = (0, s.hexToNumber)(e.gasLimit), r.gasUsed = (0, s.hexToNumber)(e.gasUsed), r.size = (0, s.hexToNumber)(e.size), r.timestamp = (0, s.hexToNumber)(e.timestamp), e.number && (r.number = (0, s.hexToNumber)(e.number)), e.difficulty && (r.difficulty = (0, t.outputBigIntegerFormatter)(e.difficulty)), e.totalDifficulty && (r.totalDifficulty = (0, t.outputBigIntegerFormatter)(e.totalDifficulty)), e.transactions && Array.isArray(e.transactions) && (r.transactions = e.transactions.map(t.outputTransactionFormatter)), e.miner && (r.miner = (0, s.toChecksumAddress)(e.miner)), e.baseFeePerGas && (r.baseFeePerGas = (0, t.outputBigIntegerFormatter)(e.baseFeePerGas)), r;\n        }, t.inputPostFormatter = e => {\n          var t;\n          const r = Object.assign({}, e);\n          return e.ttl && (r.ttl = (0, s.numberToHex)(e.ttl)), e.workToProve && (r.workToProve = (0, s.numberToHex)(e.workToProve)), e.priority && (r.priority = (0, s.numberToHex)(e.priority)), e.topics && !Array.isArray(e.topics) && (r.topics = e.topics ? [e.topics] : []), r.topics = null === (t = r.topics) || void 0 === t ? void 0 : t.map(e => e.startsWith(\"0x\") ? e : (0, s.fromUtf8)(e)), r;\n        }, t.outputPostFormatter = e => {\n          var t;\n          const r = Object.assign({}, e);\n          return e.expiry && (r.expiry = (0, s.hexToNumber)(e.expiry)), e.sent && (r.sent = (0, s.hexToNumber)(e.sent)), e.ttl && (r.ttl = (0, s.hexToNumber)(e.ttl)), e.workProved && (r.workProved = (0, s.hexToNumber)(e.workProved)), e.topics || (r.topics = []), r.topics = null === (t = r.topics) || void 0 === t ? void 0 : t.map(s.toUtf8), r;\n        }, t.outputSyncingFormatter = e => {\n          const t = Object.assign({}, e);\n          return t.startingBlock = (0, s.hexToNumber)(e.startingBlock), t.currentBlock = (0, s.hexToNumber)(e.currentBlock), t.highestBlock = (0, s.hexToNumber)(e.highestBlock), e.knownStates && (t.knownStates = (0, s.hexToNumber)(e.knownStates)), e.pulledStates && (t.pulledStates = (0, s.hexToNumber)(e.pulledStates)), t;\n        };\n      },\n      6527: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          },\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.formatters = void 0, o(r(6171), t), o(r(8441), t), o(r(860), t), o(r(1819), t), o(r(8174), t), o(r(8202), t), o(r(7003), t), o(r(8165), t), o(r(1732), t), o(r(4738), t), o(r(8976), t), t.formatters = s(r(1732));\n      },\n      8165: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      7003: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isSupportSubscriptions = t.isSupportedProvider = t.isLegacySendAsyncProvider = t.isLegacySendProvider = t.isEIP1193Provider = t.isLegacyRequestProvider = t.isWeb3Provider = void 0;\n        const n = r(9970);\n        t.isWeb3Provider = e => n.Web3BaseProvider.isWeb3Provider(e), t.isLegacyRequestProvider = e => \"string\" != typeof e && \"request\" in e && \"Function\" === e.request.constructor.name, t.isEIP1193Provider = e => \"string\" != typeof e && \"request\" in e && \"AsyncFunction\" === e.request.constructor.name, t.isLegacySendProvider = e => \"string\" != typeof e && \"send\" in e, t.isLegacySendAsyncProvider = e => \"string\" != typeof e && \"sendAsync\" in e, t.isSupportedProvider = e => e && ((0, t.isWeb3Provider)(e) || (0, t.isEIP1193Provider)(e) || (0, t.isLegacyRequestProvider)(e) || (0, t.isLegacySendAsyncProvider)(e) || (0, t.isLegacySendProvider)(e)), t.isSupportSubscriptions = e => e && \"supportsSubscriptions\" in e ? e.supportsSubscriptions() : !(!e || \"string\" == typeof e || !(\"on\" in e));\n      },\n      8202: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3BatchRequest = t.DEFAULT_BATCH_REQUEST_TIMEOUT = void 0;\n        const i = r(9634),\n          o = r(5071);\n        t.DEFAULT_BATCH_REQUEST_TIMEOUT = 1e3, t.Web3BatchRequest = class {\n          constructor(e) {\n            this._requestManager = e, this._requests = new Map();\n          }\n          get requests() {\n            return [...this._requests.values()].map(e => e.payload);\n          }\n          add(e) {\n            const t = i.jsonRpc.toPayload(e),\n              r = new i.Web3DeferredPromise();\n            return this._requests.set(t.id, {\n              payload: t,\n              promise: r\n            }), r;\n          }\n          execute(e) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              if (0 === this.requests.length) return Promise.resolve([]);\n              const n = new i.Web3DeferredPromise({\n                timeout: null !== (r = null == e ? void 0 : e.timeout) && void 0 !== r ? r : t.DEFAULT_BATCH_REQUEST_TIMEOUT,\n                eagerStart: !0,\n                timeoutMessage: \"Batch request timeout\"\n              });\n              return this._processBatchRequest(n).catch(e => n.reject(e)), n.catch(e => {\n                e instanceof o.OperationTimeoutError && this._abortAllRequests(\"Batch request timeout\"), n.reject(e);\n              }), n;\n            });\n          }\n          _processBatchRequest(e) {\n            var t, r;\n            return n(this, void 0, void 0, function* () {\n              const n = yield this._requestManager.sendBatch([...this._requests.values()].map(e => e.payload));\n              if (n.length !== this._requests.size) throw this._abortAllRequests(\"Invalid batch response\"), new o.ResponseError(n, \"Batch request size mismatch the results size. Requests: \".concat(this._requests.size, \", Responses: \").concat(n.length));\n              const s = this.requests.map(e => e.id).map(Number).sort((e, t) => e - t),\n                a = n.map(e => e.id).map(Number).sort((e, t) => e - t);\n              if (JSON.stringify(s) !== JSON.stringify(a)) throw this._abortAllRequests(\"Invalid batch response\"), new o.ResponseError(n, \"Batch request mismatch the results. Requests: [\".concat(s.join(), \"], Responses: [\").concat(a.join(), \"]\"));\n              for (const e of n) i.jsonRpc.isResponseWithResult(e) ? null === (t = this._requests.get(e.id)) || void 0 === t || t.promise.resolve(e.result) : i.jsonRpc.isResponseWithError(e) && (null === (r = this._requests.get(e.id)) || void 0 === r || r.promise.reject(e.error));\n              e.resolve(n);\n            });\n          }\n          _abortAllRequests(e) {\n            for (const {\n              promise: t\n            } of this._requests.values()) t.reject(new o.OperationAbortError(e));\n          }\n        };\n      },\n      6171: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Config = t.Web3ConfigEvent = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(8976);\n        var s;\n        !function (e) {\n          e.CONFIG_CHANGE = \"CONFIG_CHANGE\";\n        }(s = t.Web3ConfigEvent || (t.Web3ConfigEvent = {}));\n        class a extends o.Web3EventEmitter {\n          constructor(e) {\n            super(), this.config = {\n              handleRevert: !1,\n              defaultAccount: void 0,\n              defaultBlock: \"latest\",\n              transactionBlockTimeout: 50,\n              transactionConfirmationBlocks: 24,\n              transactionPollingInterval: 1e3,\n              transactionPollingTimeout: 75e4,\n              transactionReceiptPollingInterval: void 0,\n              transactionSendTimeout: 75e4,\n              transactionConfirmationPollingInterval: void 0,\n              blockHeaderTimeout: 10,\n              maxListenersWarningThreshold: 100,\n              contractDataInputFill: \"input\",\n              defaultNetworkId: void 0,\n              defaultChain: \"mainnet\",\n              defaultHardfork: \"london\",\n              defaultCommon: void 0,\n              defaultTransactionType: \"0x2\",\n              defaultMaxPriorityFeePerGas: (0, i.toHex)(25e8),\n              enableExperimentalFeatures: {\n                useSubscriptionWhenCheckingBlockTimeout: !1,\n                useRpcCallSpecification: !1\n              },\n              transactionBuilder: void 0,\n              transactionTypeParser: void 0\n            }, this.setConfig(null != e ? e : {});\n          }\n          setConfig(e) {\n            Object.assign(this.config, e);\n          }\n          get handleRevert() {\n            return this.config.handleRevert;\n          }\n          set handleRevert(e) {\n            this._triggerConfigChange(\"handleRevert\", e), this.config.handleRevert = e;\n          }\n          get contractDataInputFill() {\n            return this.config.contractDataInputFill;\n          }\n          set contractDataInputFill(e) {\n            this._triggerConfigChange(\"contractDataInputFill\", e), this.config.contractDataInputFill = e;\n          }\n          get defaultAccount() {\n            return this.config.defaultAccount;\n          }\n          set defaultAccount(e) {\n            this._triggerConfigChange(\"defaultAccount\", e), this.config.defaultAccount = e;\n          }\n          get defaultBlock() {\n            return this.config.defaultBlock;\n          }\n          set defaultBlock(e) {\n            this._triggerConfigChange(\"defaultBlock\", e), this.config.defaultBlock = e;\n          }\n          get transactionSendTimeout() {\n            return this.config.transactionSendTimeout;\n          }\n          set transactionSendTimeout(e) {\n            this._triggerConfigChange(\"transactionSendTimeout\", e), this.config.transactionSendTimeout = e;\n          }\n          get transactionBlockTimeout() {\n            return this.config.transactionBlockTimeout;\n          }\n          set transactionBlockTimeout(e) {\n            this._triggerConfigChange(\"transactionBlockTimeout\", e), this.config.transactionBlockTimeout = e;\n          }\n          get transactionConfirmationBlocks() {\n            return this.config.transactionConfirmationBlocks;\n          }\n          set transactionConfirmationBlocks(e) {\n            this._triggerConfigChange(\"transactionConfirmationBlocks\", e), this.config.transactionConfirmationBlocks = e;\n          }\n          get transactionPollingInterval() {\n            return this.config.transactionPollingInterval;\n          }\n          set transactionPollingInterval(e) {\n            this._triggerConfigChange(\"transactionPollingInterval\", e), this.config.transactionPollingInterval = e, this.transactionReceiptPollingInterval = e, this.transactionConfirmationPollingInterval = e;\n          }\n          get transactionPollingTimeout() {\n            return this.config.transactionPollingTimeout;\n          }\n          set transactionPollingTimeout(e) {\n            this._triggerConfigChange(\"transactionPollingTimeout\", e), this.config.transactionPollingTimeout = e;\n          }\n          get transactionReceiptPollingInterval() {\n            return this.config.transactionReceiptPollingInterval;\n          }\n          set transactionReceiptPollingInterval(e) {\n            this._triggerConfigChange(\"transactionReceiptPollingInterval\", e), this.config.transactionReceiptPollingInterval = e;\n          }\n          get transactionConfirmationPollingInterval() {\n            return this.config.transactionConfirmationPollingInterval;\n          }\n          set transactionConfirmationPollingInterval(e) {\n            this._triggerConfigChange(\"transactionConfirmationPollingInterval\", e), this.config.transactionConfirmationPollingInterval = e;\n          }\n          get blockHeaderTimeout() {\n            return this.config.blockHeaderTimeout;\n          }\n          set blockHeaderTimeout(e) {\n            this._triggerConfigChange(\"blockHeaderTimeout\", e), this.config.blockHeaderTimeout = e;\n          }\n          get enableExperimentalFeatures() {\n            return this.config.enableExperimentalFeatures;\n          }\n          set enableExperimentalFeatures(e) {\n            this._triggerConfigChange(\"enableExperimentalFeatures\", e), this.config.enableExperimentalFeatures = e;\n          }\n          get maxListenersWarningThreshold() {\n            return this.config.maxListenersWarningThreshold;\n          }\n          set maxListenersWarningThreshold(e) {\n            this._triggerConfigChange(\"maxListenersWarningThreshold\", e), this.setMaxListenerWarningThreshold(e), this.config.maxListenersWarningThreshold = e;\n          }\n          get defaultNetworkId() {\n            return this.config.defaultNetworkId;\n          }\n          set defaultNetworkId(e) {\n            this._triggerConfigChange(\"defaultNetworkId\", e), this.config.defaultNetworkId = e;\n          }\n          get defaultChain() {\n            return this.config.defaultChain;\n          }\n          set defaultChain(e) {\n            if (!(0, i.isNullish)(this.config.defaultCommon) && !(0, i.isNullish)(this.config.defaultCommon.baseChain) && e !== this.config.defaultCommon.baseChain) throw new n.ConfigChainMismatchError(this.config.defaultChain, e);\n            this._triggerConfigChange(\"defaultChain\", e), this.config.defaultChain = e;\n          }\n          get defaultHardfork() {\n            return this.config.defaultHardfork;\n          }\n          set defaultHardfork(e) {\n            if (!(0, i.isNullish)(this.config.defaultCommon) && !(0, i.isNullish)(this.config.defaultCommon.hardfork) && e !== this.config.defaultCommon.hardfork) throw new n.ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, e);\n            this._triggerConfigChange(\"defaultHardfork\", e), this.config.defaultHardfork = e;\n          }\n          get defaultCommon() {\n            return this.config.defaultCommon;\n          }\n          set defaultCommon(e) {\n            if (!(0, i.isNullish)(this.config.defaultHardfork) && !(0, i.isNullish)(e) && !(0, i.isNullish)(e.hardfork) && this.config.defaultHardfork !== e.hardfork) throw new n.ConfigHardforkMismatchError(this.config.defaultHardfork, e.hardfork);\n            if (!(0, i.isNullish)(this.config.defaultChain) && !(0, i.isNullish)(e) && !(0, i.isNullish)(e.baseChain) && this.config.defaultChain !== e.baseChain) throw new n.ConfigChainMismatchError(this.config.defaultChain, e.baseChain);\n            this._triggerConfigChange(\"defaultCommon\", e), this.config.defaultCommon = e;\n          }\n          get defaultTransactionType() {\n            return this.config.defaultTransactionType;\n          }\n          set defaultTransactionType(e) {\n            this._triggerConfigChange(\"defaultTransactionType\", e), this.config.defaultTransactionType = e;\n          }\n          get defaultMaxPriorityFeePerGas() {\n            return this.config.defaultMaxPriorityFeePerGas;\n          }\n          set defaultMaxPriorityFeePerGas(e) {\n            this._triggerConfigChange(\"defaultMaxPriorityFeePerGas\", e), this.config.defaultMaxPriorityFeePerGas = e;\n          }\n          get transactionBuilder() {\n            return this.config.transactionBuilder;\n          }\n          set transactionBuilder(e) {\n            this._triggerConfigChange(\"transactionBuilder\", e), this.config.transactionBuilder = e;\n          }\n          get transactionTypeParser() {\n            return this.config.transactionTypeParser;\n          }\n          set transactionTypeParser(e) {\n            this._triggerConfigChange(\"transactionTypeParser\", e), this.config.transactionTypeParser = e;\n          }\n          _triggerConfigChange(e, t) {\n            this.emit(s.CONFIG_CHANGE, {\n              name: e,\n              oldValue: this.config[e],\n              newValue: t\n            });\n          }\n        }\n        t.Web3Config = a;\n      },\n      8174: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3EthPluginBase = t.Web3PluginBase = t.Web3Context = void 0;\n        const i = r(9634),\n          o = r(5071),\n          s = r(7003),\n          a = r(6171),\n          c = r(8441),\n          u = r(860),\n          d = r(8202);\n        class l extends a.Web3Config {\n          constructor(e) {\n            var t;\n            if (super(), this.providers = c.Web3RequestManager.providers, (0, i.isNullish)(e) || \"string\" == typeof e && \"\" !== e.trim() || (0, s.isSupportedProvider)(e)) return this._requestManager = new c.Web3RequestManager(e), void (this._subscriptionManager = new u.Web3SubscriptionManager(this._requestManager, {}));\n            const {\n              config: r,\n              provider: n,\n              requestManager: o,\n              subscriptionManager: a,\n              registeredSubscriptions: d,\n              accountProvider: l,\n              wallet: h\n            } = e;\n            this.setConfig(null != r ? r : {}), this._requestManager = null != o ? o : new c.Web3RequestManager(n, null === (t = null == r ? void 0 : r.enableExperimentalFeatures) || void 0 === t ? void 0 : t.useSubscriptionWhenCheckingBlockTimeout), this._subscriptionManager = a || new u.Web3SubscriptionManager(this.requestManager, null != d ? d : {}), l && (this._accountProvider = l), h && (this._wallet = h);\n          }\n          get requestManager() {\n            return this._requestManager;\n          }\n          get subscriptionManager() {\n            return this._subscriptionManager;\n          }\n          get wallet() {\n            return this._wallet;\n          }\n          get accountProvider() {\n            return this._accountProvider;\n          }\n          static fromContextObject() {\n            for (var _len12 = arguments.length, e = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n              e[_key12] = arguments[_key12];\n            }\n            return new this(...e.reverse());\n          }\n          getContextObject() {\n            var e;\n            return {\n              config: this.config,\n              provider: this.provider,\n              requestManager: this.requestManager,\n              subscriptionManager: this.subscriptionManager,\n              registeredSubscriptions: null === (e = this.subscriptionManager) || void 0 === e ? void 0 : e.registeredSubscriptions,\n              providers: this.providers,\n              wallet: this.wallet,\n              accountProvider: this.accountProvider\n            };\n          }\n          use(e) {\n            for (var _len13 = arguments.length, t = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n              t[_key13 - 1] = arguments[_key13];\n            }\n            const r = new e(...[...t, this.getContextObject()]);\n            return this.on(a.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              r.setConfig({\n                [e.name]: e.newValue\n              });\n            }), r;\n          }\n          link(e) {\n            this.setConfig(e.config), this._requestManager = e.requestManager, this.provider = e.provider, this._subscriptionManager = e.subscriptionManager, this._wallet = e.wallet, this._accountProvider = e._accountProvider, e.on(a.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              this.setConfig({\n                [e.name]: e.newValue\n              });\n            });\n          }\n          registerPlugin(e) {\n            if (void 0 !== this[e.pluginNamespace]) throw new o.ExistingPluginNamespaceError(e.pluginNamespace);\n            const t = {\n              [e.pluginNamespace]: e\n            };\n            t[e.pluginNamespace].link(this), Object.assign(this, t);\n          }\n          get provider() {\n            return this.currentProvider;\n          }\n          set provider(e) {\n            this.requestManager.setProvider(e);\n          }\n          get currentProvider() {\n            return this.requestManager.provider;\n          }\n          set currentProvider(e) {\n            this.requestManager.setProvider(e);\n          }\n          get givenProvider() {\n            return l.givenProvider;\n          }\n          setProvider(e) {\n            return this.provider = e, !0;\n          }\n          get BatchRequest() {\n            return d.Web3BatchRequest.bind(void 0, this._requestManager);\n          }\n          extend(e) {\n            var _this5 = this;\n            var t;\n            return e.property && !this[e.property] && (this[e.property] = {}), null === (t = e.methods) || void 0 === t || t.forEach(t => {\n              const r = function r() {\n                for (var _len14 = arguments.length, e = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n                  e[_key14] = arguments[_key14];\n                }\n                return n(_this5, void 0, void 0, function* () {\n                  return this.requestManager.send({\n                    method: t.call,\n                    params: e\n                  });\n                });\n              };\n              e.property ? this[e.property][t.name] = r : this[t.name] = r;\n            }), this;\n          }\n        }\n        t.Web3Context = l, l.providers = c.Web3RequestManager.providers;\n        class h extends l {}\n        t.Web3PluginBase = h, t.Web3EthPluginBase = class extends h {};\n      },\n      8976: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3EventEmitter = void 0;\n        const n = r(9634);\n        t.Web3EventEmitter = class {\n          constructor() {\n            this._emitter = new n.EventEmitter();\n          }\n          on(e, t) {\n            this._emitter.on(e, t);\n          }\n          once(e, t) {\n            this._emitter.once(e, t);\n          }\n          off(e, t) {\n            this._emitter.off(e, t);\n          }\n          emit(e, t) {\n            this._emitter.emit(e, t);\n          }\n          listenerCount(e) {\n            return this._emitter.listenerCount(e);\n          }\n          listeners(e) {\n            return this._emitter.listeners(e);\n          }\n          eventNames() {\n            return this._emitter.eventNames();\n          }\n          removeAllListeners() {\n            return this._emitter.removeAllListeners();\n          }\n          setMaxListenerWarningThreshold(e) {\n            this._emitter.setMaxListeners(e);\n          }\n          getMaxListeners() {\n            return this._emitter.getMaxListeners();\n          }\n        };\n      },\n      4738: function _(e, t, r) {\n        \"use strict\";\n\n        var n,\n          i = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3PromiEvent = void 0;\n        const o = r(8976);\n        class s extends o.Web3EventEmitter {\n          constructor(e) {\n            super(), this[n] = \"Promise\", this._promise = new Promise(e);\n          }\n          then(e, t) {\n            return i(this, void 0, void 0, function* () {\n              return this._promise.then(e, t);\n            });\n          }\n          catch(e) {\n            return i(this, void 0, void 0, function* () {\n              return this._promise.catch(e);\n            });\n          }\n          finally(e) {\n            return i(this, void 0, void 0, function* () {\n              return this._promise.finally(e);\n            });\n          }\n          on(e, t) {\n            return super.on(e, t), this;\n          }\n          once(e, t) {\n            return super.once(e, t), this;\n          }\n        }\n        t.Web3PromiEvent = s, n = Symbol.toStringTag;\n      },\n      8441: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          i = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3RequestManager = t.Web3RequestManagerEvent = void 0;\n        const o = r(5071),\n          s = i(r(2636)),\n          a = i(r(1161)),\n          c = r(9634),\n          u = r(7003),\n          d = r(8976);\n        var l;\n        !function (e) {\n          e.PROVIDER_CHANGED = \"PROVIDER_CHANGED\", e.BEFORE_PROVIDER_CHANGE = \"BEFORE_PROVIDER_CHANGE\";\n        }(l = t.Web3RequestManagerEvent || (t.Web3RequestManagerEvent = {}));\n        const h = {\n          HttpProvider: s.default,\n          WebsocketProvider: a.default\n        };\n        class f extends d.Web3EventEmitter {\n          constructor(e, t) {\n            super(), (0, c.isNullish)(e) || this.setProvider(e), this.useRpcCallSpecification = t;\n          }\n          static get providers() {\n            return h;\n          }\n          get provider() {\n            return this._provider;\n          }\n          get providers() {\n            return h;\n          }\n          setProvider(e) {\n            let t;\n            if (e && \"string\" == typeof e && this.providers) {\n              if (/^http(s)?:\\/\\//i.test(e)) t = new this.providers.HttpProvider(e);else {\n                if (!/^ws(s)?:\\/\\//i.test(e)) throw new o.ProviderError(\"Can't autodetect provider for \\\"\".concat(e, \"\\\"\"));\n                t = new this.providers.WebsocketProvider(e);\n              }\n            } else t = (0, c.isNullish)(e) ? void 0 : e;\n            return this.emit(l.BEFORE_PROVIDER_CHANGE, this._provider), this._provider = t, this.emit(l.PROVIDER_CHANGED, this._provider), !0;\n          }\n          send(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = yield this._sendRequest(e);\n              if (c.jsonRpc.isResponseWithResult(t)) return t.result;\n              throw new o.ResponseError(t);\n            });\n          }\n          sendBatch(e) {\n            return n(this, void 0, void 0, function* () {\n              return yield this._sendRequest(e);\n            });\n          }\n          _sendRequest(e) {\n            return n(this, void 0, void 0, function* () {\n              const {\n                provider: t\n              } = this;\n              if ((0, c.isNullish)(t)) throw new o.ProviderError(\"Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.\");\n              const r = c.jsonRpc.isBatchRequest(e) ? c.jsonRpc.toBatchPayload(e) : c.jsonRpc.toPayload(e);\n              if ((0, u.isWeb3Provider)(t)) {\n                let e;\n                try {\n                  e = yield t.request(r);\n                } catch (t) {\n                  e = t;\n                }\n                return this._processJsonRpcResponse(r, e, {\n                  legacy: !1,\n                  error: !1\n                });\n              }\n              if ((0, u.isEIP1193Provider)(t)) return t.request(r).then(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !1\n              })).catch(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !0\n              }));\n              if ((0, u.isLegacyRequestProvider)(t)) return new Promise((e, n) => {\n                const i = e => n(this._processJsonRpcResponse(r, e, {\n                    legacy: !0,\n                    error: !0\n                  })),\n                  o = t => e(this._processJsonRpcResponse(r, t, {\n                    legacy: !0,\n                    error: !1\n                  })),\n                  s = t.request(r, (e, t) => e ? i(e) : o(t));\n                (0, c.isPromise)(s) && s.then(o).catch(i);\n              });\n              if ((0, u.isLegacySendProvider)(t)) return new Promise((e, n) => {\n                t.send(r, (t, i) => {\n                  if (t) return n(this._processJsonRpcResponse(r, t, {\n                    legacy: !0,\n                    error: !0\n                  }));\n                  if ((0, c.isNullish)(i)) throw new o.ResponseError(\"\", 'Got a \"nullish\" response from provider.');\n                  return e(this._processJsonRpcResponse(r, i, {\n                    legacy: !0,\n                    error: !1\n                  }));\n                });\n              });\n              if ((0, u.isLegacySendAsyncProvider)(t)) return t.sendAsync(r).then(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !1\n              })).catch(e => this._processJsonRpcResponse(r, e, {\n                legacy: !0,\n                error: !0\n              }));\n              throw new o.ProviderError(\"Provider does not have a request or send method to use.\");\n            });\n          }\n          _processJsonRpcResponse(e, t, _ref20) {\n            let {\n              legacy: r,\n              error: n\n            } = _ref20;\n            if ((0, c.isNullish)(t)) return this._buildResponse(e, null, n);\n            if (c.jsonRpc.isResponseWithError(t)) {\n              if (this.useRpcCallSpecification && (0, c.isResponseRpcError)(t)) {\n                const e = t;\n                if (o.rpcErrorsMap.get(e.error.code)) throw new (0, o.rpcErrorsMap.get(e.error.code).error)(e);\n                throw new o.RpcError(e);\n              }\n              if (!f._isReverted(t)) throw new o.InvalidResponseError(t, e);\n            }\n            if (c.jsonRpc.isResponseWithResult(t)) return t;\n            if (t instanceof Error) throw f._isReverted(t), t;\n            if (!r && c.jsonRpc.isBatchRequest(e) && c.jsonRpc.isBatchResponse(t)) return t;\n            if (r && !n && c.jsonRpc.isBatchRequest(e)) return t;\n            if (r && n && c.jsonRpc.isBatchRequest(e)) throw t;\n            if (r && !c.jsonRpc.isResponseWithError(t) && !c.jsonRpc.isResponseWithResult(t)) return this._buildResponse(e, t, n);\n            if (c.jsonRpc.isBatchRequest(e) && !Array.isArray(t)) throw new o.ResponseError(t, \"Got normal response for a batch request.\");\n            if (!c.jsonRpc.isBatchRequest(e) && Array.isArray(t)) throw new o.ResponseError(t, \"Got batch response for a normal request.\");\n            if ((c.jsonRpc.isResponseWithError(t) || c.jsonRpc.isResponseWithResult(t)) && !c.jsonRpc.isBatchRequest(e) && t.id && e.id !== t.id) throw new o.InvalidResponseError(t);\n            throw new o.ResponseError(t, \"Invalid response\");\n          }\n          static _isReverted(e) {\n            let t;\n            if (c.jsonRpc.isResponseWithError(e) ? t = e.error : e instanceof Error && (t = e), null == t ? void 0 : t.message.includes(\"revert\")) throw new o.ContractExecutionError(t);\n            return !1;\n          }\n          _buildResponse(e, t, r) {\n            const n = {\n              jsonrpc: \"2.0\",\n              id: c.jsonRpc.isBatchRequest(e) ? e[0].id : \"id\" in e ? e.id : null\n            };\n            return r ? Object.assign(Object.assign({}, n), {\n              error: t\n            }) : Object.assign(Object.assign({}, n), {\n              result: t\n            });\n          }\n        }\n        t.Web3RequestManager = f;\n      },\n      860: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3SubscriptionManager = void 0;\n        const i = r(9970),\n          o = r(5071),\n          s = r(9634),\n          a = r(7003),\n          c = r(8441);\n        t.Web3SubscriptionManager = class {\n          constructor(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n            this.requestManager = e, this.registeredSubscriptions = t, this.tolerateUnlinkedSubscription = r, this._subscriptions = new Map(), this.requestManager.on(c.Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, () => n(this, void 0, void 0, function* () {\n              yield this.unsubscribe();\n            })), this.requestManager.on(c.Web3RequestManagerEvent.PROVIDER_CHANGED, () => {\n              this.clear(), this.listenToProviderEvents();\n            }), this.listenToProviderEvents();\n          }\n          listenToProviderEvents() {\n            const e = this.requestManager.provider;\n            this.requestManager.provider && (\"function\" != typeof (null == e ? void 0 : e.supportsSubscriptions) || (null == e ? void 0 : e.supportsSubscriptions())) && \"function\" == typeof this.requestManager.provider.on && (\"function\" == typeof this.requestManager.provider.request ? this.requestManager.provider.on(\"message\", e => this.messageListener(e)) : e.on(\"data\", e => this.messageListener(e)));\n          }\n          messageListener(e) {\n            var t, r, n;\n            if (!e) throw new o.SubscriptionError(\"Should not call messageListener with no data. Type was\");\n            const i = (null === (t = e.params) || void 0 === t ? void 0 : t.subscription) || (null === (r = e.data) || void 0 === r ? void 0 : r.subscription) || (null === (n = e.id) || void 0 === n ? void 0 : n.toString(16));\n            if (i) {\n              const t = this._subscriptions.get(i);\n              null == t || t.processSubscriptionData(e);\n            }\n          }\n          subscribe(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : i.DEFAULT_RETURN_FORMAT;\n            return n(this, void 0, void 0, function* () {\n              const n = this.registeredSubscriptions[e];\n              if (!n) throw new o.SubscriptionError(\"Invalid subscription type\");\n              const i = new n(null != t ? t : void 0, {\n                subscriptionManager: this,\n                returnFormat: r\n              });\n              return yield this.addSubscription(i), i;\n            });\n          }\n          get subscriptions() {\n            return this._subscriptions;\n          }\n          addSubscription(e) {\n            return n(this, void 0, void 0, function* () {\n              if (!this.requestManager.provider) throw new o.ProviderError(\"Provider not available\");\n              if (!this.supportsSubscriptions()) throw new o.SubscriptionError(\"The current provider does not support subscriptions\");\n              if (e.id && this._subscriptions.has(e.id)) throw new o.SubscriptionError(\"Subscription with id \\\"\".concat(e.id, \"\\\" already exists\"));\n              if (yield e.sendSubscriptionRequest(), (0, s.isNullish)(e.id)) throw new o.SubscriptionError(\"Subscription is not subscribed yet.\");\n              return this._subscriptions.set(e.id, e), e.id;\n            });\n          }\n          removeSubscription(e) {\n            return n(this, void 0, void 0, function* () {\n              const {\n                id: t\n              } = e;\n              if ((0, s.isNullish)(t)) throw new o.SubscriptionError(\"Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.\");\n              if (!this._subscriptions.has(t) && !this.tolerateUnlinkedSubscription) throw new o.SubscriptionError(\"Subscription with id \\\"\".concat(t.toString(), \"\\\" does not exists\"));\n              return yield e.sendUnsubscribeRequest(), this._subscriptions.delete(t), t;\n            });\n          }\n          unsubscribe(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = [];\n              for (const [r, n] of this.subscriptions.entries()) (!e || \"function\" == typeof e && e({\n                id: r,\n                sub: n\n              })) && t.push(this.removeSubscription(n));\n              return Promise.all(t);\n            });\n          }\n          clear() {\n            this._subscriptions.clear();\n          }\n          supportsSubscriptions() {\n            return !(0, s.isNullish)(this.requestManager.provider) && (0, a.isSupportSubscriptions)(this.requestManager.provider);\n          }\n        };\n      },\n      1819: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Subscription = void 0;\n        const i = r(9970),\n          o = r(9634),\n          s = r(5071),\n          a = r(860),\n          c = r(8976);\n        class u extends c.Web3EventEmitter {\n          constructor(e, t) {\n            var r;\n            super(), this.args = e;\n            const {\n                requestManager: n\n              } = t,\n              {\n                subscriptionManager: o\n              } = t;\n            if (n && o) throw new s.SubscriptionError(\"Only requestManager or subscriptionManager should be provided at Subscription constructor\");\n            if (!n && !o) throw new s.SubscriptionError(\"Either requestManager or subscriptionManager should be provided at Subscription constructor\");\n            this._subscriptionManager = n ? new a.Web3SubscriptionManager(n, {}, !0) : o, this._returnFormat = null !== (r = null == t ? void 0 : t.returnFormat) && void 0 !== r ? r : i.DEFAULT_RETURN_FORMAT;\n          }\n          get id() {\n            return this._id;\n          }\n          get lastBlock() {\n            return this._lastBlock;\n          }\n          subscribe() {\n            return n(this, void 0, void 0, function* () {\n              return this._subscriptionManager.addSubscription(this);\n            });\n          }\n          processSubscriptionData(e) {\n            var t, r;\n            (null == e ? void 0 : e.data) ? this._processSubscriptionResult(null !== (r = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.result) && void 0 !== r ? r : null == e ? void 0 : e.data) : e && o.jsonRpc.isResponseWithNotification(e) && this._processSubscriptionResult(null == e ? void 0 : e.params.result);\n          }\n          sendSubscriptionRequest() {\n            return n(this, void 0, void 0, function* () {\n              return this._id = yield this._subscriptionManager.requestManager.send({\n                method: \"eth_subscribe\",\n                params: this._buildSubscriptionParams()\n              }), this.emit(\"connected\", this._id), this._id;\n            });\n          }\n          get returnFormat() {\n            return this._returnFormat;\n          }\n          get subscriptionManager() {\n            return this._subscriptionManager;\n          }\n          resubscribe() {\n            return n(this, void 0, void 0, function* () {\n              yield this.unsubscribe(), yield this.subscribe();\n            });\n          }\n          unsubscribe() {\n            return n(this, void 0, void 0, function* () {\n              this.id && (yield this._subscriptionManager.removeSubscription(this));\n            });\n          }\n          sendUnsubscribeRequest() {\n            return n(this, void 0, void 0, function* () {\n              yield this._subscriptionManager.requestManager.send({\n                method: \"eth_unsubscribe\",\n                params: [this.id]\n              }), this._id = void 0;\n            });\n          }\n          formatSubscriptionResult(e) {\n            return e;\n          }\n          _processSubscriptionResult(e) {\n            this.emit(\"data\", this.formatSubscriptionResult(e));\n          }\n          _processSubscriptionError(e) {\n            this.emit(\"error\", e);\n          }\n          _buildSubscriptionParams() {\n            throw new Error(\"Implement in the child class\");\n          }\n        }\n        t.Web3Subscription = u;\n      },\n      7639: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = t.ERR_TX_POLLING_TIMEOUT = t.ERR_TX_DATA_AND_INPUT = t.ERR_TX_UNSUPPORTED_TYPE = t.ERR_TX_UNSUPPORTED_EIP_1559 = t.ERR_TX_UNABLE_TO_POPULATE_NONCE = t.ERR_TX_INVALID_NONCE_OR_CHAIN_ID = t.ERR_TX_INVALID_OBJECT = t.ERR_TX_INVALID_LEGACY_FEE_MARKET = t.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = t.ERR_TX_INVALID_FEE_MARKET_GAS = t.ERR_TX_INVALID_LEGACY_GAS = t.ERR_TX_MISSING_GAS = t.ERR_TX_MISSING_CHAIN_INFO = t.ERR_TX_INVALID_CHAIN_INFO = t.ERR_TX_CHAIN_ID_MISMATCH = t.ERR_TX_MISSING_CUSTOM_CHAIN_ID = t.ERR_TX_MISSING_CUSTOM_CHAIN = t.ERR_TX_INVALID_CALL = t.ERR_TX_INVALID_SENDER = t.ERR_RAW_TX_UNDEFINED = t.ERR_TX_OUT_OF_GAS = t.ERR_TX_REVERT_WITHOUT_REASON = t.ERR_TX_CONTRACT_NOT_STORED = t.ERR_TX_NO_CONTRACT_ADDRESS = t.ERR_TX_REVERT_TRANSACTION = t.ERR_TX_REVERT_INSTRUCTION = t.ERR_TX = t.ERR_CONTRACT_TX_DATA_AND_INPUT = t.ERR_CONTRACT_EXECUTION_REVERTED = t.ERR_CONTRACT_INSTANTIATION = t.ERR_CONTRACT_MISSING_FROM_ADDRESS = t.ERR_CONTRACT_MISSING_ADDRESS = t.ERR_CONTRACT_MISSING_DEPLOY_DATA = t.ERR_CONTRACT_RESERVED_EVENT = t.ERR_CONTRACT_EVENT_NOT_EXISTS = t.ERR_CONTRACT_REQUIRED_CALLBACK = t.ERR_CONTRACT_ABI_MISSING = t.ERR_CONTRACT_RESOLVER_MISSING = t.ERR_CONTRACT = t.ERR_INVALID_METHOD_PARAMS = t.ERR_EXISTING_PLUGIN_NAMESPACE = t.ERR_ABI_ENCODING = t.ERR_OPERATION_ABORT = t.ERR_OPERATION_TIMEOUT = t.ERR_METHOD_NOT_IMPLEMENTED = t.ERR_FORMATTERS = t.ERR_PARAM = t.ERR_INVALID_RESPONSE = t.ERR_RESPONSE = void 0, t.ERR_INVALID_NUMBER = t.ERR_INVALID_BYTES = t.ERR_INVALID_STRING = t.ERR_ENS_NETWORK_NOT_SYNCED = t.ERR_ENS_UNSUPPORTED_NETWORK = t.ERR_ENS_CHECK_INTERFACE_SUPPORT = t.JSONRPC_ERR_CHAIN_DISCONNECTED = t.JSONRPC_ERR_DISCONNECTED = t.JSONRPC_ERR_UNSUPPORTED_METHOD = t.JSONRPC_ERR_UNAUTHORIZED = t.JSONRPC_ERR_REJECTED_REQUEST = t.GENESIS_BLOCK_NUMBER = t.ERR_INVALID_SIGNATURE = t.ERR_SIGNATURE_FAILED = t.ERR_PBKDF2_ITERATIONS = t.ERR_INVALID_KEYSTORE = t.ERR_IV_LENGTH = t.ERR_INVALID_PASSWORD = t.ERR_KEY_VERSION_UNSUPPORTED = t.ERR_KEY_DERIVATION_FAIL = t.ERR_UNSUPPORTED_KDF = t.ERR_INVALID_PRIVATE_KEY = t.ERR_PRIVATE_KEY_LENGTH = t.ERR_WS_PROVIDER = t.ERR_SUBSCRIPTION = t.ERR_INVALID_CLIENT = t.ERR_INVALID_PROVIDER = t.ERR_PROVIDER = t.ERR_REQ_ALREADY_SENT = t.ERR_CONN_PENDING_REQUESTS = t.ERR_CONN_MAX_ATTEMPTS = t.ERR_CONN_CLOSE = t.ERR_CONN_NOT_OPEN = t.ERR_CONN_TIMEOUT = t.ERR_CONN_INVALID = t.ERR_CONN = t.ERR_TX_GAS_MISMATCH_INNER_ERROR = t.ERR_TX_MISSING_GAS_INNER_ERROR = t.ERR_TX_INVALID_PROPERTIES_FOR_TYPE = t.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = t.ERR_TX_INVALID_RECEIVER = t.ERR_TX_HARDFORK_MISMATCH = t.ERR_TX_CHAIN_MISMATCH = t.ERR_TX_GAS_MISMATCH = t.ERR_TX_SIGNING = t.ERR_TX_BLOCK_TIMEOUT = t.ERR_TX_SEND_TIMEOUT = t.ERR_TX_NOT_FOUND = t.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = t.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = void 0, t.ERR_RPC_NOT_SUPPORTED = t.ERR_RPC_LIMIT_EXCEEDED = t.ERR_RPC_UNSUPPORTED_METHOD = t.ERR_RPC_TRANSACTION_REJECTED = t.ERR_RPC_UNAVAILABLE_RESOURCE = t.ERR_RPC_MISSING_RESOURCE = t.ERR_RPC_INVALID_INPUT = t.ERR_RPC_INTERNAL_ERROR = t.ERR_RPC_INVALID_PARAMS = t.ERR_RPC_INVALID_METHOD = t.ERR_RPC_INVALID_REQUEST = t.ERR_RPC_INVALID_JSON = t.ERR_SCHEMA_FORMAT = t.ERR_CORE_CHAIN_MISMATCH = t.ERR_CORE_HARDFORK_MISMATCH = t.ERR_VALIDATION = t.ERR_INVALID_NIBBLE_WIDTH = t.ERR_INVALID_TYPE_ABI = t.ERR_INVALID_BLOCK = t.ERR_INVALID_LARGE_VALUE = t.ERR_INVALID_SIZE = t.ERR_INVALID_UNSIGNED_INTEGER = t.ERR_INVALID_BOOLEAN = t.ERR_INVALID_TYPE = t.ERR_INVALID_HEX = t.ERR_INVALID_ADDRESS = t.ERR_INVALID_UNIT = void 0, t.ERR_RESPONSE = 100, t.ERR_INVALID_RESPONSE = 101, t.ERR_PARAM = 200, t.ERR_FORMATTERS = 201, t.ERR_METHOD_NOT_IMPLEMENTED = 202, t.ERR_OPERATION_TIMEOUT = 203, t.ERR_OPERATION_ABORT = 204, t.ERR_ABI_ENCODING = 205, t.ERR_EXISTING_PLUGIN_NAMESPACE = 206, t.ERR_INVALID_METHOD_PARAMS = 207, t.ERR_CONTRACT = 300, t.ERR_CONTRACT_RESOLVER_MISSING = 301, t.ERR_CONTRACT_ABI_MISSING = 302, t.ERR_CONTRACT_REQUIRED_CALLBACK = 303, t.ERR_CONTRACT_EVENT_NOT_EXISTS = 304, t.ERR_CONTRACT_RESERVED_EVENT = 305, t.ERR_CONTRACT_MISSING_DEPLOY_DATA = 306, t.ERR_CONTRACT_MISSING_ADDRESS = 307, t.ERR_CONTRACT_MISSING_FROM_ADDRESS = 308, t.ERR_CONTRACT_INSTANTIATION = 309, t.ERR_CONTRACT_EXECUTION_REVERTED = 310, t.ERR_CONTRACT_TX_DATA_AND_INPUT = 311, t.ERR_TX = 400, t.ERR_TX_REVERT_INSTRUCTION = 401, t.ERR_TX_REVERT_TRANSACTION = 402, t.ERR_TX_NO_CONTRACT_ADDRESS = 403, t.ERR_TX_CONTRACT_NOT_STORED = 404, t.ERR_TX_REVERT_WITHOUT_REASON = 405, t.ERR_TX_OUT_OF_GAS = 406, t.ERR_RAW_TX_UNDEFINED = 407, t.ERR_TX_INVALID_SENDER = 408, t.ERR_TX_INVALID_CALL = 409, t.ERR_TX_MISSING_CUSTOM_CHAIN = 410, t.ERR_TX_MISSING_CUSTOM_CHAIN_ID = 411, t.ERR_TX_CHAIN_ID_MISMATCH = 412, t.ERR_TX_INVALID_CHAIN_INFO = 413, t.ERR_TX_MISSING_CHAIN_INFO = 414, t.ERR_TX_MISSING_GAS = 415, t.ERR_TX_INVALID_LEGACY_GAS = 416, t.ERR_TX_INVALID_FEE_MARKET_GAS = 417, t.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = 418, t.ERR_TX_INVALID_LEGACY_FEE_MARKET = 419, t.ERR_TX_INVALID_OBJECT = 420, t.ERR_TX_INVALID_NONCE_OR_CHAIN_ID = 421, t.ERR_TX_UNABLE_TO_POPULATE_NONCE = 422, t.ERR_TX_UNSUPPORTED_EIP_1559 = 423, t.ERR_TX_UNSUPPORTED_TYPE = 424, t.ERR_TX_DATA_AND_INPUT = 425, t.ERR_TX_POLLING_TIMEOUT = 426, t.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = 427, t.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = 428, t.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = 429, t.ERR_TX_NOT_FOUND = 430, t.ERR_TX_SEND_TIMEOUT = 431, t.ERR_TX_BLOCK_TIMEOUT = 432, t.ERR_TX_SIGNING = 433, t.ERR_TX_GAS_MISMATCH = 434, t.ERR_TX_CHAIN_MISMATCH = 435, t.ERR_TX_HARDFORK_MISMATCH = 436, t.ERR_TX_INVALID_RECEIVER = 437, t.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = 438, t.ERR_TX_INVALID_PROPERTIES_FOR_TYPE = 439, t.ERR_TX_MISSING_GAS_INNER_ERROR = 440, t.ERR_TX_GAS_MISMATCH_INNER_ERROR = 441, t.ERR_CONN = 500, t.ERR_CONN_INVALID = 501, t.ERR_CONN_TIMEOUT = 502, t.ERR_CONN_NOT_OPEN = 503, t.ERR_CONN_CLOSE = 504, t.ERR_CONN_MAX_ATTEMPTS = 505, t.ERR_CONN_PENDING_REQUESTS = 506, t.ERR_REQ_ALREADY_SENT = 507, t.ERR_PROVIDER = 600, t.ERR_INVALID_PROVIDER = 601, t.ERR_INVALID_CLIENT = 602, t.ERR_SUBSCRIPTION = 603, t.ERR_WS_PROVIDER = 604, t.ERR_PRIVATE_KEY_LENGTH = 701, t.ERR_INVALID_PRIVATE_KEY = 702, t.ERR_UNSUPPORTED_KDF = 703, t.ERR_KEY_DERIVATION_FAIL = 704, t.ERR_KEY_VERSION_UNSUPPORTED = 705, t.ERR_INVALID_PASSWORD = 706, t.ERR_IV_LENGTH = 707, t.ERR_INVALID_KEYSTORE = 708, t.ERR_PBKDF2_ITERATIONS = 709, t.ERR_SIGNATURE_FAILED = 801, t.ERR_INVALID_SIGNATURE = 802, t.GENESIS_BLOCK_NUMBER = \"0x0\", t.JSONRPC_ERR_REJECTED_REQUEST = 4001, t.JSONRPC_ERR_UNAUTHORIZED = 4100, t.JSONRPC_ERR_UNSUPPORTED_METHOD = 4200, t.JSONRPC_ERR_DISCONNECTED = 4900, t.JSONRPC_ERR_CHAIN_DISCONNECTED = 4901, t.ERR_ENS_CHECK_INTERFACE_SUPPORT = 901, t.ERR_ENS_UNSUPPORTED_NETWORK = 902, t.ERR_ENS_NETWORK_NOT_SYNCED = 903, t.ERR_INVALID_STRING = 1001, t.ERR_INVALID_BYTES = 1002, t.ERR_INVALID_NUMBER = 1003, t.ERR_INVALID_UNIT = 1004, t.ERR_INVALID_ADDRESS = 1005, t.ERR_INVALID_HEX = 1006, t.ERR_INVALID_TYPE = 1007, t.ERR_INVALID_BOOLEAN = 1008, t.ERR_INVALID_UNSIGNED_INTEGER = 1009, t.ERR_INVALID_SIZE = 1010, t.ERR_INVALID_LARGE_VALUE = 1011, t.ERR_INVALID_BLOCK = 1012, t.ERR_INVALID_TYPE_ABI = 1013, t.ERR_INVALID_NIBBLE_WIDTH = 1014, t.ERR_VALIDATION = 1100, t.ERR_CORE_HARDFORK_MISMATCH = 1101, t.ERR_CORE_CHAIN_MISMATCH = 1102, t.ERR_SCHEMA_FORMAT = 1200, t.ERR_RPC_INVALID_JSON = -32700, t.ERR_RPC_INVALID_REQUEST = -32600, t.ERR_RPC_INVALID_METHOD = -32601, t.ERR_RPC_INVALID_PARAMS = -32602, t.ERR_RPC_INTERNAL_ERROR = -32603, t.ERR_RPC_INVALID_INPUT = -32e3, t.ERR_RPC_MISSING_RESOURCE = -32001, t.ERR_RPC_UNAVAILABLE_RESOURCE = -32002, t.ERR_RPC_TRANSACTION_REJECTED = -32003, t.ERR_RPC_UNSUPPORTED_METHOD = -32004, t.ERR_RPC_LIMIT_EXCEEDED = -32005, t.ERR_RPC_NOT_SUPPORTED = -32006;\n      },\n      8105: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.PBKDF2IterationsError = t.IVLengthError = t.InvalidPasswordError = t.KeyStoreVersionError = t.KeyDerivationError = t.InvalidKdfError = t.InvalidSignatureError = t.InvalidPrivateKeyError = t.PrivateKeyLengthError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Private key must be 32 bytes.\"), this.code = n.ERR_PRIVATE_KEY_LENGTH;\n          }\n        }\n        t.PrivateKeyLengthError = o;\n        class s extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Invalid Private Key, Not a valid string or uint8Array\"), this.code = n.ERR_INVALID_PRIVATE_KEY;\n          }\n        }\n        t.InvalidPrivateKeyError = s;\n        class a extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"\\\"\".concat(e, \"\\\"\")), this.code = n.ERR_INVALID_SIGNATURE;\n          }\n        }\n        t.InvalidSignatureError = a;\n        class c extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Invalid key derivation function\"), this.code = n.ERR_UNSUPPORTED_KDF;\n          }\n        }\n        t.InvalidKdfError = c;\n        class u extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Key derivation failed - possibly wrong password\"), this.code = n.ERR_KEY_DERIVATION_FAIL;\n          }\n        }\n        t.KeyDerivationError = u;\n        class d extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Unsupported key store version\"), this.code = n.ERR_KEY_VERSION_UNSUPPORTED;\n          }\n        }\n        t.KeyStoreVersionError = d;\n        class l extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Password cannot be empty\"), this.code = n.ERR_INVALID_PASSWORD;\n          }\n        }\n        t.InvalidPasswordError = l;\n        class h extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Initialization vector must be 16 bytes\"), this.code = n.ERR_IV_LENGTH;\n          }\n        }\n        t.IVLengthError = h;\n        class f extends i.BaseWeb3Error {\n          constructor() {\n            super(\"c > 1000, pbkdf2 is less secure with less iterations\"), this.code = n.ERR_PBKDF2_ITERATIONS;\n          }\n        }\n        t.PBKDF2IterationsError = f;\n      },\n      3789: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RequestAlreadySentError = t.PendingRequestsOnReconnectingError = t.MaxAttemptsReachedOnReconnectingError = t.ConnectionCloseError = t.ConnectionNotOpenError = t.ConnectionTimeoutError = t.InvalidConnectionError = t.ConnectionError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.code = n.ERR_CONN, t && (this.errorCode = t.code, this.errorReason = t.reason);\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              errorCode: this.errorCode,\n              errorReason: this.errorReason\n            });\n          }\n        }\n        t.ConnectionError = o, t.InvalidConnectionError = class extends o {\n          constructor(e, t) {\n            super(\"CONNECTION ERROR: Couldn't connect to node \".concat(e, \".\"), t), this.host = e, this.code = n.ERR_CONN_INVALID;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              host: this.host\n            });\n          }\n        }, t.ConnectionTimeoutError = class extends o {\n          constructor(e) {\n            super(\"CONNECTION TIMEOUT: timeout of \".concat(e, \"ms achieved\")), this.duration = e, this.code = n.ERR_CONN_TIMEOUT;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              duration: this.duration\n            });\n          }\n        }, t.ConnectionNotOpenError = class extends o {\n          constructor(e) {\n            super(\"Connection not open\", e), this.code = n.ERR_CONN_NOT_OPEN;\n          }\n        }, t.ConnectionCloseError = class extends o {\n          constructor(e) {\n            var t, r;\n            super(\"CONNECTION ERROR: The connection got closed with the close code \".concat(null !== (t = null == e ? void 0 : e.code) && void 0 !== t ? t : \"\", \" and the following reason string \").concat(null !== (r = null == e ? void 0 : e.reason) && void 0 !== r ? r : \"\"), e), this.code = n.ERR_CONN_CLOSE;\n          }\n        }, t.MaxAttemptsReachedOnReconnectingError = class extends o {\n          constructor(e) {\n            super(\"Maximum number of reconnect attempts reached! (\".concat(e, \")\")), this.code = n.ERR_CONN_MAX_ATTEMPTS;\n          }\n        }, t.PendingRequestsOnReconnectingError = class extends o {\n          constructor() {\n            super(\"CONNECTION ERROR: Provider started to reconnect before the response got received!\"), this.code = n.ERR_CONN_PENDING_REQUESTS;\n          }\n        }, t.RequestAlreadySentError = class extends o {\n          constructor(e) {\n            super(\"Request already sent with following id: \".concat(e)), this.code = n.ERR_REQ_ALREADY_SENT;\n          }\n        };\n      },\n      510: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ContractTransactionDataAndInputError = t.ContractExecutionError = t.Eip838ExecutionError = t.ContractInstantiationError = t.ContractNoFromAddressDefinedError = t.ContractNoAddressDefinedError = t.ContractMissingDeployDataError = t.ContractReservedEventError = t.ContractEventDoesNotExistError = t.ContractOnceRequiresCallbackError = t.ContractMissingABIError = t.ResolverMethodMissingError = t.Web3ContractError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.code = n.ERR_CONTRACT, this.receipt = t;\n          }\n        }\n        t.Web3ContractError = o;\n        class s extends i.BaseWeb3Error {\n          constructor(e, t) {\n            super(\"The resolver at \".concat(e, \" does not implement requested method: \\\"\").concat(t, \"\\\".\")), this.address = e, this.name = t, this.code = n.ERR_CONTRACT_RESOLVER_MISSING;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              address: this.address,\n              name: this.name\n            });\n          }\n        }\n        t.ResolverMethodMissingError = s;\n        class a extends i.BaseWeb3Error {\n          constructor() {\n            super(\"You must provide the json interface of the contract when instantiating a contract object.\"), this.code = n.ERR_CONTRACT_ABI_MISSING;\n          }\n        }\n        t.ContractMissingABIError = a;\n        class c extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Once requires a callback as the second parameter.\"), this.code = n.ERR_CONTRACT_REQUIRED_CALLBACK;\n          }\n        }\n        t.ContractOnceRequiresCallbackError = c;\n        class u extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Event \\\"\".concat(e, \"\\\" doesn't exist in this contract.\")), this.eventName = e, this.code = n.ERR_CONTRACT_EVENT_NOT_EXISTS;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              eventName: this.eventName\n            });\n          }\n        }\n        t.ContractEventDoesNotExistError = u;\n        class d extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Event \\\"\".concat(e, \"\\\" doesn't exist in this contract.\")), this.type = e, this.code = n.ERR_CONTRACT_RESERVED_EVENT;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              type: this.type\n            });\n          }\n        }\n        t.ContractReservedEventError = d;\n        class l extends i.BaseWeb3Error {\n          constructor() {\n            super('No \"data\" specified in neither the given options, nor the default options.'), this.code = n.ERR_CONTRACT_MISSING_DEPLOY_DATA;\n          }\n        }\n        t.ContractMissingDeployDataError = l;\n        class h extends i.BaseWeb3Error {\n          constructor() {\n            super(\"This contract object doesn't have address set yet, please set an address first.\"), this.code = n.ERR_CONTRACT_MISSING_ADDRESS;\n          }\n        }\n        t.ContractNoAddressDefinedError = h;\n        class f extends i.BaseWeb3Error {\n          constructor() {\n            super('No \"from\" address specified in neither the given options, nor the default options.'), this.code = n.ERR_CONTRACT_MISSING_FROM_ADDRESS;\n          }\n        }\n        t.ContractNoFromAddressDefinedError = f;\n        class p extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_CONTRACT_INSTANTIATION;\n          }\n        }\n        t.ContractInstantiationError = p;\n        class m extends o {\n          constructor(e) {\n            if (super(e.message || \"Error\"), this.name = \"name\" in e && e.name || this.constructor.name, this.stack = \"stack\" in e && e.stack || void 0, this.code = e.code, \"object\" == typeof e.data) {\n              let t;\n              t = \"originalError\" in e.data ? e.data.originalError : e.data, this.data = t.data, this.innerError = new m(t);\n            } else this.data = e.data;\n          }\n          setDecodedProperties(e, t, r) {\n            this.errorName = e, this.errorSignature = t, this.errorArgs = r;\n          }\n          toJSON() {\n            let e = Object.assign(Object.assign({}, super.toJSON()), {\n              data: this.data\n            });\n            return this.errorName && (e = Object.assign(Object.assign({}, e), {\n              errorName: this.errorName,\n              errorSignature: this.errorSignature,\n              errorArgs: this.errorArgs\n            })), e;\n          }\n        }\n        t.Eip838ExecutionError = m, t.ContractExecutionError = class extends o {\n          constructor(e) {\n            super(\"Error happened while trying to execute a function inside a smart contract\"), this.code = n.ERR_CONTRACT_EXECUTION_REVERTED, this.innerError = new m(e);\n          }\n        };\n        class g extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"data: \".concat(null !== (t = e.data) && void 0 !== t ? t : \"undefined\", \", input: \").concat(null !== (r = e.input) && void 0 !== r ? r : \"undefined\"), 'You can\\'t have \"data\" and \"input\" as properties of a contract at the same time, please use either \"data\" or \"input\" instead.'), this.code = n.ERR_CONTRACT_TX_DATA_AND_INPUT;\n          }\n        }\n        t.ContractTransactionDataAndInputError = g;\n      },\n      3628: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ConfigChainMismatchError = t.ConfigHardforkMismatchError = void 0;\n        const n = r(3685),\n          i = r(7639);\n        class o extends n.BaseWeb3Error {\n          constructor(e, t) {\n            super(\"Web3Config hardfork doesnt match in defaultHardfork \".concat(e, \" and common.hardfork \").concat(t)), this.code = i.ERR_CORE_HARDFORK_MISMATCH;\n          }\n        }\n        t.ConfigHardforkMismatchError = o;\n        class s extends n.BaseWeb3Error {\n          constructor(e, t) {\n            super(\"Web3Config chain doesnt match in defaultHardfork \".concat(e, \" and common.hardfork \").concat(t)), this.code = i.ERR_CORE_HARDFORK_MISMATCH;\n          }\n        }\n        t.ConfigChainMismatchError = s;\n      },\n      1591: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ENSNetworkNotSyncedError = t.ENSUnsupportedNetworkError = t.ENSCheckInterfaceSupportError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"ENS resolver check interface support error. \\\"\".concat(e, \"\\\"\")), this.code = n.ERR_ENS_CHECK_INTERFACE_SUPPORT;\n          }\n        }\n        t.ENSCheckInterfaceSupportError = o;\n        class s extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"ENS is not supported on network \".concat(e)), this.code = n.ERR_ENS_UNSUPPORTED_NETWORK;\n          }\n        }\n        t.ENSUnsupportedNetworkError = s;\n        class a extends i.BaseWeb3Error {\n          constructor() {\n            super(\"Network not synced\"), this.code = n.ERR_ENS_NETWORK_NOT_SYNCED;\n          }\n        }\n        t.ENSNetworkNotSyncedError = a;\n      },\n      7297: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ExistingPluginNamespaceError = t.AbiError = t.OperationAbortError = t.OperationTimeoutError = t.MethodNotImplementedError = t.FormatterError = t.InvalidMethodParamsError = t.InvalidNumberOfParamsError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor(e, t, r) {\n            super(\"Invalid number of parameters for \\\"\".concat(r, \"\\\". Got \\\"\").concat(e, \"\\\" expected \\\"\").concat(t, \"\\\"!\")), this.got = e, this.expected = t, this.method = r, this.code = n.ERR_PARAM;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              got: this.got,\n              expected: this.expected,\n              method: this.method\n            });\n          }\n        }\n        t.InvalidNumberOfParamsError = o;\n        class s extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Invalid parameters passed. \\\"\".concat(void 0 !== e ? e : \"\", \"\\\"\")), this.hint = e, this.code = n.ERR_INVALID_METHOD_PARAMS;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              hint: this.hint\n            });\n          }\n        }\n        t.InvalidMethodParamsError = s;\n        class a extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_FORMATTERS;\n          }\n        }\n        t.FormatterError = a;\n        class c extends i.BaseWeb3Error {\n          constructor() {\n            super(\"The method you're trying to call is not implemented.\"), this.code = n.ERR_METHOD_NOT_IMPLEMENTED;\n          }\n        }\n        t.MethodNotImplementedError = c;\n        class u extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_OPERATION_TIMEOUT;\n          }\n        }\n        t.OperationTimeoutError = u;\n        class d extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_OPERATION_ABORT;\n          }\n        }\n        t.OperationAbortError = d;\n        class l extends i.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.code = n.ERR_ABI_ENCODING, this.props = null != t ? t : {};\n          }\n        }\n        t.AbiError = l;\n        class h extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"A plugin with the namespace: \".concat(e, \" has already been registered.\")), this.code = n.ERR_EXISTING_PLUGIN_NAMESPACE;\n          }\n        }\n        t.ExistingPluginNamespaceError = h;\n      },\n      7108: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3WSProviderError = t.SubscriptionError = t.InvalidClientError = t.InvalidProviderError = t.ProviderError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_PROVIDER;\n          }\n        }\n        t.ProviderError = o;\n        class s extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Provider with url \\\"\".concat(e, \"\\\" is not set or invalid\")), this.clientUrl = e, this.code = n.ERR_INVALID_PROVIDER;\n          }\n        }\n        t.InvalidProviderError = s;\n        class a extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Client URL \\\"\".concat(e, \"\\\" is invalid.\")), this.code = n.ERR_INVALID_CLIENT;\n          }\n        }\n        t.InvalidClientError = a;\n        class c extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_SUBSCRIPTION;\n          }\n        }\n        t.SubscriptionError = c;\n        class u extends i.BaseWeb3Error {\n          constructor() {\n            super(...arguments), this.code = n.ERR_WS_PROVIDER;\n          }\n        }\n        t.Web3WSProviderError = u;\n      },\n      9491: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidResponseError = t.ResponseError = void 0;\n        const n = r(3685),\n          i = r(7639),\n          o = e => (e => !(Array.isArray(e) || \"2.0\" !== e.jsonrpc || !e || void 0 !== e.result && null !== e.result || !(\"error\" in e) || \"number\" != typeof e.id && \"string\" != typeof e.id))(e) ? e.error.message : \"\";\n        class s extends n.BaseWeb3Error {\n          constructor(e, t, r) {\n            var n;\n            let s;\n            super(null != t ? t : \"Returned error: \".concat(Array.isArray(e) ? e.map(e => o(e)).join(\",\") : o(e))), this.code = i.ERR_RESPONSE, t || (this.data = Array.isArray(e) ? e.map(e => {\n              var t;\n              return null === (t = e.error) || void 0 === t ? void 0 : t.data;\n            }) : null === (n = null == e ? void 0 : e.error) || void 0 === n ? void 0 : n.data), this.request = r, \"error\" in e ? s = e.error : e instanceof Array && (s = e.map(e => e.error)), this.innerError = s;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              data: this.data,\n              request: this.request\n            });\n          }\n        }\n        t.ResponseError = s, t.InvalidResponseError = class extends s {\n          constructor(e, t) {\n            let r;\n            super(e, void 0, t), this.code = i.ERR_INVALID_RESPONSE, \"error\" in e ? r = e.error : e instanceof Array && (r = e.map(e => e.error)), this.innerError = r;\n          }\n        };\n      },\n      4032: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.RpcErrorMessages = t.genericRpcErrorMessageTemplate = void 0;\n        const n = r(7639);\n        t.genericRpcErrorMessageTemplate = \"An Rpc error has occured with a code of *code*\", t.RpcErrorMessages = {\n          [n.ERR_RPC_INVALID_JSON]: {\n            message: \"Parse error\",\n            description: \"Invalid JSON\"\n          },\n          [n.ERR_RPC_INVALID_REQUEST]: {\n            message: \"Invalid request\",\n            description: \"JSON is not a valid request object\\t\"\n          },\n          [n.ERR_RPC_INVALID_METHOD]: {\n            message: \"Method not found\",\n            description: \"Method does not exist\\t\"\n          },\n          [n.ERR_RPC_INVALID_PARAMS]: {\n            message: \"Invalid params\",\n            description: \"Invalid method parameters\"\n          },\n          [n.ERR_RPC_INTERNAL_ERROR]: {\n            message: \"Internal error\",\n            description: \"Internal JSON-RPC error\"\n          },\n          [n.ERR_RPC_INVALID_INPUT]: {\n            message: \"Invalid input\",\n            description: \"Missing or invalid parameters\"\n          },\n          [n.ERR_RPC_MISSING_RESOURCE]: {\n            message: \"Resource not found\",\n            description: \"Requested resource not found\"\n          },\n          [n.ERR_RPC_UNAVAILABLE_RESOURCE]: {\n            message: \"Resource unavailable\",\n            description: \"Requested resource not available\"\n          },\n          [n.ERR_RPC_TRANSACTION_REJECTED]: {\n            message: \"Transaction rejected\",\n            description: \"Transaction creation failed\"\n          },\n          [n.ERR_RPC_UNSUPPORTED_METHOD]: {\n            message: \"Method not supported\",\n            description: \"Method is not implemented\"\n          },\n          [n.ERR_RPC_LIMIT_EXCEEDED]: {\n            message: \"Limit exceeded\",\n            description: \"Request exceeds defined limit\"\n          },\n          [n.ERR_RPC_NOT_SUPPORTED]: {\n            message: \"JSON-RPC version not supported\",\n            description: \"Version of JSON-RPC protocol is not supported\"\n          },\n          [n.JSONRPC_ERR_REJECTED_REQUEST]: {\n            name: \"User Rejected Request\",\n            message: \"The user rejected the request.\"\n          },\n          [n.JSONRPC_ERR_UNAUTHORIZED]: {\n            name: \"Unauthorized\",\n            message: \"The requested method and/or account has not been authorized by the user.\"\n          },\n          [n.JSONRPC_ERR_UNSUPPORTED_METHOD]: {\n            name: \"Unsupported Method\",\n            message: \"The Provider does not support the requested method.\"\n          },\n          [n.JSONRPC_ERR_DISCONNECTED]: {\n            name: \"Disconnected\",\n            message: \"The Provider is disconnected from all chains.\"\n          },\n          [n.JSONRPC_ERR_CHAIN_DISCONNECTED]: {\n            name: \"Chain Disconnected\",\n            message: \"The Provider is not connected to the requested chain.\"\n          },\n          \"0-999\": {\n            name: \"\",\n            message: \"Not used.\"\n          },\n          1e3: {\n            name: \"Normal Closure\",\n            message: \"The connection successfully completed the purpose for which it was created.\"\n          },\n          1001: {\n            name: \"Going Away\",\n            message: \"The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.\"\n          },\n          1002: {\n            name: \"Protocol error\",\n            message: \"The endpoint is terminating the connection due to a protocol error.\"\n          },\n          1003: {\n            name: \"Unsupported Data\",\n            message: \"The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)\"\n          },\n          1004: {\n            name: \"Reserved\",\n            message: \"Reserved. A meaning might be defined in the future.\"\n          },\n          1005: {\n            name: \"No Status Rcvd\",\n            message: \"Reserved. Indicates that no status code was provided even though one was expected.\"\n          },\n          1006: {\n            name: \"Abnormal Closure\",\n            message: \"Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.\"\n          },\n          1007: {\n            name: \"Invalid frame payload data\",\n            message: \"The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).\"\n          },\n          1008: {\n            name: \"Policy Violation\",\n            message: \"The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.\"\n          },\n          1009: {\n            name: \"Message Too Big\",\n            message: \"The endpoint is terminating the connection because a data frame was received that is too large.\"\n          },\n          1010: {\n            name: \"Mandatory Ext.\",\n            message: \"The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't.\"\n          },\n          1011: {\n            name: \"Internal Error\",\n            message: \"The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.\"\n          },\n          1012: {\n            name: \"Service Restart\",\n            message: \"The server is terminating the connection because it is restarting.\"\n          },\n          1013: {\n            name: \"Try Again Later\",\n            message: \"The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.\"\n          },\n          1014: {\n            name: \"Bad Gateway\",\n            message: \"The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.\"\n          },\n          1015: {\n            name: \"TLS handshake\",\n            message: \"Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).\"\n          },\n          \"1016-2999\": {\n            name: \"\",\n            message: \"For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications.\"\n          },\n          \"3000-3999\": {\n            name: \"\",\n            message: \"For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol.\"\n          },\n          \"4000-4999\": {\n            name: \"\",\n            message: \"For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol.\"\n          }\n        };\n      },\n      655: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.rpcErrorsMap = t.LimitExceededError = t.TransactionRejectedError = t.VersionNotSupportedError = t.ResourcesNotFoundError = t.ResourceUnavailableError = t.MethodNotSupported = t.InvalidInputError = t.InternalError = t.InvalidParamsError = t.MethodNotFoundError = t.InvalidRequestError = t.ParseError = t.EIP1193ProviderRpcError = t.RpcError = void 0;\n        const n = r(3685),\n          i = r(7639),\n          o = r(4032);\n        class s extends n.BaseWeb3Error {\n          constructor(e, t) {\n            super(null != t ? t : o.genericRpcErrorMessageTemplate.replace(\"*code*\", e.error.code.toString())), this.code = e.error.code, this.id = e.id, this.jsonrpc = e.jsonrpc, this.jsonRpcError = e.error;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              error: this.jsonRpcError,\n              id: this.id,\n              jsonRpc: this.jsonrpc\n            });\n          }\n        }\n        t.RpcError = s;\n        class a extends n.BaseWeb3Error {\n          constructor(e, t) {\n            var r, n, i, s;\n            if (e) {\n              if (null === (r = o.RpcErrorMessages[e]) || void 0 === r ? void 0 : r.message) super(o.RpcErrorMessages[e].message);else {\n                const t = Object.keys(o.RpcErrorMessages).find(t => \"string\" == typeof t && e >= parseInt(t.split(\"-\")[0], 10) && e <= parseInt(t.split(\"-\")[1], 10));\n                super(null !== (i = null === (n = o.RpcErrorMessages[null != t ? t : \"\"]) || void 0 === n ? void 0 : n.message) && void 0 !== i ? i : o.genericRpcErrorMessageTemplate.replace(\"*code*\", null !== (s = null == e ? void 0 : e.toString()) && void 0 !== s ? s : '\"\"'));\n              }\n            } else super();\n            this.code = e, this.data = t;\n          }\n        }\n        t.EIP1193ProviderRpcError = a;\n        class c extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_INVALID_JSON].message), this.code = i.ERR_RPC_INVALID_JSON;\n          }\n        }\n        t.ParseError = c;\n        class u extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_INVALID_REQUEST].message), this.code = i.ERR_RPC_INVALID_REQUEST;\n          }\n        }\n        t.InvalidRequestError = u;\n        class d extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_INVALID_METHOD].message), this.code = i.ERR_RPC_INVALID_METHOD;\n          }\n        }\n        t.MethodNotFoundError = d;\n        class l extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_INVALID_PARAMS].message), this.code = i.ERR_RPC_INVALID_PARAMS;\n          }\n        }\n        t.InvalidParamsError = l;\n        class h extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_INTERNAL_ERROR].message), this.code = i.ERR_RPC_INTERNAL_ERROR;\n          }\n        }\n        t.InternalError = h;\n        class f extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_INVALID_INPUT].message), this.code = i.ERR_RPC_INVALID_INPUT;\n          }\n        }\n        t.InvalidInputError = f;\n        class p extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_UNSUPPORTED_METHOD].message), this.code = i.ERR_RPC_UNSUPPORTED_METHOD;\n          }\n        }\n        t.MethodNotSupported = p;\n        class m extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_UNAVAILABLE_RESOURCE].message), this.code = i.ERR_RPC_UNAVAILABLE_RESOURCE;\n          }\n        }\n        t.ResourceUnavailableError = m;\n        class g extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_MISSING_RESOURCE].message), this.code = i.ERR_RPC_MISSING_RESOURCE;\n          }\n        }\n        t.ResourcesNotFoundError = g;\n        class y extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_NOT_SUPPORTED].message), this.code = i.ERR_RPC_NOT_SUPPORTED;\n          }\n        }\n        t.VersionNotSupportedError = y;\n        class v extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_TRANSACTION_REJECTED].message), this.code = i.ERR_RPC_TRANSACTION_REJECTED;\n          }\n        }\n        t.TransactionRejectedError = v;\n        class b extends s {\n          constructor(e) {\n            super(e, o.RpcErrorMessages[i.ERR_RPC_LIMIT_EXCEEDED].message), this.code = i.ERR_RPC_LIMIT_EXCEEDED;\n          }\n        }\n        t.LimitExceededError = b, t.rpcErrorsMap = new Map(), t.rpcErrorsMap.set(i.ERR_RPC_INVALID_JSON, {\n          error: c\n        }), t.rpcErrorsMap.set(i.ERR_RPC_INVALID_REQUEST, {\n          error: u\n        }), t.rpcErrorsMap.set(i.ERR_RPC_INVALID_METHOD, {\n          error: d\n        }), t.rpcErrorsMap.set(i.ERR_RPC_INVALID_PARAMS, {\n          error: l\n        }), t.rpcErrorsMap.set(i.ERR_RPC_INTERNAL_ERROR, {\n          error: h\n        }), t.rpcErrorsMap.set(i.ERR_RPC_INVALID_INPUT, {\n          error: f\n        }), t.rpcErrorsMap.set(i.ERR_RPC_UNSUPPORTED_METHOD, {\n          error: p\n        }), t.rpcErrorsMap.set(i.ERR_RPC_UNAVAILABLE_RESOURCE, {\n          error: m\n        }), t.rpcErrorsMap.set(i.ERR_RPC_TRANSACTION_REJECTED, {\n          error: v\n        }), t.rpcErrorsMap.set(i.ERR_RPC_MISSING_RESOURCE, {\n          error: g\n        }), t.rpcErrorsMap.set(i.ERR_RPC_NOT_SUPPORTED, {\n          error: y\n        }), t.rpcErrorsMap.set(i.ERR_RPC_LIMIT_EXCEEDED, {\n          error: b\n        });\n      },\n      1066: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SchemaFormatError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Format for the type \".concat(e, \" is unsupported\")), this.type = e, this.code = n.ERR_SCHEMA_FORMAT;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              type: this.type\n            });\n          }\n        }\n        t.SchemaFormatError = o;\n      },\n      1075: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SignatureError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.InvalidValueError {\n          constructor() {\n            super(...arguments), this.code = n.ERR_SIGNATURE_FAILED;\n          }\n        }\n        t.SignatureError = o;\n      },\n      8450: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidPropertiesForTransactionTypeError = t.LocalWalletNotAvailableError = t.TransactionSigningError = t.TransactionReceiptMissingBlockNumberError = t.TransactionMissingReceiptOrBlockHashError = t.TransactionBlockTimeoutError = t.TransactionPollingTimeoutError = t.TransactionSendTimeoutError = t.TransactionDataAndInputError = t.UnsupportedTransactionTypeError = t.Eip1559NotSupportedError = t.UnableToPopulateNonceError = t.InvalidNonceOrChainIdError = t.InvalidTransactionObjectError = t.UnsupportedFeeMarketError = t.Eip1559GasPriceError = t.InvalidMaxPriorityFeePerGasOrMaxFeePerGas = t.InvalidGasOrGasPrice = t.TransactionGasMismatchError = t.TransactionGasMismatchInnerError = t.MissingGasError = t.MissingGasInnerError = t.MissingChainOrHardforkError = t.CommonOrChainAndHardforkError = t.HardforkMismatchError = t.ChainMismatchError = t.ChainIdMismatchError = t.MissingCustomChainIdError = t.MissingCustomChainError = t.InvalidTransactionCall = t.InvalidTransactionWithReceiver = t.InvalidTransactionWithSender = t.TransactionNotFound = t.UndefinedRawTransactionError = t.TransactionOutOfGasError = t.TransactionRevertedWithoutReasonError = t.ContractCodeNotStoredError = t.NoContractAddressFoundError = t.TransactionRevertWithCustomError = t.TransactionRevertInstructionError = t.RevertInstructionError = t.TransactionError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.BaseWeb3Error {\n          constructor(e, t) {\n            super(e), this.receipt = t, this.code = n.ERR_TX;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              receipt: this.receipt\n            });\n          }\n        }\n        t.TransactionError = o;\n        class s extends i.BaseWeb3Error {\n          constructor(e, t) {\n            super(\"Your request got reverted with the following reason string: \".concat(e)), this.reason = e, this.signature = t, this.code = n.ERR_TX_REVERT_INSTRUCTION;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              reason: this.reason,\n              signature: this.signature\n            });\n          }\n        }\n        t.RevertInstructionError = s;\n        class a extends i.BaseWeb3Error {\n          constructor(e, t, r, o) {\n            super(\"Transaction has been reverted by the EVM\" + (void 0 === r ? \"\" : \":\\n \".concat(i.BaseWeb3Error.convertToString(r)))), this.reason = e, this.signature = t, this.receipt = r, this.data = o, this.code = n.ERR_TX_REVERT_TRANSACTION;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              reason: this.reason,\n              signature: this.signature,\n              receipt: this.receipt,\n              data: this.data\n            });\n          }\n        }\n        t.TransactionRevertInstructionError = a, t.TransactionRevertWithCustomError = class extends a {\n          constructor(e, t, r, i, o, s, a) {\n            super(e), this.reason = e, this.customErrorName = t, this.customErrorDecodedSignature = r, this.customErrorArguments = i, this.signature = o, this.receipt = s, this.data = a, this.code = n.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              reason: this.reason,\n              customErrorName: this.customErrorName,\n              customErrorDecodedSignature: this.customErrorDecodedSignature,\n              customErrorArguments: this.customErrorArguments,\n              signature: this.signature,\n              receipt: this.receipt,\n              data: this.data\n            });\n          }\n        }, t.NoContractAddressFoundError = class extends o {\n          constructor(e) {\n            super(\"The transaction receipt didn't contain a contract address.\", e), this.code = n.ERR_TX_NO_CONTRACT_ADDRESS;\n          }\n          toJSON() {\n            return Object.assign(Object.assign({}, super.toJSON()), {\n              receipt: this.receipt\n            });\n          }\n        }, t.ContractCodeNotStoredError = class extends o {\n          constructor(e) {\n            super(\"The contract code couldn't be stored, please check your gas limit.\", e), this.code = n.ERR_TX_CONTRACT_NOT_STORED;\n          }\n        }, t.TransactionRevertedWithoutReasonError = class extends o {\n          constructor(e) {\n            super(\"Transaction has been reverted by the EVM\" + (void 0 === e ? \"\" : \":\\n \".concat(i.BaseWeb3Error.convertToString(e))), e), this.code = n.ERR_TX_REVERT_WITHOUT_REASON;\n          }\n        }, t.TransactionOutOfGasError = class extends o {\n          constructor(e) {\n            super(\"Transaction ran out of gas. Please provide more gas:\\n \".concat(JSON.stringify(e, void 0, 2)), e), this.code = n.ERR_TX_OUT_OF_GAS;\n          }\n        }, t.UndefinedRawTransactionError = class extends o {\n          constructor() {\n            super(\"Raw transaction undefined\"), this.code = n.ERR_RAW_TX_UNDEFINED;\n          }\n        }, t.TransactionNotFound = class extends o {\n          constructor() {\n            super(\"Transaction not found\"), this.code = n.ERR_TX_NOT_FOUND;\n          }\n        };\n        class c extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction with invalid sender\"), this.code = n.ERR_TX_INVALID_SENDER;\n          }\n        }\n        t.InvalidTransactionWithSender = c;\n        class u extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction with invalid receiver\"), this.code = n.ERR_TX_INVALID_RECEIVER;\n          }\n        }\n        t.InvalidTransactionWithReceiver = u;\n        class d extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction call\"), this.code = n.ERR_TX_INVALID_CALL;\n          }\n        }\n        t.InvalidTransactionCall = d;\n        class l extends i.InvalidValueError {\n          constructor() {\n            super(\"MissingCustomChainError\", \"If tx.common is provided it must have tx.common.customChain\"), this.code = n.ERR_TX_MISSING_CUSTOM_CHAIN;\n          }\n        }\n        t.MissingCustomChainError = l;\n        class h extends i.InvalidValueError {\n          constructor() {\n            super(\"MissingCustomChainIdError\", \"If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId\"), this.code = n.ERR_TX_MISSING_CUSTOM_CHAIN_ID;\n          }\n        }\n        t.MissingCustomChainIdError = h;\n        class f extends i.InvalidValueError {\n          constructor(e) {\n            super(JSON.stringify(e), \"Chain Id doesnt match in tx.chainId tx.common.customChain.chainId\"), this.code = n.ERR_TX_CHAIN_ID_MISMATCH;\n          }\n        }\n        t.ChainIdMismatchError = f;\n        class p extends i.InvalidValueError {\n          constructor(e) {\n            super(JSON.stringify(e), \"Chain doesnt match in tx.chain tx.common.basechain\"), this.code = n.ERR_TX_CHAIN_MISMATCH;\n          }\n        }\n        t.ChainMismatchError = p;\n        class m extends i.InvalidValueError {\n          constructor(e) {\n            super(JSON.stringify(e), \"hardfork doesnt match in tx.hardfork tx.common.hardfork\"), this.code = n.ERR_TX_HARDFORK_MISMATCH;\n          }\n        }\n        t.HardforkMismatchError = m;\n        class g extends i.InvalidValueError {\n          constructor() {\n            super(\"CommonOrChainAndHardforkError\", \"Please provide the common object or the chain and hardfork property but not all together.\"), this.code = n.ERR_TX_INVALID_CHAIN_INFO;\n          }\n        }\n        t.CommonOrChainAndHardforkError = g;\n        class y extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"MissingChainOrHardforkError\", \"When specifying chain and hardfork, both values must be defined. Received \\\"chain\\\": \".concat(null !== (t = e.chain) && void 0 !== t ? t : \"undefined\", \", \\\"hardfork\\\": \").concat(null !== (r = e.hardfork) && void 0 !== r ? r : \"undefined\")), this.code = n.ERR_TX_MISSING_CHAIN_INFO;\n          }\n        }\n        t.MissingChainOrHardforkError = y;\n        class v extends i.BaseWeb3Error {\n          constructor() {\n            super('Missing properties in transaction, either define \"gas\" and \"gasPrice\" for type 0 transactions or \"gas\", \"maxPriorityFeePerGas\" and \"maxFeePerGas\" for type 2 transactions'), this.code = n.ERR_TX_MISSING_GAS_INNER_ERROR;\n          }\n        }\n        t.MissingGasInnerError = v;\n        class b extends i.InvalidValueError {\n          constructor(e) {\n            var t, r, i, o;\n            super(\"gas: \".concat(null !== (t = e.gas) && void 0 !== t ? t : \"undefined\", \", gasPrice: \").concat(null !== (r = e.gasPrice) && void 0 !== r ? r : \"undefined\", \", maxPriorityFeePerGas: \").concat(null !== (i = e.maxPriorityFeePerGas) && void 0 !== i ? i : \"undefined\", \", maxFeePerGas: \").concat(null !== (o = e.maxFeePerGas) && void 0 !== o ? o : \"undefined\"), '\"gas\" is missing'), this.code = n.ERR_TX_MISSING_GAS, this.innerError = new v();\n          }\n        }\n        t.MissingGasError = b;\n        class E extends i.BaseWeb3Error {\n          constructor() {\n            super('Missing properties in transaction, either define \"gas\" and \"gasPrice\" for type 0 transactions or \"gas\", \"maxPriorityFeePerGas\" and \"maxFeePerGas\" for type 2 transactions, not both'), this.code = n.ERR_TX_GAS_MISMATCH_INNER_ERROR;\n          }\n        }\n        t.TransactionGasMismatchInnerError = E;\n        class _ extends i.InvalidValueError {\n          constructor(e) {\n            var t, r, i, o;\n            super(\"gas: \".concat(null !== (t = e.gas) && void 0 !== t ? t : \"undefined\", \", gasPrice: \").concat(null !== (r = e.gasPrice) && void 0 !== r ? r : \"undefined\", \", maxPriorityFeePerGas: \").concat(null !== (i = e.maxPriorityFeePerGas) && void 0 !== i ? i : \"undefined\", \", maxFeePerGas: \").concat(null !== (o = e.maxFeePerGas) && void 0 !== o ? o : \"undefined\"), \"transaction must specify legacy or fee market gas properties, not both\"), this.code = n.ERR_TX_GAS_MISMATCH, this.innerError = new E();\n          }\n        }\n        t.TransactionGasMismatchError = _;\n        class A extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"gas: \".concat(null !== (t = e.gas) && void 0 !== t ? t : \"undefined\", \", gasPrice: \").concat(null !== (r = e.gasPrice) && void 0 !== r ? r : \"undefined\"), \"Gas or gasPrice is lower than 0\"), this.code = n.ERR_TX_INVALID_LEGACY_GAS;\n          }\n        }\n        t.InvalidGasOrGasPrice = A;\n        class T extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"maxPriorityFeePerGas: \".concat(null !== (t = e.maxPriorityFeePerGas) && void 0 !== t ? t : \"undefined\", \", maxFeePerGas: \").concat(null !== (r = e.maxFeePerGas) && void 0 !== r ? r : \"undefined\"), \"maxPriorityFeePerGas or maxFeePerGas is lower than 0\"), this.code = n.ERR_TX_INVALID_FEE_MARKET_GAS;\n          }\n        }\n        t.InvalidMaxPriorityFeePerGasOrMaxFeePerGas = T;\n        class I extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"eip-1559 transactions don't support gasPrice\"), this.code = n.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE;\n          }\n        }\n        t.Eip1559GasPriceError = I;\n        class R extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"maxPriorityFeePerGas: \".concat(null !== (t = e.maxPriorityFeePerGas) && void 0 !== t ? t : \"undefined\", \", maxFeePerGas: \").concat(null !== (r = e.maxFeePerGas) && void 0 !== r ? r : \"undefined\"), \"pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas\"), this.code = n.ERR_TX_INVALID_LEGACY_FEE_MARKET;\n          }\n        }\n        t.UnsupportedFeeMarketError = R;\n        class w extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid transaction object\"), this.code = n.ERR_TX_INVALID_OBJECT;\n          }\n        }\n        t.InvalidTransactionObjectError = w;\n        class P extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"nonce: \".concat(null !== (t = e.nonce) && void 0 !== t ? t : \"undefined\", \", chainId: \").concat(null !== (r = e.chainId) && void 0 !== r ? r : \"undefined\"), \"Nonce or chainId is lower than 0\"), this.code = n.ERR_TX_INVALID_NONCE_OR_CHAIN_ID;\n          }\n        }\n        t.InvalidNonceOrChainIdError = P;\n        class x extends i.InvalidValueError {\n          constructor() {\n            super(\"UnableToPopulateNonceError\", \"unable to populate nonce, no from address available\"), this.code = n.ERR_TX_UNABLE_TO_POPULATE_NONCE;\n          }\n        }\n        t.UnableToPopulateNonceError = x;\n        class S extends i.InvalidValueError {\n          constructor() {\n            super(\"Eip1559NotSupportedError\", \"Network doesn't support eip-1559\"), this.code = n.ERR_TX_UNSUPPORTED_EIP_1559;\n          }\n        }\n        t.Eip1559NotSupportedError = S;\n        class O extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"unsupported transaction type\"), this.code = n.ERR_TX_UNSUPPORTED_TYPE;\n          }\n        }\n        t.UnsupportedTransactionTypeError = O;\n        class C extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"data: \".concat(null !== (t = e.data) && void 0 !== t ? t : \"undefined\", \", input: \").concat(null !== (r = e.input) && void 0 !== r ? r : \"undefined\"), 'You can\\'t have \"data\" and \"input\" as properties of transactions at the same time, please use either \"data\" or \"input\" instead.'), this.code = n.ERR_TX_DATA_AND_INPUT;\n          }\n        }\n        t.TransactionDataAndInputError = C;\n        class B extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"The connected Ethereum Node did not respond within \".concat(e.numberOfSeconds, \" seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\\n\\tTransaction Hash: \").concat(e.transactionHash ? e.transactionHash.toString() : \"not available\")), this.code = n.ERR_TX_SEND_TIMEOUT;\n          }\n        }\n        function N(e) {\n          return \"Please make sure your transaction was properly sent and there no pervious pending transaction for the same account. However, be aware that it might still be mined!\\n\\tTransaction Hash: \".concat(e ? e.toString() : \"not available\");\n        }\n        t.TransactionSendTimeoutError = B;\n        class k extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Transaction was not mined within \".concat(e.numberOfSeconds, \" seconds. \").concat(N(e.transactionHash))), this.code = n.ERR_TX_POLLING_TIMEOUT;\n          }\n        }\n        t.TransactionPollingTimeoutError = k;\n        class M extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Transaction started at \".concat(e.starterBlockNumber, \" but was not mined within \").concat(e.numberOfBlocks, \" blocks. \").concat(N(e.transactionHash))), this.code = n.ERR_TX_BLOCK_TIMEOUT;\n          }\n        }\n        t.TransactionBlockTimeoutError = M;\n        class D extends i.InvalidValueError {\n          constructor(e) {\n            var t, r;\n            super(\"receipt: \".concat(JSON.stringify(e.receipt), \", blockHash: \").concat(null === (t = e.blockHash) || void 0 === t ? void 0 : t.toString(), \", transactionHash: \").concat(null === (r = e.transactionHash) || void 0 === r ? void 0 : r.toString()), \"Receipt missing or blockHash null\"), this.code = n.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL;\n          }\n        }\n        t.TransactionMissingReceiptOrBlockHashError = D;\n        class L extends i.InvalidValueError {\n          constructor(e) {\n            super(\"receipt: \".concat(JSON.stringify(e.receipt)), \"Receipt missing block number\"), this.code = n.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER;\n          }\n        }\n        t.TransactionReceiptMissingBlockNumberError = L;\n        class F extends i.BaseWeb3Error {\n          constructor(e) {\n            super(\"Invalid signature. \\\"\".concat(e, \"\\\"\")), this.code = n.ERR_TX_SIGNING;\n          }\n        }\n        t.TransactionSigningError = F;\n        class j extends i.InvalidValueError {\n          constructor() {\n            super(\"LocalWalletNotAvailableError\", \"Attempted to index account in local wallet, but no wallet is available\"), this.code = n.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE;\n          }\n        }\n        t.LocalWalletNotAvailableError = j;\n        class H extends i.BaseWeb3Error {\n          constructor(e, t) {\n            const r = [];\n            e.forEach(e => r.push(e.keyword)), super(\"The following properties are invalid for the transaction type \".concat(t, \": \").concat(r.join(\", \"))), this.code = n.ERR_TX_INVALID_PROPERTIES_FOR_TYPE;\n          }\n        }\n        t.InvalidPropertiesForTransactionTypeError = H;\n      },\n      4618: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidTypeAbiInputError = t.InvalidBlockError = t.InvalidLargeValueError = t.InvalidSizeError = t.InvalidUnsignedIntegerError = t.InvalidBooleanError = t.InvalidTypeError = t.NibbleWidthError = t.HexProcessingError = t.InvalidUnitError = t.InvalidStringError = t.InvalidAddressError = t.InvalidNumberError = t.InvalidBytesError = void 0;\n        const n = r(7639),\n          i = r(3685);\n        class o extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"can not parse as byte data\"), this.code = n.ERR_INVALID_BYTES;\n          }\n        }\n        t.InvalidBytesError = o;\n        class s extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"can not parse as number data\"), this.code = n.ERR_INVALID_NUMBER;\n          }\n        }\n        t.InvalidNumberError = s;\n        class a extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid ethereum address\"), this.code = n.ERR_INVALID_ADDRESS;\n          }\n        }\n        t.InvalidAddressError = a;\n        class c extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid string\"), this.code = n.ERR_INVALID_STRING;\n          }\n        }\n        t.InvalidStringError = c;\n        class u extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid unit\"), this.code = n.ERR_INVALID_UNIT;\n          }\n        }\n        t.InvalidUnitError = u;\n        class d extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"can not be converted to hex\"), this.code = n.ERR_INVALID_HEX;\n          }\n        }\n        t.HexProcessingError = d;\n        class l extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"value greater than the nibble width\"), this.code = n.ERR_INVALID_NIBBLE_WIDTH;\n          }\n        }\n        t.NibbleWidthError = l;\n        class h extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid type, type not supported\"), this.code = n.ERR_INVALID_TYPE;\n          }\n        }\n        t.InvalidTypeError = h;\n        class f extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid boolean.\"), this.code = n.ERR_INVALID_BOOLEAN;\n          }\n        }\n        t.InvalidBooleanError = f;\n        class p extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"not a valid unsigned integer.\"), this.code = n.ERR_INVALID_UNSIGNED_INTEGER;\n          }\n        }\n        t.InvalidUnsignedIntegerError = p;\n        class m extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid size given.\"), this.code = n.ERR_INVALID_SIZE;\n          }\n        }\n        t.InvalidSizeError = m;\n        class g extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"value is larger than size.\"), this.code = n.ERR_INVALID_LARGE_VALUE;\n          }\n        }\n        t.InvalidLargeValueError = g;\n        class y extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"invalid string given\"), this.code = n.ERR_INVALID_BLOCK;\n          }\n        }\n        t.InvalidBlockError = y;\n        class v extends i.InvalidValueError {\n          constructor(e) {\n            super(e, \"components found but type is not tuple\"), this.code = n.ERR_INVALID_TYPE_ABI;\n          }\n        }\n        t.InvalidTypeAbiInputError = v;\n      },\n      5071: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), i(r(7639), t), i(r(3685), t), i(r(8105), t), i(r(3789), t), i(r(510), t), i(r(1591), t), i(r(7297), t), i(r(7108), t), i(r(1075), t), i(r(8450), t), i(r(4618), t), i(r(9491), t), i(r(3628), t), i(r(655), t), i(r(4032), t), i(r(1066), t);\n      },\n      3685: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InvalidValueError = t.BaseWeb3Error = void 0;\n        class r extends Error {\n          constructor(e, t) {\n            super(e), this.innerError = t, this.name = this.constructor.name, \"function\" == typeof Error.captureStackTrace ? Error.captureStackTrace(new.target.constructor) : this.stack = new Error().stack;\n          }\n          static convertToString(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n            if (null == e) return \"undefined\";\n            const r = JSON.stringify(e, (e, t) => \"bigint\" == typeof t ? t.toString() : t);\n            return t && [\"bigint\", \"string\"].includes(typeof e) ? r.replace(/['\\\\\"]+/g, \"\") : r;\n          }\n          toJSON() {\n            return {\n              name: this.name,\n              code: this.code,\n              message: this.message,\n              innerError: this.innerError\n            };\n          }\n        }\n        t.BaseWeb3Error = r, t.InvalidValueError = class extends r {\n          constructor(e, t) {\n            super(\"Invalid value given \\\"\".concat(r.convertToString(e, !0), \"\\\". Error: \").concat(t, \".\")), this.name = this.constructor.name;\n          }\n        };\n      },\n      9722: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeErrorSignature = void 0;\n        const n = r(9634),\n          i = r(5071),\n          o = r(1583);\n        t.encodeErrorSignature = e => {\n          if (\"string\" != typeof e && !(0, o.isAbiErrorFragment)(e)) throw new i.AbiError(\"Invalid parameter value in encodeErrorSignature\");\n          let t;\n          return t = !e || \"function\" != typeof e && \"object\" != typeof e ? e : (0, o.jsonInterfaceMethodToString)(e), (0, n.sha3Raw)(t);\n        };\n      },\n      5893: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeEventSignature = void 0;\n        const n = r(9634),\n          i = r(5071),\n          o = r(1583);\n        t.encodeEventSignature = e => {\n          if (\"string\" != typeof e && !(0, o.isAbiEventFragment)(e)) throw new i.AbiError(\"Invalid parameter value in encodeEventSignature\");\n          let t;\n          return t = !e || \"function\" != typeof e && \"object\" != typeof e ? e : (0, o.jsonInterfaceMethodToString)(e), (0, n.sha3Raw)(t);\n        };\n      },\n      3249: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeFunctionCall = t.encodeFunctionSignature = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(1583),\n          s = r(4566);\n        t.encodeFunctionSignature = e => {\n          if (\"string\" != typeof e && !(0, o.isAbiFunctionFragment)(e)) throw new n.AbiError(\"Invalid parameter value in encodeFunctionSignature\");\n          let t;\n          return t = !e || \"function\" != typeof e && \"object\" != typeof e ? e : (0, o.jsonInterfaceMethodToString)(e), (0, i.sha3Raw)(t).slice(0, 10);\n        }, t.encodeFunctionCall = (e, r) => {\n          var i;\n          if (!(0, o.isAbiFunctionFragment)(e)) throw new n.AbiError(\"Invalid parameter value in encodeFunctionCall\");\n          return \"\".concat((0, t.encodeFunctionSignature)(e)).concat((0, s.encodeParameters)(null !== (i = e.inputs) && void 0 !== i ? i : [], null != r ? r : []).replace(\"0x\", \"\"));\n        };\n      },\n      734: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeLog = void 0;\n        const n = r(4566),\n          i = [\"bool\", \"string\", \"int\", \"uint\", \"address\", \"fixed\", \"ufixed\"];\n        t.decodeLog = (e, t, r) => {\n          const o = Array.isArray(r) ? r : [r],\n            s = {},\n            a = {};\n          for (const [t, r] of e.entries()) r.indexed ? s[t] = r : a[t] = r;\n          const c = t ? (0, n.decodeParametersWith)(Object.values(a), t, !0) : {\n              __length__: 0\n            },\n            u = o.length - Object.keys(s).length,\n            d = Object.values(s).map((e, t) => {\n              return i.some(t => e.type.startsWith(t)) ? (r = e.type, s = o[t + u], \"string\" === r ? s : (0, n.decodeParameter)(r, s)) : o[t + u];\n              var r, s;\n            }),\n            l = {\n              __length__: 0\n            };\n          let h = 0,\n            f = 0;\n          for (const [t, r] of e.entries()) l[t] = \"string\" === r.type ? \"\" : void 0, s[t] && (l[t] = d[h], h += 1), a[t] && (l[t] = c[String(f)], f += 1), r.name && (l[r.name] = l[t]), l.__length__ += 1;\n          return l;\n        };\n      },\n      4566: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeParameter = t.decodeParameters = t.decodeParametersWith = t.encodeParameter = t.encodeParameters = void 0;\n        const n = r(5071),\n          i = r(6729),\n          o = r(4581);\n        t.encodeParameters = (e, t) => (0, o.encodeParameters)(e, t), t.encodeParameter = (e, r) => (0, t.encodeParameters)([e], [r]), t.decodeParametersWith = (e, t, r) => {\n          try {\n            if (e.length > 0 && (!t || \"0x\" === t || \"0X\" === t)) throw new n.AbiError(\"Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.\");\n            return (0, i.decodeParameters)(e, \"0x\".concat(t.replace(/0x/i, \"\")), r);\n          } catch (e) {\n            throw new n.AbiError(\"Parameter decoding error: \".concat(e.message), {\n              internalErr: e\n            });\n          }\n        }, t.decodeParameters = (e, r) => (0, t.decodeParametersWith)(e, r, !1), t.decodeParameter = (e, r) => (0, t.decodeParameters)([e], r)[0];\n      },\n      1691: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeAddress = t.encodeAddress = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(7345),\n          s = r(3852),\n          a = s.WORD_SIZE - 20;\n        t.encodeAddress = function (e, t) {\n          if (\"string\" != typeof t) throw new n.AbiError(\"address type expects string as input type\", {\n            value: t,\n            name: e.name,\n            type: e.type\n          });\n          let r = t.toLowerCase();\n          if (r.startsWith(\"0x\") || (r = \"0x\".concat(r)), !(0, o.isAddress)(r)) throw new n.AbiError(\"provided input is not valid address\", {\n            value: t,\n            name: e.name,\n            type: e.type\n          });\n          const i = o.utils.hexToUint8Array(r),\n            c = (0, s.alloc)(s.WORD_SIZE);\n          return c.set(i, a), {\n            dynamic: !1,\n            encoded: c\n          };\n        }, t.decodeAddress = function (e, t) {\n          const r = t.subarray(a, s.WORD_SIZE);\n          if (20 !== r.length) throw new n.AbiError(\"Invalid decoding input, not enough bytes to decode address\", {\n            bytes: t\n          });\n          const c = o.utils.uint8ArrayToHexString(r);\n          return {\n            result: (0, i.toChecksumAddress)(c),\n            encoded: t.subarray(s.WORD_SIZE),\n            consumed: s.WORD_SIZE\n          };\n        };\n      },\n      7064: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeArray = t.encodeArray = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(5555),\n          s = r(3852),\n          a = r(8809),\n          c = r(5433);\n        t.encodeArray = function (e, t) {\n          if (!Array.isArray(t)) throw new n.AbiError(\"Expected value to be array\", {\n            abi: e,\n            values: t\n          });\n          const {\n              size: r,\n              param: a\n            } = (0, s.extractArrayType)(e),\n            u = t.map(e => (0, o.encodeParamFromAbiParameter)(a, e)),\n            d = -1 === r,\n            l = u.length > 0 && u[0].dynamic;\n          if (!d && t.length !== r) throw new n.AbiError(\"Given arguments count doesn't match array length\", {\n            arrayLength: r,\n            argumentsLength: t.length\n          });\n          if (d || l) {\n            const e = (0, c.encodeDynamicParams)(u);\n            if (d) {\n              const t = (0, o.encodeNumber)({\n                type: \"uint256\",\n                name: \"\"\n              }, u.length).encoded;\n              return {\n                dynamic: !0,\n                encoded: u.length > 0 ? (0, i.uint8ArrayConcat)(t, e) : t\n              };\n            }\n            return {\n              dynamic: !0,\n              encoded: e\n            };\n          }\n          return {\n            dynamic: !1,\n            encoded: (0, i.uint8ArrayConcat)(...u.map(e => e.encoded))\n          };\n        }, t.decodeArray = function (e, t) {\n          let {\n              size: r,\n              param: n\n            } = (0, s.extractArrayType)(e),\n            i = 0;\n          const c = [];\n          let u = t;\n          if (-1 === r) {\n            const e = (0, a.decodeNumber)({\n              type: \"uint32\",\n              name: \"\"\n            }, t);\n            r = Number(e.result), i = e.consumed, u = e.encoded;\n          }\n          if ((0, s.isDynamic)(n)) {\n            for (let e = 0; e < r; e += 1) {\n              const t = (0, a.decodeNumber)({\n                type: \"uint32\",\n                name: \"\"\n              }, u.subarray(e * s.WORD_SIZE));\n              i += t.consumed;\n              const r = (0, o.decodeParamFromAbiParameter)(n, u.subarray(Number(t.result)));\n              i += r.consumed, c.push(r.result);\n            }\n            return {\n              result: c,\n              encoded: u.subarray(i),\n              consumed: i\n            };\n          }\n          for (let e = 0; e < r; e += 1) {\n            const e = (0, o.decodeParamFromAbiParameter)(n, t.subarray(i));\n            i += e.consumed, c.push(e.result);\n          }\n          return {\n            result: c,\n            encoded: t.subarray(i),\n            consumed: i\n          };\n        };\n      },\n      2252: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeBool = t.encodeBoolean = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(3852),\n          s = r(8809);\n        t.encodeBoolean = function (e, t) {\n          let r;\n          try {\n            r = (0, i.toBool)(t);\n          } catch (r) {\n            if (r instanceof n.InvalidBooleanError) throw new n.AbiError(\"provided input is not valid boolean value\", {\n              type: e.type,\n              value: t,\n              name: e.name\n            });\n          }\n          return (0, s.encodeNumber)({\n            type: \"uint8\",\n            name: \"\"\n          }, Number(r));\n        }, t.decodeBool = function (e, t) {\n          const r = (0, s.decodeNumber)({\n            type: \"uint8\",\n            name: \"\"\n          }, t);\n          if (r.result > 1 || r.result < 0) throw new n.AbiError(\"Invalid boolean value encoded\", {\n            boolBytes: t.subarray(0, o.WORD_SIZE),\n            numberResult: r\n          });\n          return {\n            result: r.result === BigInt(1),\n            encoded: r.encoded,\n            consumed: o.WORD_SIZE\n          };\n        };\n      },\n      7144: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeBytes = t.encodeBytes = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(7345),\n          s = r(3852),\n          a = r(8809);\n        t.encodeBytes = function (e, t) {\n          if (\"string\" == typeof t && t.length % 2 != 0 && (t += \"0\"), !(0, o.isBytes)(t)) throw new n.AbiError(\"provided input is not valid bytes value\", {\n            type: e.type,\n            value: t,\n            name: e.name\n          });\n          const r = (0, i.bytesToUint8Array)(t),\n            [, c] = e.type.split(\"bytes\");\n          if (c) {\n            if (Number(c) > 32 || Number(c) < 1) throw new n.AbiError(\"invalid bytes type. Static byte type can have between 1 and 32 bytes\", {\n              type: e.type\n            });\n            if (Number(c) < r.length) throw new n.AbiError(\"provided input size is different than type size\", {\n              type: e.type,\n              value: t,\n              name: e.name\n            });\n            const i = (0, s.alloc)(s.WORD_SIZE);\n            return i.set(r), {\n              dynamic: !1,\n              encoded: i\n            };\n          }\n          const u = Math.ceil(r.length / s.WORD_SIZE),\n            d = (0, s.alloc)(s.WORD_SIZE + u * s.WORD_SIZE);\n          return d.set((0, a.encodeNumber)({\n            type: \"uint32\",\n            name: \"\"\n          }, r.length).encoded), d.set(r, s.WORD_SIZE), {\n            dynamic: !0,\n            encoded: d\n          };\n        }, t.decodeBytes = function (e, t) {\n          const [, r] = e.type.split(\"bytes\");\n          let o = Number(r),\n            c = t,\n            u = 1,\n            d = 0;\n          if (!o) {\n            const e = (0, a.decodeNumber)({\n              type: \"uint32\",\n              name: \"\"\n            }, c);\n            o = Number(e.result), d += e.consumed, c = e.encoded, u = Math.ceil(o / s.WORD_SIZE);\n          }\n          if (o > t.length) throw new n.AbiError(\"there is not enough data to decode\", {\n            type: e.type,\n            encoded: t,\n            size: o\n          });\n          return {\n            result: (0, i.bytesToHex)(c.subarray(0, o)),\n            encoded: c.subarray(u * s.WORD_SIZE),\n            consumed: d + u * s.WORD_SIZE\n          };\n        };\n      },\n      5555: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeParamFromAbiParameter = t.encodeParamFromAbiParameter = t.decodeArray = t.encodeArray = t.decodeTuple = t.encodeTuple = t.decodeString = t.encodeString = t.decodeNumber = t.encodeNumber = t.decodeBytes = t.encodeBytes = t.decodeBool = t.encodeBoolean = t.decodeAddress = t.encodeAddress = void 0;\n        const n = r(1691),\n          i = r(2252),\n          o = r(7144),\n          s = r(8809),\n          a = r(8574),\n          c = r(4759),\n          u = r(7064);\n        var d = r(1691);\n        Object.defineProperty(t, \"encodeAddress\", {\n          enumerable: !0,\n          get: function get() {\n            return d.encodeAddress;\n          }\n        }), Object.defineProperty(t, \"decodeAddress\", {\n          enumerable: !0,\n          get: function get() {\n            return d.decodeAddress;\n          }\n        });\n        var l = r(2252);\n        Object.defineProperty(t, \"encodeBoolean\", {\n          enumerable: !0,\n          get: function get() {\n            return l.encodeBoolean;\n          }\n        }), Object.defineProperty(t, \"decodeBool\", {\n          enumerable: !0,\n          get: function get() {\n            return l.decodeBool;\n          }\n        });\n        var h = r(7144);\n        Object.defineProperty(t, \"encodeBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return h.encodeBytes;\n          }\n        }), Object.defineProperty(t, \"decodeBytes\", {\n          enumerable: !0,\n          get: function get() {\n            return h.decodeBytes;\n          }\n        });\n        var f = r(8809);\n        Object.defineProperty(t, \"encodeNumber\", {\n          enumerable: !0,\n          get: function get() {\n            return f.encodeNumber;\n          }\n        }), Object.defineProperty(t, \"decodeNumber\", {\n          enumerable: !0,\n          get: function get() {\n            return f.decodeNumber;\n          }\n        });\n        var p = r(8574);\n        Object.defineProperty(t, \"encodeString\", {\n          enumerable: !0,\n          get: function get() {\n            return p.encodeString;\n          }\n        }), Object.defineProperty(t, \"decodeString\", {\n          enumerable: !0,\n          get: function get() {\n            return p.decodeString;\n          }\n        });\n        var m = r(4759);\n        Object.defineProperty(t, \"encodeTuple\", {\n          enumerable: !0,\n          get: function get() {\n            return m.encodeTuple;\n          }\n        }), Object.defineProperty(t, \"decodeTuple\", {\n          enumerable: !0,\n          get: function get() {\n            return m.decodeTuple;\n          }\n        });\n        var g = r(7064);\n        Object.defineProperty(t, \"encodeArray\", {\n          enumerable: !0,\n          get: function get() {\n            return g.encodeArray;\n          }\n        }), Object.defineProperty(t, \"decodeArray\", {\n          enumerable: !0,\n          get: function get() {\n            return g.decodeArray;\n          }\n        }), t.encodeParamFromAbiParameter = function (e, t) {\n          if (\"string\" === e.type) return (0, a.encodeString)(e, t);\n          if (\"bool\" === e.type) return (0, i.encodeBoolean)(e, t);\n          if (\"address\" === e.type) return (0, n.encodeAddress)(e, t);\n          if (\"tuple\" === e.type) return (0, c.encodeTuple)(e, t);\n          if (e.type.endsWith(\"]\")) return (0, u.encodeArray)(e, t);\n          if (e.type.startsWith(\"bytes\")) return (0, o.encodeBytes)(e, t);\n          if (e.type.startsWith(\"uint\") || e.type.startsWith(\"int\")) return (0, s.encodeNumber)(e, t);\n          throw new Error(\"Unsupported\");\n        }, t.decodeParamFromAbiParameter = function (e, t) {\n          if (\"string\" === e.type) return (0, a.decodeString)(e, t);\n          if (\"bool\" === e.type) return (0, i.decodeBool)(e, t);\n          if (\"address\" === e.type) return (0, n.decodeAddress)(e, t);\n          if (\"tuple\" === e.type) return (0, c.decodeTuple)(e, t);\n          if (e.type.endsWith(\"]\")) return (0, u.decodeArray)(e, t);\n          if (e.type.startsWith(\"bytes\")) return (0, o.decodeBytes)(e, t);\n          if (e.type.startsWith(\"uint\") || e.type.startsWith(\"int\")) return (0, s.decodeNumber)(e, t);\n          throw new Error(\"Unsupported\");\n        };\n      },\n      8809: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeNumber = t.encodeNumber = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(7345),\n          s = r(3852),\n          a = r(5978),\n          c = BigInt(1) << BigInt(256);\n        function u(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : s.WORD_SIZE;\n          let r;\n          return r = e < 0 ? (c + e).toString(16) : e.toString(16), r = (0, i.padLeft)(r, 2 * t), o.utils.hexToUint8Array(r);\n        }\n        t.encodeNumber = function (e, t) {\n          let r;\n          try {\n            r = (0, i.toBigInt)(t);\n          } catch (r) {\n            throw new n.AbiError(\"provided input is not number value\", {\n              type: e.type,\n              value: t,\n              name: e.name\n            });\n          }\n          const o = a.numberLimits.get(e.type);\n          if (!o) throw new n.AbiError(\"provided abi contains invalid number datatype\", {\n            type: e.type\n          });\n          if (r < o.min) throw new n.AbiError(\"provided input is less then minimum for given type\", {\n            type: e.type,\n            value: t,\n            name: e.name,\n            minimum: o.min.toString()\n          });\n          if (r > o.max) throw new n.AbiError(\"provided input is greater then maximum for given type\", {\n            type: e.type,\n            value: t,\n            name: e.name,\n            maximum: o.max.toString()\n          });\n          return {\n            dynamic: !1,\n            encoded: u(r)\n          };\n        }, t.decodeNumber = function (e, t) {\n          if (t.length < s.WORD_SIZE) throw new n.AbiError(\"Not enough bytes left to decode\", {\n            param: e,\n            bytesLeft: t.length\n          });\n          const r = t.subarray(0, s.WORD_SIZE),\n            i = a.numberLimits.get(e.type);\n          if (!i) throw new n.AbiError(\"provided abi contains invalid number datatype\", {\n            type: e.type\n          });\n          const u = function (e, t) {\n            const r = o.utils.uint8ArrayToHexString(e),\n              n = BigInt(r);\n            return n <= t ? n : n - c;\n          }(r, i.max);\n          if (u < i.min) throw new n.AbiError(\"decoded value is less then minimum for given type\", {\n            type: e.type,\n            value: u,\n            name: e.name,\n            minimum: i.min.toString()\n          });\n          if (u > i.max) throw new n.AbiError(\"decoded value is greater then maximum for given type\", {\n            type: e.type,\n            value: u,\n            name: e.name,\n            maximum: i.max.toString()\n          });\n          return {\n            result: u,\n            encoded: t.subarray(s.WORD_SIZE),\n            consumed: s.WORD_SIZE\n          };\n        };\n      },\n      5978: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.numberLimits = void 0, t.numberLimits = new Map();\n        let r = BigInt(256);\n        for (let e = 8; e <= 256; e += 8) t.numberLimits.set(\"uint\".concat(e), {\n          min: BigInt(0),\n          max: r - BigInt(1)\n        }), t.numberLimits.set(\"int\".concat(e), {\n          min: -r / BigInt(2),\n          max: r / BigInt(2) - BigInt(1)\n        }), r *= BigInt(256);\n        t.numberLimits.set(\"int\", t.numberLimits.get(\"int256\")), t.numberLimits.set(\"uint\", t.numberLimits.get(\"uint256\"));\n      },\n      8574: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeString = t.encodeString = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(7144);\n        t.encodeString = function (e, t) {\n          if (\"string\" != typeof t) throw new n.AbiError(\"invalid input, should be string\", {\n            input: t\n          });\n          const r = (0, i.utf8ToBytes)(t);\n          return (0, o.encodeBytes)({\n            type: \"bytes\",\n            name: \"\"\n          }, r);\n        }, t.decodeString = function (e, t) {\n          const r = (0, o.decodeBytes)({\n            type: \"bytes\",\n            name: \"\"\n          }, t);\n          return {\n            result: (0, i.hexToUtf8)(r.result),\n            encoded: r.encoded,\n            consumed: r.consumed\n          };\n        };\n      },\n      4759: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeTuple = t.encodeTuple = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(5555),\n          s = r(5433),\n          a = r(3852),\n          c = r(8809);\n        t.encodeTuple = function (e, t) {\n          var r, a, c;\n          let u = !1;\n          if (!Array.isArray(t) && \"object\" != typeof t) throw new n.AbiError(\"param must be either Array or Object\", {\n            param: e,\n            input: t\n          });\n          const d = t,\n            l = [];\n          for (let i = 0; i < (null !== (a = null === (r = e.components) || void 0 === r ? void 0 : r.length) && void 0 !== a ? a : 0); i += 1) {\n            const r = e.components[i];\n            let s;\n            if (Array.isArray(d)) {\n              if (i >= d.length) throw new n.AbiError(\"input param length missmatch\", {\n                param: e,\n                input: t\n              });\n              s = (0, o.encodeParamFromAbiParameter)(r, d[i]);\n            } else {\n              const i = d[null !== (c = r.name) && void 0 !== c ? c : \"\"];\n              if (null == i) throw new n.AbiError(\"missing input defined in abi\", {\n                param: e,\n                input: t,\n                paramName: r.name\n              });\n              s = (0, o.encodeParamFromAbiParameter)(r, i);\n            }\n            s.dynamic && (u = !0), l.push(s);\n          }\n          return u ? {\n            dynamic: !0,\n            encoded: (0, s.encodeDynamicParams)(l)\n          } : {\n            dynamic: !1,\n            encoded: (0, i.uint8ArrayConcat)(...l.map(e => e.encoded))\n          };\n        }, t.decodeTuple = function (e, t) {\n          const r = {\n            __length__: 0\n          };\n          let n = 0;\n          if (!e.components) return {\n            result: r,\n            encoded: t,\n            consumed: n\n          };\n          let i = 0;\n          for (const [s, u] of e.components.entries()) {\n            let e;\n            if ((0, a.isDynamic)(u)) {\n              const r = (0, c.decodeNumber)({\n                type: \"uint32\",\n                name: \"\"\n              }, t.subarray(n));\n              e = (0, o.decodeParamFromAbiParameter)(u, t.subarray(Number(r.result))), n += r.consumed, i += e.consumed;\n            } else e = (0, o.decodeParamFromAbiParameter)(u, t.subarray(n)), n += e.consumed;\n            r.__length__ += 1, r[s] = e.result, u.name && \"\" !== u.name && (r[u.name] = e.result);\n          }\n          return {\n            encoded: t.subarray(n + i),\n            result: r,\n            consumed: n + i\n          };\n        };\n      },\n      5433: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeDynamicParams = void 0;\n        const n = r(9634),\n          i = r(3852),\n          o = r(8809);\n        t.encodeDynamicParams = function (e) {\n          let t = 0,\n            r = 0;\n          const s = [],\n            a = [];\n          for (const r of e) r.dynamic ? t += i.WORD_SIZE : t += r.encoded.length;\n          for (const n of e) n.dynamic ? (s.push((0, o.encodeNumber)({\n            type: \"uint256\",\n            name: \"\"\n          }, t + r)), a.push(n), r += n.encoded.length) : s.push(n);\n          return (0, n.uint8ArrayConcat)(...s.map(e => e.encoded), ...a.map(e => e.encoded));\n        };\n      },\n      6729: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeParameters = void 0;\n        const n = r(7345),\n          i = r(4759),\n          o = r(3852);\n        t.decodeParameters = function (e, t, r) {\n          const s = (0, o.toAbiParams)(e),\n            a = n.utils.hexToUint8Array(t);\n          return (0, i.decodeTuple)({\n            type: \"tuple\",\n            name: \"\",\n            components: s\n          }, a).result;\n        };\n      },\n      4581: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeParameters = void 0;\n        const n = r(5071),\n          i = r(7345),\n          o = r(5555),\n          s = r(3852);\n        t.encodeParameters = function (e, t) {\n          if (e.length !== t.length) throw new n.AbiError(\"Invalid number of values received for given ABI\", {\n            expected: e.length,\n            received: t.length\n          });\n          const r = (0, s.toAbiParams)(e);\n          return i.utils.uint8ArrayToHexString((0, o.encodeTuple)({\n            type: \"tuple\",\n            name: \"\",\n            components: r\n          }, t).encoded);\n        };\n      },\n      3852: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isDynamic = t.extractArrayType = t.toAbiParams = t.isAbiParameter = t.convertExternalAbiParameter = t.allocUnsafe = t.alloc = t.WORD_SIZE = void 0;\n        const n = r(3879),\n          i = r(5071),\n          o = r(9634),\n          s = r(1583);\n        function a(e) {\n          var t, r;\n          return Object.assign(Object.assign({}, e), {\n            name: null !== (t = e.name) && void 0 !== t ? t : \"\",\n            components: null === (r = e.components) || void 0 === r ? void 0 : r.map(e => a(e))\n          });\n        }\n        function c(e) {\n          return !(0, o.isNullish)(e) && \"object\" == typeof e && !(0, o.isNullish)(e.type) && \"string\" == typeof e.type;\n        }\n        function u(e) {\n          const t = e.type.lastIndexOf(\"[\"),\n            r = e.type.substring(0, t),\n            n = e.type.substring(t);\n          let o = -1;\n          if (\"[]\" !== n && (o = Number(n.slice(1, -1)), isNaN(o))) throw new i.AbiError(\"Invalid fixed array size\", {\n            size: n\n          });\n          return {\n            param: {\n              type: r,\n              name: \"\",\n              components: e.components\n            },\n            size: o\n          };\n        }\n        t.WORD_SIZE = 32, t.alloc = function () {\n          let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var t;\n          if (void 0 !== (null === (t = globalThis.Buffer) || void 0 === t ? void 0 : t.alloc)) {\n            const t = globalThis.Buffer.alloc(e);\n            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n          }\n          return new Uint8Array(e);\n        }, t.allocUnsafe = function () {\n          let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var t;\n          if (void 0 !== (null === (t = globalThis.Buffer) || void 0 === t ? void 0 : t.allocUnsafe)) {\n            const t = globalThis.Buffer.allocUnsafe(e);\n            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n          }\n          return new Uint8Array(e);\n        }, t.convertExternalAbiParameter = a, t.isAbiParameter = c, t.toAbiParams = function (e) {\n          return e.map(e => {\n            var t;\n            if (c(e)) return e;\n            if (\"string\" == typeof e) return a((0, n.parseAbiParameter)(e.replace(/tuple/, \"\")));\n            if ((0, s.isSimplifiedStructFormat)(e)) {\n              const r = Object.keys(e)[0],\n                n = (0, s.mapStructNameAndType)(r);\n              return n.name = null !== (t = n.name) && void 0 !== t ? t : \"\", Object.assign(Object.assign({}, n), {\n                components: (0, s.mapStructToCoderFormat)(e[r])\n              });\n            }\n            throw new i.AbiError(\"Invalid abi\");\n          });\n        }, t.extractArrayType = u, t.isDynamic = function e(t) {\n          var r, n;\n          return !(\"string\" !== t.type && \"bytes\" !== t.type && !t.type.endsWith(\"[]\")) || (\"tuple\" === t.type ? null !== (n = null === (r = t.components) || void 0 === r ? void 0 : r.some(e)) && void 0 !== n && n : !!t.type.endsWith(\"]\") && e(u(t).param));\n        };\n      },\n      5610: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeContractErrorData = void 0;\n        const n = r(9722),\n          i = r(4566),\n          o = r(1583);\n        t.decodeContractErrorData = (e, t) => {\n          if (null == t ? void 0 : t.data) {\n            let r, s, a;\n            try {\n              const c = t.data.slice(0, 10),\n                u = e.find(e => (0, n.encodeErrorSignature)(e).startsWith(c));\n              (null == u ? void 0 : u.inputs) && (r = u.name, s = (0, o.jsonInterfaceMethodToString)(u), a = (0, i.decodeParameters)([...u.inputs], t.data.substring(10)));\n            } catch (e) {\n              console.error(e);\n            }\n            r && t.setDecodedProperties(r, s, a);\n          }\n        };\n      },\n      6329: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getMessage = void 0;\n        const n = r(9634),\n          i = r(4581),\n          o = /^\\w+/,\n          s = /^(.*)\\[([0-9]*?)]$/,\n          a = function a(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n            const n = t.match(o)[0];\n            return r.includes(n) ? r : e.types[n] ? [n, ...e.types[n].reduce((t, r) => [...t, ...a(e, r.type, t).filter(e => !t.includes(e))], [])] : r;\n          },\n          c = (e, t) => (0, n.keccak256)(((e, t) => {\n            const [r, ...n] = a(e, t);\n            return [r, ...n.sort()].map(t => \"\".concat(t, \"(\").concat(e.types[t].map(e => \"\".concat(e.type, \" \").concat(e.name)), \")\")).join(\"\");\n          })(e, t)),\n          u = (e, t, r) => (0, n.keccak256)(l(e, t, r));\n        t.getMessage = (e, t) => {\n          const r = \"0x1901\".concat(u(e, \"EIP712Domain\", e.domain).substring(2)).concat(u(e, e.primaryType, e.message).substring(2));\n          return t ? (0, n.keccak256)(r) : r;\n        };\n        const d = (e, t, r) => {\n            const o = t.match(s);\n            if (o) {\n              const t = o[1],\n                s = Number(o[2]) || void 0;\n              if (!Array.isArray(r)) throw new Error(\"Cannot encode data: value is not of array type\");\n              if (s && r.length !== s) throw new Error(\"Cannot encode data: expected length of \".concat(s, \", but got \").concat(r.length));\n              const a = r.map(r => d(e, t, r)),\n                c = a.map(e => e[0]),\n                u = a.map(e => e[1]);\n              return [\"bytes32\", (0, n.keccak256)((0, i.encodeParameters)(c, u))];\n            }\n            return e.types[t] ? [\"bytes32\", u(e, t, r)] : \"string\" === t || \"bytes\" === t ? [\"bytes32\", (0, n.keccak256)(r)] : [t, r];\n          },\n          l = (e, t, r) => {\n            const [o, s] = e.types[t].reduce((_ref21, o) => {\n              let [t, i] = _ref21;\n              if ((0, n.isNullish)(r[o.name]) || (0, n.isNullish)(r[o.name])) throw new Error(\"Cannot encode data: missing data for '\".concat(o.name, \"'\"));\n              const s = r[o.name],\n                [a, c] = d(e, o.type, s);\n              return [[...t, a], [...i, c]];\n            }, [[\"bytes32\"], [c(e, t)]]);\n            return (0, i.encodeParameters)(o, s);\n          };\n      },\n      8381: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getEncodedEip712Data = void 0, i(r(9722), t), i(r(5893), t), i(r(3249), t), i(r(734), t), i(r(4566), t), i(r(1583), t), i(r(5610), t);\n        var o = r(6329);\n        Object.defineProperty(t, \"getEncodedEip712Data\", {\n          enumerable: !0,\n          get: function get() {\n            return o.getMessage;\n          }\n        });\n      },\n      1583: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.jsonInterfaceMethodToString = t.flattenTypes = t.formatParam = t.formatOddHexstrings = t.isOddHexstring = t.mapTypes = t.mapStructToCoderFormat = t.mapStructNameAndType = t.isSimplifiedStructFormat = t.isAbiConstructorFragment = t.isAbiFunctionFragment = t.isAbiEventFragment = t.isAbiErrorFragment = t.isAbiFragment = void 0;\n        const n = r(5071),\n          i = r(9634);\n        t.isAbiFragment = e => !(0, i.isNullish)(e) && \"object\" == typeof e && !(0, i.isNullish)(e.type) && [\"function\", \"event\", \"constructor\", \"error\"].includes(e.type), t.isAbiErrorFragment = e => !(0, i.isNullish)(e) && \"object\" == typeof e && !(0, i.isNullish)(e.type) && \"error\" === e.type, t.isAbiEventFragment = e => !(0, i.isNullish)(e) && \"object\" == typeof e && !(0, i.isNullish)(e.type) && \"event\" === e.type, t.isAbiFunctionFragment = e => !(0, i.isNullish)(e) && \"object\" == typeof e && !(0, i.isNullish)(e.type) && \"function\" === e.type, t.isAbiConstructorFragment = e => !(0, i.isNullish)(e) && \"object\" == typeof e && !(0, i.isNullish)(e.type) && \"constructor\" === e.type, t.isSimplifiedStructFormat = e => \"object\" == typeof e && void 0 === e.components && void 0 === e.name, t.mapStructNameAndType = e => e.includes(\"[]\") ? {\n          type: \"tuple[]\",\n          name: e.slice(0, -2)\n        } : {\n          type: \"tuple\",\n          name: e\n        }, t.mapStructToCoderFormat = e => {\n          const r = [];\n          for (const n of Object.keys(e)) {\n            const i = e[n];\n            \"object\" == typeof i ? r.push(Object.assign(Object.assign({}, (0, t.mapStructNameAndType)(n)), {\n              components: (0, t.mapStructToCoderFormat)(i)\n            })) : r.push({\n              name: n,\n              type: e[n]\n            });\n          }\n          return r;\n        }, t.mapTypes = e => {\n          const r = [];\n          for (const n of e) {\n            let e = n;\n            if (\"object\" == typeof n && (e = Object.assign({}, n)), \"object\" == typeof n && \"function\" === n.type && (e = Object.assign(Object.assign({}, n), {\n              type: \"bytes24\"\n            })), (0, t.isSimplifiedStructFormat)(e)) {\n              const n = Object.keys(e)[0];\n              r.push(Object.assign(Object.assign({}, (0, t.mapStructNameAndType)(n)), {\n                components: (0, t.mapStructToCoderFormat)(e[n])\n              }));\n            } else r.push(e);\n          }\n          return r;\n        }, t.isOddHexstring = e => \"string\" == typeof e && /^(-)?0x[0-9a-f]*$/i.test(e) && e.length % 2 == 1, t.formatOddHexstrings = e => (0, t.isOddHexstring)(e) ? \"0x0\".concat(e.substring(2)) : e, t.formatParam = (e, r) => {\n          var n;\n          const o = \"object\" != typeof r || Array.isArray(r) ? r : Object.assign({}, r);\n          if (o instanceof BigInt) return o.toString(10);\n          if (/^bytes([0-9]*)\\[\\]$/.exec(e) || /^(u?int)([0-9]*)\\[\\]$/.exec(e)) return [...o].map(r => (0, t.formatParam)(e.replace(\"[]\", \"\"), r));\n          let s = /^(u?int)([0-9]*)$/.exec(e);\n          if (s) {\n            const e = parseInt(null !== (n = s[2]) && void 0 !== n ? n : \"256\", 10);\n            if (e / 8 < o.length) return (0, i.leftPad)(o, e);\n          }\n          if (s = /^bytes([0-9]*)$/.exec(e), s) {\n            const e = o instanceof Uint8Array ? (0, i.toHex)(o) : o,\n              r = parseInt(s[1], 10);\n            if (r) {\n              let n = 2 * r;\n              o.startsWith(\"0x\") && (n += 2);\n              const s = e.length < n ? (0, i.rightPad)(o, 2 * r) : e;\n              return (0, t.formatOddHexstrings)(s);\n            }\n            return (0, t.formatOddHexstrings)(e);\n          }\n          return o;\n        }, t.flattenTypes = (e, r) => {\n          const i = [];\n          return r.forEach(r => {\n            if (\"object\" == typeof r.components) {\n              if (!r.type.startsWith(\"tuple\")) throw new n.AbiError(\"Invalid value given \\\"\".concat(r.type, \"\\\". Error: components found but type is not tuple.\"));\n              const o = r.type.indexOf(\"[\"),\n                s = o >= 0 ? r.type.substring(o) : \"\",\n                a = (0, t.flattenTypes)(e, r.components);\n              Array.isArray(a) && e ? i.push(\"tuple(\".concat(a.join(\",\"), \")\").concat(s)) : e ? i.push(\"(\".concat(a.join(), \")\")) : i.push(\"(\".concat(a.join(\",\"), \")\").concat(s));\n            } else i.push(r.type);\n          }), i;\n        }, t.jsonInterfaceMethodToString = e => {\n          var r, n, i, o;\n          return (0, t.isAbiErrorFragment)(e) || (0, t.isAbiEventFragment)(e) || (0, t.isAbiFunctionFragment)(e) ? (null === (r = e.name) || void 0 === r ? void 0 : r.includes(\"(\")) ? e.name : \"\".concat(null !== (n = e.name) && void 0 !== n ? n : \"\", \"(\").concat((0, t.flattenTypes)(!1, null !== (i = e.inputs) && void 0 !== i ? i : []).join(\",\"), \")\") : \"(\".concat((0, t.flattenTypes)(!1, null !== (o = e.inputs) && void 0 !== o ? o : []).join(\",\"), \")\");\n        };\n      },\n      1560: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decrypt = t.create = t.privateKeyToAccount = t.encrypt = t.privateKeyToPublicKey = t.privateKeyToAddress = t.recover = t.recoverTransaction = t.signTransaction = t.sign = t.hashMessage = t.parseAndValidatePrivateKey = void 0;\n        const i = r(3072),\n          o = r(8109),\n          s = r(7002),\n          a = r(5071),\n          c = r(9634),\n          u = r(7345),\n          d = r(4555),\n          l = r(5774),\n          h = r(7668);\n        t.parseAndValidatePrivateKey = (e, t) => {\n          let r;\n          if (!t && \"string\" == typeof e && (0, u.isHexStrict)(e) && 66 !== e.length) throw new a.PrivateKeyLengthError();\n          try {\n            r = e instanceof Uint8Array ? e : (0, c.bytesToUint8Array)(e);\n          } catch (e) {\n            throw new a.InvalidPrivateKeyError();\n          }\n          if (!t && 32 !== r.byteLength) throw new a.PrivateKeyLengthError();\n          return r;\n        }, t.hashMessage = e => {\n          const t = (0, u.isHexStrict)(e) ? e : (0, c.utf8ToHex)(e),\n            r = (0, c.hexToBytes)(t),\n            n = (0, c.hexToBytes)((0, c.fromUtf8)(\"\\x19Ethereum Signed Message:\\n\".concat(r.byteLength))),\n            i = (0, c.uint8ArrayConcat)(n, r);\n          return (0, c.sha3Raw)(i);\n        }, t.sign = (e, r) => {\n          const n = (0, t.parseAndValidatePrivateKey)(r),\n            i = (0, t.hashMessage)(e),\n            o = d.secp256k1.sign(i.substring(2), n),\n            s = o.toCompactRawBytes(),\n            a = o.r.toString(16).padStart(64, \"0\"),\n            u = o.s.toString(16).padStart(64, \"0\"),\n            l = o.recovery + 27;\n          return {\n            message: e,\n            messageHash: i,\n            v: (0, c.numberToHex)(l),\n            r: \"0x\".concat(a),\n            s: \"0x\".concat(u),\n            signature: \"\".concat((0, c.bytesToHex)(s)).concat(l.toString(16))\n          };\n        }, t.signTransaction = (e, t) => n(void 0, void 0, void 0, function* () {\n          const r = e.sign((0, c.hexToBytes)(t));\n          if ((0, u.isNullish)(r.v) || (0, u.isNullish)(r.r) || (0, u.isNullish)(r.s)) throw new a.TransactionSigningError(\"Signer Error\");\n          const n = r.validate(!0);\n          if (n.length > 0) {\n            let e = \"Signer Error \";\n            for (const t of n) e += \"\".concat(e, \" \").concat(t, \".\");\n            throw new a.TransactionSigningError(e);\n          }\n          const i = (0, c.bytesToHex)(r.serialize()),\n            o = (0, c.sha3Raw)(i);\n          return {\n            messageHash: (0, c.bytesToHex)(r.getMessageToSign(!0)),\n            v: \"0x\".concat(r.v.toString(16)),\n            r: \"0x\".concat(r.r.toString(16).padStart(64, \"0\")),\n            s: \"0x\".concat(r.s.toString(16).padStart(64, \"0\")),\n            rawTransaction: i,\n            transactionHash: (0, c.bytesToHex)(o)\n          };\n        }), t.recoverTransaction = e => {\n          if ((0, u.isNullish)(e)) throw new a.UndefinedRawTransactionError();\n          const t = h.TransactionFactory.fromSerializedData((0, c.hexToBytes)(e));\n          return (0, c.toChecksumAddress)(t.getSenderAddress().toString());\n        }, t.recover = (e, r, n, i, o) => {\n          if (\"object\" == typeof e) {\n            const r = \"\".concat(e.r).concat(e.s.slice(2)).concat(e.v.slice(2));\n            return (0, t.recover)(e.messageHash, r, n);\n          }\n          if (\"string\" == typeof r && \"string\" == typeof n && !(0, u.isNullish)(i)) {\n            const s = \"\".concat(n).concat(i.slice(2)).concat(r.slice(2));\n            return (0, t.recover)(e, s, o);\n          }\n          if ((0, u.isNullish)(r)) throw new a.InvalidSignatureError(\"signature string undefined\");\n          const s = n ? e : (0, t.hashMessage)(e);\n          let l = parseInt(r.substring(130), 16);\n          l > 26 && (l -= 27);\n          const h = d.secp256k1.Signature.fromCompact(r.slice(2, 130)).addRecoveryBit(l).recoverPublicKey(s.replace(\"0x\", \"\")).toRawBytes(!1),\n            f = (0, c.sha3Raw)(h.subarray(1));\n          return (0, c.toChecksumAddress)(\"0x\".concat(f.slice(-40)));\n        }, t.privateKeyToAddress = e => {\n          const r = (0, t.parseAndValidatePrivateKey)(e),\n            n = d.secp256k1.getPublicKey(r, !1),\n            i = (0, c.sha3Raw)(n.slice(1)).slice(-40);\n          return (0, c.toChecksumAddress)(\"0x\".concat(i));\n        }, t.privateKeyToPublicKey = (e, r) => {\n          const n = (0, t.parseAndValidatePrivateKey)(e);\n          return \"0x\".concat((0, c.bytesToHex)(d.secp256k1.getPublicKey(n, r)).slice(4));\n        }, t.encrypt = (e, r, d) => n(void 0, void 0, void 0, function* () {\n          var n, l, h, f, p, m, g;\n          const y = (0, t.parseAndValidatePrivateKey)(e);\n          let v;\n          if (v = (null == d ? void 0 : d.salt) ? \"string\" == typeof d.salt ? (0, c.hexToBytes)(d.salt) : d.salt : (0, c.randomBytes)(32), !((0, u.isString)(r) || r instanceof Uint8Array)) throw new a.InvalidPasswordError();\n          const b = \"string\" == typeof r ? (0, c.hexToBytes)((0, c.utf8ToHex)(r)) : r;\n          let E;\n          if (null == d ? void 0 : d.iv) {\n            if (E = \"string\" == typeof d.iv ? (0, c.hexToBytes)(d.iv) : d.iv, 16 !== E.length) throw new a.IVLengthError();\n          } else E = (0, c.randomBytes)(16);\n          const _ = null !== (n = null == d ? void 0 : d.kdf) && void 0 !== n ? n : \"scrypt\";\n          let A, T;\n          if (\"pbkdf2\" === _) {\n            if (T = {\n              dklen: null !== (l = null == d ? void 0 : d.dklen) && void 0 !== l ? l : 32,\n              salt: (0, c.bytesToHex)(v).replace(\"0x\", \"\"),\n              c: null !== (h = null == d ? void 0 : d.c) && void 0 !== h ? h : 262144,\n              prf: \"hmac-sha256\"\n            }, T.c < 1e3) throw new a.PBKDF2IterationsError();\n            A = (0, o.pbkdf2Sync)(b, v, T.c, T.dklen, \"sha256\");\n          } else {\n            if (\"scrypt\" !== _) throw new a.InvalidKdfError();\n            T = {\n              n: null !== (f = null == d ? void 0 : d.n) && void 0 !== f ? f : 8192,\n              r: null !== (p = null == d ? void 0 : d.r) && void 0 !== p ? p : 8,\n              p: null !== (m = null == d ? void 0 : d.p) && void 0 !== m ? m : 1,\n              dklen: null !== (g = null == d ? void 0 : d.dklen) && void 0 !== g ? g : 32,\n              salt: (0, c.bytesToHex)(v).replace(\"0x\", \"\")\n            }, A = (0, s.scryptSync)(b, v, T.n, T.p, T.r, T.dklen);\n          }\n          const I = yield (0, i.encrypt)(y, A.slice(0, 16), E, \"aes-128-ctr\"),\n            R = (0, c.bytesToHex)(I).slice(2),\n            w = (0, c.sha3Raw)((0, c.uint8ArrayConcat)(A.slice(16, 32), I)).replace(\"0x\", \"\");\n          return {\n            version: 3,\n            id: (0, c.uuidV4)(),\n            address: (0, t.privateKeyToAddress)(y).toLowerCase().replace(\"0x\", \"\"),\n            crypto: {\n              ciphertext: R,\n              cipherparams: {\n                iv: (0, c.bytesToHex)(E).replace(\"0x\", \"\")\n              },\n              cipher: \"aes-128-ctr\",\n              kdf: _,\n              kdfparams: T,\n              mac: w\n            }\n          };\n        }), t.privateKeyToAccount = (e, r) => {\n          const i = (0, t.parseAndValidatePrivateKey)(e, r);\n          return {\n            address: (0, t.privateKeyToAddress)(i),\n            privateKey: (0, c.bytesToHex)(i),\n            signTransaction: e => {\n              throw new a.TransactionSigningError(\"Do not have network access to sign the transaction\");\n            },\n            sign: e => (0, t.sign)(\"string\" == typeof e ? e : JSON.stringify(e), i),\n            encrypt: (e, r) => n(void 0, void 0, void 0, function* () {\n              return (0, t.encrypt)(i, e, r);\n            })\n          };\n        }, t.create = () => {\n          const e = d.secp256k1.utils.randomPrivateKey();\n          return (0, t.privateKeyToAccount)(\"\".concat((0, c.bytesToHex)(e)));\n        }, t.decrypt = (e, r, d) => n(void 0, void 0, void 0, function* () {\n          const n = \"object\" == typeof e ? e : JSON.parse(d ? e.toLowerCase() : e);\n          if (u.validator.validateJSONSchema(l.keyStoreSchema, n), 3 !== n.version) throw new a.KeyStoreVersionError();\n          const h = \"string\" == typeof r ? (0, c.hexToBytes)((0, c.utf8ToHex)(r)) : r;\n          let f;\n          if (u.validator.validate([\"bytes\"], [h]), \"scrypt\" === n.crypto.kdf) {\n            const e = n.crypto.kdfparams,\n              t = \"string\" == typeof e.salt ? (0, c.hexToBytes)(e.salt) : e.salt;\n            f = (0, s.scryptSync)(h, t, e.n, e.p, e.r, e.dklen);\n          } else {\n            if (\"pbkdf2\" !== n.crypto.kdf) throw new a.InvalidKdfError();\n            {\n              const e = n.crypto.kdfparams,\n                t = \"string\" == typeof e.salt ? (0, c.hexToBytes)(e.salt) : e.salt;\n              f = (0, o.pbkdf2Sync)(h, t, e.c, e.dklen, \"sha256\");\n            }\n          }\n          const p = (0, c.hexToBytes)(n.crypto.ciphertext);\n          if ((0, c.sha3Raw)((0, c.uint8ArrayConcat)(f.slice(16, 32), p)).replace(\"0x\", \"\") !== n.crypto.mac) throw new a.KeyDerivationError();\n          const m = yield (0, i.decrypt)((0, c.hexToBytes)(n.crypto.ciphertext), f.slice(0, 16), (0, c.hexToBytes)(n.crypto.cipherparams.iv));\n          return (0, t.privateKeyToAccount)(m);\n        });\n      },\n      7634: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"goerli\",\n          chainId: 5,\n          networkId: 5,\n          defaultHardfork: \"merge\",\n          consensus: {\n            type: \"poa\",\n            algorithm: \"clique\",\n            clique: {\n              period: 15,\n              epoch: 3e4\n            }\n          },\n          comment: \"Cross-client PoA test network\",\n          url: \"https://github.com/goerli/testnet\",\n          genesis: {\n            timestamp: \"0x5c51a607\",\n            gasLimit: 10485760,\n            difficulty: 1,\n            nonce: \"0x0000000000000000\",\n            extraData: \"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n          },\n          hardforks: [{\n            name: \"chainstart\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"homestead\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"tangerineWhistle\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"spuriousDragon\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"byzantium\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"constantinople\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"petersburg\",\n            block: 0,\n            forkHash: \"0xa3f5ab08\"\n          }, {\n            name: \"istanbul\",\n            block: 1561651,\n            forkHash: \"0xc25efa5c\"\n          }, {\n            name: \"berlin\",\n            block: 4460644,\n            forkHash: \"0x757a1c47\"\n          }, {\n            name: \"london\",\n            block: 5062605,\n            forkHash: \"0xb8c6299d\"\n          }, {\n            \"//_comment\": \"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818\",\n            name: \"merge\",\n            ttd: \"10790000\",\n            block: 7382819,\n            forkHash: \"0xb8c6299d\"\n          }, {\n            name: \"mergeForkIdTransition\",\n            block: null,\n            forkHash: null\n          }, {\n            name: \"shanghai\",\n            block: null,\n            forkHash: null\n          }],\n          bootstrapNodes: [],\n          dnsNetworks: [\"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net\"]\n        };\n      },\n      3233: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"mainnet\",\n          chainId: 1,\n          networkId: 1,\n          defaultHardfork: \"merge\",\n          consensus: {\n            type: \"pow\",\n            algorithm: \"ethash\",\n            ethash: {}\n          },\n          comment: \"The Ethereum main chain\",\n          url: \"https://ethstats.net/\",\n          genesis: {\n            gasLimit: 5e3,\n            difficulty: 17179869184,\n            nonce: \"0x0000000000000042\",\n            extraData: \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\"\n          },\n          hardforks: [{\n            name: \"chainstart\",\n            block: 0,\n            forkHash: \"0xfc64ec04\"\n          }, {\n            name: \"homestead\",\n            block: 115e4,\n            forkHash: \"0x97c2c34c\"\n          }, {\n            name: \"dao\",\n            block: 192e4,\n            forkHash: \"0x91d1f948\"\n          }, {\n            name: \"tangerineWhistle\",\n            block: 2463e3,\n            forkHash: \"0x7a64da13\"\n          }, {\n            name: \"spuriousDragon\",\n            block: 2675e3,\n            forkHash: \"0x3edd5b10\"\n          }, {\n            name: \"byzantium\",\n            block: 437e4,\n            forkHash: \"0xa00bc324\"\n          }, {\n            name: \"constantinople\",\n            block: 728e4,\n            forkHash: \"0x668db0af\"\n          }, {\n            name: \"petersburg\",\n            block: 728e4,\n            forkHash: \"0x668db0af\"\n          }, {\n            name: \"istanbul\",\n            block: 9069e3,\n            forkHash: \"0x879d6e30\"\n          }, {\n            name: \"muirGlacier\",\n            block: 92e5,\n            forkHash: \"0xe029e991\"\n          }, {\n            name: \"berlin\",\n            block: 12244e3,\n            forkHash: \"0x0eb440f6\"\n          }, {\n            name: \"london\",\n            block: 12965e3,\n            forkHash: \"0xb715077d\"\n          }, {\n            name: \"arrowGlacier\",\n            block: 13773e3,\n            forkHash: \"0x20c327fc\"\n          }, {\n            name: \"grayGlacier\",\n            block: 1505e4,\n            forkHash: \"0xf0afd0e3\"\n          }, {\n            \"//_comment\": \"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393\",\n            name: \"merge\",\n            ttd: \"58750000000000000000000\",\n            block: 15537394,\n            forkHash: \"0xf0afd0e3\"\n          }, {\n            name: \"mergeForkIdTransition\",\n            block: null,\n            forkHash: null\n          }, {\n            name: \"shanghai\",\n            block: null,\n            forkHash: null\n          }],\n          bootstrapNodes: [],\n          dnsNetworks: [\"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net\"]\n        };\n      },\n      5077: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"sepolia\",\n          chainId: 11155111,\n          networkId: 11155111,\n          defaultHardfork: \"merge\",\n          consensus: {\n            type: \"pow\",\n            algorithm: \"ethash\",\n            ethash: {}\n          },\n          comment: \"PoW test network to replace Ropsten\",\n          url: \"https://github.com/ethereum/go-ethereum/pull/23730\",\n          genesis: {\n            timestamp: \"0x6159af19\",\n            gasLimit: 3e7,\n            difficulty: 131072,\n            nonce: \"0x0000000000000000\",\n            extraData: \"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521\"\n          },\n          hardforks: [{\n            name: \"chainstart\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"homestead\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"tangerineWhistle\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"spuriousDragon\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"byzantium\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"constantinople\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"petersburg\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"istanbul\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"muirGlacier\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"berlin\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"london\",\n            block: 0,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            \"//_comment\": \"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408\",\n            name: \"merge\",\n            ttd: \"17000000000000000\",\n            block: 1450409,\n            forkHash: \"0xfe3366e7\"\n          }, {\n            name: \"mergeForkIdTransition\",\n            block: 1735371,\n            forkHash: \"0xb96cbd13\"\n          }, {\n            name: \"shanghai\",\n            block: null,\n            timestamp: \"1677557088\",\n            forkHash: \"0xf7f9bc08\"\n          }],\n          bootstrapNodes: [],\n          dnsNetworks: [\"enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net\"]\n        };\n      },\n      6664: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Common = void 0;\n        const i = n(r(1238)),\n          o = r(9634),\n          s = r(850),\n          a = r(2290),\n          c = n(r(7634)),\n          u = n(r(3233)),\n          d = n(r(5077)),\n          l = r(5257),\n          h = r(4443),\n          f = r(9137),\n          {\n            buf: p\n          } = i.default;\n        class m extends o.EventEmitter {\n          constructor(e) {\n            var t, r;\n            super(), this._eips = [], this._customChains = null !== (t = e.customChains) && void 0 !== t ? t : [], this._chainParams = this.setChain(e.chain), this.DEFAULT_HARDFORK = null !== (r = this._chainParams.defaultHardfork) && void 0 !== r ? r : h.Hardfork.Merge, this.HARDFORK_CHANGES = this.hardforks().map(e => [e.name, f.hardforks[e.name]]), this._hardfork = this.DEFAULT_HARDFORK, void 0 !== e.hardfork && this.setHardfork(e.hardfork), e.eips && this.setEIPs(e.eips);\n          }\n          static custom(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var r;\n            const n = null !== (r = t.baseChain) && void 0 !== r ? r : \"mainnet\",\n              i = Object.assign({}, m._getChainParams(n));\n            if (i.name = \"custom-chain\", \"string\" != typeof e) return new m(Object.assign({\n              chain: Object.assign(Object.assign({}, i), e)\n            }, t));\n            if (e === h.CustomChain.PolygonMainnet) return m.custom({\n              name: h.CustomChain.PolygonMainnet,\n              chainId: 137,\n              networkId: 137\n            }, t);\n            if (e === h.CustomChain.PolygonMumbai) return m.custom({\n              name: h.CustomChain.PolygonMumbai,\n              chainId: 80001,\n              networkId: 80001\n            }, t);\n            if (e === h.CustomChain.ArbitrumRinkebyTestnet) return m.custom({\n              name: h.CustomChain.ArbitrumRinkebyTestnet,\n              chainId: 421611,\n              networkId: 421611\n            }, t);\n            if (e === h.CustomChain.ArbitrumOne) return m.custom({\n              name: h.CustomChain.ArbitrumOne,\n              chainId: 42161,\n              networkId: 42161\n            }, t);\n            if (e === h.CustomChain.xDaiChain) return m.custom({\n              name: h.CustomChain.xDaiChain,\n              chainId: 100,\n              networkId: 100\n            }, t);\n            if (e === h.CustomChain.OptimisticKovan) return m.custom({\n              name: h.CustomChain.OptimisticKovan,\n              chainId: 69,\n              networkId: 69\n            }, Object.assign({\n              hardfork: h.Hardfork.Berlin\n            }, t));\n            if (e === h.CustomChain.OptimisticEthereum) return m.custom({\n              name: h.CustomChain.OptimisticEthereum,\n              chainId: 10,\n              networkId: 10\n            }, Object.assign({\n              hardfork: h.Hardfork.Berlin\n            }, t));\n            throw new Error(\"Custom chain \".concat(e, \" not supported\"));\n          }\n          static fromGethGenesis(e, _ref22) {\n            let {\n              chain: t,\n              eips: r,\n              genesisHash: n,\n              hardfork: i,\n              mergeForkIdPostMerge: o\n            } = _ref22;\n            var s;\n            const c = (0, a.parseGethGenesis)(e, t, o),\n              u = new m({\n                chain: null !== (s = c.name) && void 0 !== s ? s : \"custom\",\n                customChains: [c],\n                eips: r,\n                hardfork: null != i ? i : c.hardfork\n              });\n            return void 0 !== n && u.setForkHashes(n), u;\n          }\n          static isSupportedChainId(e) {\n            const t = this._getInitializedChains();\n            return Boolean(t.names[e.toString()]);\n          }\n          static _getChainParams(e, t) {\n            let r = e;\n            const n = this._getInitializedChains(t);\n            if (\"number\" == typeof r || \"bigint\" == typeof r) {\n              if (r = r.toString(), n.names[r]) return n[n.names[r]];\n              throw new Error(\"Chain with ID \".concat(r, \" not supported\"));\n            }\n            if (void 0 !== n[r]) return n[r];\n            throw new Error(\"Chain with name \".concat(r, \" not supported\"));\n          }\n          setChain(e) {\n            if (\"number\" == typeof e || \"bigint\" == typeof e || \"string\" == typeof e) this._chainParams = m._getChainParams(e, this._customChains);else {\n              if (\"object\" != typeof e) throw new Error(\"Wrong input format\");\n              {\n                if (this._customChains.length > 0) throw new Error(\"Chain must be a string, number, or bigint when initialized with customChains passed in\");\n                const t = [\"networkId\", \"genesis\", \"hardforks\", \"bootstrapNodes\"];\n                for (const r of t) if (!(r in e)) throw new Error(\"Missing required chain parameter: \".concat(r));\n                this._chainParams = e;\n              }\n            }\n            for (const e of this.hardforks()) if (void 0 === e.block) throw new Error(\"Hardfork cannot have undefined block number\");\n            return this._chainParams;\n          }\n          setHardfork(e) {\n            let t = !1;\n            for (const r of this.HARDFORK_CHANGES) r[0] === e && (this._hardfork !== e && (this._hardfork = e, this.emit(\"hardforkChanged\", e)), t = !0);\n            if (!t) throw new Error(\"Hardfork with name \".concat(e, \" not supported\"));\n          }\n          getHardforkByBlockNumber(e, t, r) {\n            const n = (0, a.toType)(e, s.TypeOutput.BigInt),\n              i = (0, a.toType)(t, s.TypeOutput.BigInt),\n              o = (0, a.toType)(r, s.TypeOutput.Number),\n              c = this.hardforks().filter(e => null !== e.block || null !== e.ttd && void 0 !== e.ttd || void 0 !== e.timestamp),\n              u = c.findIndex(e => null !== e.ttd && void 0 !== e.ttd);\n            if (c.slice(u + 1).findIndex(e => null !== e.ttd && void 0 !== e.ttd) >= 0) throw Error(\"More than one merge hardforks found with ttd specified\");\n            let d = c.findIndex(e => null !== e.block && e.block > n || void 0 !== o && Number(e.timestamp) > o);\n            if (-1 === d) d = c.length;else if (0 === d) throw Error(\"Must have at least one hardfork at block 0\");\n            if (void 0 === o && (d -= c.slice(0, d).reverse().findIndex(e => null !== e.block || void 0 !== e.ttd)), d -= 1, null === c[d].block && void 0 === c[d].timestamp) (null == i || BigInt(c[d].ttd) > i) && (d -= 1);else if (u >= 0 && null != i) {\n              if (d >= u && BigInt(c[u].ttd) > i) throw Error(\"Maximum HF determined by total difficulty is lower than the block number HF\");\n              if (d < u && BigInt(c[u].ttd) <= i) throw Error(\"HF determined by block number is lower than the minimum total difficulty HF\");\n            }\n            const l = d;\n            for (; d < c.length - 1 && c[d].block === c[d + 1].block && c[d].timestamp === c[d + 1].timestamp; d += 1);\n            if (o) {\n              if (c.slice(0, l).reduce((e, t) => {\n                var r;\n                return Math.max(Number(null !== (r = t.timestamp) && void 0 !== r ? r : \"0\"), e);\n              }, 0) > o) throw Error(\"Maximum HF determined by timestamp is lower than the block number/ttd HF\");\n              if (c.slice(d + 1).reduce((e, t) => {\n                var r;\n                return Math.min(Number(null !== (r = t.timestamp) && void 0 !== r ? r : o), e);\n              }, o) < o) throw Error(\"Maximum HF determined by block number/ttd is lower than timestamp HF\");\n            }\n            return c[d].name;\n          }\n          setHardforkByBlockNumber(e, t, r) {\n            const n = this.getHardforkByBlockNumber(e, t, r);\n            return this.setHardfork(n), n;\n          }\n          _getHardfork(e) {\n            const t = this.hardforks();\n            for (const r of t) if (r.name === e) return r;\n            return null;\n          }\n          setEIPs() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n            for (const t of e) {\n              if (!(t in l.EIPs)) throw new Error(\"\".concat(t, \" not supported\"));\n              const r = this.gteHardfork(l.EIPs[t].minimumHardfork);\n              if (!r) throw new Error(\"\".concat(t, \" cannot be activated on hardfork \").concat(this.hardfork(), \", minimumHardfork: \").concat(r));\n              if (void 0 !== l.EIPs[t].requiredEIPs) for (const r of l.EIPs[t].requiredEIPs) if (!e.includes(r) && !this.isActivatedEIP(r)) throw new Error(\"\".concat(t, \" requires EIP \").concat(r, \", but is not included in the EIP list\"));\n            }\n            this._eips = e;\n          }\n          param(e, t) {\n            let r;\n            for (const n of this._eips) if (r = this.paramByEIP(e, t, n), void 0 !== r) return r;\n            return this.paramByHardfork(e, t, this._hardfork);\n          }\n          paramByHardfork(e, t, r) {\n            let n = null;\n            for (const i of this.HARDFORK_CHANGES) {\n              if (\"eips\" in i[1]) {\n                const r = i[1].eips;\n                for (const i of r) {\n                  const r = this.paramByEIP(e, t, i);\n                  n = \"bigint\" == typeof r ? r : n;\n                }\n              } else {\n                if (void 0 === i[1][e]) throw new Error(\"Topic \".concat(e, \" not defined\"));\n                void 0 !== i[1][e][t] && (n = i[1][e][t].v);\n              }\n              if (i[0] === r) break;\n            }\n            return BigInt(null != n ? n : 0);\n          }\n          paramByEIP(e, t, r) {\n            if (!(r in l.EIPs)) throw new Error(\"\".concat(r, \" not supported\"));\n            const n = l.EIPs[r];\n            if (!(e in n)) throw new Error(\"Topic \".concat(e, \" not defined\"));\n            if (void 0 === n[e][t]) return;\n            const i = n[e][t].v;\n            return BigInt(i);\n          }\n          paramByBlock(e, t, r, n, i) {\n            const o = this.getHardforkByBlockNumber(r, n, i);\n            return this.paramByHardfork(e, t, o);\n          }\n          isActivatedEIP(e) {\n            if (this.eips().includes(e)) return !0;\n            for (const t of this.HARDFORK_CHANGES) {\n              const r = t[1];\n              if (this.gteHardfork(r.name) && \"eips\" in r && r.eips.includes(e)) return !0;\n            }\n            return !1;\n          }\n          hardforkIsActiveOnBlock(e, t) {\n            const r = (0, a.toType)(t, s.TypeOutput.BigInt),\n              n = null != e ? e : this._hardfork,\n              i = this.hardforkBlock(n);\n            return \"bigint\" == typeof i && i !== BigInt(0) && r >= i;\n          }\n          activeOnBlock(e) {\n            return this.hardforkIsActiveOnBlock(null, e);\n          }\n          hardforkGteHardfork(e, t) {\n            const r = null != e ? e : this._hardfork,\n              n = this.hardforks();\n            let i = -1,\n              o = -1,\n              s = 0;\n            for (const e of n) e.name === r && (i = s), e.name === t && (o = s), s += 1;\n            return i >= o && -1 !== o;\n          }\n          gteHardfork(e) {\n            return this.hardforkGteHardfork(null, e);\n          }\n          hardforkBlock(e) {\n            var t;\n            const r = null != e ? e : this._hardfork,\n              n = null === (t = this._getHardfork(r)) || void 0 === t ? void 0 : t.block;\n            return null == n ? null : BigInt(n);\n          }\n          hardforkTimestamp(e) {\n            var t;\n            const r = null != e ? e : this._hardfork,\n              n = null === (t = this._getHardfork(r)) || void 0 === t ? void 0 : t.timestamp;\n            return null == n ? null : BigInt(n);\n          }\n          eipBlock(e) {\n            for (const t of this.HARDFORK_CHANGES) {\n              const r = t[1];\n              if (\"eips\" in r && r.eips.includes(e)) return this.hardforkBlock(\"number\" == typeof t[0] ? String(t[0]) : t[0]);\n            }\n            return null;\n          }\n          hardforkTTD(e) {\n            var t;\n            const r = null != e ? e : this._hardfork,\n              n = null === (t = this._getHardfork(r)) || void 0 === t ? void 0 : t.ttd;\n            return null == n ? null : BigInt(n);\n          }\n          isHardforkBlock(e, t) {\n            const r = (0, a.toType)(e, s.TypeOutput.BigInt),\n              n = null != t ? t : this._hardfork,\n              i = this.hardforkBlock(n);\n            return \"bigint\" == typeof i && i !== BigInt(0) && i === r;\n          }\n          nextHardforkBlockOrTimestamp(e) {\n            var t, r;\n            const n = null != e ? e : this._hardfork,\n              i = this.hardforks();\n            let o = i.findIndex(e => e.name === n);\n            if (n === h.Hardfork.Merge && (o -= 1), o < 0) return null;\n            let s = null !== (t = i[o].timestamp) && void 0 !== t ? t : i[o].block;\n            s = null != s ? Number(s) : null;\n            const a = i.slice(o + 1).find(e => {\n              var t;\n              let r = null !== (t = e.timestamp) && void 0 !== t ? t : e.block;\n              return r = null != r ? Number(r) : null, e.name !== h.Hardfork.Merge && null != r && r !== s;\n            });\n            if (void 0 === a) return null;\n            const c = null !== (r = a.timestamp) && void 0 !== r ? r : a.block;\n            return null == c ? null : BigInt(c);\n          }\n          nextHardforkBlock(e) {\n            const t = null != e ? e : this._hardfork;\n            let r = this.hardforkBlock(t);\n            if (null === r && t === h.Hardfork.Merge) {\n              const e = this.hardforks(),\n                t = e.findIndex(e => null !== e.ttd && void 0 !== e.ttd);\n              if (t < 0) throw Error(\"Merge hardfork should have been found\");\n              r = this.hardforkBlock(e[t - 1].name);\n            }\n            return null === r ? null : this.hardforks().reduce((e, t) => {\n              const n = BigInt(null === t.block || void 0 !== t.ttd && null !== t.ttd ? 0 : t.block);\n              return n > r && null === e ? n : e;\n            }, null);\n          }\n          isNextHardforkBlock(e, t) {\n            const r = (0, a.toType)(e, s.TypeOutput.BigInt),\n              n = null != t ? t : this._hardfork,\n              i = this.nextHardforkBlock(n);\n            return null !== i && i === r;\n          }\n          _calcForkHash(e, t) {\n            let r = new Uint8Array(),\n              n = 0;\n            for (const t of this.hardforks()) {\n              const {\n                block: i,\n                timestamp: s,\n                name: a\n              } = t;\n              let c = null != s ? s : i;\n              if (c = null !== c ? Number(c) : null, \"number\" == typeof c && 0 !== c && c !== n && a !== h.Hardfork.Merge) {\n                const e = (0, o.hexToBytes)(c.toString(16).padStart(16, \"0\"));\n                r = (0, o.uint8ArrayConcat)(r, e), n = c;\n              }\n              if (t.name === e) break;\n            }\n            const i = (0, o.uint8ArrayConcat)(t, r);\n            return (0, o.bytesToHex)((0, a.intToUint8Array)(p(i) >>> 0));\n          }\n          forkHash(e, t) {\n            const r = null != e ? e : this._hardfork,\n              n = this._getHardfork(r);\n            if (null === n || null === (null == n ? void 0 : n.block) && void 0 === (null == n ? void 0 : n.timestamp) && void 0 === (null == n ? void 0 : n.ttd)) throw new Error(\"No fork hash calculation possible for future hardfork\");\n            if (null !== (null == n ? void 0 : n.forkHash) && void 0 !== (null == n ? void 0 : n.forkHash)) return n.forkHash;\n            if (!t) throw new Error(\"genesisHash required for forkHash calculation\");\n            return this._calcForkHash(r, t);\n          }\n          hardforkForForkHash(e) {\n            const t = this.hardforks().filter(t => t.forkHash === e);\n            return t.length >= 1 ? t[t.length - 1] : null;\n          }\n          setForkHashes(e) {\n            var t;\n            for (const r of this.hardforks()) {\n              const n = null !== (t = r.timestamp) && void 0 !== t ? t : r.block;\n              null !== r.forkHash && void 0 !== r.forkHash || null == n && void 0 === r.ttd || (r.forkHash = this.forkHash(r.name, e));\n            }\n          }\n          genesis() {\n            return this._chainParams.genesis;\n          }\n          hardforks() {\n            return this._chainParams.hardforks;\n          }\n          bootstrapNodes() {\n            return this._chainParams.bootstrapNodes;\n          }\n          dnsNetworks() {\n            return this._chainParams.dnsNetworks;\n          }\n          hardfork() {\n            return this._hardfork;\n          }\n          chainId() {\n            return BigInt(this._chainParams.chainId);\n          }\n          chainName() {\n            return this._chainParams.name;\n          }\n          networkId() {\n            return BigInt(this._chainParams.networkId);\n          }\n          eips() {\n            return this._eips;\n          }\n          consensusType() {\n            const e = this.hardfork();\n            let t;\n            for (const r of this.HARDFORK_CHANGES) if (\"consensus\" in r[1] && (t = r[1].consensus.type), r[0] === e) break;\n            return null != t ? t : this._chainParams.consensus.type;\n          }\n          consensusAlgorithm() {\n            const e = this.hardfork();\n            let t;\n            for (const r of this.HARDFORK_CHANGES) if (\"consensus\" in r[1] && (t = r[1].consensus.algorithm), r[0] === e) break;\n            return null != t ? t : this._chainParams.consensus.algorithm;\n          }\n          consensusConfig() {\n            var e;\n            const t = this.hardfork();\n            let r;\n            for (const e of this.HARDFORK_CHANGES) if (\"consensus\" in e[1] && (r = e[1].consensus[e[1].consensus.algorithm]), e[0] === t) break;\n            return null !== (e = null != r ? r : this._chainParams.consensus[this.consensusAlgorithm()]) && void 0 !== e ? e : {};\n          }\n          copy() {\n            const e = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n            return e.removeAllListeners(), e;\n          }\n          static _getInitializedChains(e) {\n            const t = {};\n            for (const [e, r] of Object.entries(h.Chain)) t[r] = e.toLowerCase();\n            const r = {\n              mainnet: u.default,\n              goerli: c.default,\n              sepolia: d.default\n            };\n            if (e) for (const n of e) {\n              const {\n                name: e\n              } = n;\n              t[n.chainId.toString()] = e, r[e] = n;\n            }\n            return r.names = t, r;\n          }\n        }\n        t.Common = m;\n      },\n      2819: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-1153\",\n          number: 1153,\n          comment: \"Transient Storage\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1153\",\n          status: \"Review\",\n          minimumHardfork: \"chainstart\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {\n            tstore: {\n              v: 100,\n              d: \"Base fee of the TSTORE opcode\"\n            },\n            tload: {\n              v: 100,\n              d: \"Base fee of the TLOAD opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      4013: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-1559\",\n          number: 1559,\n          comment: \"Fee market change for ETH 1.0 chain\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1559\",\n          status: \"Final\",\n          minimumHardfork: \"berlin\",\n          requiredEIPs: [2930],\n          gasConfig: {\n            baseFeeMaxChangeDenominator: {\n              v: 8,\n              d: \"Maximum base fee change denominator\"\n            },\n            elasticityMultiplier: {\n              v: 2,\n              d: \"Maximum block gas target elasticity\"\n            },\n            initialBaseFee: {\n              v: 1e9,\n              d: \"Initial base fee on first EIP1559 block\"\n            }\n          },\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      1933: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2315\",\n          number: 2315,\n          comment: \"Simple subroutines for the EVM\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2315\",\n          status: \"Draft\",\n          minimumHardfork: \"istanbul\",\n          gasConfig: {},\n          gasPrices: {\n            beginsub: {\n              v: 2,\n              d: \"Base fee of the BEGINSUB opcode\"\n            },\n            returnsub: {\n              v: 5,\n              d: \"Base fee of the RETURNSUB opcode\"\n            },\n            jumpsub: {\n              v: 10,\n              d: \"Base fee of the JUMPSUB opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      4638: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2537\",\n          number: 2537,\n          comment: \"BLS12-381 precompiles\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2537\",\n          status: \"Draft\",\n          minimumHardfork: \"chainstart\",\n          gasConfig: {},\n          gasPrices: {\n            Bls12381G1AddGas: {\n              v: 600,\n              d: \"Gas cost of a single BLS12-381 G1 addition precompile-call\"\n            },\n            Bls12381G1MulGas: {\n              v: 12e3,\n              d: \"Gas cost of a single BLS12-381 G1 multiplication precompile-call\"\n            },\n            Bls12381G2AddGas: {\n              v: 4500,\n              d: \"Gas cost of a single BLS12-381 G2 addition precompile-call\"\n            },\n            Bls12381G2MulGas: {\n              v: 55e3,\n              d: \"Gas cost of a single BLS12-381 G2 multiplication precompile-call\"\n            },\n            Bls12381PairingBaseGas: {\n              v: 115e3,\n              d: \"Base gas cost of BLS12-381 pairing check\"\n            },\n            Bls12381PairingPerPairGas: {\n              v: 23e3,\n              d: \"Per-pair gas cost of BLS12-381 pairing check\"\n            },\n            Bls12381MapG1Gas: {\n              v: 5500,\n              d: \"Gas cost of BLS12-381 map field element to G1\"\n            },\n            Bls12381MapG2Gas: {\n              v: 11e4,\n              d: \"Gas cost of BLS12-381 map field element to G2\"\n            },\n            Bls12381MultiExpGasDiscount: {\n              v: [[1, 1200], [2, 888], [3, 764], [4, 641], [5, 594], [6, 547], [7, 500], [8, 453], [9, 438], [10, 423], [11, 408], [12, 394], [13, 379], [14, 364], [15, 349], [16, 334], [17, 330], [18, 326], [19, 322], [20, 318], [21, 314], [22, 310], [23, 306], [24, 302], [25, 298], [26, 294], [27, 289], [28, 285], [29, 281], [30, 277], [31, 273], [32, 269], [33, 268], [34, 266], [35, 265], [36, 263], [37, 262], [38, 260], [39, 259], [40, 257], [41, 256], [42, 254], [43, 253], [44, 251], [45, 250], [46, 248], [47, 247], [48, 245], [49, 244], [50, 242], [51, 241], [52, 239], [53, 238], [54, 236], [55, 235], [56, 233], [57, 232], [58, 231], [59, 229], [60, 228], [61, 226], [62, 225], [63, 223], [64, 222], [65, 221], [66, 220], [67, 219], [68, 219], [69, 218], [70, 217], [71, 216], [72, 216], [73, 215], [74, 214], [75, 213], [76, 213], [77, 212], [78, 211], [79, 211], [80, 210], [81, 209], [82, 208], [83, 208], [84, 207], [85, 206], [86, 205], [87, 205], [88, 204], [89, 203], [90, 202], [91, 202], [92, 201], [93, 200], [94, 199], [95, 199], [96, 198], [97, 197], [98, 196], [99, 196], [100, 195], [101, 194], [102, 193], [103, 193], [104, 192], [105, 191], [106, 191], [107, 190], [108, 189], [109, 188], [110, 188], [111, 187], [112, 186], [113, 185], [114, 185], [115, 184], [116, 183], [117, 182], [118, 182], [119, 181], [120, 180], [121, 179], [122, 179], [123, 178], [124, 177], [125, 176], [126, 176], [127, 175], [128, 174]],\n              d: \"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      6906: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2565\",\n          number: 2565,\n          comment: \"ModExp gas cost\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2565\",\n          status: \"Final\",\n          minimumHardfork: \"byzantium\",\n          gasConfig: {},\n          gasPrices: {\n            modexpGquaddivisor: {\n              v: 3,\n              d: \"Gquaddivisor from modexp precompile for gas calculation\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      3399: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2718\",\n          comment: \"Typed Transaction Envelope\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2718\",\n          status: \"Final\",\n          minimumHardfork: \"chainstart\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      7387: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2929\",\n          comment: \"Gas cost increases for state access opcodes\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2929\",\n          status: \"Final\",\n          minimumHardfork: \"chainstart\",\n          gasConfig: {},\n          gasPrices: {\n            coldsload: {\n              v: 2100,\n              d: \"Gas cost of the first read of storage from a given location (per transaction)\"\n            },\n            coldaccountaccess: {\n              v: 2600,\n              d: \"Gas cost of the first read of a given address (per transaction)\"\n            },\n            warmstorageread: {\n              v: 100,\n              d: \"Gas cost of reading storage locations which have already loaded 'cold'\"\n            },\n            sstoreCleanGasEIP2200: {\n              v: 2900,\n              d: \"Once per SSTORE operation from clean non-zero to something else\"\n            },\n            sstoreNoopGasEIP2200: {\n              v: 100,\n              d: \"Once per SSTORE operation if the value doesn't change\"\n            },\n            sstoreDirtyGasEIP2200: {\n              v: 100,\n              d: \"Once per SSTORE operation if a dirty value is changed\"\n            },\n            sstoreInitRefundEIP2200: {\n              v: 19900,\n              d: \"Once per SSTORE operation for resetting to the original zero value\"\n            },\n            sstoreCleanRefundEIP2200: {\n              v: 4900,\n              d: \"Once per SSTORE operation for resetting to the original non-zero value\"\n            },\n            call: {\n              v: 0,\n              d: \"Base fee of the CALL opcode\"\n            },\n            callcode: {\n              v: 0,\n              d: \"Base fee of the CALLCODE opcode\"\n            },\n            delegatecall: {\n              v: 0,\n              d: \"Base fee of the DELEGATECALL opcode\"\n            },\n            staticcall: {\n              v: 0,\n              d: \"Base fee of the STATICCALL opcode\"\n            },\n            balance: {\n              v: 0,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            extcodesize: {\n              v: 0,\n              d: \"Base fee of the EXTCODESIZE opcode\"\n            },\n            extcodecopy: {\n              v: 0,\n              d: \"Base fee of the EXTCODECOPY opcode\"\n            },\n            extcodehash: {\n              v: 0,\n              d: \"Base fee of the EXTCODEHASH opcode\"\n            },\n            sload: {\n              v: 0,\n              d: \"Base fee of the SLOAD opcode\"\n            },\n            sstore: {\n              v: 0,\n              d: \"Base fee of the SSTORE opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      6299: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-2930\",\n          comment: \"Optional access lists\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2930\",\n          status: \"Final\",\n          minimumHardfork: \"istanbul\",\n          requiredEIPs: [2718, 2929],\n          gasConfig: {},\n          gasPrices: {\n            accessListStorageKeyCost: {\n              v: 1900,\n              d: \"Gas cost per storage key in an Access List transaction\"\n            },\n            accessListAddressCost: {\n              v: 2400,\n              d: \"Gas cost per storage key in an Access List transaction\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      1073: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3198\",\n          number: 3198,\n          comment: \"BASEFEE opcode\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3198\",\n          status: \"Final\",\n          minimumHardfork: \"london\",\n          gasConfig: {},\n          gasPrices: {\n            basefee: {\n              v: 2,\n              d: \"Gas cost of the BASEFEE opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      634: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3529\",\n          comment: \"Reduction in refunds\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3529\",\n          status: \"Final\",\n          minimumHardfork: \"berlin\",\n          requiredEIPs: [2929],\n          gasConfig: {\n            maxRefundQuotient: {\n              v: 5,\n              d: \"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)\"\n            }\n          },\n          gasPrices: {\n            selfdestructRefund: {\n              v: 0,\n              d: \"Refunded following a selfdestruct operation\"\n            },\n            sstoreClearRefundEIP2200: {\n              v: 4800,\n              d: \"Once per SSTORE operation for clearing an originally existing storage slot\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      3829: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3540\",\n          number: 3540,\n          comment: \"EVM Object Format (EOF) v1\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3540\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [3541],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      5729: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3541\",\n          comment: \"Reject new contracts starting with the 0xEF byte\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3541\",\n          status: \"Final\",\n          minimumHardfork: \"berlin\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      8958: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3554\",\n          comment: \"Reduction in refunds\",\n          url: \"Difficulty Bomb Delay to December 1st 2021\",\n          status: \"Final\",\n          minimumHardfork: \"muirGlacier\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 95e5,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      8334: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3607\",\n          number: 3607,\n          comment: \"Reject transactions from senders with deployed code\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3607\",\n          status: \"Final\",\n          minimumHardfork: \"chainstart\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      3412: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3651\",\n          number: 3198,\n          comment: \"Warm COINBASE\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3651\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [2929],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      6337: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3670\",\n          number: 3670,\n          comment: \"EOF - Code Validation\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3670\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [3540],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      2610: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3675\",\n          number: 3675,\n          comment: \"Upgrade consensus to Proof-of-Stake\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3675\",\n          status: \"Final\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      7619: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3855\",\n          number: 3855,\n          comment: \"PUSH0 instruction\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3855\",\n          status: \"Review\",\n          minimumHardfork: \"chainstart\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {\n            push0: {\n              v: 2,\n              d: \"Base fee of the PUSH0 opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      8018: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-3860\",\n          number: 3860,\n          comment: \"Limit and meter initcode\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3860\",\n          status: \"Review\",\n          minimumHardfork: \"spuriousDragon\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {\n            initCodeWordCost: {\n              v: 2,\n              d: \"Gas to pay for each word (32 bytes) of initcode when creating a contract\"\n            }\n          },\n          vm: {\n            maxInitCodeSize: {\n              v: 49152,\n              d: \"Maximum length of initialization code when creating a contract\"\n            }\n          },\n          pow: {}\n        };\n      },\n      6779: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-4345\",\n          number: 4345,\n          comment: \"Difficulty Bomb Delay to June 2022\",\n          url: \"https://eips.ethereum.org/EIPS/eip-4345\",\n          status: \"Final\",\n          minimumHardfork: \"london\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 107e5,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      623: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-4399\",\n          number: 4399,\n          comment: \"Supplant DIFFICULTY opcode with PREVRANDAO\",\n          url: \"https://eips.ethereum.org/EIPS/eip-4399\",\n          status: \"Review\",\n          minimumHardfork: \"london\",\n          requiredEIPs: [],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      797: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"EIP-5133\",\n          number: 5133,\n          comment: \"Delaying Difficulty Bomb to mid-September 2022\",\n          url: \"https://eips.ethereum.org/EIPS/eip-5133\",\n          status: \"Draft\",\n          minimumHardfork: \"grayGlacier\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 114e5,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      5257: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.EIPs = void 0;\n        const i = n(r(2819)),\n          o = n(r(4013)),\n          s = n(r(1933)),\n          a = n(r(4638)),\n          c = n(r(6906)),\n          u = n(r(3399)),\n          d = n(r(7387)),\n          l = n(r(6299)),\n          h = n(r(1073)),\n          f = n(r(634)),\n          p = n(r(3829)),\n          m = n(r(5729)),\n          g = n(r(8958)),\n          y = n(r(8334)),\n          v = n(r(3412)),\n          b = n(r(6337)),\n          E = n(r(2610)),\n          _ = n(r(7619)),\n          A = n(r(8018)),\n          T = n(r(6779)),\n          I = n(r(623)),\n          R = n(r(797));\n        t.EIPs = {\n          1153: i.default,\n          1559: o.default,\n          2315: s.default,\n          2537: a.default,\n          2565: c.default,\n          2718: u.default,\n          2929: d.default,\n          2930: l.default,\n          3198: h.default,\n          3529: f.default,\n          3540: p.default,\n          3541: m.default,\n          3554: g.default,\n          3607: y.default,\n          3651: v.default,\n          3670: b.default,\n          3675: E.default,\n          3855: _.default,\n          3860: A.default,\n          4345: T.default,\n          4399: I.default,\n          5133: R.default\n        };\n      },\n      4443: (e, t) => {\n        \"use strict\";\n\n        var r, n, i, o, s;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.CustomChain = t.ConsensusAlgorithm = t.ConsensusType = t.Hardfork = t.Chain = void 0, (s = t.Chain || (t.Chain = {}))[s.Mainnet = 1] = \"Mainnet\", s[s.Goerli = 5] = \"Goerli\", s[s.Sepolia = 11155111] = \"Sepolia\", (o = t.Hardfork || (t.Hardfork = {})).Chainstart = \"chainstart\", o.Homestead = \"homestead\", o.Dao = \"dao\", o.TangerineWhistle = \"tangerineWhistle\", o.SpuriousDragon = \"spuriousDragon\", o.Byzantium = \"byzantium\", o.Constantinople = \"constantinople\", o.Petersburg = \"petersburg\", o.Istanbul = \"istanbul\", o.MuirGlacier = \"muirGlacier\", o.Berlin = \"berlin\", o.London = \"london\", o.ArrowGlacier = \"arrowGlacier\", o.GrayGlacier = \"grayGlacier\", o.MergeForkIdTransition = \"mergeForkIdTransition\", o.Merge = \"merge\", o.Shanghai = \"shanghai\", o.ShardingForkDev = \"shardingFork\", (i = t.ConsensusType || (t.ConsensusType = {})).ProofOfStake = \"pos\", i.ProofOfWork = \"pow\", i.ProofOfAuthority = \"poa\", (n = t.ConsensusAlgorithm || (t.ConsensusAlgorithm = {})).Ethash = \"ethash\", n.Clique = \"clique\", n.Casper = \"casper\", (r = t.CustomChain || (t.CustomChain = {})).PolygonMainnet = \"polygon-mainnet\", r.PolygonMumbai = \"polygon-mumbai\", r.ArbitrumRinkebyTestnet = \"arbitrum-rinkeby-testnet\", r.ArbitrumOne = \"arbitrum-one\", r.xDaiChain = \"x-dai-chain\", r.OptimisticKovan = \"optimistic-kovan\", r.OptimisticEthereum = \"optimistic-ethereum\";\n      },\n      3923: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"arrowGlacier\",\n          comment: \"HF to delay the difficulty bomb\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md\",\n          status: \"Final\",\n          eips: [4345],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      9126: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"berlin\",\n          comment: \"HF targeted for July 2020 following the Muir Glacier HF\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2070\",\n          status: \"Final\",\n          eips: [2565, 2929, 2718, 2930]\n        };\n      },\n      7251: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"byzantium\",\n          comment: \"Hardfork with new precompiles, instructions and other protocol changes\",\n          url: \"https://eips.ethereum.org/EIPS/eip-609\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            modexpGquaddivisor: {\n              v: 20,\n              d: \"Gquaddivisor from modexp precompile for gas calculation\"\n            },\n            ecAdd: {\n              v: 500,\n              d: \"Gas costs for curve addition precompile\"\n            },\n            ecMul: {\n              v: 4e4,\n              d: \"Gas costs for curve multiplication precompile\"\n            },\n            ecPairing: {\n              v: 1e5,\n              d: \"Base gas costs for curve pairing precompile\"\n            },\n            ecPairingWord: {\n              v: 8e4,\n              d: \"Gas costs regarding curve pairing precompile input length\"\n            },\n            revert: {\n              v: 0,\n              d: \"Base fee of the REVERT opcode\"\n            },\n            staticcall: {\n              v: 700,\n              d: \"Base fee of the STATICCALL opcode\"\n            },\n            returndatasize: {\n              v: 2,\n              d: \"Base fee of the RETURNDATASIZE opcode\"\n            },\n            returndatacopy: {\n              v: 3,\n              d: \"Base fee of the RETURNDATACOPY opcode\"\n            }\n          },\n          vm: {},\n          pow: {\n            minerReward: {\n              v: \"3000000000000000000\",\n              d: \"the amount a miner get rewarded for mining a block\"\n            },\n            difficultyBombDelay: {\n              v: 3e6,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      9454: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"chainstart\",\n          comment: \"Start of the Ethereum main chain\",\n          url: \"\",\n          status: \"\",\n          gasConfig: {\n            minGasLimit: {\n              v: 5e3,\n              d: \"Minimum the gas limit may ever be\"\n            },\n            gasLimitBoundDivisor: {\n              v: 1024,\n              d: \"The bound divisor of the gas limit, used in update calculations\"\n            },\n            maxRefundQuotient: {\n              v: 2,\n              d: \"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)\"\n            }\n          },\n          gasPrices: {\n            base: {\n              v: 2,\n              d: \"Gas base cost, used e.g. for ChainID opcode (Istanbul)\"\n            },\n            tierStep: {\n              v: [0, 2, 3, 5, 8, 10, 20],\n              d: \"Once per operation, for a selection of them\"\n            },\n            exp: {\n              v: 10,\n              d: \"Base fee of the EXP opcode\"\n            },\n            expByte: {\n              v: 10,\n              d: \"Times ceil(log256(exponent)) for the EXP instruction\"\n            },\n            sha3: {\n              v: 30,\n              d: \"Base fee of the SHA3 opcode\"\n            },\n            sha3Word: {\n              v: 6,\n              d: \"Once per word of the SHA3 operation's data\"\n            },\n            sload: {\n              v: 50,\n              d: \"Base fee of the SLOAD opcode\"\n            },\n            sstoreSet: {\n              v: 2e4,\n              d: \"Once per SSTORE operation if the zeroness changes from zero\"\n            },\n            sstoreReset: {\n              v: 5e3,\n              d: \"Once per SSTORE operation if the zeroness does not change from zero\"\n            },\n            sstoreRefund: {\n              v: 15e3,\n              d: \"Once per SSTORE operation if the zeroness changes to zero\"\n            },\n            jumpdest: {\n              v: 1,\n              d: \"Base fee of the JUMPDEST opcode\"\n            },\n            log: {\n              v: 375,\n              d: \"Base fee of the LOG opcode\"\n            },\n            logData: {\n              v: 8,\n              d: \"Per byte in a LOG* operation's data\"\n            },\n            logTopic: {\n              v: 375,\n              d: \"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas\"\n            },\n            create: {\n              v: 32e3,\n              d: \"Base fee of the CREATE opcode\"\n            },\n            call: {\n              v: 40,\n              d: \"Base fee of the CALL opcode\"\n            },\n            callStipend: {\n              v: 2300,\n              d: \"Free gas given at beginning of call\"\n            },\n            callValueTransfer: {\n              v: 9e3,\n              d: \"Paid for CALL when the value transfor is non-zero\"\n            },\n            callNewAccount: {\n              v: 25e3,\n              d: \"Paid for CALL when the destination address didn't exist prior\"\n            },\n            selfdestructRefund: {\n              v: 24e3,\n              d: \"Refunded following a selfdestruct operation\"\n            },\n            memory: {\n              v: 3,\n              d: \"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL\"\n            },\n            quadCoeffDiv: {\n              v: 512,\n              d: \"Divisor for the quadratic particle of the memory cost equation\"\n            },\n            createData: {\n              v: 200,\n              d: \"\"\n            },\n            tx: {\n              v: 21e3,\n              d: \"Per transaction. NOTE: Not payable on data of calls between transactions\"\n            },\n            txCreation: {\n              v: 32e3,\n              d: \"The cost of creating a contract via tx\"\n            },\n            txDataZero: {\n              v: 4,\n              d: \"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions\"\n            },\n            txDataNonZero: {\n              v: 68,\n              d: \"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions\"\n            },\n            copy: {\n              v: 3,\n              d: \"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added\"\n            },\n            ecRecover: {\n              v: 3e3,\n              d: \"\"\n            },\n            sha256: {\n              v: 60,\n              d: \"\"\n            },\n            sha256Word: {\n              v: 12,\n              d: \"\"\n            },\n            ripemd160: {\n              v: 600,\n              d: \"\"\n            },\n            ripemd160Word: {\n              v: 120,\n              d: \"\"\n            },\n            identity: {\n              v: 15,\n              d: \"\"\n            },\n            identityWord: {\n              v: 3,\n              d: \"\"\n            },\n            stop: {\n              v: 0,\n              d: \"Base fee of the STOP opcode\"\n            },\n            add: {\n              v: 3,\n              d: \"Base fee of the ADD opcode\"\n            },\n            mul: {\n              v: 5,\n              d: \"Base fee of the MUL opcode\"\n            },\n            sub: {\n              v: 3,\n              d: \"Base fee of the SUB opcode\"\n            },\n            div: {\n              v: 5,\n              d: \"Base fee of the DIV opcode\"\n            },\n            sdiv: {\n              v: 5,\n              d: \"Base fee of the SDIV opcode\"\n            },\n            mod: {\n              v: 5,\n              d: \"Base fee of the MOD opcode\"\n            },\n            smod: {\n              v: 5,\n              d: \"Base fee of the SMOD opcode\"\n            },\n            addmod: {\n              v: 8,\n              d: \"Base fee of the ADDMOD opcode\"\n            },\n            mulmod: {\n              v: 8,\n              d: \"Base fee of the MULMOD opcode\"\n            },\n            signextend: {\n              v: 5,\n              d: \"Base fee of the SIGNEXTEND opcode\"\n            },\n            lt: {\n              v: 3,\n              d: \"Base fee of the LT opcode\"\n            },\n            gt: {\n              v: 3,\n              d: \"Base fee of the GT opcode\"\n            },\n            slt: {\n              v: 3,\n              d: \"Base fee of the SLT opcode\"\n            },\n            sgt: {\n              v: 3,\n              d: \"Base fee of the SGT opcode\"\n            },\n            eq: {\n              v: 3,\n              d: \"Base fee of the EQ opcode\"\n            },\n            iszero: {\n              v: 3,\n              d: \"Base fee of the ISZERO opcode\"\n            },\n            and: {\n              v: 3,\n              d: \"Base fee of the AND opcode\"\n            },\n            or: {\n              v: 3,\n              d: \"Base fee of the OR opcode\"\n            },\n            xor: {\n              v: 3,\n              d: \"Base fee of the XOR opcode\"\n            },\n            not: {\n              v: 3,\n              d: \"Base fee of the NOT opcode\"\n            },\n            byte: {\n              v: 3,\n              d: \"Base fee of the BYTE opcode\"\n            },\n            address: {\n              v: 2,\n              d: \"Base fee of the ADDRESS opcode\"\n            },\n            balance: {\n              v: 20,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            origin: {\n              v: 2,\n              d: \"Base fee of the ORIGIN opcode\"\n            },\n            caller: {\n              v: 2,\n              d: \"Base fee of the CALLER opcode\"\n            },\n            callvalue: {\n              v: 2,\n              d: \"Base fee of the CALLVALUE opcode\"\n            },\n            calldataload: {\n              v: 3,\n              d: \"Base fee of the CALLDATALOAD opcode\"\n            },\n            calldatasize: {\n              v: 2,\n              d: \"Base fee of the CALLDATASIZE opcode\"\n            },\n            calldatacopy: {\n              v: 3,\n              d: \"Base fee of the CALLDATACOPY opcode\"\n            },\n            codesize: {\n              v: 2,\n              d: \"Base fee of the CODESIZE opcode\"\n            },\n            codecopy: {\n              v: 3,\n              d: \"Base fee of the CODECOPY opcode\"\n            },\n            gasprice: {\n              v: 2,\n              d: \"Base fee of the GASPRICE opcode\"\n            },\n            extcodesize: {\n              v: 20,\n              d: \"Base fee of the EXTCODESIZE opcode\"\n            },\n            extcodecopy: {\n              v: 20,\n              d: \"Base fee of the EXTCODECOPY opcode\"\n            },\n            blockhash: {\n              v: 20,\n              d: \"Base fee of the BLOCKHASH opcode\"\n            },\n            coinbase: {\n              v: 2,\n              d: \"Base fee of the COINBASE opcode\"\n            },\n            timestamp: {\n              v: 2,\n              d: \"Base fee of the TIMESTAMP opcode\"\n            },\n            number: {\n              v: 2,\n              d: \"Base fee of the NUMBER opcode\"\n            },\n            difficulty: {\n              v: 2,\n              d: \"Base fee of the DIFFICULTY opcode\"\n            },\n            gaslimit: {\n              v: 2,\n              d: \"Base fee of the GASLIMIT opcode\"\n            },\n            pop: {\n              v: 2,\n              d: \"Base fee of the POP opcode\"\n            },\n            mload: {\n              v: 3,\n              d: \"Base fee of the MLOAD opcode\"\n            },\n            mstore: {\n              v: 3,\n              d: \"Base fee of the MSTORE opcode\"\n            },\n            mstore8: {\n              v: 3,\n              d: \"Base fee of the MSTORE8 opcode\"\n            },\n            sstore: {\n              v: 0,\n              d: \"Base fee of the SSTORE opcode\"\n            },\n            jump: {\n              v: 8,\n              d: \"Base fee of the JUMP opcode\"\n            },\n            jumpi: {\n              v: 10,\n              d: \"Base fee of the JUMPI opcode\"\n            },\n            pc: {\n              v: 2,\n              d: \"Base fee of the PC opcode\"\n            },\n            msize: {\n              v: 2,\n              d: \"Base fee of the MSIZE opcode\"\n            },\n            gas: {\n              v: 2,\n              d: \"Base fee of the GAS opcode\"\n            },\n            push: {\n              v: 3,\n              d: \"Base fee of the PUSH opcode\"\n            },\n            dup: {\n              v: 3,\n              d: \"Base fee of the DUP opcode\"\n            },\n            swap: {\n              v: 3,\n              d: \"Base fee of the SWAP opcode\"\n            },\n            callcode: {\n              v: 40,\n              d: \"Base fee of the CALLCODE opcode\"\n            },\n            return: {\n              v: 0,\n              d: \"Base fee of the RETURN opcode\"\n            },\n            invalid: {\n              v: 0,\n              d: \"Base fee of the INVALID opcode\"\n            },\n            selfdestruct: {\n              v: 0,\n              d: \"Base fee of the SELFDESTRUCT opcode\"\n            }\n          },\n          vm: {\n            stackLimit: {\n              v: 1024,\n              d: \"Maximum size of VM stack allowed\"\n            },\n            callCreateDepth: {\n              v: 1024,\n              d: \"Maximum depth of call/create stack\"\n            },\n            maxExtraDataSize: {\n              v: 32,\n              d: \"Maximum size extra data may be after Genesis\"\n            }\n          },\n          pow: {\n            minimumDifficulty: {\n              v: 131072,\n              d: \"The minimum that the difficulty may ever be\"\n            },\n            difficultyBoundDivisor: {\n              v: 2048,\n              d: \"The bound divisor of the difficulty, used in the update calculations\"\n            },\n            durationLimit: {\n              v: 13,\n              d: \"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not\"\n            },\n            epochDuration: {\n              v: 3e4,\n              d: \"Duration between proof-of-work epochs\"\n            },\n            timebombPeriod: {\n              v: 1e5,\n              d: \"Exponential difficulty timebomb period\"\n            },\n            minerReward: {\n              v: \"5000000000000000000\",\n              d: \"the amount a miner get rewarded for mining a block\"\n            },\n            difficultyBombDelay: {\n              v: 0,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      1353: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"constantinople\",\n          comment: \"Postponed hardfork including EIP-1283 (SSTORE gas metering changes)\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1013\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            netSstoreNoopGas: {\n              v: 200,\n              d: \"Once per SSTORE operation if the value doesn't change\"\n            },\n            netSstoreInitGas: {\n              v: 2e4,\n              d: \"Once per SSTORE operation from clean zero\"\n            },\n            netSstoreCleanGas: {\n              v: 5e3,\n              d: \"Once per SSTORE operation from clean non-zero\"\n            },\n            netSstoreDirtyGas: {\n              v: 200,\n              d: \"Once per SSTORE operation from dirty\"\n            },\n            netSstoreClearRefund: {\n              v: 15e3,\n              d: \"Once per SSTORE operation for clearing an originally existing storage slot\"\n            },\n            netSstoreResetRefund: {\n              v: 4800,\n              d: \"Once per SSTORE operation for resetting to the original non-zero value\"\n            },\n            netSstoreResetClearRefund: {\n              v: 19800,\n              d: \"Once per SSTORE operation for resetting to the original zero value\"\n            },\n            shl: {\n              v: 3,\n              d: \"Base fee of the SHL opcode\"\n            },\n            shr: {\n              v: 3,\n              d: \"Base fee of the SHR opcode\"\n            },\n            sar: {\n              v: 3,\n              d: \"Base fee of the SAR opcode\"\n            },\n            extcodehash: {\n              v: 400,\n              d: \"Base fee of the EXTCODEHASH opcode\"\n            },\n            create2: {\n              v: 32e3,\n              d: \"Base fee of the CREATE2 opcode\"\n            }\n          },\n          vm: {},\n          pow: {\n            minerReward: {\n              v: \"2000000000000000000\",\n              d: \"The amount a miner gets rewarded for mining a block\"\n            },\n            difficultyBombDelay: {\n              v: 5e6,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      3810: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"dao\",\n          comment: \"DAO rescue hardfork\",\n          url: \"https://eips.ethereum.org/EIPS/eip-779\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      6257: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"grayGlacier\",\n          comment: \"Delaying the difficulty bomb to Mid September 2022\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md\",\n          status: \"Draft\",\n          eips: [5133],\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {}\n        };\n      },\n      7446: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"homestead\",\n          comment: \"Homestead hardfork with protocol and network changes\",\n          url: \"https://eips.ethereum.org/EIPS/eip-606\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            delegatecall: {\n              v: 40,\n              d: \"Base fee of the DELEGATECALL opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      9137: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hardforks = void 0;\n        const i = n(r(9454)),\n          o = n(r(3810)),\n          s = n(r(7446)),\n          a = n(r(7458)),\n          c = n(r(2546)),\n          u = n(r(7251)),\n          d = n(r(1353)),\n          l = n(r(5338)),\n          h = n(r(9597)),\n          f = n(r(7931)),\n          p = n(r(9126)),\n          m = n(r(1233)),\n          g = n(r(2761)),\n          y = n(r(3923)),\n          v = n(r(6257)),\n          b = n(r(6697)),\n          E = n(r(6668));\n        t.hardforks = {\n          chainstart: i.default,\n          homestead: s.default,\n          dao: o.default,\n          tangerineWhistle: a.default,\n          spuriousDragon: c.default,\n          byzantium: u.default,\n          constantinople: d.default,\n          petersburg: l.default,\n          istanbul: h.default,\n          muirGlacier: f.default,\n          berlin: p.default,\n          london: m.default,\n          shanghai: g.default,\n          arrowGlacier: y.default,\n          grayGlacier: v.default,\n          mergeForkIdTransition: b.default,\n          merge: E.default\n        };\n      },\n      9597: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"istanbul\",\n          comment: \"HF targeted for December 2019 following the Constantinople/Petersburg HF\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1679\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            blake2Round: {\n              v: 1,\n              d: \"Gas cost per round for the Blake2 F precompile\"\n            },\n            ecAdd: {\n              v: 150,\n              d: \"Gas costs for curve addition precompile\"\n            },\n            ecMul: {\n              v: 6e3,\n              d: \"Gas costs for curve multiplication precompile\"\n            },\n            ecPairing: {\n              v: 45e3,\n              d: \"Base gas costs for curve pairing precompile\"\n            },\n            ecPairingWord: {\n              v: 34e3,\n              d: \"Gas costs regarding curve pairing precompile input length\"\n            },\n            txDataNonZero: {\n              v: 16,\n              d: \"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions\"\n            },\n            sstoreSentryGasEIP2200: {\n              v: 2300,\n              d: \"Minimum gas required to be present for an SSTORE call, not consumed\"\n            },\n            sstoreNoopGasEIP2200: {\n              v: 800,\n              d: \"Once per SSTORE operation if the value doesn't change\"\n            },\n            sstoreDirtyGasEIP2200: {\n              v: 800,\n              d: \"Once per SSTORE operation if a dirty value is changed\"\n            },\n            sstoreInitGasEIP2200: {\n              v: 2e4,\n              d: \"Once per SSTORE operation from clean zero to non-zero\"\n            },\n            sstoreInitRefundEIP2200: {\n              v: 19200,\n              d: \"Once per SSTORE operation for resetting to the original zero value\"\n            },\n            sstoreCleanGasEIP2200: {\n              v: 5e3,\n              d: \"Once per SSTORE operation from clean non-zero to something else\"\n            },\n            sstoreCleanRefundEIP2200: {\n              v: 4200,\n              d: \"Once per SSTORE operation for resetting to the original non-zero value\"\n            },\n            sstoreClearRefundEIP2200: {\n              v: 15e3,\n              d: \"Once per SSTORE operation for clearing an originally existing storage slot\"\n            },\n            balance: {\n              v: 700,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            extcodehash: {\n              v: 700,\n              d: \"Base fee of the EXTCODEHASH opcode\"\n            },\n            chainid: {\n              v: 2,\n              d: \"Base fee of the CHAINID opcode\"\n            },\n            selfbalance: {\n              v: 5,\n              d: \"Base fee of the SELFBALANCE opcode\"\n            },\n            sload: {\n              v: 800,\n              d: \"Base fee of the SLOAD opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      1233: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"london\",\n          comment: \"HF targeted for July 2021 following the Berlin fork\",\n          url: \"https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md\",\n          status: \"Final\",\n          eips: [1559, 3198, 3529, 3541]\n        };\n      },\n      6668: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"merge\",\n          comment: \"Hardfork to upgrade the consensus mechanism to Proof-of-Stake\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md\",\n          status: \"Final\",\n          consensus: {\n            type: \"pos\",\n            algorithm: \"casper\",\n            casper: {}\n          },\n          eips: [3675, 4399]\n        };\n      },\n      6697: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"mergeForkIdTransition\",\n          comment: \"Pre-merge hardfork to fork off non-upgraded clients\",\n          url: \"https://eips.ethereum.org/EIPS/eip-3675\",\n          status: \"Draft\",\n          eips: []\n        };\n      },\n      7931: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"muirGlacier\",\n          comment: \"HF to delay the difficulty bomb\",\n          url: \"https://eips.ethereum.org/EIPS/eip-2384\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {},\n          vm: {},\n          pow: {\n            difficultyBombDelay: {\n              v: 9e6,\n              d: \"the amount of blocks to delay the difficulty bomb with\"\n            }\n          }\n        };\n      },\n      5338: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"petersburg\",\n          comment: \"Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople\",\n          url: \"https://eips.ethereum.org/EIPS/eip-1716\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            netSstoreNoopGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreInitGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreCleanGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreDirtyGas: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreClearRefund: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreResetRefund: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            },\n            netSstoreResetClearRefund: {\n              v: null,\n              d: \"Removed along EIP-1283\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      2761: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"shanghai\",\n          comment: \"Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode\",\n          url: \"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md\",\n          status: \"Final\",\n          eips: [3651, 3855, 3860, 4895]\n        };\n      },\n      2546: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"spuriousDragon\",\n          comment: \"HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit\",\n          url: \"https://eips.ethereum.org/EIPS/eip-607\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            expByte: {\n              v: 50,\n              d: \"Times ceil(log256(exponent)) for the EXP instruction\"\n            }\n          },\n          vm: {\n            maxCodeSize: {\n              v: 24576,\n              d: \"Maximum length of contract code\"\n            }\n          },\n          pow: {}\n        };\n      },\n      7458: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.default = {\n          name: \"tangerineWhistle\",\n          comment: \"Hardfork with gas cost changes for IO-heavy operations\",\n          url: \"https://eips.ethereum.org/EIPS/eip-608\",\n          status: \"Final\",\n          gasConfig: {},\n          gasPrices: {\n            sload: {\n              v: 200,\n              d: \"Once per SLOAD operation\"\n            },\n            call: {\n              v: 700,\n              d: \"Once per CALL operation & message call transaction\"\n            },\n            extcodesize: {\n              v: 700,\n              d: \"Base fee of the EXTCODESIZE opcode\"\n            },\n            extcodecopy: {\n              v: 700,\n              d: \"Base fee of the EXTCODECOPY opcode\"\n            },\n            balance: {\n              v: 400,\n              d: \"Base fee of the BALANCE opcode\"\n            },\n            delegatecall: {\n              v: 700,\n              d: \"Base fee of the DELEGATECALL opcode\"\n            },\n            callcode: {\n              v: 700,\n              d: \"Base fee of the CALLCODE opcode\"\n            },\n            selfdestruct: {\n              v: 5e3,\n              d: \"Base fee of the SELFDESTRUCT opcode\"\n            }\n          },\n          vm: {},\n          pow: {}\n        };\n      },\n      8317: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), i(r(6664), t), i(r(4443), t), i(r(850), t), i(r(2290), t);\n      },\n      850: (e, t) => {\n        \"use strict\";\n\n        var r;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TypeOutput = void 0, (r = t.TypeOutput || (t.TypeOutput = {}))[r.Number = 0] = \"Number\", r[r.BigInt = 1] = \"BigInt\", r[r.Uint8Array = 2] = \"Uint8Array\", r[r.PrefixedHexString = 3] = \"PrefixedHexString\";\n      },\n      2290: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.toType = t.ecrecover = t.bigIntToUnpaddedUint8Array = t.bigIntToHex = t.unpadUint8Array = t.stripZeros = t.setLengthLeft = t.assertIsUint8Array = t.zeros = t.bigIntToUint8Array = t.uint8ArrayToBigInt = t.toUint8Array = t.intToUint8Array = t.padToEven = t.parseGethGenesis = t.stripHexPrefix = void 0;\n        const n = r(7345),\n          i = r(9634),\n          o = r(4555),\n          s = r(4443),\n          a = r(850);\n        t.stripHexPrefix = e => {\n          if (\"string\" != typeof e) throw new Error(\"[stripHexPrefix] input must be type 'string', received \" + typeof e);\n          return (0, n.isHexPrefixed)(e) ? e.slice(2) : e;\n        };\n        const c = function c(e) {\n          if (!Number.isSafeInteger(e) || e < 0) throw new Error(\"Received an invalid integer type: \".concat(e));\n          return \"0x\".concat(e.toString(16));\n        };\n        function u(e) {\n          let t = e;\n          if (\"string\" != typeof t) throw new Error(\"[padToEven] value must be type 'string', received \" + typeof t);\n          return t.length % 2 && (t = \"0\".concat(t)), t;\n        }\n        function d(e) {\n          const t = (0, i.bytesToHex)(e);\n          return \"0x\" === t ? BigInt(0) : BigInt(t);\n        }\n        function l(e) {\n          return (0, t.toUint8Array)(\"0x\".concat(e.toString(16)));\n        }\n        function h(e) {\n          if (!(e instanceof Uint8Array)) throw new Error(\"This method only supports Uint8Array but input was: \".concat(e));\n        }\n        function f(e) {\n          let t = e[0];\n          for (; e.length > 0 && \"0\" === t.toString();) t = (e = e.slice(1))[0];\n          return e;\n        }\n        t.parseGethGenesis = function (e, r, i) {\n          try {\n            if ([\"config\", \"difficulty\", \"gasLimit\", \"alloc\"].some(t => !(t in e))) throw new Error(\"Invalid format, expected geth genesis fields missing\");\n            return void 0 !== r && (e.name = r), function (e) {\n              let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n              var i, o;\n              const {\n                name: a,\n                config: u,\n                difficulty: d,\n                mixHash: l,\n                gasLimit: h,\n                coinbase: f,\n                baseFeePerGas: p\n              } = e;\n              let {\n                extraData: m,\n                timestamp: g,\n                nonce: y\n              } = e;\n              const v = Number(g),\n                {\n                  chainId: b\n                } = u;\n              if (\"\" === m && (m = \"0x\"), (0, n.isHexPrefixed)(g) || (g = c(parseInt(g))), 18 !== y.length && (y = function (e) {\n                return e && \"0x0\" !== e ? (0, n.isHexPrefixed)(e) ? \"0x\".concat((0, t.stripHexPrefix)(e).padStart(16, \"0\")) : \"0x\".concat(e.padStart(16, \"0\")) : \"0x0000000000000000\";\n              }(y)), u.eip155Block !== u.eip158Block) throw new Error(\"EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork\");\n              const E = {\n                  name: a,\n                  chainId: b,\n                  networkId: b,\n                  genesis: {\n                    timestamp: g,\n                    gasLimit: parseInt(h),\n                    difficulty: parseInt(d),\n                    nonce: y,\n                    extraData: m,\n                    mixHash: l,\n                    coinbase: f,\n                    baseFeePerGas: p\n                  },\n                  hardfork: void 0,\n                  hardforks: [],\n                  bootstrapNodes: [],\n                  consensus: void 0 !== u.clique ? {\n                    type: \"poa\",\n                    algorithm: \"clique\",\n                    clique: {\n                      period: null !== (i = u.clique.period) && void 0 !== i ? i : u.clique.blockperiodseconds,\n                      epoch: null !== (o = u.clique.epoch) && void 0 !== o ? o : u.clique.epochlength\n                    }\n                  } : {\n                    type: \"pow\",\n                    algorithm: \"ethash\",\n                    ethash: {}\n                  }\n                },\n                _ = {\n                  [s.Hardfork.Homestead]: {\n                    name: \"homesteadBlock\"\n                  },\n                  [s.Hardfork.Dao]: {\n                    name: \"daoForkBlock\"\n                  },\n                  [s.Hardfork.TangerineWhistle]: {\n                    name: \"eip150Block\"\n                  },\n                  [s.Hardfork.SpuriousDragon]: {\n                    name: \"eip155Block\"\n                  },\n                  [s.Hardfork.Byzantium]: {\n                    name: \"byzantiumBlock\"\n                  },\n                  [s.Hardfork.Constantinople]: {\n                    name: \"constantinopleBlock\"\n                  },\n                  [s.Hardfork.Petersburg]: {\n                    name: \"petersburgBlock\"\n                  },\n                  [s.Hardfork.Istanbul]: {\n                    name: \"istanbulBlock\"\n                  },\n                  [s.Hardfork.MuirGlacier]: {\n                    name: \"muirGlacierBlock\"\n                  },\n                  [s.Hardfork.Berlin]: {\n                    name: \"berlinBlock\"\n                  },\n                  [s.Hardfork.London]: {\n                    name: \"londonBlock\"\n                  },\n                  [s.Hardfork.MergeForkIdTransition]: {\n                    name: \"mergeForkBlock\",\n                    postMerge: r\n                  },\n                  [s.Hardfork.Shanghai]: {\n                    name: \"shanghaiTime\",\n                    postMerge: !0,\n                    isTimestamp: !0\n                  },\n                  [s.Hardfork.ShardingForkDev]: {\n                    name: \"shardingForkTime\",\n                    postMerge: !0,\n                    isTimestamp: !0\n                  }\n                },\n                A = Object.keys(_).reduce((e, t) => (e[_[t].name] = t, e), {}),\n                T = Object.keys(u).filter(e => void 0 !== A[e] && void 0 !== u[e] && null !== u[e]);\n              if (E.hardforks = T.map(e => ({\n                name: A[e],\n                block: !0 === _[A[e]].isTimestamp || \"number\" != typeof u[e] ? null : u[e],\n                timestamp: !0 === _[A[e]].isTimestamp && \"number\" == typeof u[e] ? u[e] : void 0\n              })).filter(e => null !== e.block || void 0 !== e.timestamp), E.hardforks.sort((e, t) => {\n                var r, n;\n                return (null !== (r = e.block) && void 0 !== r ? r : 1 / 0) - (null !== (n = t.block) && void 0 !== n ? n : 1 / 0);\n              }), E.hardforks.sort((e, t) => {\n                var r, n;\n                return (null !== (r = e.timestamp) && void 0 !== r ? r : v) - (null !== (n = t.timestamp) && void 0 !== n ? n : v);\n              }), void 0 !== u.terminalTotalDifficulty) {\n                const e = {\n                    name: s.Hardfork.Merge,\n                    ttd: u.terminalTotalDifficulty,\n                    block: null\n                  },\n                  t = E.hardforks.findIndex(e => {\n                    var t;\n                    return !0 === (null === (t = _[e.name]) || void 0 === t ? void 0 : t.postMerge);\n                  });\n                -1 !== t ? E.hardforks.splice(t, 0, e) : E.hardforks.push(e);\n              }\n              const I = E.hardforks.length > 0 ? E.hardforks.slice(-1)[0] : void 0;\n              return E.hardfork = null == I ? void 0 : I.name, E.hardforks.unshift({\n                name: s.Hardfork.Chainstart,\n                block: 0\n              }), E;\n            }(e, i);\n          } catch (e) {\n            throw new Error(\"Error parsing parameters file: \".concat(e.message));\n          }\n        }, t.padToEven = u, t.intToUint8Array = function (e) {\n          const t = c(e);\n          return (0, i.hexToBytes)(\"0x\".concat(u(t.slice(2))));\n        }, t.toUint8Array = function (e) {\n          if (null == e) return new Uint8Array();\n          if (e instanceof Uint8Array) return e;\n          if (Array.isArray(e)) return Uint8Array.from(e);\n          if (\"string\" == typeof e) {\n            if (!(0, n.isHexString)(e)) throw new Error(\"Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: \".concat(e));\n            return (0, i.hexToBytes)(u((0, t.stripHexPrefix)(e)));\n          }\n          if (\"number\" == typeof e) return (0, t.toUint8Array)((0, i.numberToHex)(e));\n          if (\"bigint\" == typeof e) {\n            if (e < BigInt(0)) throw new Error(\"Cannot convert negative bigint to Uint8Array. Given: \".concat(e));\n            let r = e.toString(16);\n            return r.length % 2 && (r = \"0\".concat(r)), (0, t.toUint8Array)(\"0x\".concat(r));\n          }\n          if (e.toArray) return Uint8Array.from(e.toArray());\n          throw new Error(\"invalid type\");\n        }, t.uint8ArrayToBigInt = d, t.bigIntToUint8Array = l, t.zeros = function (e) {\n          return new Uint8Array(e).fill(0);\n        }, t.assertIsUint8Array = h, t.setLengthLeft = function (e, r) {\n          return h(e), function (e, r, n) {\n            const i = (0, t.zeros)(r);\n            return e.length < r ? (i.set(e, r - e.length), i) : e.subarray(-r);\n          }(e, r);\n        }, t.stripZeros = f, t.unpadUint8Array = function (e) {\n          return h(e), f(e);\n        }, t.bigIntToHex = e => \"0x\".concat(e.toString(16)), t.bigIntToUnpaddedUint8Array = function (e) {\n          return (0, t.unpadUint8Array)(l(e));\n        }, t.ecrecover = function (e, t, r, n, i) {\n          const s = function (e, t) {\n            return e === BigInt(0) || e === BigInt(1) ? e : void 0 === t ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35));\n          }(t, i);\n          if (!function (e) {\n            return e === BigInt(0) || e === BigInt(1);\n          }(s)) throw new Error(\"Invalid signature v value\");\n          return new o.secp256k1.Signature(d(r), d(n)).addRecoveryBit(Number(s)).recoverPublicKey(e).toRawBytes(!1).slice(1);\n        }, t.toType = function (e, r) {\n          if (null === e) return null;\n          if (void 0 === e) return;\n          if (\"string\" == typeof e && !(0, n.isHexString)(e)) throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(e));\n          if (\"number\" == typeof e && !Number.isSafeInteger(e)) throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n          const o = (0, t.toUint8Array)(e);\n          switch (r) {\n            case a.TypeOutput.Uint8Array:\n              return o;\n            case a.TypeOutput.BigInt:\n              return d(o);\n            case a.TypeOutput.Number:\n              {\n                const e = d(o);\n                if (e > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n                return Number(e);\n              }\n            case a.TypeOutput.PrefixedHexString:\n              return (0, i.bytesToHex)(o);\n            default:\n              throw new Error(\"unknown outputType\");\n          }\n        };\n      },\n      9247: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), i(r(8632), t), i(r(1560), t), i(r(4874), t), i(r(5774), t), i(r(8317), t), i(r(9275), t);\n      },\n      5774: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.keyStoreSchema = void 0, t.keyStoreSchema = {\n          type: \"object\",\n          required: [\"crypto\", \"id\", \"version\", \"address\"],\n          properties: {\n            crypto: {\n              type: \"object\",\n              required: [\"cipher\", \"ciphertext\", \"cipherparams\", \"kdf\", \"kdfparams\", \"mac\"],\n              properties: {\n                cipher: {\n                  type: \"string\"\n                },\n                ciphertext: {\n                  type: \"string\"\n                },\n                cipherparams: {\n                  type: \"object\"\n                },\n                kdf: {\n                  type: \"string\"\n                },\n                kdfparams: {\n                  type: \"object\"\n                },\n                salt: {\n                  type: \"string\"\n                },\n                mac: {\n                  type: \"string\"\n                }\n              }\n            },\n            id: {\n              type: \"string\"\n            },\n            version: {\n              type: \"number\"\n            },\n            address: {\n              type: \"string\"\n            }\n          }\n        };\n      },\n      7592: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Address = void 0;\n        const n = r(7423),\n          i = r(9634),\n          o = r(4555),\n          s = r(2290);\n        class a {\n          constructor(e) {\n            if (20 !== e.length) throw new Error(\"Invalid address length\");\n            this.buf = e;\n          }\n          static zero() {\n            return new a((0, s.zeros)(20));\n          }\n          equals(e) {\n            return (0, i.uint8ArrayEquals)(this.buf, e.buf);\n          }\n          isZero() {\n            return this.equals(a.zero());\n          }\n          toString() {\n            return (0, i.bytesToHex)(this.buf);\n          }\n          toArray() {\n            return this.buf;\n          }\n          static publicToAddress(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n            let r = e;\n            if ((0, s.assertIsUint8Array)(r), t && 64 !== r.length && (r = o.secp256k1.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)), 64 !== r.length) throw new Error(\"Expected pubKey to be of length 64\");\n            return (0, n.keccak256)(r).slice(-20);\n          }\n        }\n        t.Address = a;\n      },\n      915: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.BaseTransaction = void 0;\n        const n = r(9634),\n          i = r(4555),\n          o = r(2290),\n          s = r(6664),\n          a = r(4443),\n          c = r(9964),\n          u = r(7592),\n          d = r(4562);\n        t.BaseTransaction = class {\n          constructor(e, t) {\n            var r, n;\n            this.cache = {\n              hash: void 0,\n              dataFee: void 0\n            }, this.activeCapabilities = [], this.DEFAULT_CHAIN = a.Chain.Mainnet, this.DEFAULT_HARDFORK = a.Hardfork.Merge;\n            const {\n              nonce: i,\n              gasLimit: s,\n              to: c,\n              value: l,\n              data: h,\n              v: f,\n              r: p,\n              s: m,\n              type: g\n            } = e;\n            this._type = Number((0, o.uint8ArrayToBigInt)((0, o.toUint8Array)(g))), this.txOptions = t;\n            const y = (0, o.toUint8Array)(\"\" === c ? \"0x\" : c),\n              v = (0, o.toUint8Array)(\"\" === f ? \"0x\" : f),\n              b = (0, o.toUint8Array)(\"\" === p ? \"0x\" : p),\n              E = (0, o.toUint8Array)(\"\" === m ? \"0x\" : m);\n            this.nonce = (0, o.uint8ArrayToBigInt)((0, o.toUint8Array)(\"\" === i ? \"0x\" : i)), this.gasLimit = (0, o.uint8ArrayToBigInt)((0, o.toUint8Array)(\"\" === s ? \"0x\" : s)), this.to = y.length > 0 ? new u.Address(y) : void 0, this.value = (0, o.uint8ArrayToBigInt)((0, o.toUint8Array)(\"\" === l ? \"0x\" : l)), this.data = (0, o.toUint8Array)(\"\" === h ? \"0x\" : h), this.v = v.length > 0 ? (0, o.uint8ArrayToBigInt)(v) : void 0, this.r = b.length > 0 ? (0, o.uint8ArrayToBigInt)(b) : void 0, this.s = E.length > 0 ? (0, o.uint8ArrayToBigInt)(E) : void 0, this._validateCannotExceedMaxInteger({\n              value: this.value,\n              r: this.r,\n              s: this.s\n            }), this._validateCannotExceedMaxInteger({\n              gasLimit: this.gasLimit\n            }, 64), this._validateCannotExceedMaxInteger({\n              nonce: this.nonce\n            }, 64, !0);\n            const _ = void 0 === this.to || null === this.to,\n              A = null !== (r = t.allowUnlimitedInitCodeSize) && void 0 !== r && r,\n              T = null !== (n = t.common) && void 0 !== n ? n : this._getCommon();\n            _ && T.isActivatedEIP(3860) && !A && (0, d.checkMaxInitCodeSize)(T, this.data.length);\n          }\n          get type() {\n            return this._type;\n          }\n          supports(e) {\n            return this.activeCapabilities.includes(e);\n          }\n          validate() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n            const t = [];\n            return this.getBaseFee() > this.gasLimit && t.push(\"gasLimit is too low. given \".concat(this.gasLimit, \", need at least \").concat(this.getBaseFee())), this.isSigned() && !this.verifySignature() && t.push(\"Invalid Signature\"), e ? t : 0 === t.length;\n          }\n          _validateYParity() {\n            const {\n              v: e\n            } = this;\n            if (void 0 !== e && e !== BigInt(0) && e !== BigInt(1)) {\n              const e = this._errorMsg(\"The y-parity of the transaction should either be 0 or 1\");\n              throw new Error(e);\n            }\n          }\n          _validateHighS() {\n            const {\n              s: e\n            } = this;\n            if (this.common.gteHardfork(\"homestead\") && void 0 !== e && e > i.SECP256K1_ORDER_DIV_2) {\n              const e = this._errorMsg(\"Invalid Signature: s-values greater than secp256k1n/2 are considered invalid\");\n              throw new Error(e);\n            }\n          }\n          getBaseFee() {\n            const e = this.common.param(\"gasPrices\", \"tx\");\n            let t = this.getDataFee();\n            if (e && (t += e), this.common.gteHardfork(\"homestead\") && this.toCreationAddress()) {\n              const e = this.common.param(\"gasPrices\", \"txCreation\");\n              e && (t += e);\n            }\n            return t;\n          }\n          getDataFee() {\n            const e = this.common.param(\"gasPrices\", \"txDataZero\"),\n              t = this.common.param(\"gasPrices\", \"txDataNonZero\");\n            let r = BigInt(0);\n            for (let n = 0; n < this.data.length; n += 1) 0 === this.data[n] ? r += e : r += t;\n            if ((void 0 === this.to || null === this.to) && this.common.isActivatedEIP(3860)) {\n              const e = BigInt(Math.ceil(this.data.length / 32));\n              r += this.common.param(\"gasPrices\", \"initCodeWordCost\") * e;\n            }\n            return r;\n          }\n          toCreationAddress() {\n            return void 0 === this.to || 0 === this.to.buf.length;\n          }\n          isSigned() {\n            const {\n              v: e,\n              r: t,\n              s: r\n            } = this;\n            return void 0 !== e && void 0 !== t && void 0 !== r;\n          }\n          verifySignature() {\n            try {\n              const e = this.getSenderPublicKey();\n              return 0 !== (0, o.unpadUint8Array)(e).length;\n            } catch (e) {\n              return !1;\n            }\n          }\n          getSenderAddress() {\n            return new u.Address(u.Address.publicToAddress(this.getSenderPublicKey()));\n          }\n          sign(e) {\n            if (32 !== e.length) {\n              const e = this._errorMsg(\"Private key must be 32 bytes in length.\");\n              throw new Error(e);\n            }\n            let t = !1;\n            0 === this.type && this.common.gteHardfork(\"spuriousDragon\") && !this.supports(c.Capability.EIP155ReplayProtection) && (this.activeCapabilities.push(c.Capability.EIP155ReplayProtection), t = !0);\n            const r = this.getMessageToSign(!0),\n              {\n                v: n,\n                r: i,\n                s: o\n              } = this._ecsign(r, e),\n              s = this._processSignature(n, i, o);\n            if (t) {\n              const e = this.activeCapabilities.indexOf(c.Capability.EIP155ReplayProtection);\n              e > -1 && this.activeCapabilities.splice(e, 1);\n            }\n            return s;\n          }\n          _getCommon(e, t) {\n            var r;\n            if (void 0 !== t) {\n              const r = (0, o.uint8ArrayToBigInt)((0, o.toUint8Array)(t));\n              if (e) {\n                if (e.chainId() !== r) {\n                  const e = this._errorMsg(\"The chain ID does not match the chain ID of Common\");\n                  throw new Error(e);\n                }\n                return e.copy();\n              }\n              return s.Common.isSupportedChainId(r) ? new s.Common({\n                chain: r,\n                hardfork: this.DEFAULT_HARDFORK\n              }) : s.Common.custom({\n                name: \"custom-chain\",\n                networkId: r,\n                chainId: r\n              }, {\n                baseChain: this.DEFAULT_CHAIN,\n                hardfork: this.DEFAULT_HARDFORK\n              });\n            }\n            return null !== (r = null == e ? void 0 : e.copy()) && void 0 !== r ? r : new s.Common({\n              chain: this.DEFAULT_CHAIN,\n              hardfork: this.DEFAULT_HARDFORK\n            });\n          }\n          _validateCannotExceedMaxInteger(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n            for (const [n, o] of Object.entries(e)) switch (t) {\n              case 64:\n                if (r) {\n                  if (void 0 !== o && o >= i.MAX_UINT64) {\n                    const e = this._errorMsg(\"\".concat(n, \" cannot equal or exceed MAX_UINT64 (2^64-1), given \").concat(o));\n                    throw new Error(e);\n                  }\n                } else if (void 0 !== o && o > i.MAX_UINT64) {\n                  const e = this._errorMsg(\"\".concat(n, \" cannot exceed MAX_UINT64 (2^64-1), given \").concat(o));\n                  throw new Error(e);\n                }\n                break;\n              case 256:\n                if (r) {\n                  if (void 0 !== o && o >= i.MAX_INTEGER) {\n                    const e = this._errorMsg(\"\".concat(n, \" cannot equal or exceed MAX_INTEGER (2^256-1), given \").concat(o));\n                    throw new Error(e);\n                  }\n                } else if (void 0 !== o && o > i.MAX_INTEGER) {\n                  const e = this._errorMsg(\"\".concat(n, \" cannot exceed MAX_INTEGER (2^256-1), given \").concat(o));\n                  throw new Error(e);\n                }\n                break;\n              default:\n                {\n                  const e = this._errorMsg(\"unimplemented bits value\");\n                  throw new Error(e);\n                }\n            }\n          }\n          static _validateNotArray(e) {\n            const t = [\"nonce\", \"gasPrice\", \"gasLimit\", \"to\", \"value\", \"data\", \"v\", \"r\", \"s\", \"type\", \"baseFee\", \"maxFeePerGas\", \"chainId\"];\n            for (const [r, n] of Object.entries(e)) if (t.includes(r) && Array.isArray(n)) throw new Error(\"\".concat(r, \" cannot be an array\"));\n          }\n          _getSharedErrorPostfix() {\n            let e = \"\";\n            try {\n              e = this.isSigned() ? (0, n.bytesToHex)(this.hash()) : \"not available (unsigned)\";\n            } catch (t) {\n              e = \"error\";\n            }\n            let t = \"\";\n            try {\n              t = this.isSigned().toString();\n            } catch (t) {\n              e = \"error\";\n            }\n            let r = \"\";\n            try {\n              r = this.common.hardfork();\n            } catch (e) {\n              r = \"error\";\n            }\n            let i = \"tx type=\".concat(this.type, \" hash=\").concat(e, \" nonce=\").concat(this.nonce, \" value=\").concat(this.value, \" \");\n            return i += \"signed=\".concat(t, \" hf=\").concat(r), i;\n          }\n          _ecsign(e, t, r) {\n            const n = i.secp256k1.sign(e, t),\n              o = n.toCompactRawBytes();\n            return {\n              r: o.subarray(0, 32),\n              s: o.subarray(32, 64),\n              v: void 0 === r ? BigInt(n.recovery + 27) : BigInt(n.recovery + 35) + BigInt(r) * BigInt(2)\n            };\n          }\n          static fromSerializedTx(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          }\n          static fromTxData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          }\n        };\n      },\n      4555: function _(e, t, r) {\n        \"use strict\";\n\n        var n,\n          i = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && i(t, e, r);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SECP256K1_ORDER_DIV_2 = t.SECP256K1_ORDER = t.MAX_INTEGER = t.MAX_UINT64 = t.secp256k1 = void 0;\n        const a = s(r(5473));\n        t.secp256k1 = null !== (n = a.secp256k1) && void 0 !== n ? n : a, t.MAX_UINT64 = BigInt(\"0xffffffffffffffff\"), t.MAX_INTEGER = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"), t.SECP256K1_ORDER = t.secp256k1.CURVE.n, t.SECP256K1_ORDER_DIV_2 = t.SECP256K1_ORDER / BigInt(2);\n      },\n      6135: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.FeeMarketEIP1559Transaction = void 0;\n        const n = r(7423),\n          i = r(7345),\n          o = r(7256),\n          s = r(9634),\n          a = r(4555),\n          c = r(915),\n          u = r(4562),\n          d = r(2290),\n          l = (0, s.hexToBytes)(2..toString(16).padStart(2, \"0\"));\n        class h extends c.BaseTransaction {\n          constructor(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var r;\n            super(Object.assign(Object.assign({}, e), {\n              type: 2\n            }), t), this.DEFAULT_HARDFORK = \"london\";\n            const {\n              chainId: n,\n              accessList: i,\n              maxFeePerGas: o,\n              maxPriorityFeePerGas: s\n            } = e;\n            if (this.common = this._getCommon(t.common, n), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(1559)) throw new Error(\"EIP-1559 not enabled on Common\");\n            this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);\n            const l = (0, u.getAccessListData)(null != i ? i : []);\n            if (this.accessList = l.accessList, this.AccessListJSON = l.AccessListJSON, (0, u.verifyAccessList)(this.accessList), this.maxFeePerGas = (0, d.uint8ArrayToBigInt)((0, d.toUint8Array)(\"\" === o ? \"0x\" : o)), this.maxPriorityFeePerGas = (0, d.uint8ArrayToBigInt)((0, d.toUint8Array)(\"\" === s ? \"0x\" : s)), this._validateCannotExceedMaxInteger({\n              maxFeePerGas: this.maxFeePerGas,\n              maxPriorityFeePerGas: this.maxPriorityFeePerGas\n            }), c.BaseTransaction._validateNotArray(e), this.gasLimit * this.maxFeePerGas > a.MAX_INTEGER) {\n              const e = this._errorMsg(\"gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)\");\n              throw new Error(e);\n            }\n            if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\n              const e = this._errorMsg(\"maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)\");\n              throw new Error(e);\n            }\n            this._validateYParity(), this._validateHighS(), (null === (r = null == t ? void 0 : t.freeze) || void 0 === r || r) && Object.freeze(this);\n          }\n          static fromTxData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return new h(e, t);\n          }\n          static fromSerializedTx(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (!(0, s.uint8ArrayEquals)(e.subarray(0, 1), l)) throw new Error(\"Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: 2, received: \".concat((0, s.bytesToHex)(e.subarray(0, 1))));\n            const r = o.RLP.decode(e.subarray(1));\n            if (!Array.isArray(r)) throw new Error(\"Invalid serialized tx input: must be array\");\n            return h.fromValuesArray(r, t);\n          }\n          static fromValuesArray(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (9 !== e.length && 12 !== e.length) throw new Error(\"Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).\");\n            const [r, n, o, s, a, c, u, l, f, p, m, g] = e;\n            return this._validateNotArray({\n              chainId: r,\n              v: p\n            }), (0, i.validateNoLeadingZeroes)({\n              nonce: n,\n              maxPriorityFeePerGas: o,\n              maxFeePerGas: s,\n              gasLimit: a,\n              value: u,\n              v: p,\n              r: m,\n              s: g\n            }), new h({\n              chainId: (0, d.uint8ArrayToBigInt)(r),\n              nonce: n,\n              maxPriorityFeePerGas: o,\n              maxFeePerGas: s,\n              gasLimit: a,\n              to: c,\n              value: u,\n              data: l,\n              accessList: null != f ? f : [],\n              v: void 0 !== p ? (0, d.uint8ArrayToBigInt)(p) : void 0,\n              r: m,\n              s: g\n            }, t);\n          }\n          getDataFee() {\n            if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;\n            let e = super.getDataFee();\n            return e += BigInt((0, u.getDataFeeEIP2930)(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {\n              value: e,\n              hardfork: this.common.hardfork()\n            }), e;\n          }\n          getUpfrontCost() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BigInt(0);\n            const t = this.maxPriorityFeePerGas,\n              r = this.maxFeePerGas - e,\n              n = (t < r ? t : r) + e;\n            return this.gasLimit * n + this.value;\n          }\n          raw() {\n            return [(0, d.bigIntToUnpaddedUint8Array)(this.chainId), (0, d.bigIntToUnpaddedUint8Array)(this.nonce), (0, d.bigIntToUnpaddedUint8Array)(this.maxPriorityFeePerGas), (0, d.bigIntToUnpaddedUint8Array)(this.maxFeePerGas), (0, d.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, d.bigIntToUnpaddedUint8Array)(this.value), this.data, this.accessList, void 0 !== this.v ? (0, d.bigIntToUnpaddedUint8Array)(this.v) : Uint8Array.from([]), void 0 !== this.r ? (0, d.bigIntToUnpaddedUint8Array)(this.r) : Uint8Array.from([]), void 0 !== this.s ? (0, d.bigIntToUnpaddedUint8Array)(this.s) : Uint8Array.from([])];\n          }\n          serialize() {\n            const e = this.raw();\n            return (0, s.uint8ArrayConcat)(l, o.RLP.encode(e));\n          }\n          getMessageToSign() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n            const t = this.raw().slice(0, 9),\n              r = (0, s.uint8ArrayConcat)(l, o.RLP.encode(t));\n            return e ? (0, n.keccak256)(r) : r;\n          }\n          hash() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call hash method if transaction is not signed\");\n              throw new Error(e);\n            }\n            return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = (0, n.keccak256)(this.serialize())), this.cache.hash) : (0, n.keccak256)(this.serialize());\n          }\n          getMessageToVerifySignature() {\n            return this.getMessageToSign();\n          }\n          getSenderPublicKey() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call this method if transaction is not signed\");\n              throw new Error(e);\n            }\n            const e = this.getMessageToVerifySignature(),\n              {\n                v: t,\n                r,\n                s: n\n              } = this;\n            this._validateHighS();\n            try {\n              return (0, d.ecrecover)(e, t + BigInt(27), (0, d.bigIntToUnpaddedUint8Array)(r), (0, d.bigIntToUnpaddedUint8Array)(n));\n            } catch (e) {\n              const t = this._errorMsg(\"Invalid Signature\");\n              throw new Error(t);\n            }\n          }\n          _processSignature(e, t, r) {\n            const n = Object.assign(Object.assign({}, this.txOptions), {\n              common: this.common\n            });\n            return h.fromTxData({\n              chainId: this.chainId,\n              nonce: this.nonce,\n              maxPriorityFeePerGas: this.maxPriorityFeePerGas,\n              maxFeePerGas: this.maxFeePerGas,\n              gasLimit: this.gasLimit,\n              to: this.to,\n              value: this.value,\n              data: this.data,\n              accessList: this.accessList,\n              v: e - BigInt(27),\n              r: (0, d.uint8ArrayToBigInt)(t),\n              s: (0, d.uint8ArrayToBigInt)(r)\n            }, n);\n          }\n          toJSON() {\n            const e = (0, u.getAccessListJSON)(this.accessList);\n            return {\n              chainId: (0, d.bigIntToHex)(this.chainId),\n              nonce: (0, d.bigIntToHex)(this.nonce),\n              maxPriorityFeePerGas: (0, d.bigIntToHex)(this.maxPriorityFeePerGas),\n              maxFeePerGas: (0, d.bigIntToHex)(this.maxFeePerGas),\n              gasLimit: (0, d.bigIntToHex)(this.gasLimit),\n              to: void 0 !== this.to ? this.to.toString() : void 0,\n              value: (0, d.bigIntToHex)(this.value),\n              data: (0, s.bytesToHex)(this.data),\n              accessList: e,\n              v: void 0 !== this.v ? (0, d.bigIntToHex)(this.v) : void 0,\n              r: void 0 !== this.r ? (0, d.bigIntToHex)(this.r) : void 0,\n              s: void 0 !== this.s ? (0, d.bigIntToHex)(this.s) : void 0\n            };\n          }\n          errorStr() {\n            let e = this._getSharedErrorPostfix();\n            return e += \" maxFeePerGas=\".concat(this.maxFeePerGas, \" maxPriorityFeePerGas=\").concat(this.maxPriorityFeePerGas), e;\n          }\n          _errorMsg(e) {\n            return \"\".concat(e, \" (\").concat(this.errorStr(), \")\");\n          }\n        }\n        t.FeeMarketEIP1559Transaction = h;\n      },\n      9013: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.AccessListEIP2930Transaction = void 0;\n        const n = r(7423),\n          i = r(7345),\n          o = r(7256),\n          s = r(9634),\n          a = r(4555),\n          c = r(4562),\n          u = r(2290),\n          d = r(915),\n          l = (0, s.hexToBytes)(1..toString(16).padStart(2, \"0\"));\n        class h extends d.BaseTransaction {\n          constructor(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var r;\n            super(Object.assign(Object.assign({}, e), {\n              type: 1\n            }), t), this.DEFAULT_HARDFORK = \"berlin\";\n            const {\n              chainId: n,\n              accessList: i,\n              gasPrice: o\n            } = e;\n            if (this.common = this._getCommon(t.common, n), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(2930)) throw new Error(\"EIP-2930 not enabled on Common\");\n            this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);\n            const s = (0, c.getAccessListData)(null != i ? i : []);\n            if (this.accessList = s.accessList, this.AccessListJSON = s.AccessListJSON, (0, c.verifyAccessList)(this.accessList), this.gasPrice = (0, u.uint8ArrayToBigInt)((0, u.toUint8Array)(\"\" === o ? \"0x\" : o)), this._validateCannotExceedMaxInteger({\n              gasPrice: this.gasPrice\n            }), d.BaseTransaction._validateNotArray(e), this.gasPrice * this.gasLimit > a.MAX_INTEGER) {\n              const e = this._errorMsg(\"gasLimit * gasPrice cannot exceed MAX_INTEGER\");\n              throw new Error(e);\n            }\n            this._validateYParity(), this._validateHighS(), (null === (r = null == t ? void 0 : t.freeze) || void 0 === r || r) && Object.freeze(this);\n          }\n          static fromTxData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return new h(e, t);\n          }\n          static fromSerializedTx(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (!(0, s.uint8ArrayEquals)(e.subarray(0, 1), l)) throw new Error(\"Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: 1, received: \".concat((0, s.bytesToHex)(e.subarray(0, 1))));\n            const r = o.RLP.decode(Uint8Array.from(e.subarray(1)));\n            if (!Array.isArray(r)) throw new Error(\"Invalid serialized tx input: must be array\");\n            return h.fromValuesArray(r, t);\n          }\n          static fromValuesArray(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (8 !== e.length && 11 !== e.length) throw new Error(\"Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).\");\n            const [r, n, o, s, a, c, d, l, f, p, m] = e;\n            return this._validateNotArray({\n              chainId: r,\n              v: f\n            }), (0, i.validateNoLeadingZeroes)({\n              nonce: n,\n              gasPrice: o,\n              gasLimit: s,\n              value: c,\n              v: f,\n              r: p,\n              s: m\n            }), new h({\n              chainId: (0, u.uint8ArrayToBigInt)(r),\n              nonce: n,\n              gasPrice: o,\n              gasLimit: s,\n              to: a,\n              value: c,\n              data: d,\n              accessList: null != l ? l : [],\n              v: void 0 !== f ? (0, u.uint8ArrayToBigInt)(f) : void 0,\n              r: p,\n              s: m\n            }, t);\n          }\n          getDataFee() {\n            if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;\n            let e = super.getDataFee();\n            return e += BigInt((0, c.getDataFeeEIP2930)(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {\n              value: e,\n              hardfork: this.common.hardfork()\n            }), e;\n          }\n          getUpfrontCost() {\n            return this.gasLimit * this.gasPrice + this.value;\n          }\n          raw() {\n            return [(0, u.bigIntToUnpaddedUint8Array)(this.chainId), (0, u.bigIntToUnpaddedUint8Array)(this.nonce), (0, u.bigIntToUnpaddedUint8Array)(this.gasPrice), (0, u.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, u.bigIntToUnpaddedUint8Array)(this.value), this.data, this.accessList, void 0 !== this.v ? (0, u.bigIntToUnpaddedUint8Array)(this.v) : Uint8Array.from([]), void 0 !== this.r ? (0, u.bigIntToUnpaddedUint8Array)(this.r) : Uint8Array.from([]), void 0 !== this.s ? (0, u.bigIntToUnpaddedUint8Array)(this.s) : Uint8Array.from([])];\n          }\n          serialize() {\n            const e = this.raw();\n            return (0, s.uint8ArrayConcat)(l, o.RLP.encode(e));\n          }\n          getMessageToSign() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n            const t = this.raw().slice(0, 8),\n              r = (0, s.uint8ArrayConcat)(l, o.RLP.encode(t));\n            return e ? (0, n.keccak256)(r) : r;\n          }\n          hash() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call hash method if transaction is not signed\");\n              throw new Error(e);\n            }\n            return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = (0, n.keccak256)(this.serialize())), this.cache.hash) : (0, n.keccak256)(this.serialize());\n          }\n          getMessageToVerifySignature() {\n            return this.getMessageToSign();\n          }\n          getSenderPublicKey() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call this method if transaction is not signed\");\n              throw new Error(e);\n            }\n            const e = this.getMessageToVerifySignature(),\n              {\n                v: t,\n                r,\n                s: n\n              } = this;\n            this._validateHighS();\n            try {\n              return (0, u.ecrecover)(e, t + BigInt(27), (0, u.bigIntToUnpaddedUint8Array)(r), (0, u.bigIntToUnpaddedUint8Array)(n));\n            } catch (e) {\n              const t = this._errorMsg(\"Invalid Signature\");\n              throw new Error(t);\n            }\n          }\n          _processSignature(e, t, r) {\n            const n = Object.assign(Object.assign({}, this.txOptions), {\n              common: this.common\n            });\n            return h.fromTxData({\n              chainId: this.chainId,\n              nonce: this.nonce,\n              gasPrice: this.gasPrice,\n              gasLimit: this.gasLimit,\n              to: this.to,\n              value: this.value,\n              data: this.data,\n              accessList: this.accessList,\n              v: e - BigInt(27),\n              r: (0, u.uint8ArrayToBigInt)(t),\n              s: (0, u.uint8ArrayToBigInt)(r)\n            }, n);\n          }\n          toJSON() {\n            const e = (0, c.getAccessListJSON)(this.accessList);\n            return {\n              chainId: (0, u.bigIntToHex)(this.chainId),\n              nonce: (0, u.bigIntToHex)(this.nonce),\n              gasPrice: (0, u.bigIntToHex)(this.gasPrice),\n              gasLimit: (0, u.bigIntToHex)(this.gasLimit),\n              to: void 0 !== this.to ? this.to.toString() : void 0,\n              value: (0, u.bigIntToHex)(this.value),\n              data: (0, s.bytesToHex)(this.data),\n              accessList: e,\n              v: void 0 !== this.v ? (0, u.bigIntToHex)(this.v) : void 0,\n              r: void 0 !== this.r ? (0, u.bigIntToHex)(this.r) : void 0,\n              s: void 0 !== this.s ? (0, u.bigIntToHex)(this.s) : void 0\n            };\n          }\n          errorStr() {\n            var e, t;\n            let r = this._getSharedErrorPostfix();\n            return r += \" gasPrice=\".concat(this.gasPrice, \" accessListCount=\").concat(null !== (t = null === (e = this.accessList) || void 0 === e ? void 0 : e.length) && void 0 !== t ? t : 0), r;\n          }\n          _errorMsg(e) {\n            return \"\".concat(e, \" (\").concat(this.errorStr(), \")\");\n          }\n        }\n        t.AccessListEIP2930Transaction = h;\n      },\n      9275: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.txUtils = t.BaseTransaction = t.TransactionFactory = t.Transaction = t.AccessListEIP2930Transaction = t.FeeMarketEIP1559Transaction = void 0;\n        var a = r(6135);\n        Object.defineProperty(t, \"FeeMarketEIP1559Transaction\", {\n          enumerable: !0,\n          get: function get() {\n            return a.FeeMarketEIP1559Transaction;\n          }\n        });\n        var c = r(9013);\n        Object.defineProperty(t, \"AccessListEIP2930Transaction\", {\n          enumerable: !0,\n          get: function get() {\n            return c.AccessListEIP2930Transaction;\n          }\n        });\n        var u = r(5381);\n        Object.defineProperty(t, \"Transaction\", {\n          enumerable: !0,\n          get: function get() {\n            return u.Transaction;\n          }\n        });\n        var d = r(7668);\n        Object.defineProperty(t, \"TransactionFactory\", {\n          enumerable: !0,\n          get: function get() {\n            return d.TransactionFactory;\n          }\n        });\n        var l = r(915);\n        Object.defineProperty(t, \"BaseTransaction\", {\n          enumerable: !0,\n          get: function get() {\n            return l.BaseTransaction;\n          }\n        }), t.txUtils = o(r(4562)), s(r(9964), t);\n      },\n      5381: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Transaction = void 0;\n        const n = r(7256),\n          i = r(7423),\n          o = r(9634),\n          s = r(7345),\n          a = r(2290),\n          c = r(4555),\n          u = r(915),\n          d = r(9964);\n        function l(e, t) {\n          const r = Number(e),\n            n = 2 * Number(t);\n          return r === n + 35 || r === n + 36;\n        }\n        class h extends u.BaseTransaction {\n          constructor(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var r;\n            if (super(Object.assign(Object.assign({}, e), {\n              type: 0\n            }), t), this.common = this._validateTxV(this.v, t.common), this.gasPrice = (0, a.uint8ArrayToBigInt)((0, a.toUint8Array)(\"\" === e.gasPrice ? \"0x\" : e.gasPrice)), this.gasPrice * this.gasLimit > c.MAX_INTEGER) {\n              const e = this._errorMsg(\"gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)\");\n              throw new Error(e);\n            }\n            this._validateCannotExceedMaxInteger({\n              gasPrice: this.gasPrice\n            }), u.BaseTransaction._validateNotArray(e), this.common.gteHardfork(\"spuriousDragon\") && (this.isSigned() ? l(this.v, this.common.chainId()) && this.activeCapabilities.push(d.Capability.EIP155ReplayProtection) : this.activeCapabilities.push(d.Capability.EIP155ReplayProtection)), (null === (r = null == t ? void 0 : t.freeze) || void 0 === r || r) && Object.freeze(this);\n          }\n          static fromTxData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return new h(e, t);\n          }\n          static fromSerializedTx(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            const r = n.RLP.decode(e);\n            if (!Array.isArray(r)) throw new Error(\"Invalid serialized tx input. Must be array\");\n            return this.fromValuesArray(r, t);\n          }\n          static fromValuesArray(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (6 !== e.length && 9 !== e.length) throw new Error(\"Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).\");\n            const [r, n, i, o, a, c, u, d, l] = e;\n            return (0, s.validateNoLeadingZeroes)({\n              nonce: r,\n              gasPrice: n,\n              gasLimit: i,\n              value: a,\n              v: u,\n              r: d,\n              s: l\n            }), new h({\n              nonce: r,\n              gasPrice: n,\n              gasLimit: i,\n              to: o,\n              value: a,\n              data: c,\n              v: u,\n              r: d,\n              s: l\n            }, t);\n          }\n          raw() {\n            return [(0, a.bigIntToUnpaddedUint8Array)(this.nonce), (0, a.bigIntToUnpaddedUint8Array)(this.gasPrice), (0, a.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, a.bigIntToUnpaddedUint8Array)(this.value), this.data, void 0 !== this.v ? (0, a.bigIntToUnpaddedUint8Array)(this.v) : Uint8Array.from([]), void 0 !== this.r ? (0, a.bigIntToUnpaddedUint8Array)(this.r) : Uint8Array.from([]), void 0 !== this.s ? (0, a.bigIntToUnpaddedUint8Array)(this.s) : Uint8Array.from([])];\n          }\n          serialize() {\n            return n.RLP.encode(this.raw());\n          }\n          _getMessageToSign() {\n            const e = [(0, a.bigIntToUnpaddedUint8Array)(this.nonce), (0, a.bigIntToUnpaddedUint8Array)(this.gasPrice), (0, a.bigIntToUnpaddedUint8Array)(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), (0, a.bigIntToUnpaddedUint8Array)(this.value), this.data];\n            return this.supports(d.Capability.EIP155ReplayProtection) && (e.push((0, a.toUint8Array)(this.common.chainId())), e.push((0, a.unpadUint8Array)((0, a.toUint8Array)(0))), e.push((0, a.unpadUint8Array)((0, a.toUint8Array)(0)))), e;\n          }\n          getMessageToSign() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n            const t = this._getMessageToSign();\n            return e ? (0, i.keccak256)(n.RLP.encode(t)) : t;\n          }\n          getDataFee() {\n            return this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork() ? this.cache.dataFee.value : (Object.isFrozen(this) && (this.cache.dataFee = {\n              value: super.getDataFee(),\n              hardfork: this.common.hardfork()\n            }), super.getDataFee());\n          }\n          getUpfrontCost() {\n            return this.gasLimit * this.gasPrice + this.value;\n          }\n          hash() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"Cannot call hash method if transaction is not signed\");\n              throw new Error(e);\n            }\n            return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = (0, i.keccak256)(n.RLP.encode(this.raw()))), this.cache.hash) : (0, i.keccak256)(n.RLP.encode(this.raw()));\n          }\n          getMessageToVerifySignature() {\n            if (!this.isSigned()) {\n              const e = this._errorMsg(\"This transaction is not signed\");\n              throw new Error(e);\n            }\n            const e = this._getMessageToSign();\n            return (0, i.keccak256)(n.RLP.encode(e));\n          }\n          getSenderPublicKey() {\n            const e = this.getMessageToVerifySignature(),\n              {\n                v: t,\n                r,\n                s: n\n              } = this;\n            this._validateHighS();\n            try {\n              return (0, a.ecrecover)(e, t, (0, a.bigIntToUnpaddedUint8Array)(r), (0, a.bigIntToUnpaddedUint8Array)(n), this.supports(d.Capability.EIP155ReplayProtection) ? this.common.chainId() : void 0);\n            } catch (e) {\n              const t = this._errorMsg(\"Invalid Signature\");\n              throw new Error(t);\n            }\n          }\n          _processSignature(e, t, r) {\n            let n = e;\n            this.supports(d.Capability.EIP155ReplayProtection) && (n += this.common.chainId() * BigInt(2) + BigInt(8));\n            const i = Object.assign(Object.assign({}, this.txOptions), {\n              common: this.common\n            });\n            return h.fromTxData({\n              nonce: this.nonce,\n              gasPrice: this.gasPrice,\n              gasLimit: this.gasLimit,\n              to: this.to,\n              value: this.value,\n              data: this.data,\n              v: n,\n              r: (0, a.uint8ArrayToBigInt)(t),\n              s: (0, a.uint8ArrayToBigInt)(r)\n            }, i);\n          }\n          toJSON() {\n            return {\n              nonce: (0, a.bigIntToHex)(this.nonce),\n              gasPrice: (0, a.bigIntToHex)(this.gasPrice),\n              gasLimit: (0, a.bigIntToHex)(this.gasLimit),\n              to: void 0 !== this.to ? this.to.toString() : void 0,\n              value: (0, a.bigIntToHex)(this.value),\n              data: (0, o.bytesToHex)(this.data),\n              v: void 0 !== this.v ? (0, a.bigIntToHex)(this.v) : void 0,\n              r: void 0 !== this.r ? (0, a.bigIntToHex)(this.r) : void 0,\n              s: void 0 !== this.s ? (0, a.bigIntToHex)(this.s) : void 0\n            };\n          }\n          _validateTxV(e, t) {\n            let r;\n            const n = void 0 !== e ? Number(e) : void 0;\n            if (void 0 !== n && n < 37 && 27 !== n && 28 !== n) throw new Error(\"Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = \".concat(n));\n            if (void 0 !== n && 0 !== n && (!t || t.gteHardfork(\"spuriousDragon\")) && 27 !== n && 28 !== n) if (t) {\n              if (!l(BigInt(n), t.chainId())) throw new Error(\"Incompatible EIP155-based V \".concat(n, \" and chain id \").concat(t.chainId(), \". See the Common parameter of the Transaction constructor to set the chain id.\"));\n            } else {\n              let e;\n              e = (n - 35) % 2 == 0 ? 35 : 36, r = BigInt(n - e) / BigInt(2);\n            }\n            return this._getCommon(t, r);\n          }\n          errorStr() {\n            let e = this._getSharedErrorPostfix();\n            return e += \" gasPrice=\".concat(this.gasPrice), e;\n          }\n          _errorMsg(e) {\n            return \"\".concat(e, \" (\").concat(this.errorStr(), \")\");\n          }\n        }\n        t.Transaction = h;\n      },\n      7668: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TransactionFactory = void 0;\n        const n = r(2290),\n          i = r(6135),\n          o = r(9013),\n          s = r(5381),\n          a = new Map();\n        class c {\n          constructor() {}\n          static typeToInt(e) {\n            return Number((0, n.uint8ArrayToBigInt)((0, n.toUint8Array)(e)));\n          }\n          static registerTransactionType(e, t) {\n            const r = c.typeToInt(e);\n            a.set(r, t);\n          }\n          static fromTxData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (!(\"type\" in e) || void 0 === e.type) return s.Transaction.fromTxData(e, t);\n            const r = c.typeToInt(e.type);\n            if (0 === r) return s.Transaction.fromTxData(e, t);\n            if (1 === r) return o.AccessListEIP2930Transaction.fromTxData(e, t);\n            if (2 === r) return i.FeeMarketEIP1559Transaction.fromTxData(e, t);\n            const n = a.get(r);\n            if (null == n ? void 0 : n.fromTxData) return n.fromTxData(e, t);\n            throw new Error(\"Tx instantiation with type \".concat(r, \" not supported\"));\n          }\n          static fromSerializedData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (!(e[0] <= 127)) return s.Transaction.fromSerializedTx(e, t);\n            switch (e[0]) {\n              case 1:\n                return o.AccessListEIP2930Transaction.fromSerializedTx(e, t);\n              case 2:\n                return i.FeeMarketEIP1559Transaction.fromSerializedTx(e, t);\n              default:\n                {\n                  const r = a.get(Number(e[0]));\n                  if (null == r ? void 0 : r.fromSerializedTx) return r.fromSerializedTx(e, t);\n                  throw new Error(\"TypedTransaction with ID \".concat(e[0], \" unknown\"));\n                }\n            }\n          }\n          static fromBlockBodyData(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            if (e instanceof Uint8Array) return this.fromSerializedData(e, t);\n            if (Array.isArray(e)) return s.Transaction.fromValuesArray(e, t);\n            throw new Error(\"Cannot decode transaction: unknown type input\");\n          }\n        }\n        t.TransactionFactory = c;\n      },\n      9964: (e, t) => {\n        \"use strict\";\n\n        function r(e) {\n          if (0 === e.length) return !0;\n          const t = e[0];\n          return !!Array.isArray(t);\n        }\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAccessList = t.isAccessListUint8Array = t.Capability = void 0, (n = t.Capability || (t.Capability = {}))[n.EIP155ReplayProtection = 155] = \"EIP155ReplayProtection\", n[n.EIP1559FeeMarket = 1559] = \"EIP1559FeeMarket\", n[n.EIP2718TypedTransaction = 2718] = \"EIP2718TypedTransaction\", n[n.EIP2930AccessLists = 2930] = \"EIP2930AccessLists\", t.isAccessListUint8Array = r, t.isAccessList = function (e) {\n          return !r(e);\n        };\n      },\n      4562: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getDataFeeEIP2930 = t.getAccessListJSON = t.verifyAccessList = t.getAccessListData = t.checkMaxInitCodeSize = void 0;\n        const n = r(9634),\n          i = r(2290),\n          o = r(9964);\n        t.checkMaxInitCodeSize = (e, t) => {\n          const r = e.param(\"vm\", \"maxInitCodeSize\");\n          if (r && BigInt(t) > r) throw new Error(\"the initcode size of this transaction is too large: it is \".concat(t, \" while the max is \").concat(e.param(\"vm\", \"maxInitCodeSize\")));\n        }, t.getAccessListData = e => {\n          let t, r;\n          if ((0, o.isAccessList)(e)) {\n            t = e;\n            const n = [];\n            for (let t = 0; t < e.length; t += 1) {\n              const r = e[t],\n                o = (0, i.toUint8Array)(r.address),\n                s = [];\n              for (let e = 0; e < r.storageKeys.length; e += 1) s.push((0, i.toUint8Array)(r.storageKeys[e]));\n              n.push([o, s]);\n            }\n            r = n;\n          } else {\n            r = null != e ? e : [];\n            const i = [];\n            for (let e = 0; e < r.length; e += 1) {\n              const t = r[e],\n                o = (0, n.bytesToHex)(t[0]),\n                s = [];\n              for (let e = 0; e < t[1].length; e += 1) s.push((0, n.bytesToHex)(t[1][e]));\n              const a = {\n                address: o,\n                storageKeys: s\n              };\n              i.push(a);\n            }\n            t = i;\n          }\n          return {\n            AccessListJSON: t,\n            accessList: r\n          };\n        }, t.verifyAccessList = e => {\n          for (let t = 0; t < e.length; t += 1) {\n            const r = e[t],\n              n = r[0],\n              i = r[1];\n            if (void 0 !== r[2]) throw new Error(\"Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.\");\n            if (20 !== n.length) throw new Error(\"Invalid EIP-2930 transaction: address length should be 20 bytes\");\n            for (let e = 0; e < i.length; e += 1) if (32 !== i[e].length) throw new Error(\"Invalid EIP-2930 transaction: storage slot length should be 32 bytes\");\n          }\n        }, t.getAccessListJSON = e => {\n          const t = [];\n          for (let r = 0; r < e.length; r += 1) {\n            const o = e[r],\n              s = {\n                address: (0, n.bytesToHex)((0, i.setLengthLeft)(o[0], 20)),\n                storageKeys: []\n              },\n              a = o && o[1];\n            for (let e = 0; e < a.length; e += 1) {\n              const t = a[e];\n              s.storageKeys.push((0, n.bytesToHex)((0, i.setLengthLeft)(t, 32)));\n            }\n            t.push(s);\n          }\n          return t;\n        }, t.getDataFeeEIP2930 = (e, t) => {\n          const r = t.param(\"gasPrices\", \"accessListStorageKeyCost\"),\n            n = t.param(\"gasPrices\", \"accessListAddressCost\");\n          let i = 0;\n          for (let t = 0; t < e.length; t += 1) i += e[t][1].length;\n          return e.length * Number(n) + i * Number(r);\n        };\n      },\n      4874: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8632: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Wallet = void 0;\n        const i = r(9970),\n          o = r(7345);\n        class s extends i.Web3BaseWallet {\n          constructor() {\n            super(...arguments), this._addressMap = new Map(), this._defaultKeyName = \"web3js_wallet\";\n          }\n          static getStorage() {\n            let e;\n            try {\n              e = window.localStorage;\n              const t = \"__storage_test__\";\n              return e.setItem(t, t), e.removeItem(t), e;\n            } catch (t) {\n              return !t || 22 !== t.code && 1014 !== t.code && \"QuotaExceededError\" !== t.name && \"NS_ERROR_DOM_QUOTA_REACHED\" !== t.name || (0, o.isNullish)(e) || 0 === e.length ? void 0 : e;\n            }\n          }\n          create(e) {\n            for (let t = 0; t < e; t += 1) this.add(this._accountProvider.create());\n            return this;\n          }\n          add(e) {\n            var t;\n            if (\"string\" == typeof e) return this.add(this._accountProvider.privateKeyToAccount(e));\n            let r = this.length;\n            return this.get(e.address) && (console.warn(\"Account \".concat(e.address.toLowerCase(), \" already exists.\")), r = null !== (t = this._addressMap.get(e.address.toLowerCase())) && void 0 !== t ? t : r), this._addressMap.set(e.address.toLowerCase(), r), this[r] = e, this;\n          }\n          get(e) {\n            if (\"string\" == typeof e) {\n              const t = this._addressMap.get(e.toLowerCase());\n              return (0, o.isNullish)(t) ? void 0 : this[t];\n            }\n            return this[e];\n          }\n          remove(e) {\n            if (\"string\" == typeof e) {\n              const t = this._addressMap.get(e.toLowerCase());\n              return !(0, o.isNullish)(t) && (this._addressMap.delete(e.toLowerCase()), this.splice(t, 1), !0);\n            }\n            return !!this[e] && (this.splice(e, 1), !0);\n          }\n          clear() {\n            return this._addressMap.clear(), this.length = 0, this;\n          }\n          encrypt(e, t) {\n            return n(this, void 0, void 0, function* () {\n              return Promise.all(this.map(r => n(this, void 0, void 0, function* () {\n                return r.encrypt(e, t);\n              })));\n            });\n          }\n          decrypt(e, t, r) {\n            return n(this, void 0, void 0, function* () {\n              const i = yield Promise.all(e.map(e => n(this, void 0, void 0, function* () {\n                return this._accountProvider.decrypt(e, t, r);\n              })));\n              for (const e of i) this.add(e);\n              return this;\n            });\n          }\n          save(e, t) {\n            return n(this, void 0, void 0, function* () {\n              const r = s.getStorage();\n              if (!r) throw new Error(\"Local storage not available.\");\n              return r.setItem(null != t ? t : this._defaultKeyName, JSON.stringify(yield this.encrypt(e))), !0;\n            });\n          }\n          load(e, t) {\n            return n(this, void 0, void 0, function* () {\n              const r = s.getStorage();\n              if (!r) throw new Error(\"Local storage not available.\");\n              const n = r.getItem(null != t ? t : this._defaultKeyName);\n              return n && (yield this.decrypt(JSON.parse(n) || [], e)), this;\n            });\n          }\n        }\n        t.Wallet = s;\n      },\n      6658: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Contract = void 0;\n        const i = r(6527),\n          o = r(5071),\n          s = r(6637),\n          a = r(8381),\n          c = r(9970),\n          u = r(9634),\n          d = r(7345),\n          l = r(5537),\n          h = r(7388),\n          f = r(3948),\n          p = {\n            logs: h.LogsSubscription,\n            newHeads: s.NewHeadsSubscription,\n            newBlockHeaders: s.NewHeadsSubscription\n          };\n        class m extends i.Web3Context {\n          constructor(e, t, r, n, s) {\n            var a, l, h;\n            const g = (0, f.isContractInitOptions)(t) ? t : (0, f.isContractInitOptions)(r) ? r : void 0;\n            let y, v;\n            if (y = (0, f.isWeb3ContractContext)(t) ? t : (0, f.isWeb3ContractContext)(r) ? r : n, v = \"object\" == typeof t && \"provider\" in t ? t.provider : \"object\" == typeof r && \"provider\" in r ? r.provider : \"object\" == typeof n && \"provider\" in n ? n.provider : m.givenProvider, super(Object.assign(Object.assign({}, y), {\n              provider: v,\n              registeredSubscriptions: p\n            })), this.syncWithContext = !1, this._functions = {}, !(0, d.isNullish)(g) && !(0, d.isNullish)(g.data) && !(0, d.isNullish)(g.input) && \"both\" !== this.config.contractDataInputFill) throw new o.ContractTransactionDataAndInputError({\n              data: g.data,\n              input: g.input\n            });\n            this._overloadedMethodAbis = new Map();\n            const b = (0, u.isDataFormat)(n) ? n : (0, u.isDataFormat)(r) ? r : null != s ? s : c.DEFAULT_RETURN_FORMAT,\n              E = \"string\" == typeof t ? t : void 0;\n            \"both\" === this.config.contractDataInputFill ? this._dataInputFill = this.config.contractDataInputFill : this._dataInputFill = null !== (a = null == g ? void 0 : g.dataInputFill) && void 0 !== a ? a : this.config.contractDataInputFill, this._parseAndSetJsonInterface(e, b), (0, d.isNullish)(E) || this._parseAndSetAddress(E, b), this.options = {\n              address: E,\n              jsonInterface: this._jsonInterface,\n              gas: null !== (l = null == g ? void 0 : g.gas) && void 0 !== l ? l : null == g ? void 0 : g.gasLimit,\n              gasPrice: null == g ? void 0 : g.gasPrice,\n              from: null == g ? void 0 : g.from,\n              input: null == g ? void 0 : g.input,\n              data: null == g ? void 0 : g.data\n            }, this.syncWithContext = null !== (h = null == g ? void 0 : g.syncWithContext) && void 0 !== h && h, y instanceof i.Web3Context && this.subscribeToContextEvents(y), Object.defineProperty(this.options, \"address\", {\n              set: e => this._parseAndSetAddress(e, b),\n              get: () => this._address\n            }), Object.defineProperty(this.options, \"jsonInterface\", {\n              set: e => this._parseAndSetJsonInterface(e, b),\n              get: () => this._jsonInterface\n            });\n          }\n          get events() {\n            return this._events;\n          }\n          get methods() {\n            return this._methods;\n          }\n          clone() {\n            let e;\n            return e = this.options.address ? new m([...this._jsonInterface, ...this._errorsInterface], this.options.address, {\n              gas: this.options.gas,\n              gasPrice: this.options.gasPrice,\n              from: this.options.from,\n              input: this.options.input,\n              data: this.options.data,\n              provider: this.currentProvider,\n              syncWithContext: this.syncWithContext,\n              dataInputFill: this._dataInputFill\n            }, this.getContextObject()) : new m([...this._jsonInterface, ...this._errorsInterface], {\n              gas: this.options.gas,\n              gasPrice: this.options.gasPrice,\n              from: this.options.from,\n              input: this.options.input,\n              data: this.options.data,\n              provider: this.currentProvider,\n              syncWithContext: this.syncWithContext,\n              dataInputFill: this._dataInputFill\n            }, this.getContextObject()), this.context && e.subscribeToContextEvents(this.context), e;\n          }\n          deploy(e) {\n            var _this6 = this;\n            var t, r, i;\n            let s = this._jsonInterface.find(e => \"constructor\" === e.type);\n            s || (s = {\n              type: \"constructor\",\n              inputs: [],\n              stateMutability: \"\"\n            });\n            const a = (0, u.format)({\n                format: \"bytes\"\n              }, null !== (t = null == e ? void 0 : e.input) && void 0 !== t ? t : this.options.input, c.DEFAULT_RETURN_FORMAT),\n              d = (0, u.format)({\n                format: \"bytes\"\n              }, null !== (r = null == e ? void 0 : e.data) && void 0 !== r ? r : this.options.data, c.DEFAULT_RETURN_FORMAT);\n            if (!(a && \"0x\" !== a.trim() || d && \"0x\" !== d.trim())) throw new o.Web3ContractError(\"contract creation without any data provided.\");\n            const h = null !== (i = null == e ? void 0 : e.arguments) && void 0 !== i ? i : [],\n              f = Object.assign(Object.assign({}, this.options), {\n                input: a,\n                data: d\n              }),\n              p = null != a ? a : d;\n            return {\n              arguments: h,\n              send: e => {\n                const t = Object.assign({}, e);\n                return this._contractMethodDeploySend(s, h, t, f);\n              },\n              estimateGas: function estimateGas(e) {\n                let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c.DEFAULT_RETURN_FORMAT;\n                return n(_this6, void 0, void 0, function* () {\n                  const r = Object.assign({}, e);\n                  return this._contractMethodEstimateGas({\n                    abi: s,\n                    params: h,\n                    returnFormat: t,\n                    options: r,\n                    contractOptions: f\n                  });\n                });\n              },\n              encodeABI: () => (0, l.encodeMethodABI)(s, h, (0, u.format)({\n                format: \"bytes\"\n              }, p, c.DEFAULT_RETURN_FORMAT))\n            };\n          }\n          getPastEvents(e, t, r) {\n            var i;\n            return n(this, void 0, void 0, function* () {\n              const n = \"string\" == typeof e ? e : s.ALL_EVENTS,\n                a = \"string\" == typeof e || (0, u.isDataFormat)(e) ? (0, u.isDataFormat)(t) ? {} : t : e,\n                d = (0, u.isDataFormat)(e) ? e : (0, u.isDataFormat)(t) ? t : null != r ? r : c.DEFAULT_RETURN_FORMAT,\n                h = \"allEvents\" === n || n === s.ALL_EVENTS ? s.ALL_EVENTS_ABI : this._jsonInterface.find(e => \"name\" in e && e.name === n);\n              if (!h) throw new o.Web3ContractError(\"Event \".concat(n, \" not found.\"));\n              const {\n                  fromBlock: f,\n                  toBlock: p,\n                  topics: m,\n                  address: g\n                } = (0, l.encodeEventABI)(this.options, h, null != a ? a : {}),\n                y = (yield (0, s.getLogs)(this, {\n                  fromBlock: f,\n                  toBlock: p,\n                  topics: m,\n                  address: g\n                }, d)).map(e => \"string\" == typeof e ? e : (0, s.decodeEventABI)(h, e, this._jsonInterface, d)),\n                v = null !== (i = null == a ? void 0 : a.filter) && void 0 !== i ? i : {},\n                b = Object.keys(v);\n              return b.length > 0 ? y.filter(e => \"string\" == typeof e || b.every(t => {\n                var r;\n                if (Array.isArray(v[t])) return v[t].some(r => String(e.returnValues[t]).toUpperCase() === String(r).toUpperCase());\n                const n = null === (r = h.inputs) || void 0 === r ? void 0 : r.filter(e => e.name === t)[0];\n                return !(!(null == n ? void 0 : n.indexed) || \"string\" !== n.type || (0, u.keccak256)(v[t]) !== String(e.returnValues[t])) || String(e.returnValues[t]).toUpperCase() === String(v[t]).toUpperCase();\n              })) : y;\n            });\n          }\n          _parseAndSetAddress(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c.DEFAULT_RETURN_FORMAT;\n            this._address = e ? (0, u.toChecksumAddress)((0, u.format)({\n              format: \"address\"\n            }, e, t)) : e;\n          }\n          _parseAndSetJsonInterface(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c.DEFAULT_RETURN_FORMAT;\n            var r, n, i, o, u;\n            this._functions = {}, this._methods = {}, this._events = {};\n            let d = [];\n            const l = e.filter(e => \"error\" !== e.type),\n              h = e.filter(e => (0, a.isAbiErrorFragment)(e));\n            for (const e of l) {\n              const s = Object.assign(Object.assign({}, e), {\n                signature: \"\"\n              });\n              if ((0, a.isAbiFunctionFragment)(s)) {\n                const e = (0, a.jsonInterfaceMethodToString)(s),\n                  t = (0, a.encodeFunctionSignature)(e);\n                s.signature = t, s.constant = null !== (n = null !== (r = \"view\" === s.stateMutability) && void 0 !== r ? r : \"pure\" === s.stateMutability) && void 0 !== n ? n : s.constant, s.payable = null !== (i = \"payable\" === s.stateMutability) && void 0 !== i ? i : s.payable, this._overloadedMethodAbis.set(s.name, [...(null !== (o = this._overloadedMethodAbis.get(s.name)) && void 0 !== o ? o : []), s]);\n                const c = null !== (u = this._overloadedMethodAbis.get(s.name)) && void 0 !== u ? u : [],\n                  d = this._createContractMethod(c, h);\n                this._functions[e] = {\n                  signature: t,\n                  method: d\n                }, this._methods[s.name] = this._functions[e].method, this._methods[e] = this._functions[e].method, this._methods[t] = this._functions[e].method;\n              } else if ((0, a.isAbiEventFragment)(s)) {\n                const e = (0, a.jsonInterfaceMethodToString)(s),\n                  r = (0, a.encodeEventSignature)(e),\n                  n = this._createContractEvent(s, t);\n                s.signature = r, e in this._events && \"bound\" !== s.name || (this._events[e] = n), this._events[s.name] = n, this._events[r] = n;\n              }\n              d = [...d, s];\n            }\n            this._events.allEvents = this._createContractEvent(s.ALL_EVENTS_ABI, t), this._jsonInterface = [...d], this._errorsInterface = h;\n          }\n          _getAbiParams(e, t) {\n            var r;\n            try {\n              return d.utils.transformJsonDataToAbiFormat(null !== (r = e.inputs) && void 0 !== r ? r : [], t);\n            } catch (t) {\n              throw new o.Web3ContractError(\"Invalid parameters for method \".concat(e.name, \": \").concat(t.message));\n            }\n          }\n          _createContractMethod(e, t) {\n            var _this7 = this;\n            const r = e[e.length - 1];\n            return function () {\n              for (var _len15 = arguments.length, e = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n                e[_key15] = arguments[_key15];\n              }\n              var i, o;\n              let s;\n              const a = null !== (i = _this7._overloadedMethodAbis.get(r.name)) && void 0 !== i ? i : [];\n              let u = a[0];\n              const h = t,\n                f = a.filter(t => {\n                  var r;\n                  return (null !== (r = t.inputs) && void 0 !== r ? r : []).length === e.length;\n                });\n              if (1 === a.length || 0 === f.length) s = _this7._getAbiParams(u, e), d.validator.validate(null !== (o = r.inputs) && void 0 !== o ? o : [], s);else {\n                const t = [];\n                for (const r of f) try {\n                  s = _this7._getAbiParams(r, e), d.validator.validate(r.inputs, s), u = r;\n                  break;\n                } catch (e) {\n                  t.push(e);\n                }\n                if (t.length === f.length) throw new d.Web3ValidatorError(t);\n              }\n              const p = {\n                arguments: s,\n                call: (e, t) => n(_this7, void 0, void 0, function* () {\n                  return this._contractMethodCall(u, s, h, e, t);\n                }),\n                send: e => _this7._contractMethodSend(u, s, h, e),\n                estimateGas: function estimateGas(e) {\n                  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c.DEFAULT_RETURN_FORMAT;\n                  return n(_this7, void 0, void 0, function* () {\n                    return this._contractMethodEstimateGas({\n                      abi: u,\n                      params: s,\n                      returnFormat: t,\n                      options: e\n                    });\n                  });\n                },\n                encodeABI: () => (0, l.encodeMethodABI)(u, s),\n                createAccessList: (e, t) => n(_this7, void 0, void 0, function* () {\n                  return this._contractMethodCreateAccessList(u, s, h, e, t);\n                })\n              };\n              return u.stateMutability, p;\n            };\n          }\n          _contractMethodCall(e, t, r, i, u) {\n            var d;\n            return n(this, void 0, void 0, function* () {\n              const n = (0, f.getEthTxCallParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, i), {\n                  dataInputFill: this._dataInputFill\n                }),\n                contractOptions: Object.assign(Object.assign({}, this.options), {\n                  from: null !== (d = this.options.from) && void 0 !== d ? d : this.config.defaultAccount\n                })\n              });\n              try {\n                const t = yield (0, s.call)(this, n, u, c.DEFAULT_RETURN_FORMAT);\n                return (0, l.decodeMethodReturn)(e, t);\n              } catch (e) {\n                throw e instanceof o.ContractExecutionError && (0, a.decodeContractErrorData)(r, e.innerError), e;\n              }\n            });\n          }\n          _contractMethodCreateAccessList(e, t, r, i, u) {\n            var d;\n            return n(this, void 0, void 0, function* () {\n              const n = (0, f.getCreateAccessListParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, i), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: Object.assign(Object.assign({}, this.options), {\n                  from: null !== (d = this.options.from) && void 0 !== d ? d : this.config.defaultAccount\n                })\n              });\n              try {\n                return (0, s.createAccessList)(this, n, u, c.DEFAULT_RETURN_FORMAT);\n              } catch (e) {\n                throw e instanceof o.ContractExecutionError && (0, a.decodeContractErrorData)(r, e.innerError), e;\n              }\n            });\n          }\n          _contractMethodSend(e, t, r, n, i) {\n            var u, d;\n            let l = null != i ? i : this.options;\n            l = Object.assign(Object.assign({}, l), {\n              input: void 0,\n              from: null !== (d = null !== (u = l.from) && void 0 !== u ? u : this.defaultAccount) && void 0 !== d ? d : void 0\n            });\n            const h = (0, f.getSendTxParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, n), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: l\n              }),\n              p = (0, s.sendTransaction)(this, h, c.DEFAULT_RETURN_FORMAT, {\n                checkRevertBeforeSending: !1,\n                contractAbi: this._jsonInterface\n              });\n            return p.on(\"error\", e => {\n              e instanceof o.ContractExecutionError && (0, a.decodeContractErrorData)(r, e.innerError);\n            }), p;\n          }\n          _contractMethodDeploySend(e, t, r, n) {\n            var i, a;\n            let u = null != n ? n : this.options;\n            u = Object.assign(Object.assign({}, u), {\n              from: null !== (a = null !== (i = u.from) && void 0 !== i ? i : this.defaultAccount) && void 0 !== a ? a : void 0\n            });\n            const d = (0, f.getSendTxParams)({\n              abi: e,\n              params: t,\n              options: Object.assign(Object.assign({}, r), {\n                dataInputFill: this.config.contractDataInputFill\n              }),\n              contractOptions: u\n            });\n            return (0, s.sendTransaction)(this, d, c.DEFAULT_RETURN_FORMAT, {\n              transactionResolver: e => {\n                if (e.status === BigInt(0)) throw new o.Web3ContractError(\"code couldn't be stored\", e);\n                const t = this.clone();\n                return t.options.address = e.contractAddress, t;\n              },\n              contractAbi: this._jsonInterface,\n              checkRevertBeforeSending: !1\n            });\n          }\n          _contractMethodEstimateGas(_ref23) {\n            let {\n              abi: e,\n              params: t,\n              returnFormat: r,\n              options: i,\n              contractOptions: o\n            } = _ref23;\n            return n(this, void 0, void 0, function* () {\n              const n = (0, f.getEstimateGasParams)({\n                abi: e,\n                params: t,\n                options: Object.assign(Object.assign({}, i), {\n                  dataInputFill: this.config.contractDataInputFill\n                }),\n                contractOptions: null != o ? o : this.options\n              });\n              return (0, s.estimateGas)(this, n, c.BlockTags.LATEST, r);\n            });\n          }\n          _createContractEvent(e) {\n            var _this8 = this;\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c.DEFAULT_RETURN_FORMAT;\n            return function () {\n              var n;\n              const {\n                  topics: i,\n                  fromBlock: s\n                } = (0, l.encodeEventABI)(_this8.options, e, arguments.length <= 0 ? undefined : arguments[0]),\n                a = new h.LogsSubscription({\n                  address: _this8.options.address,\n                  topics: i,\n                  abi: e,\n                  jsonInterface: _this8._jsonInterface\n                }, {\n                  subscriptionManager: _this8.subscriptionManager,\n                  returnFormat: t\n                });\n              return (0, d.isNullish)(s) || _this8.getPastEvents(e.name, {\n                fromBlock: s,\n                topics: i\n              }, t).then(e => {\n                e.forEach(e => a.emit(\"data\", e));\n              }).catch(e => {\n                a.emit(\"error\", new o.SubscriptionError(\"Failed to get past events.\", e));\n              }), null === (n = _this8.subscriptionManager) || void 0 === n || n.addSubscription(a).catch(e => {\n                a.emit(\"error\", new o.SubscriptionError(\"Failed to subscribe.\", e));\n              }), a;\n            };\n          }\n          subscribeToContextEvents(e) {\n            const t = this;\n            this.context = e, t.syncWithContext && e.on(i.Web3ConfigEvent.CONFIG_CHANGE, e => {\n              t.setConfig({\n                [e.name]: e.newValue\n              });\n            });\n          }\n        }\n        t.Contract = m;\n      },\n      5537: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeMethodReturn = t.encodeMethodABI = t.encodeEventABI = t.decodeEventABI = void 0;\n        const n = r(9634),\n          i = r(9970),\n          o = r(8381),\n          s = r(6637),\n          a = r(5071);\n        var c = r(6637);\n        Object.defineProperty(t, \"decodeEventABI\", {\n          enumerable: !0,\n          get: function get() {\n            return c.decodeEventABI;\n          }\n        }), t.encodeEventABI = (_ref24, t, r) => {\n          let {\n            address: e\n          } = _ref24;\n          var a, c;\n          const u = null == r ? void 0 : r.topics,\n            d = null !== (a = null == r ? void 0 : r.filter) && void 0 !== a ? a : {},\n            l = {};\n          if ((0, n.isNullish)(null == r ? void 0 : r.fromBlock) || (l.fromBlock = (0, n.format)(s.blockSchema.properties.number, null == r ? void 0 : r.fromBlock, {\n            number: i.FMT_NUMBER.HEX,\n            bytes: i.FMT_BYTES.HEX\n          })), (0, n.isNullish)(null == r ? void 0 : r.toBlock) || (l.toBlock = (0, n.format)(s.blockSchema.properties.number, null == r ? void 0 : r.toBlock, {\n            number: i.FMT_NUMBER.HEX,\n            bytes: i.FMT_BYTES.HEX\n          })), u && Array.isArray(u)) l.topics = [...u];else if (l.topics = [], !t || t.anonymous || [s.ALL_EVENTS, \"allEvents\"].includes(t.name) || l.topics.push(null !== (c = t.signature) && void 0 !== c ? c : (0, o.encodeEventSignature)((0, o.jsonInterfaceMethodToString)(t))), ![s.ALL_EVENTS, \"allEvents\"].includes(t.name) && t.inputs) for (const e of t.inputs) {\n            if (!e.indexed) continue;\n            const t = d[e.name];\n            t ? Array.isArray(t) ? l.topics.push(t.map(t => (0, o.encodeParameter)(e.type, t))) : \"string\" === e.type ? l.topics.push((0, n.keccak256)(t)) : l.topics.push((0, o.encodeParameter)(e.type, t)) : l.topics.push(null);\n          }\n          return l.topics.length || delete l.topics, e && (l.address = e.toLowerCase()), l;\n        }, t.encodeMethodABI = (e, t, r) => {\n          const n = Array.isArray(e.inputs) ? e.inputs.length : 0;\n          if (n !== t.length) throw new a.Web3ContractError(\"The number of arguments is not matching the methods required number. You need to pass \".concat(n, \" arguments.\"));\n          const i = (0, o.encodeParameters)(Array.isArray(e.inputs) ? e.inputs : [], t).replace(\"0x\", \"\");\n          if ((0, o.isAbiConstructorFragment)(e)) {\n            if (!r) throw new a.Web3ContractError(\"The contract has no contract data option set. This is necessary to append the constructor parameters.\");\n            return r.startsWith(\"0x\") ? \"\".concat(r).concat(i) : \"0x\".concat(r).concat(i);\n          }\n          return \"\".concat((0, o.encodeFunctionSignature)(e)).concat(i);\n        }, t.decodeMethodReturn = (e, t) => {\n          if (\"constructor\" === e.type) return t;\n          if (!t) return null;\n          const r = t.length >= 2 ? t.slice(2) : t;\n          if (!e.outputs) return null;\n          const n = (0, o.decodeParameters)([...e.outputs], r);\n          return 1 === n.__length__ ? n[0] : n;\n        };\n      },\n      3211: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const o = r(6658);\n        i(r(5537), t), i(r(6658), t), i(r(7388), t), i(r(3951), t), t.default = o.Contract;\n      },\n      7388: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.LogsSubscription = void 0;\n        const n = r(6527),\n          i = r(6637);\n        class o extends n.Web3Subscription {\n          constructor(e, t) {\n            super(e, t), this.address = e.address, this.topics = e.topics, this.abi = e.abi, this.jsonInterface = e.jsonInterface;\n          }\n          _buildSubscriptionParams() {\n            return [\"logs\", {\n              address: this.address,\n              topics: this.topics\n            }];\n          }\n          formatSubscriptionResult(e) {\n            return (0, i.decodeEventABI)(this.abi, e, this.jsonInterface, super.returnFormat);\n          }\n        }\n        t.LogsSubscription = o;\n      },\n      3951: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      3948: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getCreateAccessListParams = t.isWeb3ContractContext = t.isContractInitOptions = t.getEstimateGasParams = t.getEthTxCallParams = t.getSendTxParams = void 0;\n        const n = r(5071),\n          i = r(9634),\n          o = r(5537),\n          s = (e, t, r, n) => {\n            var s, a;\n            const c = {};\n            return (0, i.isNullish)(e.data) && \"both\" !== n || (c.data = (0, o.encodeMethodABI)(t, r, null !== (s = e.data) && void 0 !== s ? s : e.input)), (0, i.isNullish)(e.input) && \"both\" !== n || (c.input = (0, o.encodeMethodABI)(t, r, null !== (a = e.input) && void 0 !== a ? a : e.data)), (0, i.isNullish)(c.input) && (0, i.isNullish)(c.data) && (c[n] = (0, o.encodeMethodABI)(t, r)), {\n              data: c.data,\n              input: c.input\n            };\n          };\n        t.getSendTxParams = _ref25 => {\n          let {\n            abi: e,\n            params: t,\n            options: r,\n            contractOptions: o\n          } = _ref25;\n          var a, c, u;\n          if (!(null !== (u = null !== (c = null !== (a = null == r ? void 0 : r.input) && void 0 !== a ? a : null == r ? void 0 : r.data) && void 0 !== c ? c : o.input) && void 0 !== u ? u : o.data) && !(null == r ? void 0 : r.to) && !o.address) throw new n.Web3ContractError(\"Contract address not specified\");\n          if (!(null == r ? void 0 : r.from) && !o.from) throw new n.Web3ContractError('Contract \"from\" address not specified');\n          let d = (0, i.mergeDeep)({\n            to: o.address,\n            gas: o.gas,\n            gasPrice: o.gasPrice,\n            from: o.from,\n            input: o.input,\n            maxPriorityFeePerGas: o.maxPriorityFeePerGas,\n            maxFeePerGas: o.maxFeePerGas,\n            data: o.data\n          }, r);\n          const l = s(d, e, t, null == r ? void 0 : r.dataInputFill);\n          return d = Object.assign(Object.assign({}, d), {\n            data: l.data,\n            input: l.input\n          }), d;\n        }, t.getEthTxCallParams = _ref26 => {\n          let {\n            abi: e,\n            params: t,\n            options: r,\n            contractOptions: o\n          } = _ref26;\n          if (!(null == r ? void 0 : r.to) && !o.address) throw new n.Web3ContractError(\"Contract address not specified\");\n          let a = (0, i.mergeDeep)({\n            to: o.address,\n            gas: o.gas,\n            gasPrice: o.gasPrice,\n            from: o.from,\n            input: o.input,\n            maxPriorityFeePerGas: o.maxPriorityFeePerGas,\n            maxFeePerGas: o.maxFeePerGas,\n            data: o.data\n          }, r);\n          const c = s(a, e, t, null == r ? void 0 : r.dataInputFill);\n          return a = Object.assign(Object.assign({}, a), {\n            data: c.data,\n            input: c.input\n          }), a;\n        }, t.getEstimateGasParams = _ref27 => {\n          let {\n            abi: e,\n            params: t,\n            options: r,\n            contractOptions: n\n          } = _ref27;\n          let o = (0, i.mergeDeep)({\n            to: n.address,\n            gas: n.gas,\n            gasPrice: n.gasPrice,\n            from: n.from,\n            input: n.input,\n            data: n.data\n          }, r);\n          const a = s(o, e, t, null == r ? void 0 : r.dataInputFill);\n          return o = Object.assign(Object.assign({}, o), {\n            data: a.data,\n            input: a.input\n          }), o;\n        }, t.isContractInitOptions = e => \"object\" == typeof e && !(0, i.isNullish)(e) && [\"input\", \"data\", \"from\", \"gas\", \"gasPrice\", \"gasLimit\", \"address\", \"jsonInterface\", \"syncWithContext\", \"dataInputFill\"].some(t => t in e), t.isWeb3ContractContext = e => \"object\" == typeof e && !(0, i.isNullish)(e) && !(0, t.isContractInitOptions)(e), t.getCreateAccessListParams = _ref28 => {\n          let {\n            abi: e,\n            params: t,\n            options: r,\n            contractOptions: o\n          } = _ref28;\n          if (!(null == r ? void 0 : r.to) && !o.address) throw new n.Web3ContractError(\"Contract address not specified\");\n          if (!(null == r ? void 0 : r.from) && !o.from) throw new n.Web3ContractError('Contract \"from\" address not specified');\n          let a = (0, i.mergeDeep)({\n            to: o.address,\n            gas: o.gas,\n            gasPrice: o.gasPrice,\n            from: o.from,\n            input: o.input,\n            maxPriorityFeePerGas: o.maxPriorityFeePerGas,\n            maxFeePerGas: o.maxFeePerGas,\n            data: o.data\n          }, r);\n          const c = s(a, e, t, null == r ? void 0 : r.dataInputFill);\n          return a = Object.assign(Object.assign({}, a), {\n            data: c.data,\n            input: c.input\n          }), a;\n        };\n      },\n      6919: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ENSRegistryAbi = void 0, t.ENSRegistryAbi = [{\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"label\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }],\n          name: \"NewOwner\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"resolver\",\n            type: \"address\"\n          }],\n          name: \"NewResolver\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }],\n          name: \"Transfer\",\n          type: \"event\"\n        }, {\n          inputs: [{\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }, {\n            internalType: \"address\",\n            name: \"operator\",\n            type: \"address\"\n          }],\n          name: \"isApprovedForAll\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"owner\",\n          outputs: [{\n            internalType: \"address\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"recordExists\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"resolver\",\n          outputs: [{\n            internalType: \"address\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"ttl\",\n          outputs: [{\n            internalType: \"uint64\",\n            name: \"\",\n            type: \"uint64\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }];\n      },\n      172: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.PublicResolverAbi = void 0, t.PublicResolverAbi = [{\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"a\",\n            type: \"address\"\n          }],\n          name: \"AddrChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"uint256\",\n            name: \"coinType\",\n            type: \"uint256\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"newAddress\",\n            type: \"bytes\"\n          }],\n          name: \"AddressChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"address\",\n            name: \"owner\",\n            type: \"address\"\n          }, {\n            indexed: !0,\n            internalType: \"address\",\n            name: \"operator\",\n            type: \"address\"\n          }, {\n            indexed: !1,\n            internalType: \"bool\",\n            name: \"approved\",\n            type: \"bool\"\n          }],\n          name: \"ApprovalForAll\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"hash\",\n            type: \"bytes\"\n          }],\n          name: \"ContenthashChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"name\",\n            type: \"bytes\"\n          }, {\n            indexed: !1,\n            internalType: \"uint16\",\n            name: \"resource\",\n            type: \"uint16\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"record\",\n            type: \"bytes\"\n          }],\n          name: \"DNSRecordChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"name\",\n            type: \"bytes\"\n          }, {\n            indexed: !1,\n            internalType: \"uint16\",\n            name: \"resource\",\n            type: \"uint16\"\n          }],\n          name: \"DNSRecordDeleted\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"DNSZoneCleared\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"lastzonehash\",\n            type: \"bytes\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes\",\n            name: \"zonehash\",\n            type: \"bytes\"\n          }],\n          name: \"DNSZonehashChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !0,\n            internalType: \"bytes4\",\n            name: \"interfaceID\",\n            type: \"bytes4\"\n          }, {\n            indexed: !1,\n            internalType: \"address\",\n            name: \"implementer\",\n            type: \"address\"\n          }],\n          name: \"InterfaceChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"string\",\n            name: \"name\",\n            type: \"string\"\n          }],\n          name: \"NameChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes32\",\n            name: \"x\",\n            type: \"bytes32\"\n          }, {\n            indexed: !1,\n            internalType: \"bytes32\",\n            name: \"y\",\n            type: \"bytes32\"\n          }],\n          name: \"PubkeyChanged\",\n          type: \"event\"\n        }, {\n          anonymous: !1,\n          inputs: [{\n            indexed: !0,\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            indexed: !0,\n            internalType: \"string\",\n            name: \"indexedKey\",\n            type: \"string\"\n          }, {\n            indexed: !1,\n            internalType: \"string\",\n            name: \"key\",\n            type: \"string\"\n          }],\n          name: \"TextChanged\",\n          type: \"event\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"uint256\",\n            name: \"contentTypes\",\n            type: \"uint256\"\n          }],\n          name: \"ABI\",\n          outputs: [{\n            internalType: \"uint256\",\n            name: \"\",\n            type: \"uint256\"\n          }, {\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"addr\",\n          outputs: [{\n            internalType: \"address payable\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"uint256\",\n            name: \"coinType\",\n            type: \"uint256\"\n          }],\n          name: \"addr\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"contenthash\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes32\",\n            name: \"name\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"uint16\",\n            name: \"resource\",\n            type: \"uint16\"\n          }],\n          name: \"dnsRecord\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes32\",\n            name: \"name\",\n            type: \"bytes32\"\n          }],\n          name: \"hasDNSRecords\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes4\",\n            name: \"interfaceID\",\n            type: \"bytes4\"\n          }],\n          name: \"interfaceImplementer\",\n          outputs: [{\n            internalType: \"address\",\n            name: \"\",\n            type: \"address\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"address\",\n            name: \"account\",\n            type: \"address\"\n          }, {\n            internalType: \"address\",\n            name: \"operator\",\n            type: \"address\"\n          }],\n          name: \"isApprovedForAll\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"name\",\n          outputs: [{\n            internalType: \"string\",\n            name: \"\",\n            type: \"string\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"pubkey\",\n          outputs: [{\n            internalType: \"bytes32\",\n            name: \"x\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"bytes32\",\n            name: \"y\",\n            type: \"bytes32\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes4\",\n            name: \"interfaceID\",\n            type: \"bytes4\"\n          }],\n          name: \"supportsInterface\",\n          outputs: [{\n            internalType: \"bool\",\n            name: \"\",\n            type: \"bool\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }, {\n            internalType: \"string\",\n            name: \"key\",\n            type: \"string\"\n          }],\n          name: \"text\",\n          outputs: [{\n            internalType: \"string\",\n            name: \"\",\n            type: \"string\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }, {\n          inputs: [{\n            internalType: \"bytes32\",\n            name: \"node\",\n            type: \"bytes32\"\n          }],\n          name: \"zonehash\",\n          outputs: [{\n            internalType: \"bytes\",\n            name: \"\",\n            type: \"bytes\"\n          }],\n          stateMutability: \"view\",\n          type: \"function\"\n        }];\n      },\n      8677: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.networkIds = t.registryAddresses = t.methodsInInterface = t.interfaceIds = void 0, t.interfaceIds = {\n          addr: \"0x3b3b57de\",\n          name: \"0x691f3431\",\n          abi: \"0x2203ab56\",\n          pubkey: \"0xc8690233\",\n          text: \"0x59d1d43c\",\n          contenthash: \"0xbc1c58d1\"\n        }, t.methodsInInterface = {\n          setAddr: \"addr\",\n          addr: \"addr\",\n          setPubkey: \"pubkey\",\n          pubkey: \"pubkey\",\n          setContenthash: \"contenthash\",\n          contenthash: \"contenthash\"\n        }, t.registryAddresses = {\n          main: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n          goerli: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\"\n        }, t.networkIds = {\n          \"0x1\": \"main\",\n          \"0x5\": \"goerli\"\n        };\n      },\n      9142: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ENS = void 0;\n        const i = r(6527),\n          o = r(5071),\n          s = r(6637),\n          a = r(9820),\n          c = r(9970),\n          u = r(8677),\n          d = r(67),\n          l = r(8067);\n        class h extends i.Web3Context {\n          constructor(e, t) {\n            super(null != t ? t : \"\"), this.registryAddress = null != e ? e : u.registryAddresses.main, this._registry = new d.Registry(this.getContextObject(), e), this._resolver = new l.Resolver(this._registry);\n          }\n          getResolver(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.getResolver(e);\n            });\n          }\n          recordExists(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.recordExists(e);\n            });\n          }\n          getTTL(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.getTTL(e);\n            });\n          }\n          getOwner(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._registry.getOwner(e);\n            });\n          }\n          getAddress(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getAddress(e, t);\n            });\n          }\n          getPubkey(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getPubkey(e);\n            });\n          }\n          getContenthash(e) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.getContenthash(e);\n            });\n          }\n          checkNetwork() {\n            return n(this, void 0, void 0, function* () {\n              const e = Date.now() / 1e3;\n              if (!this._lastSyncCheck || e - this._lastSyncCheck > 3600) {\n                const t = yield (0, s.isSyncing)(this);\n                if (\"boolean\" != typeof t || t) throw new o.ENSNetworkNotSyncedError();\n                this._lastSyncCheck = e;\n              }\n              if (this._detectedAddress) return this._detectedAddress;\n              const t = yield (0, a.getId)(this, Object.assign(Object.assign({}, c.DEFAULT_RETURN_FORMAT), {\n                  number: c.FMT_NUMBER.HEX\n                })),\n                r = u.registryAddresses[u.networkIds[t]];\n              if (void 0 === r) throw new o.ENSUnsupportedNetworkError(t);\n              return this._detectedAddress = r, this._detectedAddress;\n            });\n          }\n          supportsInterface(e, t) {\n            return n(this, void 0, void 0, function* () {\n              return this._resolver.supportsInterface(e, t);\n            });\n          }\n          get events() {\n            return this._registry.events;\n          }\n        }\n        t.ENS = h;\n      },\n      1698: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.registryAddresses = void 0;\n        const o = r(8677);\n        Object.defineProperty(t, \"registryAddresses\", {\n          enumerable: !0,\n          get: function get() {\n            return o.registryAddresses;\n          }\n        }), i(r(9142), t);\n      },\n      67: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Registry = void 0;\n        const i = r(3211),\n          o = r(6919),\n          s = r(172),\n          a = r(8677),\n          c = r(8196);\n        t.Registry = class {\n          constructor(e, t) {\n            this.contract = new i.Contract(o.ENSRegistryAbi, null != t ? t : a.registryAddresses.main, e), this.context = e;\n          }\n          getOwner(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.owner((0, c.namehash)(e)).call();\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          getTTL(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.ttl((0, c.namehash)(e)).call();\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          recordExists(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.recordExists((0, c.namehash)(e)).call();\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          getResolver(e) {\n            return n(this, void 0, void 0, function* () {\n              try {\n                return this.contract.methods.resolver((0, c.namehash)(e)).call().then(e => {\n                  if (\"string\" == typeof e) return new i.Contract(s.PublicResolverAbi, e, this.context);\n                  throw new Error();\n                });\n              } catch (e) {\n                throw new Error();\n              }\n            });\n          }\n          get events() {\n            return this.contract.events;\n          }\n        };\n      },\n      8067: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Resolver = void 0;\n        const i = r(5071),\n          o = r(9634),\n          s = r(7345),\n          a = r(8677),\n          c = r(8196);\n        t.Resolver = class {\n          constructor(e) {\n            this.registry = e;\n          }\n          getResolverContractAdapter(e) {\n            return n(this, void 0, void 0, function* () {\n              return this.registry.getResolver(e);\n            });\n          }\n          checkInterfaceSupport(e, t) {\n            var r, s;\n            return n(this, void 0, void 0, function* () {\n              if ((0, o.isNullish)(a.interfaceIds[t])) throw new i.ResolverMethodMissingError(null !== (r = e.options.address) && void 0 !== r ? r : \"\", t);\n              if (!(yield e.methods.supportsInterface(a.interfaceIds[t]).call())) throw new i.ResolverMethodMissingError(null !== (s = e.options.address) && void 0 !== s ? s : \"\", t);\n            });\n          }\n          supportsInterface(e, t) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              const n = yield this.getResolverContractAdapter(e);\n              let i = t;\n              if (!(0, s.isHexStrict)(i)) {\n                if (i = null !== (r = (0, o.sha3)(t)) && void 0 !== r ? r : \"\", \"\" === t) throw new Error(\"Invalid interface Id\");\n                i = i.slice(0, 10);\n              }\n              return n.methods.supportsInterface(i).call();\n            });\n          }\n          getAddress(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n            return n(this, void 0, void 0, function* () {\n              const r = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(r, a.methodsInInterface.addr), r.methods.addr((0, c.namehash)(e), t).call();\n            });\n          }\n          getPubkey(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(t, a.methodsInInterface.pubkey), t.methods.pubkey((0, c.namehash)(e)).call();\n            });\n          }\n          getContenthash(e) {\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.getResolverContractAdapter(e);\n              return yield this.checkInterfaceSupport(t, a.methodsInInterface.contenthash), t.methods.contenthash((0, c.namehash)(e)).call();\n            });\n          }\n        };\n      },\n      8196: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.namehash = t.normalize = void 0;\n        const n = r(9634),\n          i = r(6608);\n        t.normalize = e => (0, i.ens_normalize)(e), t.namehash = e => {\n          let r = \"\";\n          for (let e = 0; e < 32; e += 1) r += \"00\";\n          if (e) {\n            const i = (0, t.normalize)(e).split(\".\");\n            for (let e = i.length - 1; e >= 0; e -= 1) {\n              const t = (0, n.sha3Raw)(i[e]).slice(2);\n              r = (0, n.sha3Raw)(\"0x\".concat(r).concat(t)).slice(2);\n            }\n          }\n          return \"0x\".concat(r);\n        };\n      },\n      5609: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Iban = void 0;\n        const n = r(9634),\n          i = r(7345),\n          o = r(5071);\n        class s {\n          constructor(e) {\n            if (this.toAddress = () => {\n              if (this.isDirect()) {\n                const e = this._iban.slice(4),\n                  t = s._parseInt(e, 36),\n                  r = (0, n.leftPad)(t, 40);\n                return (0, n.toChecksumAddress)(r);\n              }\n              throw new Error(\"Iban is indirect and cannot be converted. Must be length of 34 or 35\");\n            }, !s.isIndirect(e) && !s.isDirect(e)) throw new Error(\"Invalid IBAN was provided\");\n            this._iban = e;\n          }\n          static isDirect(e) {\n            return 34 === e.length || 35 === e.length;\n          }\n          isDirect() {\n            return s.isDirect(this._iban);\n          }\n          static isIndirect(e) {\n            return 20 === e.length;\n          }\n          isIndirect() {\n            return s.isIndirect(this._iban);\n          }\n          static isValid(e) {\n            return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(e) && 1 === s._mod9710(s._iso13616Prepare(e));\n          }\n          isValid() {\n            return s.isValid(this._iban);\n          }\n          static fromBban(e) {\n            const t = \"0\".concat((98 - this._mod9710(this._iso13616Prepare(\"XE00\".concat(e)))).toString()).slice(-2);\n            return new s(\"XE\".concat(t).concat(e));\n          }\n          static createIndirect(e) {\n            return s.fromBban(\"ETH\".concat(e.institution).concat(e.identifier));\n          }\n          static fromAddress(e) {\n            if (!(0, i.isAddress)(e)) throw new o.InvalidAddressError(e);\n            const t = BigInt((0, n.hexToNumber)(e)).toString(36),\n              r = (0, n.leftPad)(t, 15);\n            return s.fromBban(r.toUpperCase());\n          }\n          static toIban(e) {\n            return s.fromAddress(e).toString();\n          }\n          client() {\n            return this.isIndirect() ? this._iban.slice(11) : \"\";\n          }\n          checksum() {\n            return this._iban.slice(2, 4);\n          }\n          institution() {\n            return this.isIndirect() ? this._iban.slice(7, 11) : \"\";\n          }\n          toString() {\n            return this._iban;\n          }\n        }\n        t.Iban = s, s._iso13616Prepare = e => {\n          const t = \"A\".charCodeAt(0),\n            r = \"Z\".charCodeAt(0),\n            n = e.toUpperCase();\n          return \"\".concat(n.slice(4)).concat(n.slice(0, 4)).split(\"\").map(e => {\n            const n = e.charCodeAt(0);\n            return n >= t && n <= r ? n - t + 10 : e;\n          }).join(\"\");\n        }, s._parseInt = (e, t) => [...e].reduce((e, r) => BigInt(parseInt(r, t)) + BigInt(t) * e, BigInt(0)), s._mod9710 = e => {\n          let t,\n            r = e;\n          for (; r.length > 2;) t = r.slice(0, 9), r = \"\".concat((parseInt(t, 10) % 97).toString()).concat(r.slice(t.length));\n          return parseInt(r, 10) % 97;\n        }, s.toAddress = e => new s(e).toAddress();\n      },\n      9910: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const o = r(5609);\n        i(r(5609), t), i(r(1965), t), t.default = o.Iban;\n      },\n      1965: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      9757: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const o = r(9638);\n        i(r(9638), t), t.default = o.Personal;\n      },\n      9638: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Personal = void 0;\n        const a = r(6527),\n          c = o(r(706));\n        class u extends a.Web3Context {\n          getAccounts() {\n            return s(this, void 0, void 0, function* () {\n              return c.getAccounts(this.requestManager);\n            });\n          }\n          newAccount(e) {\n            return s(this, void 0, void 0, function* () {\n              return c.newAccount(this.requestManager, e);\n            });\n          }\n          unlockAccount(e, t, r) {\n            return s(this, void 0, void 0, function* () {\n              return c.unlockAccount(this.requestManager, e, t, r);\n            });\n          }\n          lockAccount(e) {\n            return s(this, void 0, void 0, function* () {\n              return c.lockAccount(this.requestManager, e);\n            });\n          }\n          importRawKey(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.importRawKey(this.requestManager, e, t);\n            });\n          }\n          sendTransaction(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.sendTransaction(this.requestManager, e, t);\n            });\n          }\n          signTransaction(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.signTransaction(this.requestManager, e, t);\n            });\n          }\n          sign(e, t, r) {\n            return s(this, void 0, void 0, function* () {\n              return c.sign(this.requestManager, e, t, r);\n            });\n          }\n          ecRecover(e, t) {\n            return s(this, void 0, void 0, function* () {\n              return c.ecRecover(this.requestManager, e, t);\n            });\n          }\n        }\n        t.Personal = u;\n      },\n      706: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ecRecover = t.sign = t.signTransaction = t.sendTransaction = t.importRawKey = t.lockAccount = t.unlockAccount = t.newAccount = t.getAccounts = void 0;\n        const i = r(9634),\n          o = r(6637),\n          s = r(9970),\n          a = r(7345),\n          c = r(1181);\n        t.getAccounts = e => n(void 0, void 0, void 0, function* () {\n          return (yield c.personalRpcMethods.getAccounts(e)).map(i.toChecksumAddress);\n        }), t.newAccount = (e, t) => n(void 0, void 0, void 0, function* () {\n          a.validator.validate([\"string\"], [t]);\n          const r = yield c.personalRpcMethods.newAccount(e, t);\n          return (0, i.toChecksumAddress)(r);\n        }), t.unlockAccount = (e, t, r, i) => n(void 0, void 0, void 0, function* () {\n          return a.validator.validate([\"address\", \"string\", \"uint\"], [t, r, i]), c.personalRpcMethods.unlockAccount(e, t, r, i);\n        }), t.lockAccount = (e, t) => n(void 0, void 0, void 0, function* () {\n          return a.validator.validate([\"address\"], [t]), c.personalRpcMethods.lockAccount(e, t);\n        }), t.importRawKey = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          return a.validator.validate([\"string\", \"string\"], [t, r]), c.personalRpcMethods.importRawKey(e, t, r);\n        }), t.sendTransaction = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          const n = (0, o.formatTransaction)(t, s.ETH_DATA_FORMAT);\n          return c.personalRpcMethods.sendTransaction(e, n, r);\n        }), t.signTransaction = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          const n = (0, o.formatTransaction)(t, s.ETH_DATA_FORMAT);\n          return c.personalRpcMethods.signTransaction(e, n, r);\n        }), t.sign = (e, t, r, o) => n(void 0, void 0, void 0, function* () {\n          a.validator.validate([\"string\", \"address\", \"string\"], [t, r, o]);\n          const n = (0, a.isHexStrict)(t) ? t : (0, i.utf8ToHex)(t);\n          return c.personalRpcMethods.sign(e, n, r, o);\n        }), t.ecRecover = (e, t, r) => n(void 0, void 0, void 0, function* () {\n          a.validator.validate([\"string\", \"string\"], [t, r]);\n          const n = (0, a.isHexStrict)(t) ? t : (0, i.utf8ToHex)(t);\n          return c.personalRpcMethods.ecRecover(e, n, r);\n        });\n      },\n      9326: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.NUMBER_DATA_FORMAT = t.ALL_EVENTS_ABI = t.ALL_EVENTS = void 0;\n        const n = r(9970);\n        t.ALL_EVENTS = \"ALLEVENTS\", t.ALL_EVENTS_ABI = {\n          name: t.ALL_EVENTS,\n          signature: \"\",\n          type: \"event\",\n          inputs: []\n        }, t.NUMBER_DATA_FORMAT = {\n          bytes: n.FMT_BYTES.HEX,\n          number: n.FMT_NUMBER.NUMBER\n        };\n      },\n      6637: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.transactionBuilder = t.detectTransactionType = void 0, r(6985);\n        const o = r(1435);\n        i(r(1435), t), i(r(7543), t), i(r(1922), t), i(r(9326), t), i(r(4832), t), i(r(8650), t), i(r(3222), t), i(r(5140), t), i(r(1258), t), i(r(7460), t);\n        var s = r(7350);\n        Object.defineProperty(t, \"detectTransactionType\", {\n          enumerable: !0,\n          get: function get() {\n            return s.detectTransactionType;\n          }\n        });\n        var a = r(223);\n        Object.defineProperty(t, \"transactionBuilder\", {\n          enumerable: !0,\n          get: function get() {\n            return a.transactionBuilder;\n          }\n        }), t.default = o.Web3Eth;\n      },\n      3222: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          i = this && this.__rest || function (e, t) {\n            var r = {};\n            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);\n            if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n              var i = 0;\n              for (n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);\n            }\n            return r;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.signTypedData = t.createAccessList = t.getFeeHistory = t.getProof = t.getChainId = t.getLogs = t.estimateGas = t.call = t.signTransaction = t.sign = t.sendSignedTransaction = t.sendTransaction = t.getTransactionCount = t.getTransactionReceipt = t.getTransactionFromBlock = t.getPendingTransactions = t.getTransaction = t.getUncle = t.getBlockUncleCount = t.getBlockTransactionCount = t.getBlock = t.getCode = t.getStorageAt = t.getBalance = t.getBlockNumber = t.getGasPrice = t.getHashRate = t.isMining = t.getCoinbase = t.isSyncing = t.getProtocolVersion = void 0;\n        const o = r(9970),\n          s = r(6527),\n          a = r(9634),\n          c = r(9247),\n          u = r(7345),\n          d = r(5071),\n          l = r(1181),\n          h = r(5900),\n          f = r(1922),\n          p = r(223),\n          m = r(5140),\n          g = r(8425),\n          y = r(4745),\n          v = r(9326),\n          b = r(7322);\n        t.getProtocolVersion = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getProtocolVersion(e.requestManager);\n        }), t.isSyncing = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getSyncing(e.requestManager);\n        }), t.getCoinbase = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getCoinbase(e.requestManager);\n        }), t.isMining = e => n(void 0, void 0, void 0, function* () {\n          return l.ethRpcMethods.getMining(e.requestManager);\n        }), t.getHashRate = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getHashRate(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.getGasPrice = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getGasPrice(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.getBlockNumber = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getBlockNumber(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.getBalance = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.getBalance(e.requestManager, t, n);\n            return (0, a.format)({\n              format: \"uint\"\n            }, s, i);\n          });\n        }, t.getStorageAt = function (e, t, r) {\n          let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.defaultBlock;\n          let s = arguments.length > 4 ? arguments[4] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              c = (0, u.isBlockTag)(i) ? i : (0, a.format)({\n                format: \"uint\"\n              }, i, o.ETH_DATA_FORMAT),\n              d = yield l.ethRpcMethods.getStorageAt(e.requestManager, t, n, c);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, d, s);\n          });\n        }, t.getCode = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.getCode(e.requestManager, t, n);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, s, i);\n          });\n        }, t.getBlock = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.defaultBlock;\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            let n;\n            if ((0, u.isBytes)(t)) {\n              const i = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockByHash(e.requestManager, i, r);\n            } else {\n              const i = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, o.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockByNumber(e.requestManager, i, r);\n            }\n            return (0, a.format)(f.blockSchema, n, i);\n          });\n        }, t.getBlockTransactionCount = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.defaultBlock;\n          let r = arguments.length > 2 ? arguments[2] : undefined;\n          return n(this, void 0, void 0, function* () {\n            let n;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockTransactionCountByHash(e.requestManager, r);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, o.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getBlockTransactionCountByNumber(e.requestManager, r);\n            }\n            return (0, a.format)({\n              format: \"uint\"\n            }, n, r);\n          });\n        }, t.getBlockUncleCount = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.defaultBlock;\n          let r = arguments.length > 2 ? arguments[2] : undefined;\n          return n(this, void 0, void 0, function* () {\n            let n;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getUncleCountByBlockHash(e.requestManager, r);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, o.ETH_DATA_FORMAT);\n              n = yield l.ethRpcMethods.getUncleCountByBlockNumber(e.requestManager, r);\n            }\n            return (0, a.format)({\n              format: \"uint\"\n            }, n, r);\n          });\n        }, t.getUncle = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.defaultBlock;\n          let r = arguments.length > 2 ? arguments[2] : undefined;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n              format: \"uint\"\n            }, r, o.ETH_DATA_FORMAT);\n            let s;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getUncleByBlockHashAndIndex(e.requestManager, r, n);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, o.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getUncleByBlockNumberAndIndex(e.requestManager, r, n);\n            }\n            return (0, a.format)(f.blockSchema, s, i);\n          });\n        }, t.getTransaction = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.DEFAULT_RETURN_FORMAT),\n              i = yield l.ethRpcMethods.getTransactionByHash(e.requestManager, n);\n            return (0, u.isNullish)(i) ? i : (0, m.formatTransaction)(i, r, {\n              fillInputAndData: !0\n            });\n          });\n        }, t.getPendingTransactions = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return (yield l.ethRpcMethods.getPendingTransactions(e.requestManager)).map(e => (0, m.formatTransaction)(e, t, {\n              fillInputAndData: !0\n            }));\n          });\n        }, t.getTransactionFromBlock = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.defaultBlock;\n          let r = arguments.length > 2 ? arguments[2] : undefined;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n              format: \"uint\"\n            }, r, o.ETH_DATA_FORMAT);\n            let s;\n            if ((0, u.isBytes)(t)) {\n              const r = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getTransactionByBlockHashAndIndex(e.requestManager, r, n);\n            } else {\n              const r = (0, u.isBlockTag)(t) ? t : (0, a.format)({\n                format: \"uint\"\n              }, t, o.ETH_DATA_FORMAT);\n              s = yield l.ethRpcMethods.getTransactionByBlockNumberAndIndex(e.requestManager, r, n);\n            }\n            return (0, u.isNullish)(s) ? s : (0, m.formatTransaction)(s, i, {\n              fillInputAndData: !0\n            });\n          });\n        }, t.getTransactionReceipt = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"bytes32\"\n              }, t, o.DEFAULT_RETURN_FORMAT),\n              i = yield l.ethRpcMethods.getTransactionReceipt(e.requestManager, n);\n            return (0, u.isNullish)(i) ? i : (0, a.format)(f.transactionReceiptSchema, i, r);\n          });\n        }, t.getTransactionCount = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.getTransactionCount(e.requestManager, t, n);\n            return (0, a.format)({\n              format: \"uint\"\n            }, s, i);\n          });\n        }, t.sendTransaction = function (e, t, r) {\n          let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            checkRevertBeforeSending: !0\n          };\n          const c = new s.Web3PromiEvent((s, d) => {\n            setImmediate(() => {\n              (() => {\n                n(this, void 0, void 0, function* () {\n                  const n = new b.SendTxHelper({\n                    web3Context: e,\n                    promiEvent: c,\n                    options: i,\n                    returnFormat: r\n                  });\n                  let l = (0, m.formatTransaction)(Object.assign(Object.assign({}, t), {\n                    from: (0, p.getTransactionFromOrToAttr)(\"from\", e, t),\n                    to: (0, p.getTransactionFromOrToAttr)(\"to\", e, t)\n                  }), o.ETH_DATA_FORMAT);\n                  try {\n                    let i;\n                    l = yield n.populateGasPrice({\n                      transaction: t,\n                      transactionFormatted: l\n                    }), yield n.checkRevertBeforeSending(l), n.emitSending(l), e.wallet && !(0, u.isNullish)(l.from) && (i = e.wallet.get(l.from));\n                    const o = yield n.signAndSend({\n                        wallet: i,\n                        tx: l\n                      }),\n                      c = (0, a.format)({\n                        format: \"bytes32\"\n                      }, o, r);\n                    n.emitSent(l), n.emitTransactionHash(c);\n                    const d = yield (0, y.waitForTransactionReceipt)(e, o, r),\n                      h = n.getReceiptWithEvents((0, a.format)(f.transactionReceiptSchema, d, r));\n                    n.emitReceipt(h), s(yield n.handleResolve({\n                      receipt: h,\n                      tx: l\n                    })), n.emitConfirmation({\n                      receipt: h,\n                      transactionHash: o\n                    });\n                  } catch (e) {\n                    d(yield n.handleError({\n                      error: e,\n                      tx: l\n                    }));\n                  }\n                });\n              })();\n            });\n          });\n          return c;\n        }, t.sendSignedTransaction = function (e, t, r) {\n          let u = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            checkRevertBeforeSending: !0\n          };\n          const d = new s.Web3PromiEvent((s, h) => {\n            setImmediate(() => {\n              (() => {\n                n(this, void 0, void 0, function* () {\n                  const p = new b.SendTxHelper({\n                      web3Context: e,\n                      promiEvent: d,\n                      options: u,\n                      returnFormat: r\n                    }),\n                    m = (0, a.format)({\n                      format: \"bytes\"\n                    }, t, o.ETH_DATA_FORMAT),\n                    v = c.TransactionFactory.fromSerializedData((0, a.bytesToUint8Array)((0, a.hexToBytes)(m))),\n                    E = Object.assign(Object.assign({}, v.toJSON()), {\n                      from: v.getSenderAddress().toString()\n                    });\n                  try {\n                    const {\n                        v: t,\n                        r: o,\n                        s: c\n                      } = E,\n                      u = i(E, [\"v\", \"r\", \"s\"]);\n                    yield p.checkRevertBeforeSending(u), p.emitSending(m);\n                    const d = yield (0, g.trySendTransaction)(e, () => n(this, void 0, void 0, function* () {\n                      return l.ethRpcMethods.sendRawTransaction(e.requestManager, m);\n                    }));\n                    p.emitSent(m);\n                    const h = (0, a.format)({\n                      format: \"bytes32\"\n                    }, d, r);\n                    p.emitTransactionHash(h);\n                    const v = yield (0, y.waitForTransactionReceipt)(e, d, r),\n                      b = p.getReceiptWithEvents((0, a.format)(f.transactionReceiptSchema, v, r));\n                    p.emitReceipt(b), s(yield p.handleResolve({\n                      receipt: b,\n                      tx: E\n                    })), p.emitConfirmation({\n                      receipt: b,\n                      transactionHash: d\n                    });\n                  } catch (e) {\n                    h(yield p.handleError({\n                      error: e,\n                      tx: E\n                    }));\n                  }\n                });\n              })();\n            });\n          });\n          return d;\n        }, t.sign = function (e, t, r, i) {\n          var s;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n              format: \"bytes\"\n            }, t, o.DEFAULT_RETURN_FORMAT);\n            if (null === (s = e.wallet) || void 0 === s ? void 0 : s.get(r)) {\n              const t = e.wallet.get(r).sign(n);\n              return (0, a.format)(f.SignatureObjectSchema, t, i);\n            }\n            if (\"number\" == typeof r) throw new d.SignatureError(t, 'RPC method \"eth_sign\" does not support index signatures');\n            const c = yield l.ethRpcMethods.sign(e.requestManager, r, n);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, c, i);\n          });\n        }, t.signTransaction = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const n = yield l.ethRpcMethods.signTransaction(e.requestManager, (0, m.formatTransaction)(t, o.ETH_DATA_FORMAT));\n            return (0, u.isString)(n) ? (0, h.decodeSignedTransaction)(n, r, {\n              fillInputAndData: !0\n            }) : {\n              raw: (0, a.format)({\n                format: \"bytes\"\n              }, n.raw, r),\n              tx: (0, m.formatTransaction)(n.tx, r, {\n                fillInputAndData: !0\n              })\n            };\n          });\n        }, t.call = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.call(e.requestManager, (0, m.formatTransaction)(t, o.ETH_DATA_FORMAT), n);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, s, i);\n          });\n        }, t.estimateGas = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, m.formatTransaction)(t, o.ETH_DATA_FORMAT),\n              s = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              c = yield l.ethRpcMethods.estimateGas(e.requestManager, n, s);\n            return (0, a.format)({\n              format: \"uint\"\n            }, c, i);\n          });\n        }, t.getLogs = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            let {\n              toBlock: n,\n              fromBlock: i\n            } = t;\n            (0, u.isNullish)(n) || \"number\" != typeof n && \"bigint\" != typeof n || (n = (0, a.numberToHex)(n)), (0, u.isNullish)(i) || \"number\" != typeof i && \"bigint\" != typeof i || (i = (0, a.numberToHex)(i));\n            const o = Object.assign(Object.assign({}, t), {\n              fromBlock: i,\n              toBlock: n\n            });\n            return (yield l.ethRpcMethods.getLogs(e.requestManager, o)).map(e => \"string\" == typeof e ? e : (0, a.format)(f.logSchema, e, r));\n          });\n        }, t.getChainId = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield l.ethRpcMethods.getChainId(e.requestManager);\n            return (0, a.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.getProof = function (e, t, r) {\n          let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : e.defaultBlock;\n          let s = arguments.length > 4 ? arguments[4] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = r.map(e => (0, a.format)({\n                format: \"bytes\"\n              }, e, o.ETH_DATA_FORMAT)),\n              c = (0, u.isBlockTag)(i) ? i : (0, a.format)({\n                format: \"uint\"\n              }, i, o.ETH_DATA_FORMAT),\n              d = yield l.ethRpcMethods.getProof(e.requestManager, t, n, c);\n            return (0, a.format)(f.accountSchema, d, s);\n          });\n        }, t.getFeeHistory = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          let s = arguments.length > 4 ? arguments[4] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, a.format)({\n                format: \"uint\"\n              }, t, o.ETH_DATA_FORMAT),\n              c = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              d = (0, a.format)({\n                type: \"array\",\n                items: {\n                  format: \"uint\"\n                }\n              }, i, v.NUMBER_DATA_FORMAT),\n              h = yield l.ethRpcMethods.getFeeHistory(e.requestManager, n, c, d);\n            return (0, a.format)(f.feeHistorySchema, h, s);\n          });\n        }, t.createAccessList = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e.defaultBlock;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          return n(this, void 0, void 0, function* () {\n            const n = (0, u.isBlockTag)(r) ? r : (0, a.format)({\n                format: \"uint\"\n              }, r, o.ETH_DATA_FORMAT),\n              s = yield l.ethRpcMethods.createAccessList(e.requestManager, (0, m.formatTransaction)(t, o.ETH_DATA_FORMAT), n);\n            return (0, a.format)(f.accessListResultSchema, s, i);\n          });\n        }, t.signTypedData = function (e, t, r, i, o) {\n          return n(this, void 0, void 0, function* () {\n            const n = yield l.ethRpcMethods.signTypedData(e.requestManager, t, r, i);\n            return (0, a.format)({\n              format: \"bytes\"\n            }, n, o);\n          });\n        };\n      },\n      1922: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.accountSchema = t.storageProofSchema = t.feeHistorySchema = t.SignatureObjectSchema = t.transactionReceiptSchema = t.syncSchema = t.logSchema = t.blockHeaderSchema = t.withdrawalsSchema = t.blockSchema = t.transactionInfoSchema = t.transactionSchema = t.customChainSchema = t.hardforkSchema = t.chainSchema = t.accessListResultSchema = t.accessListSchema = t.accessListItemSchema = void 0, t.accessListItemSchema = {\n          type: \"object\",\n          properties: {\n            address: {\n              format: \"address\"\n            },\n            storageKeys: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            }\n          }\n        }, t.accessListSchema = {\n          type: \"array\",\n          items: Object.assign({}, t.accessListItemSchema)\n        }, t.accessListResultSchema = {\n          type: \"object\",\n          properties: {\n            accessList: Object.assign({}, t.accessListSchema),\n            gasUsed: {\n              type: \"string\"\n            }\n          }\n        }, t.chainSchema = {\n          type: \"string\",\n          enum: [\"goerli\", \"kovan\", \"mainnet\", \"rinkeby\", \"ropsten\", \"sepolia\"]\n        }, t.hardforkSchema = {\n          type: \"string\",\n          enum: [\"arrowGlacier\", \"berlin\", \"byzantium\", \"chainstart\", \"constantinople\", \"dao\", \"homestead\", \"istanbul\", \"london\", \"merge\", \"muirGlacier\", \"petersburg\", \"shanghai\", \"spuriousDragon\", \"tangerineWhistle\"]\n        }, t.customChainSchema = {\n          type: \"object\",\n          properties: {\n            name: {\n              format: \"string\"\n            },\n            networkId: {\n              format: \"uint\"\n            },\n            chainId: {\n              format: \"uint\"\n            }\n          }\n        }, t.transactionSchema = {\n          type: \"object\",\n          properties: {\n            from: {\n              format: \"address\"\n            },\n            to: {\n              oneOf: [{\n                format: \"address\"\n              }, {\n                type: \"null\"\n              }]\n            },\n            value: {\n              format: \"uint\"\n            },\n            gas: {\n              format: \"uint\"\n            },\n            gasPrice: {\n              format: \"uint\"\n            },\n            effectiveGasPrice: {\n              format: \"uint\"\n            },\n            type: {\n              format: \"uint\"\n            },\n            maxFeePerGas: {\n              format: \"uint\"\n            },\n            maxPriorityFeePerGas: {\n              format: \"uint\"\n            },\n            accessList: Object.assign({}, t.accessListSchema),\n            data: {\n              format: \"bytes\"\n            },\n            input: {\n              format: \"bytes\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            chain: Object.assign({}, t.chainSchema),\n            hardfork: Object.assign({}, t.hardforkSchema),\n            chainId: {\n              format: \"uint\"\n            },\n            networkId: {\n              format: \"uint\"\n            },\n            common: {\n              type: \"object\",\n              properties: {\n                customChain: Object.assign({}, t.customChainSchema),\n                baseChain: Object.assign({}, t.chainSchema),\n                hardfork: Object.assign({}, t.hardforkSchema)\n              }\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            v: {\n              format: \"uint\"\n            },\n            r: {\n              format: \"bytes32\"\n            },\n            s: {\n              format: \"bytes32\"\n            }\n          }\n        }, t.transactionInfoSchema = {\n          type: \"object\",\n          properties: Object.assign(Object.assign({}, t.transactionSchema.properties), {\n            blockHash: {\n              format: \"bytes32\"\n            },\n            blockNumber: {\n              format: \"uint\"\n            },\n            hash: {\n              format: \"bytes32\"\n            },\n            transactionIndex: {\n              format: \"uint\"\n            },\n            from: {\n              format: \"address\"\n            },\n            to: {\n              oneOf: [{\n                format: \"address\"\n              }, {\n                type: \"null\"\n              }]\n            },\n            value: {\n              format: \"uint\"\n            },\n            gas: {\n              format: \"uint\"\n            },\n            gasPrice: {\n              format: \"uint\"\n            },\n            effectiveGasPrice: {\n              format: \"uint\"\n            },\n            type: {\n              format: \"uint\"\n            },\n            maxFeePerGas: {\n              format: \"uint\"\n            },\n            maxPriorityFeePerGas: {\n              format: \"uint\"\n            },\n            accessList: Object.assign({}, t.accessListSchema),\n            data: {\n              format: \"bytes\"\n            },\n            input: {\n              format: \"bytes\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            v: {\n              format: \"uint\"\n            },\n            r: {\n              format: \"bytes32\"\n            },\n            s: {\n              format: \"bytes32\"\n            }\n          })\n        }, t.blockSchema = {\n          type: \"object\",\n          properties: {\n            parentHash: {\n              format: \"bytes32\"\n            },\n            sha3Uncles: {\n              format: \"bytes32\"\n            },\n            miner: {\n              format: \"bytes\"\n            },\n            stateRoot: {\n              format: \"bytes32\"\n            },\n            transactionsRoot: {\n              format: \"bytes32\"\n            },\n            receiptsRoot: {\n              format: \"bytes32\"\n            },\n            logsBloom: {\n              format: \"bytes256\"\n            },\n            difficulty: {\n              format: \"uint\"\n            },\n            number: {\n              format: \"uint\"\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            gasUsed: {\n              format: \"uint\"\n            },\n            timestamp: {\n              format: \"uint\"\n            },\n            extraData: {\n              format: \"bytes\"\n            },\n            mixHash: {\n              format: \"bytes32\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            totalDifficulty: {\n              format: \"uint\"\n            },\n            baseFeePerGas: {\n              format: \"uint\"\n            },\n            size: {\n              format: \"uint\"\n            },\n            transactions: {\n              oneOf: [{\n                type: \"array\",\n                items: Object.assign({}, t.transactionInfoSchema)\n              }, {\n                type: \"array\",\n                items: {\n                  format: \"bytes32\"\n                }\n              }]\n            },\n            uncles: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            hash: {\n              format: \"bytes32\"\n            }\n          }\n        }, t.withdrawalsSchema = {\n          type: \"object\",\n          properties: {\n            index: {\n              format: \"uint\"\n            },\n            validatorIndex: {\n              format: \"uint\"\n            },\n            address: {\n              format: \"address\"\n            },\n            amount: {\n              format: \"uint\"\n            }\n          }\n        }, t.blockHeaderSchema = {\n          type: \"object\",\n          properties: {\n            author: {\n              format: \"bytes32\"\n            },\n            hash: {\n              format: \"bytes32\"\n            },\n            parentHash: {\n              format: \"bytes32\"\n            },\n            receiptsRoot: {\n              format: \"bytes32\"\n            },\n            miner: {\n              format: \"bytes\"\n            },\n            stateRoot: {\n              format: \"bytes32\"\n            },\n            transactionsRoot: {\n              format: \"bytes32\"\n            },\n            withdrawalsRoot: {\n              format: \"bytes32\"\n            },\n            logsBloom: {\n              format: \"bytes256\"\n            },\n            difficulty: {\n              format: \"uint\"\n            },\n            totalDifficulty: {\n              format: \"uint\"\n            },\n            number: {\n              format: \"uint\"\n            },\n            gasLimit: {\n              format: \"uint\"\n            },\n            gasUsed: {\n              format: \"uint\"\n            },\n            timestamp: {\n              format: \"uint\"\n            },\n            extraData: {\n              format: \"bytes\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            sha3Uncles: {\n              format: \"bytes32\"\n            },\n            size: {\n              format: \"uint\"\n            },\n            baseFeePerGas: {\n              format: \"uint\"\n            },\n            excessDataGas: {\n              format: \"uint\"\n            },\n            mixHash: {\n              format: \"bytes32\"\n            },\n            transactions: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            uncles: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            withdrawals: {\n              type: \"array\",\n              items: Object.assign({}, t.withdrawalsSchema)\n            }\n          }\n        }, t.logSchema = {\n          type: \"object\",\n          properties: {\n            removed: {\n              format: \"bool\"\n            },\n            logIndex: {\n              format: \"uint\"\n            },\n            transactionIndex: {\n              format: \"uint\"\n            },\n            transactionHash: {\n              format: \"bytes32\"\n            },\n            blockHash: {\n              format: \"bytes32\"\n            },\n            blockNumber: {\n              format: \"uint\"\n            },\n            address: {\n              format: \"address\"\n            },\n            data: {\n              format: \"bytes\"\n            },\n            topics: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            }\n          }\n        }, t.syncSchema = {\n          type: \"object\",\n          properties: {\n            startingBlock: {\n              format: \"string\"\n            },\n            currentBlock: {\n              format: \"string\"\n            },\n            highestBlock: {\n              format: \"string\"\n            },\n            knownStates: {\n              format: \"string\"\n            },\n            pulledStates: {\n              format: \"string\"\n            }\n          }\n        }, t.transactionReceiptSchema = {\n          type: \"object\",\n          properties: {\n            transactionHash: {\n              format: \"bytes32\"\n            },\n            transactionIndex: {\n              format: \"uint\"\n            },\n            blockHash: {\n              format: \"bytes32\"\n            },\n            blockNumber: {\n              format: \"uint\"\n            },\n            from: {\n              format: \"address\"\n            },\n            to: {\n              format: \"address\"\n            },\n            cumulativeGasUsed: {\n              format: \"uint\"\n            },\n            gasUsed: {\n              format: \"uint\"\n            },\n            effectiveGasPrice: {\n              format: \"uint\"\n            },\n            contractAddress: {\n              format: \"address\"\n            },\n            logs: {\n              type: \"array\",\n              items: Object.assign({}, t.logSchema)\n            },\n            logsBloom: {\n              format: \"bytes\"\n            },\n            root: {\n              format: \"bytes\"\n            },\n            status: {\n              format: \"uint\"\n            },\n            type: {\n              format: \"uint\"\n            }\n          }\n        }, t.SignatureObjectSchema = {\n          type: \"object\",\n          properties: {\n            messageHash: {\n              format: \"bytes\"\n            },\n            r: {\n              format: \"bytes32\"\n            },\n            s: {\n              format: \"bytes32\"\n            },\n            v: {\n              format: \"bytes\"\n            },\n            message: {\n              format: \"bytes\"\n            },\n            signature: {\n              format: \"bytes\"\n            }\n          }\n        }, t.feeHistorySchema = {\n          type: \"object\",\n          properties: {\n            oldestBlock: {\n              format: \"uint\"\n            },\n            baseFeePerGas: {\n              type: \"array\",\n              items: {\n                format: \"uint\"\n              }\n            },\n            reward: {\n              type: \"array\",\n              items: {\n                type: \"array\",\n                items: {\n                  format: \"uint\"\n                }\n              }\n            },\n            gasUsedRatio: {\n              type: \"array\",\n              items: {\n                type: \"number\"\n              }\n            }\n          }\n        }, t.storageProofSchema = {\n          type: \"object\",\n          properties: {\n            key: {\n              format: \"bytes32\"\n            },\n            value: {\n              format: \"uint\"\n            },\n            proof: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            }\n          }\n        }, t.accountSchema = {\n          type: \"object\",\n          properties: {\n            balance: {\n              format: \"uint\"\n            },\n            codeHash: {\n              format: \"bytes32\"\n            },\n            nonce: {\n              format: \"uint\"\n            },\n            storageHash: {\n              format: \"bytes32\"\n            },\n            accountProof: {\n              type: \"array\",\n              items: {\n                format: \"bytes32\"\n              }\n            },\n            storageProof: {\n              type: \"array\",\n              items: Object.assign({}, t.storageProofSchema)\n            }\n          }\n        };\n      },\n      4832: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      5900: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeSignedTransaction = void 0;\n        const n = r(9634),\n          i = r(9247),\n          o = r(7350),\n          s = r(5140);\n        t.decodeSignedTransaction = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n            fillInputAndData: !1\n          };\n          return {\n            raw: (0, n.format)({\n              format: \"bytes\"\n            }, e, t),\n            tx: (0, s.formatTransaction)(Object.assign(Object.assign({}, i.TransactionFactory.fromSerializedData((0, n.hexToBytes)(e)).toJSON()), {\n              hash: (0, n.bytesToHex)((0, n.keccak256)((0, n.hexToBytes)(e))),\n              type: (0, o.detectRawTransactionType)((0, n.hexToBytes)(e))\n            }), t, {\n              fillInputAndData: r.fillInputAndData\n            })\n          };\n        };\n      },\n      7543: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeEventABI = void 0;\n        const n = r(9634),\n          i = r(9970),\n          o = r(8381),\n          s = r(1922),\n          a = r(9326);\n        t.decodeEventABI = function (e, t, r) {\n          let c = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : i.DEFAULT_RETURN_FORMAT;\n          var u, d, l, h, f;\n          let p = Object.assign({}, e);\n          const m = (0, n.format)(s.logSchema, t, c);\n          if ([a.ALL_EVENTS, \"allEvents\"].includes(p.name)) {\n            p = r.find(e => e.signature === t.topics[0]) || {\n              anonymous: !0\n            };\n          }\n          if (p.inputs = null !== (d = null !== (u = p.inputs) && void 0 !== u ? u : e.inputs) && void 0 !== d ? d : [], !p.anonymous) {\n            let e = 0;\n            (null !== (l = p.inputs) && void 0 !== l ? l : []).forEach(t => {\n              t.indexed && (e += 1);\n            }), e > 0 && (null == t ? void 0 : t.topics) && (null == t ? void 0 : t.topics.length) !== e + 1 && (p = Object.assign(Object.assign({}, p), {\n              anonymous: !0,\n              inputs: []\n            }));\n          }\n          const g = p.anonymous ? t.topics : (null !== (h = t.topics) && void 0 !== h ? h : []).slice(1);\n          return Object.assign(Object.assign({}, m), {\n            returnValues: (0, o.decodeLog)([...(null !== (f = p.inputs) && void 0 !== f ? f : [])], t.data, g),\n            event: p.name,\n            signature: !p.anonymous && t.topics && 0 !== t.topics.length && t.topics[0] ? t.topics[0] : void 0,\n            raw: {\n              data: t.data,\n              topics: t.topics\n            }\n          });\n        };\n      },\n      7350: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.detectRawTransactionType = t.detectTransactionType = t.defaultTransactionTypeParser = void 0;\n        const n = r(9634),\n          i = r(9970),\n          o = r(7345),\n          s = r(5071),\n          a = {\n            type: \"object\",\n            properties: {\n              accessList: {\n                type: \"null\"\n              },\n              maxFeePerGas: {\n                type: \"null\"\n              },\n              maxPriorityFeePerGas: {\n                type: \"null\"\n              }\n            }\n          },\n          c = {\n            type: \"object\",\n            properties: {\n              maxFeePerGas: {\n                type: \"null\"\n              },\n              maxPriorityFeePerGas: {\n                type: \"null\"\n              }\n            }\n          },\n          u = {\n            type: \"object\",\n            properties: {\n              gasPrice: {\n                type: \"null\"\n              }\n            }\n          },\n          d = (e, t, r) => {\n            try {\n              o.validator.validateJSONSchema(e, t);\n            } catch (e) {\n              if (e instanceof o.Web3ValidatorError) throw new s.InvalidPropertiesForTransactionTypeError(e.errors, r);\n              throw e;\n            }\n          };\n        t.defaultTransactionTypeParser = e => {\n          var t, r;\n          const s = e;\n          if (!(0, o.isNullish)(s.type)) {\n            let e;\n            switch (s.type) {\n              case \"0x0\":\n                e = a;\n                break;\n              case \"0x1\":\n                e = c;\n                break;\n              case \"0x2\":\n                e = u;\n                break;\n              default:\n                return (0, n.format)({\n                  format: \"uint\"\n                }, s.type, i.ETH_DATA_FORMAT);\n            }\n            return d(e, s, s.type), (0, n.format)({\n              format: \"uint\"\n            }, s.type, i.ETH_DATA_FORMAT);\n          }\n          if (!(0, o.isNullish)(s.maxFeePerGas) || !(0, o.isNullish)(s.maxPriorityFeePerGas)) return d(u, s, \"0x2\"), \"0x2\";\n          if (!(0, o.isNullish)(s.accessList)) return d(c, s, \"0x1\"), \"0x1\";\n          const l = null !== (t = s.hardfork) && void 0 !== t ? t : null === (r = s.common) || void 0 === r ? void 0 : r.hardfork;\n          if (!(0, o.isNullish)(l)) {\n            const e = Object.keys(i.HardforksOrdered).indexOf(l);\n            if (e >= Object.keys(i.HardforksOrdered).indexOf(\"london\")) return (0, o.isNullish)(s.gasPrice) ? \"0x2\" : \"0x0\";\n            if (e === Object.keys(i.HardforksOrdered).indexOf(\"berlin\")) return \"0x0\";\n          }\n          return (0, o.isNullish)(s.gasPrice) ? void 0 : (d(a, s, \"0x0\"), \"0x0\");\n        }, t.detectTransactionType = (e, r) => {\n          var n;\n          return (null !== (n = null == r ? void 0 : r.transactionTypeParser) && void 0 !== n ? n : t.defaultTransactionTypeParser)(e);\n        }, t.detectRawTransactionType = e => e[0] > 127 ? \"0x0\" : (0, n.toHex)(e[0]);\n      },\n      5140: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.formatTransaction = void 0;\n        const n = r(9970),\n          i = r(7345),\n          o = r(9634),\n          s = r(5071),\n          a = r(1922);\n        t.formatTransaction = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : n.DEFAULT_RETURN_FORMAT;\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n            transactionSchema: a.transactionInfoSchema,\n            fillInputAndData: !1\n          };\n          var c, u;\n          let d = (0, o.mergeDeep)({}, e);\n          if ((0, i.isNullish)(null == e ? void 0 : e.common) || (d.common = Object.assign({}, e.common), (0, i.isNullish)(null === (c = e.common) || void 0 === c ? void 0 : c.customChain) || (d.common.customChain = Object.assign({}, e.common.customChain))), d = (0, o.format)(null !== (u = r.transactionSchema) && void 0 !== u ? u : a.transactionInfoSchema, d, t), !(0, i.isNullish)(d.data) && !(0, i.isNullish)(d.input) && (0, o.toHex)(d.data) !== (0, o.toHex)(d.input)) throw new s.TransactionDataAndInputError({\n            data: (0, o.bytesToHex)(d.data),\n            input: (0, o.bytesToHex)(d.input)\n          });\n          return r.fillInputAndData && ((0, i.isNullish)(d.data) ? (0, i.isNullish)(d.input) || (d.data = d.input) : d.input = d.data), (0, i.isNullish)(d.gasLimit) || (d.gas = d.gasLimit, delete d.gasLimit), d;\n        };\n      },\n      4429: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getRevertReason = t.parseTransactionError = void 0;\n        const i = r(5071),\n          o = r(8381),\n          s = r(9970),\n          a = r(3222);\n        t.parseTransactionError = (e, t) => {\n          var r, n, s, a;\n          if (e instanceof i.ContractExecutionError && e.innerError instanceof i.Eip838ExecutionError) {\n            if (void 0 !== t) {\n              const i = t.filter(e => (0, o.isAbiErrorFragment)(e));\n              return (0, o.decodeContractErrorData)(i, e.innerError), {\n                reason: e.innerError.message,\n                signature: null === (r = e.innerError.data) || void 0 === r ? void 0 : r.slice(0, 10),\n                data: null === (n = e.innerError.data) || void 0 === n ? void 0 : n.substring(10),\n                customErrorName: e.innerError.errorName,\n                customErrorDecodedSignature: e.innerError.errorSignature,\n                customErrorArguments: e.innerError.errorArgs\n              };\n            }\n            return {\n              reason: e.innerError.message,\n              signature: null === (s = e.innerError.data) || void 0 === s ? void 0 : s.slice(0, 10),\n              data: null === (a = e.innerError.data) || void 0 === a ? void 0 : a.substring(10)\n            };\n          }\n          if (e instanceof i.InvalidResponseError && !Array.isArray(e.innerError) && void 0 !== e.innerError) return e.innerError.message;\n          throw e;\n        }, t.getRevertReason = function (e, r, i) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : s.DEFAULT_RETURN_FORMAT;\n          return n(this, void 0, void 0, function* () {\n            try {\n              return void (yield (0, a.call)(e, r, e.defaultBlock, o));\n            } catch (e) {\n              return (0, t.parseTransactionError)(e, i);\n            }\n          });\n        };\n      },\n      1882: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getTransactionError = void 0;\n        const i = r(5071),\n          o = r(4429);\n        t.getTransactionError = function (e, t, r, s, a, c) {\n          return n(this, void 0, void 0, function* () {\n            let n,\n              u = c;\n            if (void 0 === u && (void 0 !== s ? u = (0, o.parseTransactionError)(s) : e.handleRevert && void 0 !== t && (u = yield (0, o.getRevertReason)(e, t, a))), void 0 === u) n = new i.TransactionRevertedWithoutReasonError(r);else if (\"string\" == typeof u) n = new i.TransactionRevertInstructionError(u, void 0, r);else if (void 0 !== u.customErrorName && void 0 !== u.customErrorDecodedSignature && void 0 !== u.customErrorArguments) {\n              const e = u;\n              n = new i.TransactionRevertWithCustomError(e.reason, e.customErrorName, e.customErrorDecodedSignature, e.customErrorArguments, e.signature, r, e.data);\n            } else n = new i.TransactionRevertInstructionError(u.reason, u.signature, r, u.data);\n            return n;\n          });\n        };\n      },\n      8736: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getTransactionGasPricing = void 0;\n        const i = r(7345),\n          o = r(5071),\n          s = r(9634),\n          a = r(3222),\n          c = r(223);\n        t.getTransactionGasPricing = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const u = (0, c.getTransactionType)(e, t);\n            if (!(0, i.isNullish)(u)) {\n              if (u.startsWith(\"-\")) throw new o.UnsupportedTransactionTypeError(u);\n              if (Number(u) < 0 || Number(u) > 127) throw new o.UnsupportedTransactionTypeError(u);\n              if ((0, i.isNullish)(e.gasPrice) && (\"0x0\" === u || \"0x1\" === u)) return {\n                gasPrice: yield (0, a.getGasPrice)(t, r),\n                maxPriorityFeePerGas: void 0,\n                maxFeePerGas: void 0\n              };\n              if (\"0x2\" === u) return Object.assign({\n                gasPrice: void 0\n              }, yield function (e, t, r) {\n                var c, u, d;\n                return n(this, void 0, void 0, function* () {\n                  const n = yield (0, a.getBlock)(t, t.defaultBlock, !1, r);\n                  if ((0, i.isNullish)(n.baseFeePerGas)) throw new o.Eip1559NotSupportedError();\n                  if (!(0, i.isNullish)(e.gasPrice)) {\n                    const t = (0, s.format)({\n                      format: \"uint\"\n                    }, e.gasPrice, r);\n                    return {\n                      maxPriorityFeePerGas: t,\n                      maxFeePerGas: t\n                    };\n                  }\n                  return {\n                    maxPriorityFeePerGas: (0, s.format)({\n                      format: \"uint\"\n                    }, null !== (c = e.maxPriorityFeePerGas) && void 0 !== c ? c : t.defaultMaxPriorityFeePerGas, r),\n                    maxFeePerGas: (0, s.format)({\n                      format: \"uint\"\n                    }, null !== (u = e.maxFeePerGas) && void 0 !== u ? u : BigInt(n.baseFeePerGas) * BigInt(2) + BigInt(null !== (d = e.maxPriorityFeePerGas) && void 0 !== d ? d : t.defaultMaxPriorityFeePerGas), r)\n                  };\n                });\n              }(e, t, r));\n            }\n          });\n        };\n      },\n      1258: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.prepareTransactionForSigning = void 0;\n        const i = r(9970),\n          o = r(9634),\n          s = r(9247),\n          a = r(7345),\n          c = r(8650),\n          u = r(5140),\n          d = r(223);\n        t.prepareTransactionForSigning = function (e, t, r) {\n          let l = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n          let h = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n          return n(void 0, void 0, void 0, function* () {\n            const n = yield (0, d.transactionBuilder)({\n                transaction: e,\n                web3Context: t,\n                privateKey: r,\n                fillGasPrice: l,\n                fillGasLimit: h\n              }),\n              f = (0, u.formatTransaction)(n, i.ETH_DATA_FORMAT);\n            return (0, c.validateTransactionForSigning)(f), s.TransactionFactory.fromTxData((e => {\n              var t, r;\n              return {\n                nonce: e.nonce,\n                gasPrice: e.gasPrice,\n                gasLimit: null !== (t = e.gasLimit) && void 0 !== t ? t : e.gas,\n                to: e.to,\n                value: e.value,\n                data: null !== (r = e.data) && void 0 !== r ? r : e.input,\n                type: e.type,\n                chainId: e.chainId,\n                accessList: e.accessList,\n                maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n                maxFeePerGas: e.maxFeePerGas\n              };\n            })(f), ((e, t) => {\n              var r, n, i, c, u, d, l, h, f, p, m, g, y, v, b, E, _, A;\n              let T;\n              if (((0, a.isNullish)(e.chain) || (0, a.isNullish)(e.hardfork)) && (0, a.isNullish)(e.common)) t.defaultCommon ? (T = t.defaultCommon, (0, a.isNullish)(T.hardfork) && (T.hardfork = null !== (r = e.hardfork) && void 0 !== r ? r : t.defaultHardfork), (0, a.isNullish)(T.baseChain) && (T.baseChain = t.defaultChain)) : T = s.Common.custom({\n                name: \"custom-network\",\n                chainId: (0, o.toNumber)(e.chainId),\n                networkId: (0, a.isNullish)(e.networkId) ? void 0 : (0, o.toNumber)(e.networkId),\n                defaultHardfork: null !== (n = e.hardfork) && void 0 !== n ? n : t.defaultHardfork\n              }, {\n                baseChain: t.defaultChain\n              });else {\n                const r = null !== (d = null !== (u = null === (c = null === (i = null == e ? void 0 : e.common) || void 0 === i ? void 0 : i.customChain) || void 0 === c ? void 0 : c.name) && void 0 !== u ? u : e.chain) && void 0 !== d ? d : \"custom-network\",\n                  n = (0, o.toNumber)(null !== (f = null === (h = null === (l = null == e ? void 0 : e.common) || void 0 === l ? void 0 : l.customChain) || void 0 === h ? void 0 : h.chainId) && void 0 !== f ? f : null == e ? void 0 : e.chainId),\n                  a = (0, o.toNumber)(null !== (g = null === (m = null === (p = null == e ? void 0 : e.common) || void 0 === p ? void 0 : p.customChain) || void 0 === m ? void 0 : m.networkId) && void 0 !== g ? g : null == e ? void 0 : e.networkId),\n                  I = null !== (b = null !== (v = null === (y = null == e ? void 0 : e.common) || void 0 === y ? void 0 : y.hardfork) && void 0 !== v ? v : null == e ? void 0 : e.hardfork) && void 0 !== b ? b : t.defaultHardfork,\n                  R = null !== (A = null !== (_ = null === (E = e.common) || void 0 === E ? void 0 : E.baseChain) && void 0 !== _ ? _ : e.chain) && void 0 !== A ? A : t.defaultChain;\n                n && a && r && (T = s.Common.custom({\n                  name: r,\n                  chainId: n,\n                  networkId: a,\n                  defaultHardfork: I\n                }, {\n                  baseChain: R\n                }));\n              }\n              return {\n                common: T\n              };\n            })(f, t));\n          });\n        };\n      },\n      4659: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.rejectIfBlockTimeout = void 0;\n        const i = r(9634),\n          o = r(5071),\n          s = r(9326),\n          a = r(3222);\n        function c(e, t, r) {\n          const c = e.transactionPollingInterval,\n            [u, d] = (0, i.rejectIfConditionAtInterval)(() => n(this, void 0, void 0, function* () {\n              let n;\n              try {\n                n = yield (0, a.getBlockNumber)(e, s.NUMBER_DATA_FORMAT);\n              } catch (e) {\n                return void console.warn(\"An error happen while trying to get the block number\", e);\n              }\n              const i = n - t;\n              if (i >= e.transactionBlockTimeout) return new o.TransactionBlockTimeoutError({\n                starterBlockNumber: t,\n                numberOfBlocks: i,\n                transactionHash: r\n              });\n            }), c);\n          return [d, {\n            clean: () => {\n              clearInterval(u);\n            }\n          }];\n        }\n        t.rejectIfBlockTimeout = function (e, t) {\n          var r, i;\n          return n(this, void 0, void 0, function* () {\n            const {\n              provider: u\n            } = e.requestManager;\n            let d;\n            const l = yield (0, a.getBlockNumber)(e, s.NUMBER_DATA_FORMAT);\n            return d = (null === (i = (r = u).supportsSubscriptions) || void 0 === i ? void 0 : i.call(r)) && e.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout ? yield function (e, t, r) {\n              var i;\n              return n(this, void 0, void 0, function* () {\n                let n,\n                  s,\n                  a = !0;\n                function u(n, i) {\n                  i && console.warn(\"error happened at subscription. So revert to polling...\", i), s.clean(), a = !1;\n                  const [o, u] = c(e, t, r);\n                  s.clean = u.clean, o.catch(e => n(e));\n                }\n                try {\n                  n = yield null === (i = e.subscriptionManager) || void 0 === i ? void 0 : i.subscribe(\"newHeads\"), s = {\n                    clean: () => {\n                      var t;\n                      n.id && (null === (t = e.subscriptionManager) || void 0 === t || t.removeSubscription(n).then(() => {}).catch(() => {}));\n                    }\n                  };\n                } catch (n) {\n                  return c(e, t, r);\n                }\n                return [new Promise((i, s) => {\n                  try {\n                    n.on(\"data\", n => {\n                      if (a = !1, !(null == n ? void 0 : n.number)) return;\n                      const i = Number(BigInt(n.number) - BigInt(t));\n                      i >= e.transactionBlockTimeout && s(new o.TransactionBlockTimeoutError({\n                        starterBlockNumber: t,\n                        numberOfBlocks: i,\n                        transactionHash: r\n                      }));\n                    }), n.on(\"error\", e => {\n                      u(s, e);\n                    });\n                  } catch (e) {\n                    u(s, e);\n                  }\n                  setTimeout(() => {\n                    a && u(s);\n                  }, 1e3 * e.blockHeaderTimeout);\n                }), s];\n              });\n            }(e, l, t) : c(e, l, t), d;\n          });\n        };\n      },\n      7322: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SendTxHelper = void 0;\n        const i = r(9970),\n          o = r(7345),\n          s = r(5071),\n          a = r(1181),\n          c = r(8736),\n          u = r(8425),\n          d = r(2117),\n          l = r(9326),\n          h = r(1882),\n          f = r(4429),\n          p = r(7543);\n        t.SendTxHelper = class {\n          constructor(_ref29) {\n            let {\n              options: e,\n              web3Context: t,\n              promiEvent: r,\n              returnFormat: n\n            } = _ref29;\n            this.options = {\n              checkRevertBeforeSending: !0\n            }, this.options = e, this.web3Context = t, this.promiEvent = r, this.returnFormat = n;\n          }\n          getReceiptWithEvents(e) {\n            var t, r;\n            const n = Object.assign({}, null != e ? e : {});\n            if ((null === (t = this.options) || void 0 === t ? void 0 : t.contractAbi) && n.logs && n.logs.length > 0) {\n              n.events = {};\n              for (const e of n.logs) {\n                const t = (0, p.decodeEventABI)(l.ALL_EVENTS_ABI, e, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi, this.returnFormat);\n                t.event && (n.events[t.event] = t);\n              }\n            }\n            return n;\n          }\n          checkRevertBeforeSending(e) {\n            return n(this, void 0, void 0, function* () {\n              if (!1 !== this.options.checkRevertBeforeSending) {\n                const t = yield (0, f.getRevertReason)(this.web3Context, e, this.options.contractAbi);\n                if (void 0 !== t) throw yield (0, h.getTransactionError)(this.web3Context, e, void 0, void 0, this.options.contractAbi, t);\n              }\n            });\n          }\n          emitSending(e) {\n            this.promiEvent.listenerCount(\"sending\") > 0 && this.promiEvent.emit(\"sending\", e);\n          }\n          populateGasPrice(_ref30) {\n            let {\n              transactionFormatted: e,\n              transaction: t\n            } = _ref30;\n            var r;\n            return n(this, void 0, void 0, function* () {\n              let n = e;\n              return !(null === (r = this.options) || void 0 === r ? void 0 : r.ignoreGasPricing) && (0, o.isNullish)(e.gasPrice) && ((0, o.isNullish)(t.maxPriorityFeePerGas) || (0, o.isNullish)(t.maxFeePerGas)) && (n = Object.assign(Object.assign({}, e), yield (0, c.getTransactionGasPricing)(e, this.web3Context, i.ETH_DATA_FORMAT))), n;\n            });\n          }\n          signAndSend(_ref31) {\n            let {\n              wallet: e,\n              tx: t\n            } = _ref31;\n            return n(this, void 0, void 0, function* () {\n              if (e) {\n                const r = yield e.signTransaction(t);\n                return (0, u.trySendTransaction)(this.web3Context, () => n(this, void 0, void 0, function* () {\n                  return a.ethRpcMethods.sendRawTransaction(this.web3Context.requestManager, r.rawTransaction);\n                }), r.transactionHash);\n              }\n              return (0, u.trySendTransaction)(this.web3Context, () => n(this, void 0, void 0, function* () {\n                return a.ethRpcMethods.sendTransaction(this.web3Context.requestManager, t);\n              }));\n            });\n          }\n          emitSent(e) {\n            this.promiEvent.listenerCount(\"sent\") > 0 && this.promiEvent.emit(\"sent\", e);\n          }\n          emitTransactionHash(e) {\n            this.promiEvent.listenerCount(\"transactionHash\") > 0 && this.promiEvent.emit(\"transactionHash\", e);\n          }\n          emitReceipt(e) {\n            this.promiEvent.listenerCount(\"receipt\") > 0 && this.promiEvent.emit(\"receipt\", e);\n          }\n          handleError(_ref32) {\n            let {\n              error: e,\n              tx: t\n            } = _ref32;\n            var r;\n            return n(this, void 0, void 0, function* () {\n              let n = e;\n              return n instanceof s.ContractExecutionError && this.web3Context.handleRevert && (n = yield (0, h.getTransactionError)(this.web3Context, t, void 0, void 0, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi)), (n instanceof s.InvalidResponseError || n instanceof s.ContractExecutionError || n instanceof s.TransactionRevertWithCustomError || n instanceof s.TransactionRevertedWithoutReasonError || n instanceof s.TransactionRevertInstructionError) && this.promiEvent.listenerCount(\"error\") > 0 && this.promiEvent.emit(\"error\", n), n;\n            });\n          }\n          emitConfirmation(_ref33) {\n            let {\n              receipt: e,\n              transactionHash: t\n            } = _ref33;\n            this.promiEvent.listenerCount(\"confirmation\") > 0 && (0, d.watchTransactionForConfirmations)(this.web3Context, this.promiEvent, e, t, this.returnFormat);\n          }\n          handleResolve(_ref34) {\n            let {\n              receipt: e,\n              tx: t\n            } = _ref34;\n            var r, i, o;\n            return n(this, void 0, void 0, function* () {\n              if (null === (r = this.options) || void 0 === r ? void 0 : r.transactionResolver) return null === (i = this.options) || void 0 === i ? void 0 : i.transactionResolver(e);\n              if (e.status === BigInt(0)) {\n                const r = yield (0, h.getTransactionError)(this.web3Context, t, e, void 0, null === (o = this.options) || void 0 === o ? void 0 : o.contractAbi);\n                throw this.promiEvent.listenerCount(\"error\") > 0 && this.promiEvent.emit(\"error\", r), r;\n              }\n              return e;\n            });\n          }\n        };\n      },\n      223: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.transactionBuilder = t.defaultTransactionBuilder = t.getTransactionType = t.getTransactionNonce = t.getTransactionFromOrToAttr = void 0;\n        const i = r(9970),\n          o = r(9247),\n          s = r(9820),\n          a = r(7345),\n          c = r(5071),\n          u = r(9634),\n          d = r(9326),\n          l = r(3222),\n          h = r(7350),\n          f = r(1922),\n          p = r(8736);\n        function m(e) {\n          var r, o;\n          return n(this, void 0, void 0, function* () {\n            let n = (0, u.format)(f.transactionSchema, e.transaction, i.DEFAULT_RETURN_FORMAT);\n            if ((0, a.isNullish)(n.from) && (n.from = (0, t.getTransactionFromOrToAttr)(\"from\", e.web3Context, void 0, e.privateKey)), (0, a.isNullish)(n.nonce) && (n.nonce = yield (0, t.getTransactionNonce)(e.web3Context, n.from, i.ETH_DATA_FORMAT)), (0, a.isNullish)(n.value) && (n.value = \"0x0\"), (0, a.isNullish)(n.data)) (0, a.isNullish)(n.input) ? n.input = \"0x\" : n.input.startsWith(\"0x\") || (n.input = \"0x\".concat(n.input));else {\n              if (!(0, a.isNullish)(n.input) && n.data !== n.input) throw new c.TransactionDataAndInputError({\n                data: (0, u.bytesToHex)(n.data),\n                input: (0, u.bytesToHex)(n.input)\n              });\n              n.data.startsWith(\"0x\") || (n.data = \"0x\".concat(n.data));\n            }\n            if ((0, a.isNullish)(n.common)) {\n              if (e.web3Context.defaultCommon) {\n                const t = e.web3Context.defaultCommon,\n                  r = t.customChain.chainId,\n                  i = t.customChain.networkId,\n                  o = t.customChain.name;\n                n.common = Object.assign(Object.assign({}, t), {\n                  customChain: {\n                    chainId: r,\n                    networkId: i,\n                    name: o\n                  }\n                });\n              }\n              (0, a.isNullish)(n.chain) && (n.chain = e.web3Context.defaultChain), (0, a.isNullish)(n.hardfork) && (n.hardfork = e.web3Context.defaultHardfork);\n            }\n            if ((0, a.isNullish)(n.chainId) && (0, a.isNullish)(null === (r = n.common) || void 0 === r ? void 0 : r.customChain.chainId) && (n.chainId = yield (0, l.getChainId)(e.web3Context, i.ETH_DATA_FORMAT)), (0, a.isNullish)(n.networkId) && (n.networkId = null !== (o = e.web3Context.defaultNetworkId) && void 0 !== o ? o : yield (0, s.getId)(e.web3Context, i.ETH_DATA_FORMAT)), (0, a.isNullish)(n.gasLimit) && !(0, a.isNullish)(n.gas) && (n.gasLimit = n.gas), n.type = (0, t.getTransactionType)(n, e.web3Context), !(0, a.isNullish)(n.accessList) || \"0x1\" !== n.type && \"0x2\" !== n.type || (n.accessList = []), e.fillGasPrice && (n = Object.assign(Object.assign({}, n), yield (0, p.getTransactionGasPricing)(n, e.web3Context, i.ETH_DATA_FORMAT))), (0, a.isNullish)(n.gas) && (0, a.isNullish)(n.gasLimit) && e.fillGasLimit) {\n              const t = yield (0, l.estimateGas)(e.web3Context, n, \"latest\", i.ETH_DATA_FORMAT);\n              n = Object.assign(Object.assign({}, n), {\n                gas: (0, u.format)({\n                  format: \"uint\"\n                }, t, i.ETH_DATA_FORMAT)\n              });\n            }\n            return n;\n          });\n        }\n        t.getTransactionFromOrToAttr = (e, t, r, n) => {\n          if (void 0 !== r && e in r && void 0 !== r[e]) {\n            if (\"string\" == typeof r[e] && (0, a.isAddress)(r[e])) return r[e];\n            if (!(0, a.isHexStrict)(r[e]) && (0, a.isNumber)(r[e])) {\n              if (t.wallet) {\n                const n = t.wallet.get((0, u.format)({\n                  format: \"uint\"\n                }, r[e], d.NUMBER_DATA_FORMAT));\n                if (!(0, a.isNullish)(n)) return n.address;\n                throw new c.LocalWalletNotAvailableError();\n              }\n              throw new c.LocalWalletNotAvailableError();\n            }\n            throw \"from\" === e ? new c.InvalidTransactionWithSender(r.from) : new c.InvalidTransactionWithReceiver(r.to);\n          }\n          if (\"from\" === e) {\n            if (!(0, a.isNullish)(n)) return (0, o.privateKeyToAddress)(n);\n            if (!(0, a.isNullish)(t.defaultAccount)) return t.defaultAccount;\n          }\n        }, t.getTransactionNonce = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : i.DEFAULT_RETURN_FORMAT;\n          return n(void 0, void 0, void 0, function* () {\n            if ((0, a.isNullish)(t)) throw new c.UnableToPopulateNonceError();\n            return (0, l.getTransactionCount)(e, t, e.defaultBlock, r);\n          });\n        }, t.getTransactionType = (e, t) => {\n          const r = (0, h.detectTransactionType)(e, t);\n          return (0, a.isNullish)(r) ? (0, a.isNullish)(t.defaultTransactionType) ? void 0 : (0, u.format)({\n            format: \"uint\"\n          }, t.defaultTransactionType, i.ETH_DATA_FORMAT) : r;\n        }, t.defaultTransactionBuilder = m, t.transactionBuilder = e => n(void 0, void 0, void 0, function* () {\n          var t;\n          return (null !== (t = e.web3Context.transactionBuilder) && void 0 !== t ? t : m)(Object.assign(Object.assign({}, e), {\n            transaction: e.transaction\n          }));\n        });\n      },\n      8425: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.trySendTransaction = void 0;\n        const i = r(9634),\n          o = r(5071),\n          s = r(4659);\n        t.trySendTransaction = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            const [n, a] = (0, i.rejectIfTimeout)(e.transactionSendTimeout, new o.TransactionSendTimeoutError({\n                numberOfSeconds: e.transactionSendTimeout / 1e3,\n                transactionHash: r\n              })),\n              [c, u] = yield (0, s.rejectIfBlockTimeout)(e, r);\n            try {\n              return yield Promise.race([t(), a, c]);\n            } finally {\n              clearTimeout(n), u.clean();\n            }\n          });\n        };\n      },\n      4745: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.waitForTransactionReceipt = void 0;\n        const i = r(5071),\n          o = r(9634),\n          s = r(4659),\n          a = r(3222);\n        t.waitForTransactionReceipt = function (e, t, r) {\n          var c;\n          return n(this, void 0, void 0, function* () {\n            const u = null !== (c = e.transactionReceiptPollingInterval) && void 0 !== c ? c : e.transactionPollingInterval,\n              [d, l] = (0, o.pollTillDefinedAndReturnIntervalId)(() => n(this, void 0, void 0, function* () {\n                try {\n                  return (0, a.getTransactionReceipt)(e, t, r);\n                } catch (e) {\n                  return void console.warn(\"An error happen while trying to get the transaction receipt\", e);\n                }\n              }), u),\n              [h, f] = (0, o.rejectIfTimeout)(e.transactionPollingTimeout, new i.TransactionPollingTimeoutError({\n                numberOfSeconds: e.transactionPollingTimeout / 1e3,\n                transactionHash: t\n              })),\n              [p, m] = yield (0, s.rejectIfBlockTimeout)(e, t);\n            try {\n              return yield Promise.race([d, f, p]);\n            } finally {\n              h && clearTimeout(h), l && clearInterval(l), m.clean();\n            }\n          });\n        };\n      },\n      8002: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.watchTransactionByPolling = void 0;\n        const i = r(9634),\n          o = r(1181),\n          s = r(1922);\n        t.watchTransactionByPolling = _ref35 => {\n          let {\n            web3Context: e,\n            transactionReceipt: t,\n            transactionPromiEvent: r,\n            returnFormat: a\n          } = _ref35;\n          var c;\n          let u = 1;\n          const d = setInterval(() => {\n            n(void 0, void 0, void 0, function* () {\n              u >= e.transactionConfirmationBlocks && clearInterval(d);\n              const n = yield o.ethRpcMethods.getBlockByNumber(e.requestManager, (0, i.numberToHex)(BigInt(t.blockNumber) + BigInt(u)), !1);\n              (null == n ? void 0 : n.hash) && (u += 1, r.emit(\"confirmation\", {\n                confirmations: (0, i.format)({\n                  format: \"uint\"\n                }, u, a),\n                receipt: (0, i.format)(s.transactionReceiptSchema, t, a),\n                latestBlockHash: (0, i.format)({\n                  format: \"bytes32\"\n                }, n.hash, a)\n              }));\n            });\n          }, null !== (c = e.transactionReceiptPollingInterval) && void 0 !== c ? c : e.transactionPollingInterval);\n        };\n      },\n      2539: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.watchTransactionBySubscription = void 0;\n        const i = r(9634),\n          o = r(1922),\n          s = r(8002);\n        t.watchTransactionBySubscription = _ref36 => {\n          let {\n            web3Context: e,\n            transactionReceipt: t,\n            transactionPromiEvent: r,\n            returnFormat: a\n          } = _ref36;\n          let c,\n            u = !0;\n          setImmediate(() => {\n            var d;\n            null === (d = e.subscriptionManager) || void 0 === d || d.subscribe(\"newHeads\").then(d => {\n              d.on(\"data\", s => n(void 0, void 0, void 0, function* () {\n                var n;\n                if (u = !1, !(null == s ? void 0 : s.number) || c === (null == s ? void 0 : s.parentHash)) return;\n                c = null == s ? void 0 : s.parentHash;\n                const l = BigInt(s.number) - BigInt(t.blockNumber) + BigInt(1);\n                r.emit(\"confirmation\", {\n                  confirmations: (0, i.format)({\n                    format: \"uint\"\n                  }, l, a),\n                  receipt: (0, i.format)(o.transactionReceiptSchema, t, a),\n                  latestBlockHash: (0, i.format)({\n                    format: \"bytes32\"\n                  }, s.parentHash, a)\n                }), l >= e.transactionConfirmationBlocks && (yield null === (n = e.subscriptionManager) || void 0 === n ? void 0 : n.removeSubscription(d));\n              })), d.on(\"error\", () => n(void 0, void 0, void 0, function* () {\n                var n;\n                yield null === (n = e.subscriptionManager) || void 0 === n ? void 0 : n.removeSubscription(d), u = !1, (0, s.watchTransactionByPolling)({\n                  web3Context: e,\n                  transactionReceipt: t,\n                  transactionPromiEvent: r,\n                  returnFormat: a\n                });\n              }));\n            }).catch(() => {\n              u = !1, (0, s.watchTransactionByPolling)({\n                web3Context: e,\n                transactionReceipt: t,\n                transactionPromiEvent: r,\n                returnFormat: a\n              });\n            });\n          }), setTimeout(() => {\n            u && (0, s.watchTransactionByPolling)({\n              web3Context: e,\n              transactionReceipt: t,\n              transactionPromiEvent: r,\n              returnFormat: a\n            });\n          }, 1e3 * e.blockHeaderTimeout);\n        };\n      },\n      2117: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.watchTransactionForConfirmations = void 0;\n        const n = r(9634),\n          i = r(7345),\n          o = r(5071),\n          s = r(1922),\n          a = r(8002),\n          c = r(2539);\n        t.watchTransactionForConfirmations = function (e, t, r, u, d) {\n          if ((0, i.isNullish)(r) || (0, i.isNullish)(r.blockHash)) throw new o.TransactionMissingReceiptOrBlockHashError({\n            receipt: r,\n            blockHash: (0, n.format)({\n              format: \"bytes32\"\n            }, null == r ? void 0 : r.blockHash, d),\n            transactionHash: (0, n.format)({\n              format: \"bytes32\"\n            }, u, d)\n          });\n          if (!r.blockNumber) throw new o.TransactionReceiptMissingBlockNumberError({\n            receipt: r\n          });\n          t.emit(\"confirmation\", {\n            confirmations: (0, n.format)({\n              format: \"uint\"\n            }, 1, d),\n            receipt: (0, n.format)(s.transactionReceiptSchema, r, d),\n            latestBlockHash: (0, n.format)({\n              format: \"bytes32\"\n            }, r.blockHash, d)\n          });\n          const l = e.requestManager.provider;\n          l && \"supportsSubscriptions\" in l && l.supportsSubscriptions() ? (0, c.watchTransactionBySubscription)({\n            web3Context: e,\n            transactionReceipt: r,\n            transactionPromiEvent: t,\n            returnFormat: d\n          }) : (0, a.watchTransactionByPolling)({\n            web3Context: e,\n            transactionReceipt: r,\n            transactionPromiEvent: t,\n            returnFormat: d\n          });\n        };\n      },\n      8650: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateTransactionForSigning = t.validateGas = t.validateFeeMarketGas = t.validateLegacyGas = t.validateHardfork = t.validateBaseChain = t.validateChainInfo = t.validateCustomChainInfo = t.validateTransactionCall = t.isTransactionCall = t.validateTransactionWithSender = t.isTransactionWithSender = t.isTransactionLegacyUnsigned = t.isTransaction2930Unsigned = t.isTransaction1559Unsigned = t.isAccessList = t.isAccessListEntry = t.isBaseTransaction = void 0;\n        const n = r(9970),\n          i = r(7345),\n          o = r(5071),\n          s = r(5140);\n        function a(e) {\n          return !(!(0, i.isNullish)(e.to) && !(0, i.isAddress)(e.to) || !(0, i.isHexStrict)(e.type) && !(0, i.isNullish)(e.type) && 2 !== e.type.length || !(0, i.isHexStrict)(e.nonce) || !(0, i.isHexStrict)(e.gas) || !(0, i.isHexStrict)(e.value) || !(0, i.isHexStrict)(e.input) || e.chainId && !(0, i.isHexStrict)(e.chainId));\n        }\n        function c(e) {\n          return !(!(0, i.isNullish)(e.address) && !(0, i.isAddress)(e.address) || !(0, i.isNullish)(e.storageKeys) && !e.storageKeys.every(e => (0, i.isHexString32Bytes)(e)));\n        }\n        function u(e) {\n          return !(!Array.isArray(e) || !e.every(e => c(e)));\n        }\n        function d(e) {\n          return !!(a(e) && (0, i.isHexStrict)(e.maxFeePerGas) && (0, i.isHexStrict)(e.maxPriorityFeePerGas) && u(e.accessList));\n        }\n        function l(e) {\n          return !!a(e) && !!(0, i.isHexStrict)(e.gasPrice) && !!u(e.accessList);\n        }\n        function h(e) {\n          return !!a(e) && !!(0, i.isHexStrict)(e.gasPrice);\n        }\n        function f(e) {\n          return !!(0, i.isAddress)(e.from) && !!a(e) && !!(d(e) || l(e) || h(e));\n        }\n        function p(e) {\n          return !(!(0, i.isNullish)(e.from) && !(0, i.isAddress)(e.from) || !(0, i.isAddress)(e.to) || !(0, i.isNullish)(e.gas) && !(0, i.isHexStrict)(e.gas) || !(0, i.isNullish)(e.gasPrice) && !(0, i.isHexStrict)(e.gasPrice) || !(0, i.isNullish)(e.value) && !(0, i.isHexStrict)(e.value) || !(0, i.isNullish)(e.data) && !(0, i.isHexStrict)(e.data) || !(0, i.isNullish)(e.input) && !(0, i.isHexStrict)(e.input) || !(0, i.isNullish)(e.type) || d(e) || l(e));\n        }\n        t.isBaseTransaction = a, t.isAccessListEntry = c, t.isAccessList = u, t.isTransaction1559Unsigned = d, t.isTransaction2930Unsigned = l, t.isTransactionLegacyUnsigned = h, t.isTransactionWithSender = f, t.validateTransactionWithSender = function (e) {\n          if (!f(e)) throw new o.InvalidTransactionWithSender(e);\n        }, t.isTransactionCall = p, t.validateTransactionCall = function (e) {\n          if (!p(e)) throw new o.InvalidTransactionCall(e);\n        }, t.validateCustomChainInfo = e => {\n          if (!(0, i.isNullish)(e.common)) {\n            if ((0, i.isNullish)(e.common.customChain)) throw new o.MissingCustomChainError();\n            if ((0, i.isNullish)(e.common.customChain.chainId)) throw new o.MissingCustomChainIdError();\n            if (!(0, i.isNullish)(e.chainId) && e.chainId !== e.common.customChain.chainId) throw new o.ChainIdMismatchError({\n              txChainId: e.chainId,\n              customChainId: e.common.customChain.chainId\n            });\n          }\n        }, t.validateChainInfo = e => {\n          if (!(0, i.isNullish)(e.common) && !(0, i.isNullish)(e.chain) && !(0, i.isNullish)(e.hardfork)) throw new o.CommonOrChainAndHardforkError();\n          if (!(0, i.isNullish)(e.chain) && (0, i.isNullish)(e.hardfork) || !(0, i.isNullish)(e.hardfork) && (0, i.isNullish)(e.chain)) throw new o.MissingChainOrHardforkError({\n            chain: e.chain,\n            hardfork: e.hardfork\n          });\n        }, t.validateBaseChain = e => {\n          if (!(0, i.isNullish)(e.common) && !(0, i.isNullish)(e.common.baseChain) && !(0, i.isNullish)(e.chain) && e.chain !== e.common.baseChain) throw new o.ChainMismatchError({\n            txChain: e.chain,\n            baseChain: e.common.baseChain\n          });\n        }, t.validateHardfork = e => {\n          if (!(0, i.isNullish)(e.common) && !(0, i.isNullish)(e.common.hardfork) && !(0, i.isNullish)(e.hardfork) && e.hardfork !== e.common.hardfork) throw new o.HardforkMismatchError({\n            txHardfork: e.hardfork,\n            commonHardfork: e.common.hardfork\n          });\n        }, t.validateLegacyGas = e => {\n          if ((0, i.isNullish)(e.gas) || !(0, i.isUInt)(e.gas) || (0, i.isNullish)(e.gasPrice) || !(0, i.isUInt)(e.gasPrice)) throw new o.InvalidGasOrGasPrice({\n            gas: e.gas,\n            gasPrice: e.gasPrice\n          });\n          if (!(0, i.isNullish)(e.maxFeePerGas) || !(0, i.isNullish)(e.maxPriorityFeePerGas)) throw new o.UnsupportedFeeMarketError({\n            maxFeePerGas: e.maxFeePerGas,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas\n          });\n        }, t.validateFeeMarketGas = e => {\n          if (!(0, i.isNullish)(e.gasPrice) && \"0x2\" === e.type) throw new o.Eip1559GasPriceError(e.gasPrice);\n          if (\"0x0\" === e.type || \"0x1\" === e.type) throw new o.UnsupportedFeeMarketError({\n            maxFeePerGas: e.maxFeePerGas,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas\n          });\n          if ((0, i.isNullish)(e.maxFeePerGas) || !(0, i.isUInt)(e.maxFeePerGas) || (0, i.isNullish)(e.maxPriorityFeePerGas) || !(0, i.isUInt)(e.maxPriorityFeePerGas)) throw new o.InvalidMaxPriorityFeePerGasOrMaxFeePerGas({\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n            maxFeePerGas: e.maxFeePerGas\n          });\n        }, t.validateGas = e => {\n          const r = !(0, i.isNullish)(e.gas) || !(0, i.isNullish)(e.gasLimit),\n            n = r && !(0, i.isNullish)(e.gasPrice),\n            s = r && !(0, i.isNullish)(e.maxPriorityFeePerGas) && !(0, i.isNullish)(e.maxFeePerGas);\n          if (!n && !s) throw new o.MissingGasError({\n            gas: e.gas,\n            gasPrice: e.gasPrice,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n            maxFeePerGas: e.maxFeePerGas\n          });\n          if (n && s) throw new o.TransactionGasMismatchError({\n            gas: e.gas,\n            gasPrice: e.gasPrice,\n            maxPriorityFeePerGas: e.maxPriorityFeePerGas,\n            maxFeePerGas: e.maxFeePerGas\n          });\n          (n ? t.validateLegacyGas : t.validateFeeMarketGas)(e), (!(0, i.isNullish)(e.type) && e.type > \"0x1\" ? t.validateFeeMarketGas : t.validateLegacyGas)(e);\n        }, t.validateTransactionForSigning = (e, r) => {\n          if (!(0, i.isNullish)(r)) return void r(e);\n          if (\"object\" != typeof e || (0, i.isNullish)(e)) throw new o.InvalidTransactionObjectError(e);\n          (0, t.validateCustomChainInfo)(e), (0, t.validateChainInfo)(e), (0, t.validateBaseChain)(e), (0, t.validateHardfork)(e);\n          const a = (0, s.formatTransaction)(e, n.ETH_DATA_FORMAT);\n          if ((0, t.validateGas)(a), (0, i.isNullish)(a.nonce) || (0, i.isNullish)(a.chainId) || a.nonce.startsWith(\"-\") || a.chainId.startsWith(\"-\")) throw new o.InvalidNonceOrChainIdError({\n            nonce: e.nonce,\n            chainId: e.chainId\n          });\n        };\n      },\n      1435: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Eth = t.registeredSubscriptions = void 0;\n        const a = r(9970),\n          c = r(6527),\n          u = r(5071),\n          d = r(9634),\n          l = r(1181),\n          h = o(r(3222)),\n          f = r(7460);\n        t.registeredSubscriptions = {\n          logs: f.LogsSubscription,\n          newPendingTransactions: f.NewPendingTransactionsSubscription,\n          newHeads: f.NewHeadsSubscription,\n          syncing: f.SyncingSubscription,\n          pendingTransactions: f.NewPendingTransactionsSubscription,\n          newBlockHeaders: f.NewHeadsSubscription\n        };\n        class p extends c.Web3Context {\n          constructor(e) {\n            \"string\" == typeof e || (0, c.isSupportedProvider)(e) ? super({\n              provider: e,\n              registeredSubscriptions: t.registeredSubscriptions\n            }) : e.registeredSubscriptions ? super(e) : super(Object.assign(Object.assign({}, e), {\n              registeredSubscriptions: t.registeredSubscriptions\n            }));\n          }\n          getProtocolVersion() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getProtocolVersion(this.requestManager);\n            });\n          }\n          isSyncing() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getSyncing(this.requestManager);\n            });\n          }\n          getCoinbase() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getCoinbase(this.requestManager);\n            });\n          }\n          isMining() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getMining(this.requestManager);\n            });\n          }\n          getHashrate() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return this.getHashRate(e);\n            });\n          }\n          getHashRate() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getHashRate(this, e);\n            });\n          }\n          getGasPrice() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getGasPrice(this, e);\n            });\n          }\n          getAccounts() {\n            var e;\n            return s(this, void 0, void 0, function* () {\n              return (null !== (e = yield l.ethRpcMethods.getAccounts(this.requestManager)) && void 0 !== e ? e : []).map(e => (0, d.toChecksumAddress)(e));\n            });\n          }\n          getBlockNumber() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getBlockNumber(this, e);\n            });\n          }\n          getBalance(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getBalance(this, e, t, r);\n            });\n          }\n          getStorageAt(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.defaultBlock;\n            let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getStorageAt(this, e, t, r, n);\n            });\n          }\n          getCode(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getCode(this, e, t, r);\n            });\n          }\n          getBlock() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.defaultBlock;\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getBlock(this, e, t, r);\n            });\n          }\n          getBlockTransactionCount() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.defaultBlock;\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getBlockTransactionCount(this, e, t);\n            });\n          }\n          getBlockUncleCount() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.defaultBlock;\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getBlockUncleCount(this, e, t);\n            });\n          }\n          getUncle() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.defaultBlock;\n            let t = arguments.length > 1 ? arguments[1] : undefined;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getUncle(this, e, t, r);\n            });\n          }\n          getTransaction(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              const r = yield h.getTransaction(this, e, t);\n              if (!r) throw new u.TransactionNotFound();\n              return r;\n            });\n          }\n          getPendingTransactions() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getPendingTransactions(this, e);\n            });\n          }\n          getTransactionFromBlock() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.defaultBlock;\n            let t = arguments.length > 1 ? arguments[1] : undefined;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getTransactionFromBlock(this, e, t, r);\n            });\n          }\n          getTransactionReceipt(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              const r = yield h.getTransactionReceipt(this, e, t);\n              if (!r) throw new u.TransactionNotFound();\n              return r;\n            });\n          }\n          getTransactionCount(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getTransactionCount(this, e, t, r);\n            });\n          }\n          sendTransaction(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            let r = arguments.length > 2 ? arguments[2] : undefined;\n            return h.sendTransaction(this, e, t, r);\n          }\n          sendSignedTransaction(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            let r = arguments.length > 2 ? arguments[2] : undefined;\n            return h.sendSignedTransaction(this, e, t, r);\n          }\n          sign(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.sign(this, e, t, r);\n            });\n          }\n          signTransaction(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.signTransaction(this, e, t);\n            });\n          }\n          call(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.call(this, e, t, r);\n            });\n          }\n          estimateGas(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.estimateGas(this, e, t, r);\n            });\n          }\n          getPastLogs(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getLogs(this, e, t);\n            });\n          }\n          getWork() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getWork(this.requestManager);\n            });\n          }\n          submitWork(e, t, r) {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.submitWork(this.requestManager, e, t, r);\n            });\n          }\n          requestAccounts() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.requestAccounts(this.requestManager);\n            });\n          }\n          getChainId() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getChainId(this, e);\n            });\n          }\n          getNodeInfo() {\n            return s(this, void 0, void 0, function* () {\n              return l.ethRpcMethods.getNodeInfo(this.requestManager);\n            });\n          }\n          getProof(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.defaultBlock;\n            let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getProof(this, e, t, r, n);\n            });\n          }\n          getFeeHistory(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 ? arguments[2] : undefined;\n            let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.getFeeHistory(this, e, t, r, n);\n            });\n          }\n          createAccessList(e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultBlock;\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.createAccessList(this, e, t, r);\n            });\n          }\n          signTypedData(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n            let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return h.signTypedData(this, e, t, r, n);\n            });\n          }\n          subscribe(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : a.DEFAULT_RETURN_FORMAT;\n            var n;\n            return s(this, void 0, void 0, function* () {\n              const i = yield null === (n = this.subscriptionManager) || void 0 === n ? void 0 : n.subscribe(e, t, r);\n              return i instanceof f.LogsSubscription && \"logs\" === e && \"object\" == typeof t && !(0, d.isNullish)(t.fromBlock) && Number.isFinite(Number(t.fromBlock)) && setImmediate(() => {\n                this.getPastLogs(t).then(e => {\n                  for (const t of e) i._processSubscriptionResult(t);\n                }).catch(e => {\n                  i._processSubscriptionError(e);\n                });\n              }), i;\n            });\n          }\n          static shouldClearSubscription(_ref37) {\n            let {\n              sub: e\n            } = _ref37;\n            return !(e instanceof f.SyncingSubscription);\n          }\n          clearSubscriptions() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n            var t;\n            return null === (t = this.subscriptionManager) || void 0 === t ? void 0 : t.unsubscribe(e ? p.shouldClearSubscription : void 0);\n          }\n        }\n        t.Web3Eth = p;\n      },\n      7460: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SyncingSubscription = t.NewHeadsSubscription = t.NewPendingTransactionsSubscription = t.LogsSubscription = void 0;\n        const n = r(9634),\n          i = r(6527),\n          o = r(1922);\n        class s extends i.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"logs\", this.args];\n          }\n          formatSubscriptionResult(e) {\n            return (0, n.format)(o.logSchema, e, super.returnFormat);\n          }\n        }\n        t.LogsSubscription = s;\n        class a extends i.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"newPendingTransactions\"];\n          }\n          formatSubscriptionResult(e) {\n            return (0, n.format)({\n              format: \"string\"\n            }, e, super.returnFormat);\n          }\n        }\n        t.NewPendingTransactionsSubscription = a;\n        class c extends i.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"newHeads\"];\n          }\n          formatSubscriptionResult(e) {\n            return (0, n.format)(o.blockHeaderSchema, e, super.returnFormat);\n          }\n        }\n        t.NewHeadsSubscription = c;\n        class u extends i.Web3Subscription {\n          _buildSubscriptionParams() {\n            return [\"syncing\"];\n          }\n          _processSubscriptionResult(e) {\n            if (\"boolean\" == typeof e) this.emit(\"changed\", e);else {\n              const t = Object.fromEntries(Object.entries(e.status).map(_ref38 => {\n                let [e, t] = _ref38;\n                return [e.charAt(0).toLowerCase() + e.substring(1), t];\n              }));\n              this.emit(\"changed\", e.syncing), this.emit(\"data\", (0, n.format)(o.syncSchema, t, super.returnFormat));\n            }\n          }\n        }\n        t.SyncingSubscription = u;\n      },\n      9820: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const o = r(2491);\n        i(r(2491), t), i(r(7961), t), t.default = o.Net;\n      },\n      2491: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Net = void 0;\n        const a = r(6527),\n          c = r(9970),\n          u = o(r(7961));\n        class d extends a.Web3Context {\n          getId() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : c.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return u.getId(this, e);\n            });\n          }\n          getPeerCount() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : c.DEFAULT_RETURN_FORMAT;\n            return s(this, void 0, void 0, function* () {\n              return u.getPeerCount(this, e);\n            });\n          }\n          isListening() {\n            return s(this, void 0, void 0, function* () {\n              return u.isListening(this);\n            });\n          }\n        }\n        t.Net = d;\n      },\n      7961: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isListening = t.getPeerCount = t.getId = void 0;\n        const i = r(9634),\n          o = r(1181);\n        t.getId = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield o.netRpcMethods.getId(e.requestManager);\n            return (0, i.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.getPeerCount = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            const r = yield o.netRpcMethods.getPeerCount(e.requestManager);\n            return (0, i.format)({\n              format: \"uint\"\n            }, r, t);\n          });\n        }, t.isListening = e => n(void 0, void 0, void 0, function* () {\n          return o.netRpcMethods.isListening(e.requestManager);\n        });\n      },\n      2636: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          },\n          i = this && this.__importDefault || function (e) {\n            return e && e.__esModule ? e : {\n              default: e\n            };\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.HttpProvider = void 0;\n        const o = i(r(6279)),\n          s = r(9970),\n          a = r(5071);\n        class c extends s.Web3BaseProvider {\n          constructor(e, t) {\n            if (super(), !c.validateClientUrl(e)) throw new a.InvalidClientError(e);\n            this.clientUrl = e, this.httpProviderOptions = t;\n          }\n          static validateClientUrl(e) {\n            return \"string\" == typeof e && /^http(s)?:\\/\\//i.test(e);\n          }\n          getStatus() {\n            throw new a.MethodNotImplementedError();\n          }\n          supportsSubscriptions() {\n            return !1;\n          }\n          request(e, t) {\n            var r;\n            return n(this, void 0, void 0, function* () {\n              const n = Object.assign(Object.assign({}, null === (r = this.httpProviderOptions) || void 0 === r ? void 0 : r.providerOptions), t),\n                i = yield (0, o.default)(this.clientUrl, Object.assign(Object.assign({}, n), {\n                  method: \"POST\",\n                  headers: Object.assign(Object.assign({}, n.headers), {\n                    \"Content-Type\": \"application/json\"\n                  }),\n                  body: JSON.stringify(e)\n                }));\n              if (!i.ok) throw new a.ResponseError(yield i.json());\n              return yield i.json();\n            });\n          }\n          on() {\n            throw new a.MethodNotImplementedError();\n          }\n          removeListener() {\n            throw new a.MethodNotImplementedError();\n          }\n          once() {\n            throw new a.MethodNotImplementedError();\n          }\n          removeAllListeners() {\n            throw new a.MethodNotImplementedError();\n          }\n          connect() {\n            throw new a.MethodNotImplementedError();\n          }\n          disconnect() {\n            throw new a.MethodNotImplementedError();\n          }\n          reset() {\n            throw new a.MethodNotImplementedError();\n          }\n          reconnect() {\n            throw new a.MethodNotImplementedError();\n          }\n        }\n        t.default = c, t.HttpProvider = c;\n      },\n      1161: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WebSocketProvider = void 0;\n        const i = n(r(7475)),\n          o = r(9634),\n          s = r(5071);\n        class a extends o.SocketProvider {\n          constructor(e, t, r) {\n            super(e, t, r);\n          }\n          _validateProviderPath(e) {\n            return \"string\" == typeof e && /^ws(s)?:\\/\\//i.test(e);\n          }\n          getStatus() {\n            if (this._socketConnection && !(0, o.isNullish)(this._socketConnection)) switch (this._socketConnection.readyState) {\n              case this._socketConnection.CONNECTING:\n                return \"connecting\";\n              case this._socketConnection.OPEN:\n                return \"connected\";\n              default:\n                return \"disconnected\";\n            }\n            return \"disconnected\";\n          }\n          _openSocketConnection() {\n            this._socketConnection = new i.default(this._socketPath, void 0, this._socketOptions && 0 === Object.keys(this._socketOptions).length ? void 0 : this._socketOptions);\n          }\n          _closeSocketConnection(e, t) {\n            var r;\n            null === (r = this._socketConnection) || void 0 === r || r.close(e, t);\n          }\n          _sendToSocket(e) {\n            var t;\n            if (\"disconnected\" === this.getStatus()) throw new s.ConnectionNotOpenError();\n            null === (t = this._socketConnection) || void 0 === t || t.send(JSON.stringify(e));\n          }\n          _parseResponses(e) {\n            return this.chunkResponseParser.parseResponse(e.data);\n          }\n          _addSocketListeners() {\n            var e, t, r, n;\n            null === (e = this._socketConnection) || void 0 === e || e.addEventListener(\"open\", this._onOpenHandler), null === (t = this._socketConnection) || void 0 === t || t.addEventListener(\"message\", this._onMessageHandler), null === (r = this._socketConnection) || void 0 === r || r.addEventListener(\"close\", e => this._onCloseHandler(e)), null === (n = this._socketConnection) || void 0 === n || n.addEventListener(\"error\", this._onErrorHandler);\n          }\n          _removeSocketListeners() {\n            var e, t, r;\n            null === (e = this._socketConnection) || void 0 === e || e.removeEventListener(\"message\", this._onMessageHandler), null === (t = this._socketConnection) || void 0 === t || t.removeEventListener(\"open\", this._onOpenHandler), null === (r = this._socketConnection) || void 0 === r || r.removeEventListener(\"close\", this._onCloseHandler);\n          }\n          _onCloseEvent(e) {\n            var t;\n            !this._reconnectOptions.autoReconnect || [1e3, 1001].includes(e.code) && e.wasClean ? (this._clearQueues(e), this._removeSocketListeners(), this._onDisconnect(e.code, e.reason), null === (t = this._socketConnection) || void 0 === t || t.removeEventListener(\"error\", this._onErrorHandler)) : this._reconnect();\n          }\n        }\n        t.default = a, t.WebSocketProvider = a;\n      },\n      9298: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getNodeInfo = t.getProof = t.getChainId = t.requestAccounts = t.getPendingTransactions = t.getFeeHistory = t.submitHashrate = t.submitWork = t.getWork = t.getLogs = t.getFilterLogs = t.getFilterChanges = t.uninstallFilter = t.newPendingTransactionFilter = t.newBlockFilter = t.newFilter = t.compileSerpent = t.compileLLL = t.compileSolidity = t.getCompilers = t.getUncleByBlockNumberAndIndex = t.getUncleByBlockHashAndIndex = t.getTransactionReceipt = t.getTransactionByBlockNumberAndIndex = t.getTransactionByBlockHashAndIndex = t.getTransactionByHash = t.getBlockByNumber = t.getBlockByHash = t.estimateGas = t.call = t.sendRawTransaction = t.sendTransaction = t.signTransaction = t.sign = t.getCode = t.getUncleCountByBlockNumber = t.getUncleCountByBlockHash = t.getBlockTransactionCountByNumber = t.getBlockTransactionCountByHash = t.getTransactionCount = t.getStorageAt = t.getBalance = t.getBlockNumber = t.getAccounts = t.getGasPrice = t.getHashRate = t.getMining = t.getCoinbase = t.getSyncing = t.getProtocolVersion = void 0, t.signTypedData = t.createAccessList = void 0;\n        const i = r(7345);\n        t.getProtocolVersion = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_protocolVersion\",\n              params: []\n            });\n          });\n        }, t.getSyncing = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_syncing\",\n              params: []\n            });\n          });\n        }, t.getCoinbase = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_coinbase\",\n              params: []\n            });\n          });\n        }, t.getMining = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_mining\",\n              params: []\n            });\n          });\n        }, t.getHashRate = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_hashrate\",\n              params: []\n            });\n          });\n        }, t.getGasPrice = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_gasPrice\",\n              params: []\n            });\n          });\n        }, t.getAccounts = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_accounts\",\n              params: []\n            });\n          });\n        }, t.getBlockNumber = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_blockNumber\",\n              params: []\n            });\n          });\n        }, t.getBalance = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\", \"blockNumberOrTag\"], [t, r]), e.send({\n              method: \"eth_getBalance\",\n              params: [t, r]\n            });\n          });\n        }, t.getStorageAt = function (e, t, r, o) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\", \"hex\", \"blockNumberOrTag\"], [t, r, o]), e.send({\n              method: \"eth_getStorageAt\",\n              params: [t, r, o]\n            });\n          });\n        }, t.getTransactionCount = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\", \"blockNumberOrTag\"], [t, r]), e.send({\n              method: \"eth_getTransactionCount\",\n              params: [t, r]\n            });\n          });\n        }, t.getBlockTransactionCountByHash = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getBlockTransactionCountByHash\",\n              params: [t]\n            });\n          });\n        }, t.getBlockTransactionCountByNumber = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\"], [t]), e.send({\n              method: \"eth_getBlockTransactionCountByNumber\",\n              params: [t]\n            });\n          });\n        }, t.getUncleCountByBlockHash = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getUncleCountByBlockHash\",\n              params: [t]\n            });\n          });\n        }, t.getUncleCountByBlockNumber = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\"], [t]), e.send({\n              method: \"eth_getUncleCountByBlockNumber\",\n              params: [t]\n            });\n          });\n        }, t.getCode = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\", \"blockNumberOrTag\"], [t, r]), e.send({\n              method: \"eth_getCode\",\n              params: [t, r]\n            });\n          });\n        }, t.sign = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\", \"hex\"], [t, r]), e.send({\n              method: \"eth_sign\",\n              params: [t, r]\n            });\n          });\n        }, t.signTransaction = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_signTransaction\",\n              params: [t]\n            });\n          });\n        }, t.sendTransaction = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_sendTransaction\",\n              params: [t]\n            });\n          });\n        }, t.sendRawTransaction = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_sendRawTransaction\",\n              params: [t]\n            });\n          });\n        }, t.call = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\"], [r]), e.send({\n              method: \"eth_call\",\n              params: [t, r]\n            });\n          });\n        }, t.estimateGas = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\"], [r]), e.send({\n              method: \"eth_estimateGas\",\n              params: [t, r]\n            });\n          });\n        }, t.getBlockByHash = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\", \"bool\"], [t, r]), e.send({\n              method: \"eth_getBlockByHash\",\n              params: [t, r]\n            });\n          });\n        }, t.getBlockByNumber = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\", \"bool\"], [t, r]), e.send({\n              method: \"eth_getBlockByNumber\",\n              params: [t, r]\n            });\n          });\n        }, t.getTransactionByHash = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getTransactionByHash\",\n              params: [t]\n            });\n          });\n        }, t.getTransactionByBlockHashAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getTransactionByBlockHashAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getTransactionByBlockNumberAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getTransactionByBlockNumberAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getTransactionReceipt = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\"], [t]), e.send({\n              method: \"eth_getTransactionReceipt\",\n              params: [t]\n            });\n          });\n        }, t.getUncleByBlockHashAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getUncleByBlockHashAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getUncleByBlockNumberAndIndex = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\", \"hex\"], [t, r]), e.send({\n              method: \"eth_getUncleByBlockNumberAndIndex\",\n              params: [t, r]\n            });\n          });\n        }, t.getCompilers = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_getCompilers\",\n              params: []\n            });\n          });\n        }, t.compileSolidity = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"string\"], [t]), e.send({\n              method: \"eth_compileSolidity\",\n              params: [t]\n            });\n          });\n        }, t.compileLLL = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"string\"], [t]), e.send({\n              method: \"eth_compileLLL\",\n              params: [t]\n            });\n          });\n        }, t.compileSerpent = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"string\"], [t]), e.send({\n              method: \"eth_compileSerpent\",\n              params: [t]\n            });\n          });\n        }, t.newFilter = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"filter\"], [t]), e.send({\n              method: \"eth_newFilter\",\n              params: [t]\n            });\n          });\n        }, t.newBlockFilter = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_newBlockFilter\",\n              params: []\n            });\n          });\n        }, t.newPendingTransactionFilter = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_newPendingTransactionFilter\",\n              params: []\n            });\n          });\n        }, t.uninstallFilter = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_uninstallFilter\",\n              params: [t]\n            });\n          });\n        }, t.getFilterChanges = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_getFilterChanges\",\n              params: [t]\n            });\n          });\n        }, t.getFilterLogs = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"hex\"], [t]), e.send({\n              method: \"eth_getFilterLogs\",\n              params: [t]\n            });\n          });\n        }, t.getLogs = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"filter\"], [t]), e.send({\n              method: \"eth_getLogs\",\n              params: [t]\n            });\n          });\n        }, t.getWork = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_getWork\",\n              params: []\n            });\n          });\n        }, t.submitWork = function (e, t, r, o) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes8\", \"bytes32\", \"bytes32\"], [t, r, o]), e.send({\n              method: \"eth_submitWork\",\n              params: [t, r, o]\n            });\n          });\n        }, t.submitHashrate = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"bytes32\", \"bytes32\"], [t, r]), e.send({\n              method: \"eth_submitHashrate\",\n              params: [t, r]\n            });\n          });\n        }, t.getFeeHistory = function (e, t, r, o) {\n          return n(this, void 0, void 0, function* () {\n            i.validator.validate([\"hex\", \"blockNumberOrTag\"], [t, r]);\n            for (const e of o) i.validator.validate([\"number\"], [e]);\n            return e.send({\n              method: \"eth_feeHistory\",\n              params: [t, r, o]\n            });\n          });\n        }, t.getPendingTransactions = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_pendingTransactions\",\n              params: []\n            });\n          });\n        }, t.requestAccounts = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_requestAccounts\",\n              params: []\n            });\n          });\n        }, t.getChainId = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"eth_chainId\",\n              params: []\n            });\n          });\n        }, t.getProof = function (e, t, r, o) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\", \"bytes32[]\", \"blockNumberOrTag\"], [t, r, o]), e.send({\n              method: \"eth_getProof\",\n              params: [t, r, o]\n            });\n          });\n        }, t.getNodeInfo = function (e) {\n          return n(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"web3_clientVersion\",\n              params: []\n            });\n          });\n        }, t.createAccessList = function (e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"blockNumberOrTag\"], [r]), e.send({\n              method: \"eth_createAccessList\",\n              params: [t, r]\n            });\n          });\n        }, t.signTypedData = function (e, t, r) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n          return n(this, void 0, void 0, function* () {\n            return i.validator.validate([\"address\"], [t]), e.send({\n              method: \"eth_signTypedData\" + (o ? \"\" : \"_v4\"),\n              params: [t, r]\n            });\n          });\n        };\n      },\n      1181: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.personalRpcMethods = t.netRpcMethods = t.ethRpcMethods = void 0;\n        const s = o(r(9298));\n        t.ethRpcMethods = s;\n        const a = o(r(9960));\n        t.netRpcMethods = a;\n        const c = o(r(6745));\n        t.personalRpcMethods = c;\n      },\n      9960: function _(e, t) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isListening = t.getPeerCount = t.getId = void 0, t.getId = function (e) {\n          return r(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"net_version\",\n              params: []\n            });\n          });\n        }, t.getPeerCount = function (e) {\n          return r(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"net_peerCount\",\n              params: []\n            });\n          });\n        }, t.isListening = function (e) {\n          return r(this, void 0, void 0, function* () {\n            return e.send({\n              method: \"net_listening\",\n              params: []\n            });\n          });\n        };\n      },\n      6745: function _(e, t) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ecRecover = t.sign = t.signTransaction = t.sendTransaction = t.importRawKey = t.lockAccount = t.unlockAccount = t.newAccount = t.getAccounts = void 0, t.getAccounts = e => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_listAccounts\",\n            params: []\n          });\n        }), t.newAccount = (e, t) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_newAccount\",\n            params: [t]\n          });\n        }), t.unlockAccount = (e, t, n, i) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_unlockAccount\",\n            params: [t, n, i]\n          });\n        }), t.lockAccount = (e, t) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_lockAccount\",\n            params: [t]\n          });\n        }), t.importRawKey = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_importRawKey\",\n            params: [t, n]\n          });\n        }), t.sendTransaction = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_sendTransaction\",\n            params: [t, n]\n          });\n        }), t.signTransaction = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_signTransaction\",\n            params: [t, n]\n          });\n        }), t.sign = (e, t, n, i) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_sign\",\n            params: [t, n, i]\n          });\n        }), t.ecRecover = (e, t, n) => r(void 0, void 0, void 0, function* () {\n          return e.send({\n            method: \"personal_ecRecover\",\n            params: [t, n]\n          });\n        });\n      },\n      6325: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      5529: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      2453: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      2856: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      6877: (e, t) => {\n        \"use strict\";\n\n        var r, n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ETH_DATA_FORMAT = t.DEFAULT_RETURN_FORMAT = t.FMT_BYTES = t.FMT_NUMBER = void 0, function (e) {\n          e.NUMBER = \"NUMBER_NUMBER\", e.HEX = \"NUMBER_HEX\", e.STR = \"NUMBER_STR\", e.BIGINT = \"NUMBER_BIGINT\";\n        }(r = t.FMT_NUMBER || (t.FMT_NUMBER = {})), function (e) {\n          e.HEX = \"BYTES_HEX\", e.UINT8ARRAY = \"BYTES_UINT8ARRAY\";\n        }(n = t.FMT_BYTES || (t.FMT_BYTES = {})), t.DEFAULT_RETURN_FORMAT = {\n          number: r.BIGINT,\n          bytes: n.HEX\n        }, t.ETH_DATA_FORMAT = {\n          number: r.HEX,\n          bytes: n.HEX\n        };\n      },\n      9779: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      1517: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8223: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      4205: (e, t) => {\n        \"use strict\";\n\n        var r, n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.HardforksOrdered = t.BlockTags = void 0, (n = t.BlockTags || (t.BlockTags = {})).EARLIEST = \"earliest\", n.LATEST = \"latest\", n.PENDING = \"pending\", n.SAFE = \"safe\", n.FINALIZED = \"finalized\", (r = t.HardforksOrdered || (t.HardforksOrdered = {})).chainstart = \"chainstart\", r.frontier = \"frontier\", r.homestead = \"homestead\", r.dao = \"dao\", r.tangerineWhistle = \"tangerineWhistle\", r.spuriousDragon = \"spuriousDragon\", r.byzantium = \"byzantium\", r.constantinople = \"constantinople\", r.petersburg = \"petersburg\", r.istanbul = \"istanbul\", r.muirGlacier = \"muirGlacier\", r.berlin = \"berlin\", r.london = \"london\", r.altair = \"altair\", r.arrowGlacier = \"arrowGlacier\", r.grayGlacier = \"grayGlacier\", r.bellatrix = \"bellatrix\", r.merge = \"merge\", r.capella = \"capella\", r.shanghai = \"shanghai\";\n      },\n      9970: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), i(r(9779), t), i(r(6325), t), i(r(2453), t), i(r(2856), t), i(r(5529), t), i(r(6877), t), i(r(4205), t), i(r(1517), t), i(r(8223), t), i(r(2196), t), i(r(8887), t), i(r(8173), t), i(r(1040), t), i(r(5640), t), i(r(1436), t), i(r(4933), t);\n      },\n      2196: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8887: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TypedArray = void 0, t.TypedArray = Object.getPrototypeOf(Uint8Array);\n      },\n      8173: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      1040: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      5640: function _(e, t) {\n        \"use strict\";\n\n        var r = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3BaseProvider = void 0;\n        const n = Symbol.for(\"web3/base-provider\");\n        class i {\n          static isWeb3Provider(e) {\n            return e instanceof i || Boolean(e && e[n]);\n          }\n          get [n]() {\n            return !0;\n          }\n          send(e, t) {\n            this.request(e).then(e => {\n              t(null, e);\n            }).catch(e => {\n              t(e);\n            });\n          }\n          sendAsync(e) {\n            return r(this, void 0, void 0, function* () {\n              return this.request(e);\n            });\n          }\n          asEIP1193Provider() {\n            const e = Object.create(this),\n              t = e.request;\n            return e.request = function (e) {\n              return r(this, void 0, void 0, function* () {\n                return (yield t(e)).result;\n              });\n            }, e.asEIP1193Provider = void 0, e;\n          }\n        }\n        t.Web3BaseProvider = i;\n      },\n      1436: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3BaseWallet = void 0, t.Web3BaseWallet = class extends Array {\n          constructor(e) {\n            super(), this._accountProvider = e;\n          }\n        };\n      },\n      4933: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      4108: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ChunkResponseParser = void 0;\n        const n = r(5071);\n        t.ChunkResponseParser = class {\n          constructor(e, t) {\n            this.eventEmitter = e, this.autoReconnect = t;\n          }\n          clearQueues() {\n            \"function\" == typeof this._clearQueues && this._clearQueues();\n          }\n          onError(e) {\n            this._clearQueues = e;\n          }\n          parseResponse(e) {\n            const t = [];\n            return e.replace(/\\}[\\n\\r]?\\{/g, \"}|--|{\").replace(/\\}\\][\\n\\r]?\\[\\{/g, \"}]|--|[{\").replace(/\\}[\\n\\r]?\\[\\{/g, \"}|--|[{\").replace(/\\}\\][\\n\\r]?\\{/g, \"}]|--|{\").split(\"|--|\").forEach(e => {\n              let r,\n                i = e;\n              this.lastChunk && (i = this.lastChunk + i);\n              try {\n                r = JSON.parse(i);\n              } catch (e) {\n                return this.lastChunk = i, this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout), void (this.lastChunkTimeout = setTimeout(() => {\n                  this.autoReconnect || (this.clearQueues(), this.eventEmitter.emit(\"error\", new n.InvalidResponseError({\n                    id: 1,\n                    jsonrpc: \"2.0\",\n                    error: {\n                      code: 2,\n                      message: \"Chunk timeout\"\n                    }\n                  })));\n                }, 15e3));\n              }\n              clearTimeout(this.lastChunkTimeout), this.lastChunk = void 0, r && t.push(r);\n            }), t;\n          }\n        };\n      },\n      7086: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.toBool = t.toChecksumAddress = t.toWei = t.fromWei = t.toBigInt = t.toNumber = t.toHex = t.toAscii = t.hexToAscii = t.fromAscii = t.asciiToHex = t.hexToString = t.utf8ToBytes = t.toUtf8 = t.hexToUtf8 = t.stringToHex = t.fromUtf8 = t.utf8ToHex = t.hexToNumberString = t.fromDecimal = t.numberToHex = t.toDecimal = t.hexToNumber = t.hexToBytes = t.bytesToHex = t.bytesToUint8Array = t.ethUnitMap = void 0;\n        const n = r(3687),\n          i = r(5487),\n          o = r(7345),\n          s = r(5071);\n        t.ethUnitMap = {\n          noether: BigInt(0),\n          wei: BigInt(1),\n          kwei: BigInt(1e3),\n          Kwei: BigInt(1e3),\n          babbage: BigInt(1e3),\n          femtoether: BigInt(1e3),\n          mwei: BigInt(1e6),\n          Mwei: BigInt(1e6),\n          lovelace: BigInt(1e6),\n          picoether: BigInt(1e6),\n          gwei: BigInt(1e9),\n          Gwei: BigInt(1e9),\n          shannon: BigInt(1e9),\n          nanoether: BigInt(1e9),\n          nano: BigInt(1e9),\n          szabo: BigInt(1e12),\n          microether: BigInt(1e12),\n          micro: BigInt(1e12),\n          finney: BigInt(1e15),\n          milliether: BigInt(1e15),\n          milli: BigInt(1e15),\n          ether: BigInt(\"1000000000000000000\"),\n          kether: BigInt(\"1000000000000000000000\"),\n          grand: BigInt(\"1000000000000000000000\"),\n          mether: BigInt(\"1000000000000000000000000\"),\n          gether: BigInt(\"1000000000000000000000000000\"),\n          tether: BigInt(\"1000000000000000000000000000000\")\n        }, t.bytesToUint8Array = e => {\n          if (o.validator.validate([\"bytes\"], [e]), e instanceof Uint8Array) return e;\n          if (Array.isArray(e)) return new Uint8Array(e);\n          if (\"string\" == typeof e) return o.utils.hexToUint8Array(e);\n          throw new s.InvalidBytesError(e);\n        };\n        const {\n          uint8ArrayToHexString: a\n        } = o.utils;\n        t.bytesToHex = e => a((0, t.bytesToUint8Array)(e)), t.hexToBytes = e => \"string\" == typeof e && \"0x\" !== e.slice(0, 2).toLowerCase() ? (0, t.bytesToUint8Array)(\"0x\".concat(e)) : (0, t.bytesToUint8Array)(e), t.hexToNumber = e => (o.validator.validate([\"hex\"], [e]), o.utils.hexToNumber(e)), t.toDecimal = t.hexToNumber, t.numberToHex = (e, t) => {\n          \"bigint\" != typeof e && o.validator.validate([\"int\"], [e]);\n          let r = o.utils.numberToHex(e);\n          return t && (r.startsWith(\"-\") || r.length % 2 != 1 ? r.length % 2 == 0 && r.startsWith(\"-\") && (r = \"-0x0\".concat(r.slice(3))) : r = \"0x0\".concat(r.slice(2))), r;\n        }, t.fromDecimal = t.numberToHex, t.hexToNumberString = e => (0, t.hexToNumber)(e).toString(), t.utf8ToHex = e => {\n          o.validator.validate([\"string\"], [e]);\n          let r = e.replace(/^(?:\\u0000)/, \"\");\n          return r = r.replace(/(?:\\u0000)$/, \"\"), (0, t.bytesToHex)(new TextEncoder().encode(r));\n        }, t.fromUtf8 = t.utf8ToHex, t.stringToHex = t.utf8ToHex, t.hexToUtf8 = e => (0, i.bytesToUtf8)((0, t.hexToBytes)(e)), t.toUtf8 = e => \"string\" == typeof e ? (0, t.hexToUtf8)(e) : (o.validator.validate([\"bytes\"], [e]), (0, i.bytesToUtf8)(e)), t.utf8ToBytes = i.utf8ToBytes, t.hexToString = t.hexToUtf8, t.asciiToHex = e => {\n          o.validator.validate([\"string\"], [e]);\n          let t = \"\";\n          for (let r = 0; r < e.length; r += 1) {\n            const n = e.charCodeAt(r).toString(16);\n            t += n.length % 2 != 0 ? \"0\".concat(n) : n;\n          }\n          return \"0x\".concat(t);\n        }, t.fromAscii = t.asciiToHex, t.hexToAscii = e => new TextDecoder(\"ascii\").decode((0, t.hexToBytes)(e)), t.toAscii = t.hexToAscii, t.toHex = (e, r) => {\n          if (\"string\" == typeof e && (0, o.isAddress)(e)) return r ? \"address\" : \"0x\".concat(e.toLowerCase().replace(/^0x/i, \"\"));\n          if (\"boolean\" == typeof e) return r ? \"bool\" : e ? \"0x01\" : \"0x00\";\n          if (\"number\" == typeof e) return r ? e < 0 ? \"int256\" : \"uint256\" : (0, t.numberToHex)(e);\n          if (\"bigint\" == typeof e) return r ? \"bigint\" : (0, t.numberToHex)(e);\n          if (\"object\" == typeof e && e) return r ? \"string\" : (0, t.utf8ToHex)(JSON.stringify(e));\n          if (\"string\" == typeof e) {\n            if (e.startsWith(\"-0x\") || e.startsWith(\"-0X\")) return r ? \"int256\" : (0, t.numberToHex)(e);\n            if ((0, o.isHexStrict)(e)) return r ? \"bytes\" : e;\n            if ((0, o.isHex)(e) && !(0, o.isInt)(e)) return r ? \"bytes\" : \"0x\".concat(e);\n            if (!Number.isFinite(e)) return r ? \"string\" : (0, t.utf8ToHex)(e);\n          }\n          throw new s.HexProcessingError(e);\n        }, t.toNumber = e => {\n          if (\"number\" == typeof e) return e;\n          if (\"bigint\" == typeof e) return e >= Number.MIN_SAFE_INTEGER && e <= Number.MAX_SAFE_INTEGER ? Number(e) : e;\n          if (\"string\" == typeof e && (0, o.isHexStrict)(e)) return (0, t.hexToNumber)(e);\n          try {\n            return (0, t.toNumber)(BigInt(e));\n          } catch (t) {\n            throw new s.InvalidNumberError(e);\n          }\n        }, t.toBigInt = e => {\n          if (\"number\" == typeof e) return BigInt(e);\n          if (\"bigint\" == typeof e) return e;\n          if (\"string\" == typeof e && (0, o.isHex)(e)) return e.startsWith(\"-\") ? -BigInt(e.substring(1)) : BigInt(e);\n          throw new s.InvalidNumberError(e);\n        }, t.fromWei = (e, r) => {\n          const n = t.ethUnitMap[r];\n          if (!n) throw new s.InvalidUnitError(r);\n          const i = String((0, t.toNumber)(e)),\n            o = n.toString().length - 1;\n          if (o <= 0) return i.toString();\n          const a = i.padStart(o, \"0\"),\n            c = a.slice(0, -o),\n            u = a.slice(-o).replace(/\\.?0+$/, \"\");\n          return \"\" === c ? \"0.\".concat(u) : \"\" === u ? c : \"\".concat(c, \".\").concat(u);\n        }, t.toWei = (e, r) => {\n          o.validator.validate([\"number\"], [e]);\n          const n = t.ethUnitMap[r];\n          if (!n) throw new s.InvalidUnitError(r);\n          const [i, a] = String(\"string\" != typeof e || (0, o.isHexStrict)(e) ? (0, t.toNumber)(e) : e).split(\".\").concat(\"\"),\n            c = BigInt(\"\".concat(i).concat(a)) * n,\n            u = n.toString().length - 1,\n            d = Math.min(a.length, u);\n          return 0 === d ? c.toString() : c.toString().padStart(d, \"0\").slice(0, -d);\n        }, t.toChecksumAddress = e => {\n          if (!(0, o.isAddress)(e, !1)) throw new s.InvalidAddressError(e);\n          const r = e.toLowerCase().replace(/^0x/i, \"\"),\n            i = o.utils.uint8ArrayToHexString((0, n.keccak256)((0, t.utf8ToBytes)(r)));\n          if ((0, o.isNullish)(i) || \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\" === i) return \"\";\n          let a = \"0x\";\n          const c = i.replace(/^0x/i, \"\");\n          for (let e = 0; e < r.length; e += 1) parseInt(c[e], 16) > 7 ? a += r[e].toUpperCase() : a += r[e];\n          return a;\n        }, t.toBool = e => {\n          if (\"boolean\" == typeof e) return e;\n          if (\"number\" == typeof e && (0 === e || 1 === e)) return Boolean(e);\n          if (\"bigint\" == typeof e && (e === BigInt(0) || e === BigInt(1))) return Boolean(e);\n          if (\"string\" == typeof e && !(0, o.isHexStrict)(e) && (\"1\" === e || \"0\" === e || \"false\" === e || \"true\" === e)) return \"true\" === e || \"false\" !== e && Boolean(Number(e));\n          if (\"string\" == typeof e && (0, o.isHexStrict)(e) && (\"0x1\" === e || \"0x0\" === e)) return Boolean((0, t.toNumber)(e));\n          throw new s.InvalidBooleanError(e);\n        };\n      },\n      8512: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.EventEmitter = void 0;\n        const i = r(2699);\n        class o extends EventTarget {\n          constructor() {\n            super(...arguments), this._listeners = {}, this.maxListeners = Number.MAX_SAFE_INTEGER;\n          }\n          on(e, t) {\n            return this.addEventListener(e, t), this;\n          }\n          once(e, t) {\n            const r = i => n(this, void 0, void 0, function* () {\n              this.off(e, r), yield t(i);\n            });\n            return this.on(e, r);\n          }\n          off(e, t) {\n            return this.removeEventListener(e, t), this;\n          }\n          emit(e, t) {\n            const r = new CustomEvent(e, {\n              detail: t\n            });\n            return super.dispatchEvent(r);\n          }\n          listenerCount(e) {\n            const t = this._listeners[e];\n            return t ? t.length : 0;\n          }\n          listeners(e) {\n            return this._listeners[e].map(e => e[0]) || [];\n          }\n          eventNames() {\n            return Object.keys(this._listeners);\n          }\n          removeAllListeners() {\n            return Object.keys(this._listeners).forEach(e => {\n              this._listeners[e].forEach(t => {\n                super.removeEventListener(e, t[1]);\n              });\n            }), this._listeners = {}, this;\n          }\n          setMaxListeners(e) {\n            return this.maxListeners = e, this;\n          }\n          getMaxListeners() {\n            return this.maxListeners;\n          }\n          addEventListener(e, t) {\n            const r = (e => t => e(t.detail))(t);\n            super.addEventListener(e, r), this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push([t, r]);\n          }\n          removeEventListener(e, t) {\n            const r = this._listeners[e];\n            if (r) {\n              const n = r.findIndex(e => e[0] === t);\n              -1 !== n && (super.removeEventListener(e, r[n][1]), r.splice(n, 1));\n            }\n          }\n        }\n        let s;\n        s = \"undefined\" == typeof window ? i.EventEmitter : o, t.EventEmitter = class extends s {};\n      },\n      3065: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.format = t.convert = t.convertScalarValue = t.isDataFormat = void 0;\n        const n = r(5071),\n          i = r(9970),\n          o = r(7345),\n          s = r(7086),\n          a = r(7151),\n          c = r(2557),\n          u = r(7541),\n          {\n            parseBaseType: d\n          } = o.utils;\n        t.isDataFormat = e => \"object\" == typeof e && !(0, o.isNullish)(e) && \"number\" in e && \"bytes\" in e;\n        const l = function l(e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n          let n,\n            i = Object.assign({}, e);\n          for (const e of t) {\n            if (i.oneOf && n) {\n              const e = r.find(function (e) {\n                return this === e[0];\n              }, null != n ? n : \"\");\n              e && e[0] === n && (i = i.oneOf[e[1]]);\n            }\n            if (!i.properties && !i.items) return;\n            if (i.properties) i = i.properties[e];else if (i.items && i.items.properties) {\n              const t = i.items.properties;\n              if (!t) return;\n              i = t[e];\n            } else i.items && (0, o.isObject)(i.items) ? i = i.items : i.items && Array.isArray(i.items) && (i = i.items[parseInt(e, 10)]);\n            i && e && (n = e);\n          }\n          return i;\n        };\n        t.convertScalarValue = (e, t, r) => {\n          try {\n            const {\n              baseType: o,\n              baseTypeSize: a\n            } = d(t);\n            if (\"int\" === o || \"uint\" === o) switch (r.number) {\n              case i.FMT_NUMBER.NUMBER:\n                return Number((0, s.toBigInt)(e));\n              case i.FMT_NUMBER.HEX:\n                return (0, s.numberToHex)((0, s.toBigInt)(e));\n              case i.FMT_NUMBER.STR:\n                return (0, s.toBigInt)(e).toString();\n              case i.FMT_NUMBER.BIGINT:\n                return (0, s.toBigInt)(e);\n              default:\n                throw new n.FormatterError(\"Invalid format: \".concat(String(r.number)));\n            }\n            if (\"bytes\" === o) {\n              let t;\n              switch (a ? \"string\" == typeof e ? t = (0, c.padLeft)(e, 2 * a) : e instanceof Uint8Array && (t = (0, u.uint8ArrayConcat)(new Uint8Array(a - e.length), e)) : t = e, r.bytes) {\n                case i.FMT_BYTES.HEX:\n                  return (0, s.bytesToHex)((0, s.bytesToUint8Array)(t));\n                case i.FMT_BYTES.UINT8ARRAY:\n                  return (0, s.bytesToUint8Array)(t);\n                default:\n                  throw new n.FormatterError(\"Invalid format: \".concat(String(r.bytes)));\n              }\n            }\n          } catch (t) {\n            return e;\n          }\n          return e;\n        }, t.convert = function (e, r, n, i) {\n          let s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n          var a, c;\n          if (!(0, o.isObject)(e) && !Array.isArray(e)) return (0, t.convertScalarValue)(e, null == r ? void 0 : r.format, i);\n          const u = e;\n          for (const [e, d] of Object.entries(u)) {\n            n.push(e);\n            const h = l(r, n, s);\n            if ((0, o.isNullish)(h)) delete u[e], n.pop();else if ((0, o.isObject)(d)) (0, t.convert)(d, r, n, i), n.pop();else {\n              if (Array.isArray(d)) {\n                let l = h;\n                if (void 0 !== (null == h ? void 0 : h.oneOf) && h.oneOf.forEach((t, r) => {\n                  var n, i;\n                  !Array.isArray(null == h ? void 0 : h.items) && (\"object\" == typeof d[0] && \"object\" === (null === (n = null == t ? void 0 : t.items) || void 0 === n ? void 0 : n.type) || \"string\" == typeof d[0] && \"object\" !== (null === (i = null == t ? void 0 : t.items) || void 0 === i ? void 0 : i.type)) && (l = t, s.push([e, r]));\n                }), (0, o.isNullish)(null == l ? void 0 : l.items)) {\n                  delete u[e], n.pop();\n                  continue;\n                }\n                if ((0, o.isObject)(l.items) && !(0, o.isNullish)(l.items.format)) {\n                  for (let r = 0; r < d.length; r += 1) u[e][r] = (0, t.convertScalarValue)(d[r], null === (a = null == l ? void 0 : l.items) || void 0 === a ? void 0 : a.format, i);\n                  n.pop();\n                  continue;\n                }\n                if (!Array.isArray(null == l ? void 0 : l.items) && \"object\" === (null === (c = null == l ? void 0 : l.items) || void 0 === c ? void 0 : c.type)) {\n                  for (const e of d) (0, t.convert)(e, r, n, i, s);\n                  n.pop();\n                  continue;\n                }\n                if (Array.isArray(null == l ? void 0 : l.items)) {\n                  for (let r = 0; r < d.length; r += 1) u[e][r] = (0, t.convertScalarValue)(d[r], l.items[r].format, i);\n                  n.pop();\n                  continue;\n                }\n              }\n              u[e] = (0, t.convertScalarValue)(d, h.format, i), n.pop();\n            }\n          }\n          return u;\n        }, t.format = (e, r, i) => {\n          let s;\n          s = (0, o.isObject)(r) ? (0, a.mergeDeep)({}, r) : Array.isArray(r) ? [...r] : r;\n          const c = (0, o.isObject)(e) ? e : o.utils.ethAbiToJsonSchema(e);\n          if (!c.properties && !c.items && !c.format) throw new n.FormatterError(\"Invalid json schema for formatting\");\n          return (0, t.convert)(s, c, [], i);\n        };\n      },\n      3561: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getStorageSlotNumForLongString = t.soliditySha3Raw = t.soliditySha3 = t.encodePacked = t.processSolidityEncodePackedArgs = t.keccak256 = t.keccak256Wrapper = t.sha3Raw = t.sha3 = void 0;\n        const n = r(3687),\n          i = r(5487),\n          o = r(5071),\n          s = r(7345),\n          a = r(7086),\n          c = r(2557),\n          u = \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n        t.sha3 = e => {\n          let t;\n          t = \"string\" == typeof e ? e.startsWith(\"0x\") && (0, s.isHexStrict)(e) ? (0, a.hexToBytes)(e) : (0, i.utf8ToBytes)(e) : e;\n          const r = (0, a.bytesToHex)((0, n.keccak256)(t));\n          return r === u ? void 0 : r;\n        }, t.sha3Raw = e => {\n          const r = (0, t.sha3)(e);\n          return (0, s.isNullish)(r) ? u : r;\n        }, t.keccak256Wrapper = e => {\n          let t;\n          return t = \"bigint\" == typeof e || \"number\" == typeof e ? (0, i.utf8ToBytes)(e.toString()) : Array.isArray(e) ? new Uint8Array(e) : \"string\" != typeof e || (0, s.isHexStrict)(e) ? (0, a.bytesToUint8Array)(e) : (0, i.utf8ToBytes)(e), (0, a.bytesToHex)((0, n.keccak256)(t));\n        }, t.keccak256 = t.keccak256Wrapper;\n        const d = (e, t) => {\n            const r = /^(\\d+).*$/.exec(e.slice(t));\n            return r ? parseInt(r[1], 10) : 0;\n          },\n          l = e => e.toString(2).length,\n          h = (e, t) => {\n            const r = t.toString();\n            if (\"string\" === e) {\n              if (\"string\" == typeof t) return (0, a.utf8ToHex)(t);\n              throw new o.InvalidStringError(t);\n            }\n            if (\"bool\" === e || \"boolean\" === e) {\n              if (\"boolean\" == typeof t) return t ? \"01\" : \"00\";\n              throw new o.InvalidBooleanError(t);\n            }\n            if (\"address\" === e) {\n              if (!(0, s.isAddress)(r)) throw new o.InvalidAddressError(r);\n              return r;\n            }\n            const n = (e => e.startsWith(\"int[\") ? \"int256\".concat(e.slice(3)) : \"int\" === e ? \"int256\" : e.startsWith(\"uint[\") ? \"uint256'\".concat(e.slice(4)) : \"uint\" === e ? \"uint256\" : e)(e);\n            if (e.startsWith(\"uint\")) {\n              const e = d(n, \"uint\".length);\n              if (e % 8 || e < 8 || e > 256) throw new o.InvalidSizeError(r);\n              const t = (0, a.toNumber)(r);\n              if (l(t) > e) throw new o.InvalidLargeValueError(r);\n              if (t < BigInt(0)) throw new o.InvalidUnsignedIntegerError(r);\n              return e ? (0, c.leftPad)(t.toString(16), e / 8 * 2) : t.toString(16);\n            }\n            if (e.startsWith(\"int\")) {\n              const t = d(n, \"int\".length);\n              if (t % 8 || t < 8 || t > 256) throw new o.InvalidSizeError(e);\n              const i = (0, a.toNumber)(r);\n              if (l(i) > t) throw new o.InvalidLargeValueError(r);\n              return i < BigInt(0) ? (0, c.toTwosComplement)(i.toString(), t / 8 * 2) : t ? (0, c.leftPad)(i.toString(16), t / 4) : i.toString(16);\n            }\n            if (\"bytes\" === n) {\n              if (r.replace(/^0x/i, \"\").length % 2 != 0) throw new o.InvalidBytesError(r);\n              return r;\n            }\n            if (e.startsWith(\"bytes\")) {\n              if (r.replace(/^0x/i, \"\").length % 2 != 0) throw new o.InvalidBytesError(r);\n              const t = d(e, \"bytes\".length);\n              if (!t || t < 1 || t > 64 || t < r.replace(/^0x/i, \"\").length / 2) throw new o.InvalidBytesError(r);\n              return (0, c.rightPad)(r, 2 * t);\n            }\n            return \"\";\n          };\n        t.processSolidityEncodePackedArgs = e => {\n          const [t, r] = (e => {\n            if (Array.isArray(e)) throw new Error(\"Autodetection of array types is not supported.\");\n            let t, r;\n            if (\"object\" == typeof e && (\"t\" in e || \"type\" in e) && (\"v\" in e || \"value\" in e)) t = \"t\" in e ? e.t : e.type, r = \"v\" in e ? e.v : e.value, t = \"bigint\" === t.toLowerCase() ? \"int\" : t;else {\n              if (\"bigint\" == typeof e) return [\"int\", e];\n              t = (0, a.toHex)(e, !0), r = (0, a.toHex)(e), t.startsWith(\"int\") || t.startsWith(\"uint\") || (t = \"bytes\");\n            }\n            return !t.startsWith(\"int\") && !t.startsWith(\"uint\") || \"string\" != typeof r || /^(-)?0x/i.test(r) || (r = (0, a.toBigInt)(r)), [t, r];\n          })(e);\n          return Array.isArray(r) ? r.map(e => h(t, e).replace(\"0x\", \"\")).join(\"\") : h(t, r).replace(\"0x\", \"\");\n        }, t.encodePacked = function () {\n          for (var _len16 = arguments.length, e = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n            e[_key16] = arguments[_key16];\n          }\n          return \"0x\".concat(Array.prototype.slice.call(e).map(t.processSolidityEncodePackedArgs).join(\"\").toLowerCase());\n        }, t.soliditySha3 = function () {\n          return (0, t.sha3)((0, t.encodePacked)(...arguments));\n        }, t.soliditySha3Raw = function () {\n          return (0, t.sha3Raw)((0, t.encodePacked)(...arguments));\n        }, t.getStorageSlotNumForLongString = e => (0, t.sha3)(\"0x\".concat((\"number\" == typeof e ? e.toString() : e).padStart(64, \"0\")));\n      },\n      9634: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          },\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.jsonRpc = void 0, o(r(7086), t), o(r(8512), t), o(r(4578), t), o(r(3065), t), o(r(3561), t), o(r(4822), t), o(r(2557), t), o(r(7151), t), o(r(3718), t), o(r(9250), t), t.jsonRpc = s(r(9250)), o(r(6982), t), o(r(4108), t), o(r(7717), t), o(r(997), t), o(r(222), t), o(r(7541), t);\n      },\n      9250: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBatchRequest = t.toBatchPayload = t.toPayload = t.setRequestIdStart = t.isBatchResponse = t.isValidResponse = t.validateResponse = t.isSubscriptionResult = t.isResponseWithNotification = t.isResponseWithError = t.isResponseWithResult = t.isResponseRpcError = void 0;\n        const n = r(7345),\n          i = r(5071),\n          o = r(7717);\n        let s;\n        t.isResponseRpcError = e => {\n          const t = e.error.code;\n          return i.rpcErrorsMap.has(t) || t >= -32099 && t <= -32e3;\n        }, t.isResponseWithResult = e => !Array.isArray(e) && !!e && \"2.0\" === e.jsonrpc && \"result\" in e && (0, n.isNullish)(e.error) && (\"number\" == typeof e.id || \"string\" == typeof e.id), t.isResponseWithError = e => !Array.isArray(e) && \"2.0\" === e.jsonrpc && !!e && (0, n.isNullish)(e.result) && \"error\" in e && (\"number\" == typeof e.id || \"string\" == typeof e.id), t.isResponseWithNotification = e => !(Array.isArray(e) || !e || \"2.0\" !== e.jsonrpc || (0, n.isNullish)(e.params) || (0, n.isNullish)(e.method)), t.isSubscriptionResult = e => !Array.isArray(e) && !!e && \"2.0\" === e.jsonrpc && \"id\" in e && \"result\" in e, t.validateResponse = e => (0, t.isResponseWithResult)(e) || (0, t.isResponseWithError)(e), t.isValidResponse = e => Array.isArray(e) ? e.every(t.validateResponse) : (0, t.validateResponse)(e), t.isBatchResponse = e => Array.isArray(e) && e.length > 0 && (0, t.isValidResponse)(e), t.setRequestIdStart = e => {\n          s = e;\n        }, t.toPayload = e => {\n          var t, r, n, i;\n          return void 0 !== s && (s += 1), {\n            jsonrpc: null !== (t = e.jsonrpc) && void 0 !== t ? t : \"2.0\",\n            id: null !== (n = null !== (r = e.id) && void 0 !== r ? r : s) && void 0 !== n ? n : (0, o.uuidV4)(),\n            method: e.method,\n            params: null !== (i = e.params) && void 0 !== i ? i : void 0\n          };\n        }, t.toBatchPayload = e => e.map(e => (0, t.toPayload)(e)), t.isBatchRequest = e => Array.isArray(e) && e.length > 0;\n      },\n      7151: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.mergeDeep = void 0;\n        const n = r(9970),\n          i = r(7345),\n          o = e => !(\"object\" != typeof e || (0, i.isNullish)(e) || Array.isArray(e) || e instanceof n.TypedArray);\n        t.mergeDeep = function (e) {\n          const s = e;\n          if (!o(s)) return s;\n          for (var _len17 = arguments.length, r = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n            r[_key17 - 1] = arguments[_key17];\n          }\n          for (const e of r) for (const r in e) o(e[r]) ? (s[r] || (s[r] = {}), (0, t.mergeDeep)(s[r], e[r])) : !(0, i.isNullish)(e[r]) && Object.hasOwnProperty.call(e, r) && (Array.isArray(e[r]) || e[r] instanceof n.TypedArray ? s[r] = e[r].slice(0) : s[r] = e[r]);\n          return s;\n        };\n      },\n      3718: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.rejectIfConditionAtInterval = t.rejectIfTimeout = t.pollTillDefined = t.pollTillDefinedAndReturnIntervalId = t.waitWithTimeout = t.isPromise = void 0;\n        const i = r(7345);\n        function o(e, t, r) {\n          return n(this, void 0, void 0, function* () {\n            let n;\n            const i = yield Promise.race([e instanceof Promise ? e : e(), new Promise((e, i) => {\n              n = setTimeout(() => r ? i(r) : e(void 0), t);\n            })]);\n            if (n && clearTimeout(n), i instanceof Error) throw i;\n            return i;\n          });\n        }\n        function s(e, t) {\n          let r;\n          return [new Promise((s, a) => {\n            r = setInterval(function c() {\n              return (() => {\n                n(this, void 0, void 0, function* () {\n                  try {\n                    const n = yield o(e, t);\n                    (0, i.isNullish)(n) || (clearInterval(r), s(n));\n                  } catch (e) {\n                    clearInterval(r), a(e);\n                  }\n                });\n              })(), c;\n            }(), t);\n          }), r];\n        }\n        t.isPromise = function (e) {\n          return (\"object\" == typeof e || \"function\" == typeof e) && \"function\" == typeof e.then;\n        }, t.waitWithTimeout = o, t.pollTillDefinedAndReturnIntervalId = s, t.pollTillDefined = function (e, t) {\n          return n(this, void 0, void 0, function* () {\n            return s(e, t)[0];\n          });\n        }, t.rejectIfTimeout = function (e, t) {\n          let r;\n          const n = new Promise((n, i) => {\n            r = setTimeout(() => {\n              i(t);\n            }, e);\n          });\n          return [r, n];\n        }, t.rejectIfConditionAtInterval = function (e, t) {\n          let r;\n          const i = new Promise((i, o) => {\n            r = setInterval(() => {\n              (() => {\n                n(this, void 0, void 0, function* () {\n                  const t = yield e();\n                  t && (clearInterval(r), o(t));\n                });\n              })();\n            }, t);\n          });\n          return [r, i];\n        };\n      },\n      4822: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.randomHex = t.randomBytes = void 0;\n        const n = r(1341),\n          i = r(7086);\n        t.randomBytes = e => (0, n.getRandomBytesSync)(e), t.randomHex = e => (0, i.bytesToHex)((0, t.randomBytes)(e));\n      },\n      222: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          },\n          s = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.SocketProvider = void 0;\n        const a = r(5071),\n          c = r(997),\n          u = r(4108),\n          d = r(4578),\n          l = r(6982),\n          h = o(r(9250)),\n          f = {\n            autoReconnect: !0,\n            delay: 5e3,\n            maxAttempts: 5\n          };\n        class p extends c.Eip1193Provider {\n          constructor(e, t, r) {\n            if (super(), this._connectionStatus = \"connecting\", this._onMessageHandler = this._onMessage.bind(this), this._onOpenHandler = this._onConnect.bind(this), this._onCloseHandler = this._onCloseEvent.bind(this), this._onErrorHandler = this._onError.bind(this), !this._validateProviderPath(e)) throw new a.InvalidClientError(e);\n            this._socketPath = e, this._socketOptions = t, this._reconnectOptions = Object.assign(Object.assign({}, f), null != r ? r : {}), this._pendingRequestsQueue = new Map(), this._sentRequestsQueue = new Map(), this._init(), this.connect(), this.chunkResponseParser = new u.ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect), this.chunkResponseParser.onError(() => {\n              this._clearQueues();\n            }), this.isReconnecting = !1;\n          }\n          get SocketConnection() {\n            return this._socketConnection;\n          }\n          _init() {\n            this._reconnectAttempts = 0;\n          }\n          connect() {\n            try {\n              this._openSocketConnection(), this._connectionStatus = \"connecting\", this._addSocketListeners();\n            } catch (e) {\n              if (!this.isReconnecting) throw this._connectionStatus = \"disconnected\", e && e.message ? new a.ConnectionError(\"Error while connecting to \".concat(this._socketPath, \". Reason: \").concat(e.message)) : new a.InvalidClientError(this._socketPath);\n              setImmediate(() => {\n                this._reconnect();\n              });\n            }\n          }\n          _validateProviderPath(e) {\n            return !!e;\n          }\n          supportsSubscriptions() {\n            return !0;\n          }\n          on(e, t) {\n            this._eventEmitter.on(e, t);\n          }\n          once(e, t) {\n            this._eventEmitter.once(e, t);\n          }\n          removeListener(e, t) {\n            this._eventEmitter.removeListener(e, t);\n          }\n          _onDisconnect(e, t) {\n            this._connectionStatus = \"disconnected\", super._onDisconnect(e, t);\n          }\n          disconnect(e, t) {\n            const r = null != e ? e : 1e3;\n            this._removeSocketListeners(), \"disconnected\" !== this.getStatus() && this._closeSocketConnection(r, t), this._onDisconnect(r, t);\n          }\n          removeAllListeners(e) {\n            this._eventEmitter.removeAllListeners(e);\n          }\n          _onError(e) {\n            this.isReconnecting ? this._reconnect() : this._eventEmitter.emit(\"error\", e);\n          }\n          reset() {\n            this._sentRequestsQueue.clear(), this._pendingRequestsQueue.clear(), this._init(), this._removeSocketListeners(), this._addSocketListeners();\n          }\n          _reconnect() {\n            this.isReconnecting || (this.isReconnecting = !0, this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach((e, t) => {\n              e.deferredPromise.reject(new a.PendingRequestsOnReconnectingError()), this._sentRequestsQueue.delete(t);\n            }), this._reconnectAttempts < this._reconnectOptions.maxAttempts ? (this._reconnectAttempts += 1, setTimeout(() => {\n              this._removeSocketListeners(), this.connect(), this.isReconnecting = !1;\n            }, this._reconnectOptions.delay)) : (this.isReconnecting = !1, this._clearQueues(), this._removeSocketListeners(), this._eventEmitter.emit(\"error\", new a.MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts))));\n          }\n          request(e) {\n            return s(this, void 0, void 0, function* () {\n              if ((0, d.isNullish)(this._socketConnection)) throw new Error(\"Connection is undefined\");\n              \"disconnected\" === this.getStatus() && this.connect();\n              const t = h.isBatchRequest(e) ? e[0].id : e.id;\n              if (!t) throw new a.Web3WSProviderError(\"Request Id not defined\");\n              if (this._sentRequestsQueue.has(t)) throw new a.RequestAlreadySentError(t);\n              const r = new l.Web3DeferredPromise();\n              r.catch(e => {\n                this._eventEmitter.emit(\"error\", e);\n              });\n              const n = {\n                payload: e,\n                deferredPromise: r\n              };\n              if (\"connecting\" === this.getStatus()) return this._pendingRequestsQueue.set(t, n), n.deferredPromise;\n              this._sentRequestsQueue.set(t, n);\n              try {\n                this._sendToSocket(n.payload);\n              } catch (e) {\n                this._sentRequestsQueue.delete(t), this._eventEmitter.emit(\"error\", e);\n              }\n              return r;\n            });\n          }\n          _onConnect() {\n            this._connectionStatus = \"connected\", this._reconnectAttempts = 0, super._onConnect(), this._sendPendingRequests();\n          }\n          _sendPendingRequests() {\n            for (const [e, t] of this._pendingRequestsQueue.entries()) this._sendToSocket(t.payload), this._pendingRequestsQueue.delete(e), this._sentRequestsQueue.set(e, t);\n          }\n          _onMessage(e) {\n            const t = this._parseResponses(e);\n            if (!(0, d.isNullish)(t) && 0 !== t.length) for (const e of t) {\n              if (h.isResponseWithNotification(e) && e.method.endsWith(\"_subscription\")) return void this._eventEmitter.emit(\"message\", e);\n              const t = h.isBatchResponse(e) ? e[0].id : e.id,\n                r = this._sentRequestsQueue.get(t);\n              if (!r) return;\n              (h.isBatchResponse(e) || h.isResponseWithResult(e) || h.isResponseWithError(e)) && (this._eventEmitter.emit(\"message\", e), r.deferredPromise.resolve(e)), this._sentRequestsQueue.delete(t);\n            }\n          }\n          _clearQueues(e) {\n            this._pendingRequestsQueue.size > 0 && this._pendingRequestsQueue.forEach((t, r) => {\n              t.deferredPromise.reject(new a.ConnectionNotOpenError(e)), this._pendingRequestsQueue.delete(r);\n            }), this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach((t, r) => {\n              t.deferredPromise.reject(new a.ConnectionNotOpenError(e)), this._sentRequestsQueue.delete(r);\n            }), this._removeSocketListeners();\n          }\n        }\n        t.SocketProvider = p;\n      },\n      2557: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.fromTwosComplement = t.toTwosComplement = t.leftPad = t.rightPad = t.padRight = t.padLeft = void 0;\n        const n = r(5071),\n          i = r(7345),\n          o = r(7086);\n        t.padLeft = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"0\";\n          return \"string\" == typeof e ? (0, i.isHexStrict)(e) ? i.utils.padLeft(e, t, r) : e.padStart(t, r) : (i.validator.validate([\"int\"], [e]), i.utils.padLeft(e, t, r));\n        }, t.padRight = function (e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"0\";\n          if (\"string\" == typeof e && !(0, i.isHexStrict)(e)) return e.padEnd(t, r);\n          i.validator.validate([\"int\"], [e]);\n          const n = \"string\" == typeof e && (0, i.isHexStrict)(e) ? e : (0, o.numberToHex)(e),\n            s = n.startsWith(\"-\") ? 3 : 2;\n          return n.padEnd(t + s, r);\n        }, t.rightPad = t.padRight, t.leftPad = t.padLeft, t.toTwosComplement = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n          i.validator.validate([\"int\"], [e]);\n          const s = (0, o.toNumber)(e);\n          if (s >= 0) return (0, t.padLeft)((0, o.toHex)(s), r);\n          const a = (0, i.bigintPower)(BigInt(2), BigInt(4 * r));\n          if (-s >= a) throw new n.NibbleWidthError(\"value: \".concat(e, \", nibbleWidth: \").concat(r));\n          const c = BigInt(s) + a;\n          return (0, t.padLeft)((0, o.numberToHex)(c), r);\n        }, t.fromTwosComplement = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n          i.validator.validate([\"int\"], [e]);\n          const r = (0, o.toNumber)(e);\n          if (r < 0) return r;\n          const s = Math.ceil(Math.log(Number(r)) / Math.log(2));\n          if (s > 4 * t) throw new n.NibbleWidthError(\"value: \\\"\".concat(e, \"\\\", nibbleWidth: \\\"\").concat(t, \"\\\"\"));\n          if (4 * t !== s) return r;\n          const a = (0, i.bigintPower)(BigInt(2), BigInt(t) * BigInt(4));\n          return (0, o.toNumber)(BigInt(r) - a);\n        };\n      },\n      7541: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.uint8ArrayEquals = t.uint8ArrayConcat = void 0, t.uint8ArrayConcat = function () {\n          for (var _len18 = arguments.length, e = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n            e[_key18] = arguments[_key18];\n          }\n          const t = e.reduce((e, t) => e + t.length, 0),\n            r = new Uint8Array(t);\n          let n = 0;\n          for (const t of e) r.set(t, n), n += t.length;\n          return r;\n        }, t.uint8ArrayEquals = function (e, t) {\n          if (e === t) return !0;\n          if (e.byteLength !== t.byteLength) return !1;\n          for (let r = 0; r < e.byteLength; r += 1) if (e[r] !== t[r]) return !1;\n          return !0;\n        };\n      },\n      7717: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.uuidV4 = void 0;\n        const n = r(7086),\n          i = r(4822);\n        t.uuidV4 = () => {\n          const e = (0, i.randomBytes)(16);\n          e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128;\n          const t = (0, n.bytesToHex)(e);\n          return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join(\"-\");\n        };\n      },\n      4578: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isNullish = t.compareBlockNumbers = t.isTopicInBloom = t.isTopic = t.isContractAddressInBloom = t.isUserEthereumAddressInBloom = t.isInBloom = t.isBloom = t.isAddress = t.checkAddressCheckSum = t.isHex = t.isHexStrict = void 0;\n        const n = r(5071),\n          i = r(7345),\n          o = r(9970);\n        t.isHexStrict = i.isHexStrict, t.isHex = i.isHex, t.checkAddressCheckSum = i.checkAddressCheckSum, t.isAddress = i.isAddress, t.isBloom = i.isBloom, t.isInBloom = i.isInBloom, t.isUserEthereumAddressInBloom = i.isUserEthereumAddressInBloom, t.isContractAddressInBloom = i.isContractAddressInBloom, t.isTopic = i.isTopic, t.isTopicInBloom = i.isTopicInBloom, t.compareBlockNumbers = (e, t) => {\n          const r = \"string\" == typeof e && (0, i.isBlockTag)(e),\n            s = \"string\" == typeof t && (0, i.isBlockTag)(t);\n          if (e === t || (\"earliest\" === e || 0 === e) && (\"earliest\" === t || 0 === t)) return 0;\n          if (\"earliest\" === e && t > 0) return -1;\n          if (\"earliest\" === t && e > 0) return 1;\n          if (r && s) {\n            const r = {\n              [o.BlockTags.EARLIEST]: 1,\n              [o.BlockTags.FINALIZED]: 2,\n              [o.BlockTags.SAFE]: 3,\n              [o.BlockTags.LATEST]: 4,\n              [o.BlockTags.PENDING]: 5\n            };\n            return r[e] < r[t] ? -1 : 1;\n          }\n          if (r && !s || !r && s) throw new n.InvalidBlockError(\"Cannot compare blocktag with provided non-blocktag input.\");\n          const a = BigInt(e),\n            c = BigInt(t);\n          return a < c ? -1 : a === c ? 0 : 1;\n        }, t.isNullish = i.isNullish;\n      },\n      6982: function _(e, t, r) {\n        \"use strict\";\n\n        var n,\n          i = this && this.__awaiter || function (e, t, r, n) {\n            return new (r || (r = Promise))(function (i, o) {\n              function s(e) {\n                try {\n                  c(n.next(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function a(e) {\n                try {\n                  c(n.throw(e));\n                } catch (e) {\n                  o(e);\n                }\n              }\n              function c(e) {\n                var t;\n                e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                  e(t);\n                })).then(s, a);\n              }\n              c((n = n.apply(e, t || [])).next());\n            });\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3DeferredPromise = void 0;\n        const o = r(5071);\n        t.Web3DeferredPromise = class {\n          constructor() {\n            let {\n              timeout: e,\n              eagerStart: t,\n              timeoutMessage: r\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n              timeout: 0,\n              eagerStart: !1,\n              timeoutMessage: \"DeferredPromise timed out\"\n            };\n            this[n] = \"Promise\", this._state = \"pending\", this._promise = new Promise((e, t) => {\n              this._resolve = e, this._reject = t;\n            }), this._timeoutMessage = r, this._timeoutInterval = e, t && this.startTimer();\n          }\n          get state() {\n            return this._state;\n          }\n          then(e, t) {\n            return i(this, void 0, void 0, function* () {\n              return this._promise.then(e, t);\n            });\n          }\n          catch(e) {\n            return i(this, void 0, void 0, function* () {\n              return this._promise.catch(e);\n            });\n          }\n          finally(e) {\n            return i(this, void 0, void 0, function* () {\n              return this._promise.finally(e);\n            });\n          }\n          resolve(e) {\n            this._resolve(e), this._state = \"fulfilled\", this._clearTimeout();\n          }\n          reject(e) {\n            this._reject(e), this._state = \"rejected\", this._clearTimeout();\n          }\n          startTimer() {\n            this._timeoutInterval && this._timeoutInterval > 0 && (this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval));\n          }\n          _checkTimeout() {\n            \"pending\" === this._state && this._timeoutId && this.reject(new o.OperationTimeoutError(this._timeoutMessage));\n          }\n          _clearTimeout() {\n            this._timeoutId && clearTimeout(this._timeoutId);\n          }\n        }, n = Symbol.toStringTag;\n      },\n      997: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__awaiter || function (e, t, r, n) {\n          return new (r || (r = Promise))(function (i, o) {\n            function s(e) {\n              try {\n                c(n.next(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function a(e) {\n              try {\n                c(n.throw(e));\n              } catch (e) {\n                o(e);\n              }\n            }\n            function c(e) {\n              var t;\n              e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function (e) {\n                e(t);\n              })).then(s, a);\n            }\n            c((n = n.apply(e, t || [])).next());\n          });\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Eip1193Provider = void 0;\n        const i = r(9970),\n          o = r(2699),\n          s = r(5071),\n          a = r(9250);\n        class c extends i.Web3BaseProvider {\n          constructor() {\n            super(...arguments), this._eventEmitter = new o.EventEmitter(), this._chainId = \"\", this._accounts = [];\n          }\n          _getChainId() {\n            var e;\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.request((0, a.toPayload)({\n                method: \"eth_chainId\",\n                params: []\n              }));\n              return null !== (e = null == t ? void 0 : t.result) && void 0 !== e ? e : \"\";\n            });\n          }\n          _getAccounts() {\n            var e;\n            return n(this, void 0, void 0, function* () {\n              const t = yield this.request((0, a.toPayload)({\n                method: \"eth_accounts\",\n                params: []\n              }));\n              return null !== (e = null == t ? void 0 : t.result) && void 0 !== e ? e : [];\n            });\n          }\n          _onConnect() {\n            Promise.all([this._getChainId().then(e => {\n              e !== this._chainId && (this._chainId = e, this._eventEmitter.emit(\"chainChanged\", this._chainId));\n            }).catch(e => {\n              console.error(e);\n            }), this._getAccounts().then(e => {\n              this._accounts.length === e.length && e.every(t => e.includes(t)) || (this._accounts = e, this._onAccountsChanged());\n            }).catch(e => {\n              console.error(e);\n            })]).then(() => this._eventEmitter.emit(\"connect\", {\n              chainId: this._chainId\n            })).catch(e => {\n              console.error(e);\n            });\n          }\n          _onDisconnect(e, t) {\n            this._eventEmitter.emit(\"disconnect\", new s.EIP1193ProviderRpcError(e, t));\n          }\n          _onAccountsChanged() {\n            this._eventEmitter.emit(\"accountsChanged\", this._accounts);\n          }\n        }\n        t.Eip1193Provider = c;\n      },\n      1438: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VALID_ETH_BASE_TYPES = void 0, t.VALID_ETH_BASE_TYPES = [\"bool\", \"int\", \"uint\", \"bytes\", \"string\", \"address\", \"tuple\"];\n      },\n      3637: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validator = void 0;\n        const n = r(7985);\n        t.validator = new n.Web3Validator();\n      },\n      356: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3ValidatorError = void 0;\n        const n = r(5071),\n          i = e => e.message ? e.message : \"unspecified error\";\n        class o extends n.BaseWeb3Error {\n          constructor(e) {\n            super(), this.code = n.ERR_VALIDATION, this.errors = e, super.message = \"Web3 validator found \".concat(e.length, \" error[s]:\\n\").concat(this._compileErrors().join(\"\\n\"));\n          }\n          _compileErrors() {\n            return this.errors.map(i);\n          }\n        }\n        t.Web3ValidatorError = o;\n      },\n      2677: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n        const n = r(2681),\n          i = r(6660),\n          o = r(5191),\n          s = r(4416),\n          a = r(3921),\n          c = r(5164),\n          u = r(7420),\n          d = r(6378),\n          l = {\n            address: e => (0, n.isAddress)(e),\n            bloom: e => (0, o.isBloom)(e),\n            blockNumber: e => (0, i.isBlockNumber)(e),\n            blockTag: e => (0, i.isBlockTag)(e),\n            blockNumberOrTag: e => (0, i.isBlockNumberOrTag)(e),\n            bool: e => (0, s.isBoolean)(e),\n            bytes: e => (0, a.isBytes)(e),\n            filter: e => (0, c.isFilterObject)(e),\n            hex: e => (0, u.isHexStrict)(e),\n            uint: e => (0, d.isUInt)(e),\n            int: e => (0, d.isInt)(e),\n            number: e => (0, d.isNumber)(e),\n            string: e => (0, u.isString)(e)\n          };\n        for (let e = 8; e <= 256; e += 8) l[\"int\".concat(e)] = t => (0, d.isInt)(t, {\n          bitSize: e\n        }), l[\"uint\".concat(e)] = t => (0, d.isUInt)(t, {\n          bitSize: e\n        });\n        for (let e = 1; e <= 32; e += 1) l[\"bytes\".concat(e)] = t => (0, a.isBytes)(t, {\n          size: e\n        });\n        l.bytes256 = l.bytes, t.default = l;\n      },\n      7345: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          },\n          s = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var r in e) \"default\" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);\n            return i(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.utils = void 0, o(r(7985), t), o(r(3637), t), o(r(5421), t), t.utils = s(r(8171)), o(r(356), t), o(r(1438), t), o(r(1851), t);\n      },\n      5421: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      8171: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.hexToUint8Array = t.uint8ArrayToHexString = t.padLeft = t.numberToHex = t.hexToNumber = t.codePointToInt = t.transformJsonDataToAbiFormat = t.fetchArrayElement = t.ethAbiToJsonSchema = t.abiSchemaToJsonSchema = t.parseBaseType = void 0;\n        const n = r(5071),\n          i = r(1438),\n          o = r(1283),\n          s = r(7420),\n          a = r(356),\n          c = [\"hex\", \"number\", \"blockNumber\", \"blockNumberOrTag\", \"filter\", \"bloom\"];\n        t.parseBaseType = e => {\n          let t,\n            r = e.replace(/ /, \"\"),\n            n = !1,\n            o = [];\n          if (e.includes(\"[\") && (r = r.slice(0, r.indexOf(\"[\")), o = [...e.matchAll(/(?:\\[(\\d*)\\])/g)].map(e => parseInt(e[1], 10)).map(e => Number.isNaN(e) ? -1 : e), n = o.length > 0), i.VALID_ETH_BASE_TYPES.includes(r)) return {\n            baseType: r,\n            isArray: n,\n            baseTypeSize: t,\n            arraySizes: o\n          };\n          if (r.startsWith(\"int\")) t = parseInt(r.substring(3), 10), r = \"int\";else if (r.startsWith(\"uint\")) t = parseInt(e.substring(4), 10), r = \"uint\";else {\n            if (!r.startsWith(\"bytes\")) return {\n              baseType: void 0,\n              isArray: !1,\n              baseTypeSize: void 0,\n              arraySizes: o\n            };\n            t = parseInt(r.substring(5), 10), r = \"bytes\";\n          }\n          return {\n            baseType: r,\n            isArray: n,\n            baseTypeSize: t,\n            arraySizes: o\n          };\n        };\n        const u = function u(e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          if (Object.keys(r).includes(\"type\")) throw new a.Web3ValidatorError([{\n            keyword: \"eth\",\n            message: 'Either \"eth\" or \"type\" can be presented in schema',\n            params: {\n              eth: e\n            },\n            instancePath: \"\",\n            schemaPath: \"\"\n          }]);\n          const {\n            baseType: n,\n            baseTypeSize: i\n          } = (0, t.parseBaseType)(e);\n          if (!n && !c.includes(e)) throw new a.Web3ValidatorError([{\n            keyword: \"eth\",\n            message: \"Eth data type \\\"\".concat(e, \"\\\" is not valid\"),\n            params: {\n              eth: e\n            },\n            instancePath: \"\",\n            schemaPath: \"\"\n          }]);\n          if (n) {\n            if (\"tuple\" === n) throw new Error('\"tuple\" type is not implemented directly.');\n            return {\n              format: \"\".concat(n).concat(null != i ? i : \"\"),\n              required: !0\n            };\n          }\n          return e ? {\n            format: e,\n            required: !0\n          } : {};\n        };\n        t.abiSchemaToJsonSchema = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"/0\";\n          const n = {\n            type: \"array\",\n            items: [],\n            maxItems: e.length,\n            minItems: e.length\n          };\n          for (const [i, s] of e.entries()) {\n            let e,\n              a,\n              c = [];\n            (0, o.isAbiParameterSchema)(s) ? (e = s.type, a = s.name, c = s.components) : \"string\" == typeof s ? (e = s, a = \"\".concat(r, \"/\").concat(i)) : Array.isArray(s) && (s[0] && \"string\" == typeof s[0] && s[0].startsWith(\"tuple\") && !Array.isArray(s[0]) && s[1] && Array.isArray(s[1]) ? (e = s[0], a = \"\".concat(r, \"/\").concat(i), c = s[1]) : (e = \"tuple\", a = \"\".concat(r, \"/\").concat(i), c = s));\n            const {\n              baseType: d,\n              isArray: l,\n              arraySizes: h\n            } = (0, t.parseBaseType)(e);\n            let f,\n              p = n;\n            for (let e = h.length - 1; e > 0; e -= 1) f = {\n              type: \"array\",\n              items: [],\n              maxItems: h[e],\n              minItems: h[e]\n            }, h[e] < 0 && (delete f.maxItems, delete f.minItems), Array.isArray(p.items) ? 0 === p.items.length ? p.items = f : p.items.push(f) : p.items = [p.items, f], p = f;\n            if (\"tuple\" !== d || l) {\n              if (\"tuple\" === d && l) {\n                const e = h[0],\n                  r = {\n                    $id: a,\n                    type: \"array\",\n                    items: (0, t.abiSchemaToJsonSchema)(c, a),\n                    maxItems: e,\n                    minItems: e\n                  };\n                e < 0 && (delete r.maxItems, delete r.minItems), p.items.push(r);\n              } else if (l) {\n                const e = h[0],\n                  t = {\n                    type: \"array\",\n                    $id: a,\n                    items: u(String(d)),\n                    minItems: e,\n                    maxItems: e\n                  };\n                e < 0 && (delete t.maxItems, delete t.minItems), p.items.push(t);\n              } else Array.isArray(p.items) ? p.items.push(Object.assign({\n                $id: a\n              }, u(e))) : p.items.items.push(Object.assign({\n                $id: a\n              }, u(e)));\n            } else {\n              const e = (0, t.abiSchemaToJsonSchema)(c, a);\n              e.$id = a, p.items.push(e);\n            }\n            p = n;\n          }\n          return n;\n        }, t.ethAbiToJsonSchema = e => (0, t.abiSchemaToJsonSchema)(e), t.fetchArrayElement = (e, r) => 1 === r ? e : (0, t.fetchArrayElement)(e[0], r - 1), t.transformJsonDataToAbiFormat = (e, r, n) => {\n          const i = [];\n          for (const [s, a] of e.entries()) {\n            let e,\n              c,\n              u = [];\n            (0, o.isAbiParameterSchema)(a) ? (e = a.type, c = a.name, u = a.components) : \"string\" == typeof a ? e = a : Array.isArray(a) && (a[1] && Array.isArray(a[1]) ? (e = a[0], u = a[1]) : (e = \"tuple\", u = a));\n            const {\n                baseType: d,\n                isArray: l,\n                arraySizes: h\n              } = (0, t.parseBaseType)(e),\n              f = Array.isArray(r) ? r[s] : r[c];\n            if (\"tuple\" !== d || l) {\n              if (\"tuple\" === d && l) {\n                const e = [];\n                for (const r of f) if (h.length > 1) {\n                  const i = (0, t.fetchArrayElement)(r, h.length - 1),\n                    o = [];\n                  for (const e of i) o.push((0, t.transformJsonDataToAbiFormat)(u, e, n));\n                  e.push(o);\n                } else e.push((0, t.transformJsonDataToAbiFormat)(u, r, n));\n                i.push(e);\n              } else i.push(f);\n            } else i.push((0, t.transformJsonDataToAbiFormat)(u, f, n));\n          }\n          return (n = null != n ? n : []).push(...i), n;\n        }, t.codePointToInt = e => {\n          if (e >= 48 && e <= 57) return e - 48;\n          if (e >= 65 && e <= 70) return e - 55;\n          if (e >= 97 && e <= 102) return e - 87;\n          throw new Error(\"Invalid code point: \".concat(e));\n        }, t.hexToNumber = e => {\n          if (!(0, s.isHexStrict)(e)) throw new Error(\"Invalid hex string\");\n          const [t, r] = e.startsWith(\"-\") ? [!0, e.slice(1)] : [!1, e],\n            n = BigInt(r);\n          return n > Number.MAX_SAFE_INTEGER ? t ? -n : n : n < Number.MIN_SAFE_INTEGER ? n : t ? -1 * Number(n) : Number(n);\n        }, t.numberToHex = e => {\n          if ((\"number\" == typeof e || \"bigint\" == typeof e) && e < 0) return \"-0x\".concat(e.toString(16).slice(1));\n          if ((\"number\" == typeof e || \"bigint\" == typeof e) && e >= 0) return \"0x\".concat(e.toString(16));\n          if (\"string\" == typeof e && (0, s.isHexStrict)(e)) {\n            const [t, r] = e.startsWith(\"-\") ? [!0, e.slice(1)] : [!1, e];\n            return \"\".concat(t ? \"-\" : \"\", \"0x\").concat(r.split(/^(-)?0(x|X)/).slice(-1)[0].replace(/^0+/, \"\").toLowerCase());\n          }\n          if (\"string\" == typeof e && !(0, s.isHexStrict)(e)) return (0, t.numberToHex)(BigInt(e));\n          throw new n.InvalidNumberError(e);\n        }, t.padLeft = function (e, r) {\n          let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"0\";\n          if (\"string\" == typeof e && !(0, s.isHexStrict)(e)) return e.padStart(r, n);\n          const i = \"string\" == typeof e && (0, s.isHexStrict)(e) ? e : (0, t.numberToHex)(e),\n            [o, a] = i.startsWith(\"-\") ? [\"-0x\", i.slice(3)] : [\"0x\", i.slice(2)];\n          return \"\".concat(o).concat(a.padStart(r, n));\n        }, t.uint8ArrayToHexString = function (e) {\n          let t = \"0x\";\n          for (const r of e) {\n            const e = r.toString(16);\n            t += 1 === e.length ? \"0\".concat(e) : e;\n          }\n          return t;\n        }, t.hexToUint8Array = function (e) {\n          let t;\n          if (t = e.toLowerCase().startsWith(\"0x\") ? e.slice(2) : e, t.length % 2 != 0) throw new n.InvalidBytesError(\"hex string has odd length: \".concat(e));\n          const r = new Uint8Array(Math.ceil(t.length / 2));\n          for (let e = 0; e < r.length; e += 1) {\n            const n = parseInt(t.substring(2 * e, 2 * e + 2), 16);\n            r[e] = n;\n          }\n          return r;\n        };\n      },\n      1283: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAbiParameterSchema = void 0, t.isAbiParameterSchema = e => \"object\" == typeof e && \"type\" in e && \"name\" in e;\n      },\n      2681: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isAddress = t.checkAddressCheckSum = void 0;\n        const n = r(4488),\n          i = r(7737),\n          o = r(8171),\n          s = r(7420);\n        t.checkAddressCheckSum = e => {\n          if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) return !1;\n          const t = e.slice(2),\n            r = (0, i.utf8ToBytes)(t.toLowerCase()),\n            s = (0, o.uint8ArrayToHexString)((0, n.keccak256)(r)).slice(2);\n          for (let e = 0; e < 40; e += 1) if (parseInt(s[e], 16) > 7 && t[e].toUpperCase() !== t[e] || parseInt(s[e], 16) <= 7 && t[e].toLowerCase() !== t[e]) return !1;\n          return !0;\n        }, t.isAddress = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          if (\"string\" != typeof e && !(e instanceof Uint8Array)) return !1;\n          let n;\n          return n = e instanceof Uint8Array ? (0, o.uint8ArrayToHexString)(e) : \"string\" != typeof e || (0, s.isHexStrict)(e) || e.toLowerCase().startsWith(\"0x\") ? e : \"0x\".concat(e), !!/^(0x)?[0-9a-f]{40}$/i.test(n) && (!(!/^(0x|0X)?[0-9a-f]{40}$/.test(n) && !/^(0x|0X)?[0-9A-F]{40}$/.test(n)) || !r || (0, t.checkAddressCheckSum)(n));\n        };\n      },\n      6660: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBlockNumberOrTag = t.isBlockTag = t.isBlockNumber = void 0;\n        const n = r(9970),\n          i = r(6378);\n        t.isBlockNumber = e => (0, i.isUInt)(e), t.isBlockTag = e => Object.values(n.BlockTags).includes(e), t.isBlockNumberOrTag = e => (0, t.isBlockTag)(e) || (0, t.isBlockNumber)(e);\n      },\n      5191: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isContractAddressInBloom = t.isUserEthereumAddressInBloom = t.isInBloom = t.isBloom = void 0;\n        const n = r(4488),\n          i = r(8171),\n          o = r(2681),\n          s = r(7420);\n        t.isBloom = e => !(\"string\" != typeof e || !/^(0x)?[0-9a-f]{512}$/i.test(e) || !/^(0x)?[0-9a-f]{512}$/.test(e) && !/^(0x)?[0-9A-F]{512}$/.test(e)), t.isInBloom = (e, r) => {\n          if (\"string\" == typeof r && !(0, s.isHexStrict)(r)) return !1;\n          if (!(0, t.isBloom)(e)) return !1;\n          const o = \"string\" == typeof r ? (0, i.hexToUint8Array)(r) : r,\n            a = (0, i.uint8ArrayToHexString)((0, n.keccak256)(o)).slice(2);\n          for (let t = 0; t < 12; t += 4) {\n            const r = (parseInt(a.slice(t, t + 2), 16) << 8) + parseInt(a.slice(t + 2, t + 4), 16) & 2047,\n              n = 1 << r % 4;\n            if (((0, i.codePointToInt)(e.charCodeAt(e.length - 1 - Math.floor(r / 4))) & n) !== n) return !1;\n          }\n          return !0;\n        }, t.isUserEthereumAddressInBloom = (e, r) => {\n          if (!(0, t.isBloom)(e)) return !1;\n          if (!(0, o.isAddress)(r)) return !1;\n          const n = (0, i.padLeft)(r, 64);\n          return (0, t.isInBloom)(e, n);\n        }, t.isContractAddressInBloom = (e, r) => !!(0, t.isBloom)(e) && !!(0, o.isAddress)(r) && (0, t.isInBloom)(e, r);\n      },\n      4416: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBoolean = void 0;\n        const n = r(7420);\n        t.isBoolean = e => !![\"number\", \"string\", \"boolean\"].includes(typeof e) && (\"boolean\" == typeof e || (\"string\" != typeof e || (0, n.isHexStrict)(e) ? \"string\" == typeof e && (0, n.isHexStrict)(e) ? \"0x1\" === e || \"0x0\" === e : 1 === e || 0 === e : \"1\" === e || \"0\" === e));\n      },\n      3921: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isBytes = t.isUint8Array = void 0;\n        const n = r(8171),\n          i = r(7420);\n        t.isUint8Array = e => e instanceof Uint8Array, t.isBytes = function (e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            abiType: \"bytes\"\n          };\n          if (!(\"string\" == typeof e || Array.isArray(e) || e instanceof Uint8Array)) return !1;\n          if (\"string\" == typeof e && (0, i.isHexStrict)(e) && e.startsWith(\"-\")) return !1;\n          if (\"string\" == typeof e && !(0, i.isHexStrict)(e)) return !1;\n          let r;\n          if (\"string\" == typeof e) {\n            if (e.length % 2 != 0) return !1;\n            r = (0, n.hexToUint8Array)(e);\n          } else if (Array.isArray(e)) {\n            if (e.some(e => e < 0 || e > 255 || !Number.isInteger(e))) return !1;\n            r = new Uint8Array(e);\n          } else r = e;\n          if (null == t ? void 0 : t.abiType) {\n            const {\n              baseTypeSize: e\n            } = (0, n.parseBaseType)(t.abiType);\n            return !e || r.length === e;\n          }\n          return !(null == t ? void 0 : t.size) || r.length === (null == t ? void 0 : t.size);\n        };\n      },\n      1478: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isValidEthBaseType = void 0;\n        const n = r(8171);\n        t.isValidEthBaseType = e => {\n          const {\n            baseType: t,\n            baseTypeSize: r\n          } = (0, n.parseBaseType)(e);\n          return !!t && (t === e || (\"int\" !== t && \"uint\" !== t || !r || r <= 256 && r % 8 == 0) && (\"bytes\" !== t || !r || r >= 1 && r <= 32));\n        };\n      },\n      5164: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isFilterObject = void 0;\n        const n = r(2681),\n          i = r(6660),\n          o = r(2102),\n          s = r(5702);\n        t.isFilterObject = e => {\n          const t = [\"fromBlock\", \"toBlock\", \"address\", \"topics\", \"blockHash\"];\n          if ((0, o.isNullish)(e) || \"object\" != typeof e) return !1;\n          if (!Object.keys(e).every(e => t.includes(e))) return !1;\n          if (!(0, o.isNullish)(e.fromBlock) && !(0, i.isBlockNumberOrTag)(e.fromBlock) || !(0, o.isNullish)(e.toBlock) && !(0, i.isBlockNumberOrTag)(e.toBlock)) return !1;\n          if (!(0, o.isNullish)(e.address)) if (Array.isArray(e.address)) {\n            if (!e.address.every(e => (0, n.isAddress)(e))) return !1;\n          } else if (!(0, n.isAddress)(e.address)) return !1;\n          return !(!(0, o.isNullish)(e.topics) && !e.topics.every(e => !!(0, o.isNullish)(e) || (Array.isArray(e) ? e.every(e => (0, s.isTopic)(e)) : !!(0, s.isTopic)(e))));\n        };\n      },\n      1851: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) {\n            void 0 === n && (n = r);\n            var i = Object.getOwnPropertyDescriptor(t, r);\n            i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function get() {\n                return t[r];\n              }\n            }), Object.defineProperty(e, n, i);\n          } : function (e, t, r, n) {\n            void 0 === n && (n = r), e[n] = t[r];\n          }),\n          i = this && this.__exportStar || function (e, t) {\n            for (var r in e) \"default\" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), i(r(2681), t), i(r(6660), t), i(r(5191), t), i(r(4416), t), i(r(3921), t), i(r(1478), t), i(r(5164), t), i(r(6378), t), i(r(7420), t), i(r(5702), t), i(r(2102), t);\n      },\n      6378: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isNumber = t.isInt = t.isUInt = t.bigintPower = t.isBigInt = void 0;\n        const n = r(8171),\n          i = r(7420);\n        t.isBigInt = e => \"bigint\" == typeof e, t.bigintPower = (e, t) => {\n          let r = e;\n          for (let n = 1; n < t; n += 1) r *= e;\n          return r;\n        }, t.isUInt = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            abiType: \"uint\"\n          };\n          if (![\"number\", \"string\", \"bigint\"].includes(typeof e) || \"string\" == typeof e && 0 === e.length) return !1;\n          let o;\n          if (null == r ? void 0 : r.abiType) {\n            const {\n              baseTypeSize: e\n            } = (0, n.parseBaseType)(r.abiType);\n            e && (o = e);\n          } else r.bitSize && (o = r.bitSize);\n          const s = (0, t.bigintPower)(BigInt(2), BigInt(null != o ? o : 256)) - BigInt(1);\n          try {\n            const t = \"string\" == typeof e && (0, i.isHexStrict)(e) ? BigInt((0, n.hexToNumber)(e)) : BigInt(e);\n            return t >= 0 && t <= s;\n          } catch (e) {\n            return !1;\n          }\n        }, t.isInt = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            abiType: \"int\"\n          };\n          if (![\"number\", \"string\", \"bigint\"].includes(typeof e)) return !1;\n          if (\"number\" == typeof e && e > Number.MAX_SAFE_INTEGER) return !1;\n          let o;\n          if (null == r ? void 0 : r.abiType) {\n            const {\n              baseTypeSize: e,\n              baseType: t\n            } = (0, n.parseBaseType)(r.abiType);\n            if (\"int\" !== t) return !1;\n            e && (o = e);\n          } else r.bitSize && (o = r.bitSize);\n          const s = (0, t.bigintPower)(BigInt(2), BigInt((null != o ? o : 256) - 1)),\n            a = BigInt(-1) * (0, t.bigintPower)(BigInt(2), BigInt((null != o ? o : 256) - 1));\n          try {\n            const t = \"string\" == typeof e && (0, i.isHexStrict)(e) ? BigInt((0, n.hexToNumber)(e)) : BigInt(e);\n            return t >= a && t <= s;\n          } catch (e) {\n            return !1;\n          }\n        }, t.isNumber = e => !!(0, t.isInt)(e) || !(\"string\" != typeof e || !/[0-9.]/.test(e) || e.indexOf(\".\") !== e.lastIndexOf(\".\")) || \"number\" == typeof e;\n      },\n      2102: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isObject = t.isNullish = void 0;\n        const n = r(9970);\n        t.isNullish = e => null == e, t.isObject = e => !(\"object\" != typeof e || (0, t.isNullish)(e) || Array.isArray(e) || e instanceof n.TypedArray);\n      },\n      7420: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.validateNoLeadingZeroes = t.isHexPrefixed = t.isHexString32Bytes = t.isHexString8Bytes = t.isHex = t.isHexString = t.isHexStrict = t.isString = void 0, t.isString = e => \"string\" == typeof e, t.isHexStrict = e => \"string\" == typeof e && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e), t.isHexString = function (e, t) {\n          return !(\"string\" != typeof e || !e.match(/^0x[0-9A-Fa-f]*$/) || void 0 !== t && t > 0 && e.length !== 2 + 2 * t);\n        }, t.isHex = e => \"number\" == typeof e || \"bigint\" == typeof e || \"string\" == typeof e && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e), t.isHexString8Bytes = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          return r ? (0, t.isHexStrict)(e) && 18 === e.length : (0, t.isHex)(e) && 16 === e.length;\n        }, t.isHexString32Bytes = function (e) {\n          let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n          return r ? (0, t.isHexStrict)(e) && 66 === e.length : (0, t.isHex)(e) && 64 === e.length;\n        }, t.isHexPrefixed = function (e) {\n          if (\"string\" != typeof e) throw new Error(\"[isHexPrefixed] input must be type 'string', received type \" + typeof e);\n          return e.startsWith(\"0x\");\n        }, t.validateNoLeadingZeroes = function (e) {\n          for (const [t, r] of Object.entries(e)) if (void 0 !== r && r.length > 0 && 0 === r[0]) throw new Error(\"\".concat(t, \" cannot have leading zeroes, received: \").concat(r.toString()));\n        };\n      },\n      5702: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isTopicInBloom = t.isTopic = void 0;\n        const n = r(5191);\n        t.isTopic = e => !(\"string\" != typeof e || !/^(0x)?[0-9a-f]{64}$/i.test(e) || !/^(0x)?[0-9a-f]{64}$/.test(e) && !/^(0x)?[0-9A-F]{64}$/.test(e)), t.isTopicInBloom = (e, r) => !!(0, n.isBloom)(e) && !!(0, t.isTopic)(r) && (0, n.isInBloom)(e, r);\n      },\n      1714: function _(e, t, r) {\n        \"use strict\";\n\n        var n = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Validator = void 0;\n        const i = r(5071),\n          o = r(6750),\n          s = r(356),\n          a = n(r(2677)),\n          c = e => {\n            if ((!(null == e ? void 0 : e.type) || \"object\" === (null == e ? void 0 : e.type)) && (null == e ? void 0 : e.properties)) {\n              const t = {};\n              for (const r of Object.keys(e.properties)) {\n                const n = c(e.properties[r]);\n                n && (t[r] = n);\n              }\n              return Array.isArray(e.required) ? o.z.object(t).partial().required(e.required.reduce((e, t) => Object.assign(Object.assign({}, e), {\n                [t]: !0\n              }), {})) : o.z.object(t).partial();\n            }\n            if (\"array\" === (null == e ? void 0 : e.type) && (null == e ? void 0 : e.items)) {\n              if (Array.isArray(e.items) && e.items.length > 0) {\n                const t = [];\n                for (const r of e.items) {\n                  const e = c(r);\n                  e && t.push(e);\n                }\n                return o.z.tuple(t);\n              }\n              return o.z.array(c(e.items));\n            }\n            if (e.oneOf && Array.isArray(e.oneOf)) return o.z.union(e.oneOf.map(e => c(e)));\n            if (null == e ? void 0 : e.format) {\n              if (!a.default[e.format]) throw new i.SchemaFormatError(e.format);\n              return o.z.any().refine(a.default[e.format], t => ({\n                params: {\n                  value: t,\n                  format: e.format\n                }\n              }));\n            }\n            return (null == e ? void 0 : e.type) && \"object\" !== (null == e ? void 0 : e.type) && \"function\" == typeof o.z[String(e.type)] ? o.z[String(e.type)]() : o.z.object({\n              data: o.z.any()\n            }).partial();\n          };\n        class u {\n          static factory() {\n            return u.validatorInstance || (u.validatorInstance = new u()), u.validatorInstance;\n          }\n          validate(e, t, r) {\n            var n, i;\n            const o = c(e).safeParse(t);\n            if (!o.success) {\n              const e = this.convertErrors(null !== (i = null === (n = o.error) || void 0 === n ? void 0 : n.issues) && void 0 !== i ? i : []);\n              if (e) {\n                if (null == r ? void 0 : r.silent) return e;\n                throw new s.Web3ValidatorError(e);\n              }\n            }\n          }\n          convertErrors(e) {\n            if (e && Array.isArray(e) && e.length > 0) return e.map(e => {\n              var t;\n              let r, n, i, s;\n              s = e.path.join(\"/\");\n              const a = String(e.path[e.path.length - 1]),\n                c = e.path.join(\"/\");\n              if (e.code === o.ZodIssueCode.too_big) n = \"maxItems\", s = \"\".concat(c, \"/maxItems\"), i = {\n                limit: e.maximum\n              }, r = \"must NOT have more than \".concat(e.maximum, \" items\");else if (e.code === o.ZodIssueCode.too_small) n = \"minItems\", s = \"\".concat(c, \"/minItems\"), i = {\n                limit: e.minimum\n              }, r = \"must NOT have fewer than \".concat(e.minimum, \" items\");else if (e.code === o.ZodIssueCode.custom) {\n                const {\n                  value: n,\n                  format: o\n                } = null !== (t = e.params) && void 0 !== t ? t : {};\n                r = void 0 === n ? \"value at \\\"/\".concat(s, \"\\\" is required\") : \"value \\\"\".concat(\"object\" == typeof n ? JSON.stringify(n) : n, \"\\\" at \\\"/\").concat(s, \"\\\" must pass \\\"\").concat(o, \"\\\" validation\"), i = {\n                  value: n\n                };\n              }\n              return {\n                keyword: null != n ? n : a,\n                instancePath: c ? \"/\".concat(c) : \"\",\n                schemaPath: s ? \"#\".concat(s) : \"#\",\n                params: null != i ? i : {\n                  value: e.message\n                },\n                message: null != r ? r : e.message\n              };\n            });\n          }\n        }\n        t.Validator = u;\n      },\n      7985: (e, t, r) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Web3Validator = void 0;\n        const n = r(1714),\n          i = r(8171),\n          o = r(356);\n        t.Web3Validator = class {\n          constructor() {\n            this._validator = n.Validator.factory();\n          }\n          validateJSONSchema(e, t, r) {\n            return this._validator.validate(e, t, r);\n          }\n          validate(e, t) {\n            let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n              silent: !1\n            };\n            var n, s;\n            const a = (0, i.ethAbiToJsonSchema)(e);\n            if (!Array.isArray(a.items) || 0 !== (null === (n = a.items) || void 0 === n ? void 0 : n.length) || 0 !== t.length) {\n              if (Array.isArray(a.items) && 0 === (null === (s = a.items) || void 0 === s ? void 0 : s.length) && 0 !== t.length) throw new o.Web3ValidatorError([{\n                instancePath: \"/0\",\n                schemaPath: \"/\",\n                keyword: \"required\",\n                message: \"empty schema against data can not be validated\",\n                params: t\n              }]);\n              return this._validator.validate(a, t, r);\n            }\n          }\n        };\n      },\n      3879: (e, t, r) => {\n        \"use strict\";\n\n        function n(e, t) {\n          var _e$exec;\n          return (_e$exec = e.exec(t)) === null || _e$exec === void 0 ? void 0 : _e$exec.groups;\n        }\n        r.r(t), r.d(t, {\n          BaseError: () => u,\n          narrow: () => d,\n          parseAbi: () => M,\n          parseAbiItem: () => D,\n          parseAbiParameter: () => L,\n          parseAbiParameters: () => F\n        });\n        var i = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,\n          o = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,\n          s = /^\\(.+?\\).*?$/,\n          a = Object.defineProperty,\n          c = (e, t, r) => (((e, t, r) => {\n            t in e ? a(e, t, {\n              enumerable: !0,\n              configurable: !0,\n              writable: !0,\n              value: r\n            }) : e[t] = r;\n          })(e, \"symbol\" != typeof t ? t + \"\" : t, r), r),\n          u = class extends Error {\n            constructor(e) {\n              var _t$cause;\n              let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n              const r = t.cause instanceof u ? t.cause.details : (_t$cause = t.cause) !== null && _t$cause !== void 0 && _t$cause.message ? t.cause.message : t.details,\n                n = t.cause instanceof u && t.cause.docsPath || t.docsPath;\n              super([e || \"An error occurred.\", \"\", ...(t.metaMessages ? [...t.metaMessages, \"\"] : []), ...(n ? [\"Docs: https://abitype.dev\".concat(n)] : []), ...(r ? [\"Details: \".concat(r)] : []), \"Version: abitype@0.7.1\"].join(\"\\n\")), c(this, \"details\"), c(this, \"docsPath\"), c(this, \"metaMessages\"), c(this, \"shortMessage\"), c(this, \"name\", \"AbiTypeError\"), t.cause && (this.cause = t.cause), this.details = r, this.docsPath = n, this.metaMessages = t.metaMessages, this.shortMessage = e;\n            }\n          };\n        function d(e) {\n          return e;\n        }\n        var l = /*#__PURE__*/_wrapRegExp(/^error ([a-zA-Z0-9_]+)\\((.*?)\\)$/, {\n            name: 1,\n            parameters: 2\n          }),\n          h = /*#__PURE__*/_wrapRegExp(/^event ([a-zA-Z0-9_]+)\\((.*?)\\)$/, {\n            name: 1,\n            parameters: 2\n          }),\n          f = /*#__PURE__*/_wrapRegExp(/^function ([a-zA-Z0-9_]+)\\((.*?)\\)(?: (external|public{1}))?(?: (pure|view|nonpayable|payable{1}))?(?: returns \\((.*?)\\))?$/, {\n            name: 1,\n            parameters: 2,\n            scope: 3,\n            stateMutability: 4,\n            returns: 5\n          }),\n          p = /*#__PURE__*/_wrapRegExp(/^struct ([a-zA-Z0-9_]+) \\{(.*?)\\}$/, {\n            name: 1,\n            properties: 2\n          });\n        function m(e) {\n          return p.test(e);\n        }\n        function g(e) {\n          return n(p, e);\n        }\n        var y = /*#__PURE__*/_wrapRegExp(/^constructor\\((.*?)\\)(?:\\s(payable{1}))?$/, {\n            parameters: 1,\n            stateMutability: 2\n          }),\n          v = /^fallback\\(\\)$/,\n          b = /^receive\\(\\) external payable$/,\n          E = new Set([\"memory\", \"indexed\", \"storage\", \"calldata\"]),\n          _ = new Set([\"indexed\"]),\n          A = new Set([\"calldata\", \"memory\", \"storage\"]),\n          T = new Map([[\"address\", {\n            type: \"address\"\n          }], [\"bool\", {\n            type: \"bool\"\n          }], [\"bytes\", {\n            type: \"bytes\"\n          }], [\"bytes32\", {\n            type: \"bytes32\"\n          }], [\"int\", {\n            type: \"int256\"\n          }], [\"int256\", {\n            type: \"int256\"\n          }], [\"string\", {\n            type: \"string\"\n          }], [\"uint\", {\n            type: \"uint256\"\n          }], [\"uint8\", {\n            type: \"uint8\"\n          }], [\"uint16\", {\n            type: \"uint16\"\n          }], [\"uint24\", {\n            type: \"uint24\"\n          }], [\"uint32\", {\n            type: \"uint32\"\n          }], [\"uint64\", {\n            type: \"uint64\"\n          }], [\"uint96\", {\n            type: \"uint96\"\n          }], [\"uint112\", {\n            type: \"uint112\"\n          }], [\"uint160\", {\n            type: \"uint160\"\n          }], [\"uint192\", {\n            type: \"uint192\"\n          }], [\"uint256\", {\n            type: \"uint256\"\n          }], [\"address owner\", {\n            type: \"address\",\n            name: \"owner\"\n          }], [\"address to\", {\n            type: \"address\",\n            name: \"to\"\n          }], [\"bool approved\", {\n            type: \"bool\",\n            name: \"approved\"\n          }], [\"bytes _data\", {\n            type: \"bytes\",\n            name: \"_data\"\n          }], [\"bytes data\", {\n            type: \"bytes\",\n            name: \"data\"\n          }], [\"bytes signature\", {\n            type: \"bytes\",\n            name: \"signature\"\n          }], [\"bytes32 hash\", {\n            type: \"bytes32\",\n            name: \"hash\"\n          }], [\"bytes32 r\", {\n            type: \"bytes32\",\n            name: \"r\"\n          }], [\"bytes32 root\", {\n            type: \"bytes32\",\n            name: \"root\"\n          }], [\"bytes32 s\", {\n            type: \"bytes32\",\n            name: \"s\"\n          }], [\"string name\", {\n            type: \"string\",\n            name: \"name\"\n          }], [\"string symbol\", {\n            type: \"string\",\n            name: \"symbol\"\n          }], [\"string tokenURI\", {\n            type: \"string\",\n            name: \"tokenURI\"\n          }], [\"uint tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\"\n          }], [\"uint8 v\", {\n            type: \"uint8\",\n            name: \"v\"\n          }], [\"uint256 balance\", {\n            type: \"uint256\",\n            name: \"balance\"\n          }], [\"uint256 tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\"\n          }], [\"uint256 value\", {\n            type: \"uint256\",\n            name: \"value\"\n          }], [\"event:address indexed from\", {\n            type: \"address\",\n            name: \"from\",\n            indexed: !0\n          }], [\"event:address indexed to\", {\n            type: \"address\",\n            name: \"to\",\n            indexed: !0\n          }], [\"event:uint indexed tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\",\n            indexed: !0\n          }], [\"event:uint256 indexed tokenId\", {\n            type: \"uint256\",\n            name: \"tokenId\",\n            indexed: !0\n          }]]);\n        function I(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          if (function (e) {\n            return f.test(e);\n          }(e)) {\n            var _r$stateMutability;\n            const r = function (e) {\n              return n(f, e);\n            }(e);\n            if (!r) throw new u(\"Invalid function signature.\", {\n              details: e\n            });\n            const i = S(r.parameters),\n              o = [],\n              s = i.length;\n            for (let e = 0; e < s; e++) o.push(x(i[e], {\n              modifiers: A,\n              structs: t,\n              type: \"function\"\n            }));\n            const a = [];\n            if (r.returns) {\n              const e = S(r.returns),\n                n = e.length;\n              for (let r = 0; r < n; r++) a.push(x(e[r], {\n                modifiers: A,\n                structs: t,\n                type: \"function\"\n              }));\n            }\n            return {\n              name: r.name,\n              type: \"function\",\n              stateMutability: (_r$stateMutability = r.stateMutability) !== null && _r$stateMutability !== void 0 ? _r$stateMutability : \"nonpayable\",\n              inputs: o,\n              outputs: a\n            };\n          }\n          if (function (e) {\n            return h.test(e);\n          }(e)) {\n            const r = function (e) {\n              return n(h, e);\n            }(e);\n            if (!r) throw new u(\"Invalid event signature.\", {\n              details: e\n            });\n            const i = S(r.parameters),\n              o = [],\n              s = i.length;\n            for (let e = 0; e < s; e++) o.push(x(i[e], {\n              modifiers: _,\n              structs: t,\n              type: \"event\"\n            }));\n            return {\n              name: r.name,\n              type: \"event\",\n              inputs: o\n            };\n          }\n          if (function (e) {\n            return l.test(e);\n          }(e)) {\n            const r = function (e) {\n              return n(l, e);\n            }(e);\n            if (!r) throw new u(\"Invalid error signature.\", {\n              details: e\n            });\n            const i = S(r.parameters),\n              o = [],\n              s = i.length;\n            for (let e = 0; e < s; e++) o.push(x(i[e], {\n              structs: t,\n              type: \"error\"\n            }));\n            return {\n              name: r.name,\n              type: \"error\",\n              inputs: o\n            };\n          }\n          if (function (e) {\n            return y.test(e);\n          }(e)) {\n            var _r$stateMutability2;\n            const r = function (e) {\n              return n(y, e);\n            }(e);\n            if (!r) throw new u(\"Invalid constructor signature.\", {\n              details: e\n            });\n            const i = S(r.parameters),\n              o = [],\n              s = i.length;\n            for (let e = 0; e < s; e++) o.push(x(i[e], {\n              structs: t,\n              type: \"constructor\"\n            }));\n            return {\n              type: \"constructor\",\n              stateMutability: (_r$stateMutability2 = r.stateMutability) !== null && _r$stateMutability2 !== void 0 ? _r$stateMutability2 : \"nonpayable\",\n              inputs: o\n            };\n          }\n          if (function (e) {\n            return v.test(e);\n          }(e)) return {\n            type: \"fallback\"\n          };\n          if (function (e) {\n            return b.test(e);\n          }(e)) return {\n            type: \"receive\",\n            stateMutability: \"payable\"\n          };\n          throw new u(\"Unknown signature.\", {\n            details: e\n          });\n        }\n        var R = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z0-9_]+?)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z0-9_]+))?$/, {\n            type: 1,\n            array: 2,\n            modifier: 3,\n            name: 4\n          }),\n          w = /*#__PURE__*/_wrapRegExp(/^\\((.+?)\\)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z0-9_]+))?$/, {\n            type: 1,\n            array: 2,\n            modifier: 3,\n            name: 4\n          }),\n          P = /^u?int$/;\n        function x(e, t) {\n          var _t$structs, _c$array;\n          const r = function (e, t) {\n            return t ? \"\".concat(t, \":\").concat(e) : e;\n          }(e, t === null || t === void 0 ? void 0 : t.type);\n          if (T.has(r)) return T.get(r);\n          const a = s.test(e),\n            c = n(a ? w : R, e);\n          if (!c) throw new u(\"Invalid ABI parameter.\", {\n            details: e\n          });\n          if (c.name && function (e) {\n            return \"address\" === e || \"bool\" === e || \"function\" === e || \"string\" === e || \"tuple\" === e || i.test(e) || o.test(e) || C.test(e);\n          }(c.name)) throw new u(\"Invalid ABI parameter.\", {\n            details: e,\n            metaMessages: [\"\\\"\".concat(c.name, \"\\\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html\")]\n          });\n          const d = c.name ? {\n              name: c.name\n            } : {},\n            l = \"indexed\" === c.modifier ? {\n              indexed: !0\n            } : {},\n            h = (_t$structs = t === null || t === void 0 ? void 0 : t.structs) !== null && _t$structs !== void 0 ? _t$structs : {};\n          let f,\n            p = {};\n          if (a) {\n            f = \"tuple\";\n            const e = S(c.type),\n              t = [],\n              r = e.length;\n            for (let n = 0; n < r; n++) t.push(x(e[n], {\n              structs: h\n            }));\n            p = {\n              components: t\n            };\n          } else if (c.type in h) f = \"tuple\", p = {\n            components: h[c.type]\n          };else if (P.test(c.type)) f = \"\".concat(c.type, \"256\");else if (f = c.type, \"struct\" !== (t === null || t === void 0 ? void 0 : t.type) && !O(f)) throw new u(\"Unknown type.\", {\n            metaMessages: [\"Type \\\"\".concat(f, \"\\\" is not a valid ABI type.\")]\n          });\n          if (c.modifier) {\n            var _t$modifiers, _t$modifiers$has;\n            if (!(t !== null && t !== void 0 && (_t$modifiers = t.modifiers) !== null && _t$modifiers !== void 0 && (_t$modifiers$has = _t$modifiers.has) !== null && _t$modifiers$has !== void 0 && _t$modifiers$has.call(_t$modifiers, c.modifier))) throw new u(\"Invalid ABI parameter.\", {\n              details: e,\n              metaMessages: [\"Modifier \\\"\".concat(c.modifier, \"\\\" not allowed\").concat(t !== null && t !== void 0 && t.type ? \" in \\\"\".concat(t.type, \"\\\" type\") : \"\", \".\")]\n            });\n            if (A.has(c.modifier) && !function (e, t) {\n              return t || \"bytes\" === e || \"string\" === e || \"tuple\" === e;\n            }(f, !!c.array)) throw new u(\"Invalid ABI parameter.\", {\n              details: e,\n              metaMessages: [\"Modifier \\\"\".concat(c.modifier, \"\\\" not allowed\").concat(t !== null && t !== void 0 && t.type ? \" in \\\"\".concat(t.type, \"\\\" type\") : \"\", \".\"), \"Data location can only be specified for array, struct, or mapping types, but \\\"\".concat(c.modifier, \"\\\" was given.\")]\n            });\n          }\n          const m = _objectSpread(_objectSpread(_objectSpread({\n            type: \"\".concat(f).concat((_c$array = c.array) !== null && _c$array !== void 0 ? _c$array : \"\")\n          }, d), l), p);\n          return T.set(r, m), m;\n        }\n        function S(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n          let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n          if (\"\" === e) {\n            if (\"\" === r) return t;\n            if (0 !== n) throw new u(\"Unbalanced parentheses.\", {\n              metaMessages: [\"\\\"\".concat(r.trim(), \"\\\" has too many \").concat(n > 0 ? \"opening\" : \"closing\", \" parentheses.\")],\n              details: \"Depth \\\"\".concat(n, \"\\\"\")\n            });\n            return [...t, r.trim()];\n          }\n          const i = e.length;\n          for (let o = 0; o < i; o++) {\n            const i = e[o],\n              s = e.slice(o + 1);\n            switch (i) {\n              case \",\":\n                return 0 === n ? S(s, [...t, r.trim()]) : S(s, t, \"\".concat(r).concat(i), n);\n              case \"(\":\n                return S(s, t, \"\".concat(r).concat(i), n + 1);\n              case \")\":\n                return S(s, t, \"\".concat(r).concat(i), n - 1);\n              default:\n                return S(s, t, \"\".concat(r).concat(i), n);\n            }\n          }\n          return [];\n        }\n        function O(e) {\n          return \"address\" === e || \"bool\" === e || \"function\" === e || \"string\" === e || i.test(e) || o.test(e);\n        }\n        var C = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n        function B(e) {\n          const t = {},\n            r = e.length;\n          for (let n = 0; n < r; n++) {\n            const r = e[n];\n            if (!m(r)) continue;\n            const i = g(r);\n            if (!i) throw new u(\"Invalid struct signature.\", {\n              details: r\n            });\n            const o = i.properties.split(\";\"),\n              s = [],\n              a = o.length;\n            for (let e = 0; e < a; e++) {\n              const t = o[e].trim();\n              if (!t) continue;\n              const r = x(t, {\n                type: \"struct\"\n              });\n              s.push(r);\n            }\n            if (!s.length) throw new u(\"Invalid struct signature.\", {\n              details: r,\n              metaMessages: [\"No properties exist.\"]\n            });\n            t[i.name] = s;\n          }\n          const n = {},\n            i = Object.entries(t),\n            o = i.length;\n          for (let e = 0; e < o; e++) {\n            const [r, o] = i[e];\n            n[r] = k(o, t);\n          }\n          return n;\n        }\n        var N = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z0-9_]+?)((?:\\[\\d*?\\])+?)?$/, {\n          type: 1,\n          array: 2\n        });\n        function k(e, t) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n          const i = [],\n            o = e.length;\n          for (let a = 0; a < o; a++) {\n            const o = e[a];\n            if (s.test(o.type)) i.push(o);else {\n              const e = n(N, o.type);\n              if (!(e !== null && e !== void 0 && e.type)) throw new u(\"Invalid ABI parameter.\", {\n                details: JSON.stringify(o, null, 2),\n                metaMessages: [\"ABI parameter type is invalid.\"]\n              });\n              const {\n                array: s,\n                type: a\n              } = e;\n              if (a in t) {\n                var _t$a;\n                if (r.has(a)) throw new u(\"Circular reference detected.\", {\n                  metaMessages: [\"Struct \\\"\".concat(a, \"\\\" is a circular reference.\")]\n                });\n                i.push(_objectSpread(_objectSpread({}, o), {}, {\n                  type: \"tuple\".concat(s !== null && s !== void 0 ? s : \"\"),\n                  components: k((_t$a = t[a]) !== null && _t$a !== void 0 ? _t$a : [], t, new Set([...r, a]))\n                }));\n              } else {\n                if (!O(a)) throw new u(\"Unknown type.\", {\n                  metaMessages: [\"Type \\\"\".concat(a, \"\\\" is not a valid ABI type. Perhaps you forgot to include a struct signature?\")]\n                });\n                i.push(o);\n              }\n            }\n          }\n          return i;\n        }\n        function M(e) {\n          const t = B(e),\n            r = [],\n            n = e.length;\n          for (let i = 0; i < n; i++) {\n            const n = e[i];\n            m(n) || r.push(I(n, t));\n          }\n          return r;\n        }\n        function D(e) {\n          let t;\n          if (\"string\" == typeof e) t = I(e);else {\n            const r = B(e),\n              n = e.length;\n            for (let i = 0; i < n; i++) {\n              const n = e[i];\n              if (!m(n)) {\n                t = I(n, r);\n                break;\n              }\n            }\n          }\n          if (!t) throw new u(\"Failed to parse ABI item.\", {\n            details: \"parseAbiItem(\".concat(JSON.stringify(e, null, 2), \")\"),\n            docsPath: \"/api/human.html#parseabiitem-1\"\n          });\n          return t;\n        }\n        function L(e) {\n          let t;\n          if (\"string\" == typeof e) t = x(e, {\n            modifiers: E\n          });else {\n            const r = B(e),\n              n = e.length;\n            for (let i = 0; i < n; i++) {\n              const n = e[i];\n              if (!m(n)) {\n                t = x(n, {\n                  modifiers: E,\n                  structs: r\n                });\n                break;\n              }\n            }\n          }\n          if (!t) throw new u(\"Failed to parse ABI parameter.\", {\n            details: \"parseAbiParameter(\".concat(JSON.stringify(e, null, 2), \")\"),\n            docsPath: \"/api/human.html#parseabiparameter-1\"\n          });\n          return t;\n        }\n        function F(e) {\n          const t = [];\n          if (\"string\" == typeof e) {\n            const r = S(e),\n              n = r.length;\n            for (let e = 0; e < n; e++) t.push(x(r[e], {\n              modifiers: E\n            }));\n          } else {\n            const r = B(e),\n              n = e.length;\n            for (let i = 0; i < n; i++) {\n              const n = e[i];\n              if (m(n)) continue;\n              const o = S(n),\n                s = o.length;\n              for (let e = 0; e < s; e++) t.push(x(o[e], {\n                modifiers: E,\n                structs: r\n              }));\n            }\n          }\n          if (0 === t.length) throw new u(\"Failed to parse ABI parameters.\", {\n            details: \"parseAbiParameters(\".concat(JSON.stringify(e, null, 2), \")\"),\n            docsPath: \"/api/human.html#parseabiparameters-1\"\n          });\n          return t;\n        }\n      }\n    },\n    t = {};\n  function r(n) {\n    var i = t[n];\n    if (void 0 !== i) return i.exports;\n    var o = t[n] = {\n      id: n,\n      loaded: !1,\n      exports: {}\n    };\n    return e[n].call(o.exports, o, o.exports, r), o.loaded = !0, o.exports;\n  }\n  r.d = (e, t) => {\n    for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {\n      enumerable: !0,\n      get: t[n]\n    });\n  }, r.g = function () {\n    if (\"object\" == typeof globalThis) return globalThis;\n    try {\n      return this || new Function(\"return this\")();\n    } catch (e) {\n      if (\"object\" == typeof window) return window;\n    }\n  }(), r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, r.nmd = e => (e.paths = [], e.children || (e.children = []), e);\n  var n = r(9375);\n  return n.default;\n})());","map":null,"metadata":{},"sourceType":"script"}