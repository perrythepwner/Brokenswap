{"ast":null,"code":"/**\n * ECIES encrypt/decrypt with Ethereum keys\n * A Typescript implementation of geth/crypto/ecies/ecies.go\n * Modified from https://github.com/LimelabsTech/eth-ecies/blob/master/index.js\n * At commit c858cbd021e9a99d8afa629de33c8c30d923b3e5.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ECIES = exports.Decrypt = exports.Encrypt = exports.AES128DecryptAndHMAC = exports.AES128Decrypt = exports.AES128EncryptAndHMAC = exports.AES128Encrypt = exports.IV_LENGTH = void 0;\nvar crypto_1 = require(\"crypto\");\nexports.IV_LENGTH = 16;\n/**\n * Increments big endian uint32\n *\n * @param {Buffer} ctr 32 bit unsigned big endian integer to increment.\n * @returns Incremented counter.\n */\nvar IncCounter = function IncCounter(ctr) {\n  for (var i = ctr.length - 1; i >= 0; i--) {\n    ctr[i]++;\n    if (ctr[i] !== 0) {\n      return ctr;\n    }\n  }\n  return ctr;\n};\n/**\n * NIST 8000-56C Rev 1 One Step KDF with the following parameters:\n * - H(x) is SHA-256(x)\n * - Fixed info is null\n *\n * TODO:\n * - Implement proper ceiling on reps.\n *\n * @param {Buffer} px Input keying material to derive key from.\n * @param {number} kdLen Length of output in bytes\n * @returns {Buffer} Output keying material of length kdLen bytes.\n */\nvar ConcatKDF = function ConcatKDF(px, kdLen) {\n  var blockSize = 32;\n  var reps = (kdLen + 7) * 8 / (blockSize * 8);\n  var counter = Buffer.from('00000001', 'hex');\n  var k = Buffer.from('00', 'hex');\n  for (var i = 0; i <= reps; i++) {\n    var hash = (0, crypto_1.createHash)('sha256');\n    hash.update(counter);\n    hash.update(px);\n    k = Buffer.concat([k, hash.digest()]);\n    counter = IncCounter(counter);\n  }\n  return k.slice(1, kdLen + 1);\n};\n/**\n * AES-128 CTR encrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128Encrypt(encryptionKey, iv, plaintext) {\n  var cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', encryptionKey, iv);\n  var firstChunk = cipher.update(plaintext);\n  var secondChunk = cipher.final();\n  return Buffer.concat([iv, firstChunk, secondChunk]);\n}\nexports.AES128Encrypt = AES128Encrypt;\n/**\n * AES-128 CTR encrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128EncryptAndHMAC(encryptionKey, macKey, plaintext) {\n  var iv = (0, crypto_1.randomBytes)(exports.IV_LENGTH);\n  var dataToMac = AES128Encrypt(encryptionKey, iv, plaintext);\n  var mac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n  return Buffer.concat([dataToMac, mac]);\n}\nexports.AES128EncryptAndHMAC = AES128EncryptAndHMAC;\n/**\n * AES-128 CTR decrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128Decrypt(encryptionKey, iv, ciphertext) {\n  var cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', encryptionKey, iv);\n  var firstChunk = cipher.update(ciphertext);\n  var secondChunk = cipher.final();\n  return Buffer.concat([firstChunk, secondChunk]);\n}\nexports.AES128Decrypt = AES128Decrypt;\n/**\n * AES-128 CTR decrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128DecryptAndHMAC(encryptionKey, macKey, ciphertext) {\n  var iv = ciphertext.slice(0, exports.IV_LENGTH);\n  var message = ciphertext.slice(exports.IV_LENGTH, ciphertext.length - 32);\n  var mac = ciphertext.slice(ciphertext.length - 32, ciphertext.length);\n  var dataToMac = Buffer.concat([iv, message]);\n  var computedMac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n  if (!mac.equals(computedMac)) {\n    throw new Error('MAC mismatch');\n  }\n  return AES128Decrypt(encryptionKey, iv, message);\n}\nexports.AES128DecryptAndHMAC = AES128DecryptAndHMAC;\n/**\n * ECIES encrypt\n * @param {Buffer} pubKeyTo Ethereum pub key, 64 bytes.\n * @param {Buffer} plaintext Plaintext to be encrypted.\n * @returns {Buffer} Encrypted message, serialized, 113+ bytes\n */\nfunction Encrypt(pubKeyTo, plaintext) {\n  // NOTE: elliptic is disabled elsewhere in this library to prevent\n  // accidental signing of truncated messages.\n  // tslint:disable-next-line:import-blacklist\n  var EC = require('elliptic').ec;\n  var ec = new EC('secp256k1');\n  var ephemPrivKey = ec.keyFromPrivate((0, crypto_1.randomBytes)(32));\n  var ephemPubKey = ephemPrivKey.getPublic(false, 'hex');\n  var ephemPubKeyEncoded = Buffer.from(ephemPubKey, 'hex');\n  var px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic());\n  var hash = ConcatKDF(px.toArrayLike(Buffer), 32);\n  var encryptionKey = hash.slice(0, 16);\n  var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n  var message = AES128EncryptAndHMAC(encryptionKey, macKey, plaintext);\n  var serializedCiphertext = Buffer.concat([ephemPubKeyEncoded, message // iv + ciphertext + mac (min 48 bytes)\n  ]);\n\n  return serializedCiphertext;\n}\nexports.Encrypt = Encrypt;\n/**\n * ECIES decrypt\n * @param {Buffer} privKey Ethereum private key, 32 bytes.\n * @param {Buffer} encrypted Encrypted message, serialized, 113+ bytes\n * @returns {Buffer} plaintext\n */\nfunction Decrypt(privKey, encrypted) {\n  // Read iv, ephemPubKey, mac, ciphertext from encrypted message\n  var ephemPubKeyEncoded = encrypted.slice(0, 65);\n  var symmetricEncrypted = encrypted.slice(65);\n  // NOTE: elliptic is disabled elsewhere in this library to prevent\n  // accidental signing of truncated messages.\n  // tslint:disable-next-line:import-blacklist\n  var EC = require('elliptic').ec;\n  var ec = new EC('secp256k1');\n  var ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();\n  var px = ec.keyFromPrivate(privKey).derive(ephemPubKey);\n  var hash = ConcatKDF(px.toBuffer(), 32);\n  // km, ke\n  var encryptionKey = hash.slice(0, 16);\n  var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n  return AES128DecryptAndHMAC(encryptionKey, macKey, symmetricEncrypted);\n}\nexports.Decrypt = Decrypt;\nexports.ECIES = {\n  Encrypt: Encrypt,\n  Decrypt: Decrypt,\n  AES128EncryptAndHMAC: AES128EncryptAndHMAC,\n  AES128DecryptAndHMAC: AES128DecryptAndHMAC\n};","map":{"version":3,"sources":["../src/ecies.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * ECIES encrypt/decrypt with Ethereum keys\n * A Typescript implementation of geth/crypto/ecies/ecies.go\n * Modified from https://github.com/LimelabsTech/eth-ecies/blob/master/index.js\n * At commit c858cbd021e9a99d8afa629de33c8c30d923b3e5.\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ECIES = exports.Decrypt = exports.Encrypt = exports.AES128DecryptAndHMAC = exports.AES128Decrypt = exports.AES128EncryptAndHMAC = exports.AES128Encrypt = exports.IV_LENGTH = void 0;\nvar crypto_1 = require(\"crypto\");\nexports.IV_LENGTH = 16;\n/**\n * Increments big endian uint32\n *\n * @param {Buffer} ctr 32 bit unsigned big endian integer to increment.\n * @returns Incremented counter.\n */\nvar IncCounter = function (ctr) {\n    for (var i = ctr.length - 1; i >= 0; i--) {\n        ctr[i]++;\n        if (ctr[i] !== 0) {\n            return ctr;\n        }\n    }\n    return ctr;\n};\n/**\n * NIST 8000-56C Rev 1 One Step KDF with the following parameters:\n * - H(x) is SHA-256(x)\n * - Fixed info is null\n *\n * TODO:\n * - Implement proper ceiling on reps.\n *\n * @param {Buffer} px Input keying material to derive key from.\n * @param {number} kdLen Length of output in bytes\n * @returns {Buffer} Output keying material of length kdLen bytes.\n */\nvar ConcatKDF = function (px, kdLen) {\n    var blockSize = 32;\n    var reps = ((kdLen + 7) * 8) / (blockSize * 8);\n    var counter = Buffer.from('00000001', 'hex');\n    var k = Buffer.from('00', 'hex');\n    for (var i = 0; i <= reps; i++) {\n        var hash = (0, crypto_1.createHash)('sha256');\n        hash.update(counter);\n        hash.update(px);\n        k = Buffer.concat([k, hash.digest()]);\n        counter = IncCounter(counter);\n    }\n    return k.slice(1, kdLen + 1);\n};\n/**\n * AES-128 CTR encrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128Encrypt(encryptionKey, iv, plaintext) {\n    var cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', encryptionKey, iv);\n    var firstChunk = cipher.update(plaintext);\n    var secondChunk = cipher.final();\n    return Buffer.concat([iv, firstChunk, secondChunk]);\n}\nexports.AES128Encrypt = AES128Encrypt;\n/**\n * AES-128 CTR encrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128EncryptAndHMAC(encryptionKey, macKey, plaintext) {\n    var iv = (0, crypto_1.randomBytes)(exports.IV_LENGTH);\n    var dataToMac = AES128Encrypt(encryptionKey, iv, plaintext);\n    var mac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n    return Buffer.concat([dataToMac, mac]);\n}\nexports.AES128EncryptAndHMAC = AES128EncryptAndHMAC;\n/**\n * AES-128 CTR decrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128Decrypt(encryptionKey, iv, ciphertext) {\n    var cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', encryptionKey, iv);\n    var firstChunk = cipher.update(ciphertext);\n    var secondChunk = cipher.final();\n    return Buffer.concat([firstChunk, secondChunk]);\n}\nexports.AES128Decrypt = AES128Decrypt;\n/**\n * AES-128 CTR decrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128DecryptAndHMAC(encryptionKey, macKey, ciphertext) {\n    var iv = ciphertext.slice(0, exports.IV_LENGTH);\n    var message = ciphertext.slice(exports.IV_LENGTH, ciphertext.length - 32);\n    var mac = ciphertext.slice(ciphertext.length - 32, ciphertext.length);\n    var dataToMac = Buffer.concat([iv, message]);\n    var computedMac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n    if (!mac.equals(computedMac)) {\n        throw new Error('MAC mismatch');\n    }\n    return AES128Decrypt(encryptionKey, iv, message);\n}\nexports.AES128DecryptAndHMAC = AES128DecryptAndHMAC;\n/**\n * ECIES encrypt\n * @param {Buffer} pubKeyTo Ethereum pub key, 64 bytes.\n * @param {Buffer} plaintext Plaintext to be encrypted.\n * @returns {Buffer} Encrypted message, serialized, 113+ bytes\n */\nfunction Encrypt(pubKeyTo, plaintext) {\n    // NOTE: elliptic is disabled elsewhere in this library to prevent\n    // accidental signing of truncated messages.\n    // tslint:disable-next-line:import-blacklist\n    var EC = require('elliptic').ec;\n    var ec = new EC('secp256k1');\n    var ephemPrivKey = ec.keyFromPrivate((0, crypto_1.randomBytes)(32));\n    var ephemPubKey = ephemPrivKey.getPublic(false, 'hex');\n    var ephemPubKeyEncoded = Buffer.from(ephemPubKey, 'hex');\n    var px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic());\n    var hash = ConcatKDF(px.toArrayLike(Buffer), 32);\n    var encryptionKey = hash.slice(0, 16);\n    var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n    var message = AES128EncryptAndHMAC(encryptionKey, macKey, plaintext);\n    var serializedCiphertext = Buffer.concat([\n        ephemPubKeyEncoded,\n        message, // iv + ciphertext + mac (min 48 bytes)\n    ]);\n    return serializedCiphertext;\n}\nexports.Encrypt = Encrypt;\n/**\n * ECIES decrypt\n * @param {Buffer} privKey Ethereum private key, 32 bytes.\n * @param {Buffer} encrypted Encrypted message, serialized, 113+ bytes\n * @returns {Buffer} plaintext\n */\nfunction Decrypt(privKey, encrypted) {\n    // Read iv, ephemPubKey, mac, ciphertext from encrypted message\n    var ephemPubKeyEncoded = encrypted.slice(0, 65);\n    var symmetricEncrypted = encrypted.slice(65);\n    // NOTE: elliptic is disabled elsewhere in this library to prevent\n    // accidental signing of truncated messages.\n    // tslint:disable-next-line:import-blacklist\n    var EC = require('elliptic').ec;\n    var ec = new EC('secp256k1');\n    var ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();\n    var px = ec.keyFromPrivate(privKey).derive(ephemPubKey);\n    var hash = ConcatKDF(px.toBuffer(), 32);\n    // km, ke\n    var encryptionKey = hash.slice(0, 16);\n    var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n    return AES128DecryptAndHMAC(encryptionKey, macKey, symmetricEncrypted);\n}\nexports.Decrypt = Decrypt;\nexports.ECIES = {\n    Encrypt: Encrypt,\n    Decrypt: Decrypt,\n    AES128EncryptAndHMAC: AES128EncryptAndHMAC,\n    AES128DecryptAndHMAC: AES128DecryptAndHMAC,\n};\n//# sourceMappingURL=ecies.js.map"]},"metadata":{},"sourceType":"script"}