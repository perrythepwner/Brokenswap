{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\nconst node_1 = require(\"../node\");\nconst tree_1 = require(\"../tree\");\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\nfunction createMultiProof(rootNode, gindices) {\n  const tree = new tree_1.Tree(rootNode);\n  const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map(gindex => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n  const leafGindices = gindices.slice().sort((a, b) => a < b ? 1 : -1);\n  const leaves = leafGindices.map(gindex => tree.getRoot(gindex));\n  const witnesses = witnessGindices.map(gindex => tree.getRoot(gindex));\n  return [leaves, witnesses, leafGindices];\n}\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n  var _leafBitstrings$0$len, _leafBitstrings$, _witnessBitstrings$0$, _witnessBitstrings$;\n  if (leaves.length !== gindices.length) {\n    throw new Error(\"Leaves length should equal gindices length\");\n  }\n  const leafBitstrings = gindices.map(gindex => gindex.toString(2));\n  const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n  if (witnessBitstrings.length !== witnesses.length) {\n    throw new Error(\"Witnesses length should equal witnesses gindices length\");\n  }\n  // Algorithm:\n  // create an object which tracks key-values for each level\n  // pre-load leaves and witnesses into the level object\n  // level by level, starting from the bottom,\n  // find the sibling, create the parent, store it in the next level up\n  // the root is in level 1\n  const maxLevel = Math.max((_leafBitstrings$0$len = (_leafBitstrings$ = leafBitstrings[0]) === null || _leafBitstrings$ === void 0 ? void 0 : _leafBitstrings$.length) !== null && _leafBitstrings$0$len !== void 0 ? _leafBitstrings$0$len : 0, (_witnessBitstrings$0$ = (_witnessBitstrings$ = witnessBitstrings[0]) === null || _witnessBitstrings$ === void 0 ? void 0 : _witnessBitstrings$.length) !== null && _witnessBitstrings$0$ !== void 0 ? _witnessBitstrings$0$ : 0);\n  const levels = Object.fromEntries(Array.from({\n    length: maxLevel\n  }, (_, i) => [i + 1, {}]));\n  // preload leaves and witnesses\n  for (let i = 0; i < leafBitstrings.length; i++) {\n    const leafBitstring = leafBitstrings[i];\n    const leaf = leaves[i];\n    levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n  }\n  for (let i = 0; i < witnessBitstrings.length; i++) {\n    const witnessBitstring = witnessBitstrings[i];\n    const witness = witnesses[i];\n    levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n  }\n  for (let i = maxLevel; i > 1; i--) {\n    const level = levels[i];\n    const parentLevel = levels[i - 1];\n    for (const bitstring of Object.keys(level)) {\n      const node = level[bitstring];\n      // if the node doesn't exist, we've already processed its sibling\n      if (!node) {\n        continue;\n      }\n      const isLeft = bitstring[bitstring.length - 1] === \"0\";\n      const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n      const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n      const siblingNode = level[siblingBitstring];\n      if (!siblingNode) {\n        throw new Error(\"Sibling not found: \".concat(siblingBitstring));\n      }\n      // store the parent node\n      const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n      parentLevel[parentBitstring] = parentNode;\n      // delete the used nodes\n      delete level[bitstring];\n      delete level[siblingBitstring];\n    }\n  }\n  const root = levels[1][\"1\"];\n  if (!root) {\n    throw new Error(\"Internal consistency error: no root found\");\n  }\n  return root;\n}\nexports.createNodeFromMultiProof = createNodeFromMultiProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","createNodeFromMultiProof","createMultiProof","node_1","require","tree_1","util_1","rootNode","gindices","tree","Tree","witnessGindices","computeMultiProofBitstrings","map","gindex","toString","SortOrder","Decreasing","leafGindices","slice","sort","a","b","leaves","getRoot","witnesses","_leafBitstrings$0$len","_leafBitstrings$","_witnessBitstrings$0$","_witnessBitstrings$","length","Error","leafBitstrings","witnessBitstrings","maxLevel","Math","max","levels","fromEntries","Array","from","_","i","leafBitstring","leaf","LeafNode","fromRoot","witnessBitstring","witness","level","parentLevel","bitstring","keys","node","isLeft","parentBitstring","substring","siblingBitstring","siblingNode","concat","parentNode","BranchNode","root"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\nconst node_1 = require(\"../node\");\nconst tree_1 = require(\"../tree\");\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\nfunction createMultiProof(rootNode, gindices) {\n    const tree = new tree_1.Tree(rootNode);\n    const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map((gindex) => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n    const leafGindices = gindices.slice().sort((a, b) => (a < b ? 1 : -1));\n    const leaves = leafGindices.map((gindex) => tree.getRoot(gindex));\n    const witnesses = witnessGindices.map((gindex) => tree.getRoot(gindex));\n    return [leaves, witnesses, leafGindices];\n}\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n    if (leaves.length !== gindices.length) {\n        throw new Error(\"Leaves length should equal gindices length\");\n    }\n    const leafBitstrings = gindices.map((gindex) => gindex.toString(2));\n    const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n    if (witnessBitstrings.length !== witnesses.length) {\n        throw new Error(\"Witnesses length should equal witnesses gindices length\");\n    }\n    // Algorithm:\n    // create an object which tracks key-values for each level\n    // pre-load leaves and witnesses into the level object\n    // level by level, starting from the bottom,\n    // find the sibling, create the parent, store it in the next level up\n    // the root is in level 1\n    const maxLevel = Math.max(leafBitstrings[0]?.length ?? 0, witnessBitstrings[0]?.length ?? 0);\n    const levels = Object.fromEntries(Array.from({ length: maxLevel }, (_, i) => [i + 1, {}]));\n    // preload leaves and witnesses\n    for (let i = 0; i < leafBitstrings.length; i++) {\n        const leafBitstring = leafBitstrings[i];\n        const leaf = leaves[i];\n        levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n    }\n    for (let i = 0; i < witnessBitstrings.length; i++) {\n        const witnessBitstring = witnessBitstrings[i];\n        const witness = witnesses[i];\n        levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n    }\n    for (let i = maxLevel; i > 1; i--) {\n        const level = levels[i];\n        const parentLevel = levels[i - 1];\n        for (const bitstring of Object.keys(level)) {\n            const node = level[bitstring];\n            // if the node doesn't exist, we've already processed its sibling\n            if (!node) {\n                continue;\n            }\n            const isLeft = bitstring[bitstring.length - 1] === \"0\";\n            const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n            const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n            const siblingNode = level[siblingBitstring];\n            if (!siblingNode) {\n                throw new Error(`Sibling not found: ${siblingBitstring}`);\n            }\n            // store the parent node\n            const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n            parentLevel[parentBitstring] = parentNode;\n            // delete the used nodes\n            delete level[bitstring];\n            delete level[siblingBitstring];\n        }\n    }\n    const root = levels[1][\"1\"];\n    if (!root) {\n        throw new Error(\"Internal consistency error: no root found\");\n    }\n    return root;\n}\nexports.createNodeFromMultiProof = createNodeFromMultiProof;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}