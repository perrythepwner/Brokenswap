{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$();\nimport { useCelo } from '@celo/react-celo';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { addTransaction } from './actions';\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder() {\n  _s();\n  const {\n    network,\n    address: account\n  } = useCelo();\n  const chainId = network.chainId;\n  const dispatch = useDispatch();\n  return useCallback(function (response) {\n    let {\n      summary,\n      approval,\n      claim\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!account) return;\n    if (!chainId) return;\n    const {\n      hash\n    } = response;\n    if (!hash) {\n      throw Error('No transaction hash found.');\n    }\n    dispatch(addTransaction({\n      hash,\n      from: account,\n      chainId,\n      approval,\n      summary,\n      claim\n    }));\n  }, [dispatch, chainId, account]);\n}\n\n// returns all the transactions for the current chain\n_s(useTransactionAdder, \"owgIce2DeughJcclDvuFwHjEB4w=\", false, function () {\n  return [useCelo, useDispatch];\n});\nexport function useAllTransactions() {\n  _s2();\n  var _state$chainId;\n  const {\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const state = useSelector(state => state.transactions);\n  return chainId ? (_state$chainId = state[chainId]) !== null && _state$chainId !== void 0 ? _state$chainId : {} : {};\n}\n_s2(useAllTransactions, \"sFq2Rf3VBlaqcVQX0cHNhyS2J2A=\", false, function () {\n  return [useCelo, useSelector];\n});\nexport function useIsTransactionPending(transactionHash) {\n  _s3();\n  const transactions = useAllTransactions();\n  if (!transactionHash || !transactions[transactionHash]) return false;\n  return !transactions[transactionHash].receipt;\n}\n\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\n_s3(useIsTransactionPending, \"hqz1TRfIl9I1+vK9TqtScGR9Kdg=\", false, function () {\n  return [useAllTransactions];\n});\nexport function isTransactionRecent(tx) {\n  return new Date().getTime() - tx.addedTime < 86400000;\n}\n\n// returns whether a token has a pending approval transaction\nexport function useHasPendingApproval(tokenAddress, spender) {\n  _s4();\n  const allTransactions = useAllTransactions();\n  return useMemo(() => typeof tokenAddress === 'string' && typeof spender === 'string' && Object.keys(allTransactions).some(hash => {\n    const tx = allTransactions[hash];\n    if (!tx) return false;\n    if (tx.receipt) {\n      return false;\n    } else {\n      const approval = tx.approval;\n      if (!approval) return false;\n      return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx);\n    }\n  }), [allTransactions, spender, tokenAddress]);\n}\n\n// watch for submissions to claim\n// return null if not done loading, return undefined if not found\n_s4(useHasPendingApproval, \"VezVe/KwFqNDaRAkqywKb3KU5lg=\", false, function () {\n  return [useAllTransactions];\n});\nexport function useUserHasSubmittedClaim(account) {\n  _s5();\n  const allTransactions = useAllTransactions();\n\n  // get the txn if it has been submitted\n  const claimTxn = useMemo(() => {\n    const txnIndex = Object.keys(allTransactions).find(hash => {\n      const tx = allTransactions[hash];\n      return tx.claim && tx.claim.recipient === account;\n    });\n    return txnIndex && allTransactions[txnIndex] ? allTransactions[txnIndex] : undefined;\n  }, [account, allTransactions]);\n  return {\n    claimSubmitted: Boolean(claimTxn),\n    claimTxn\n  };\n}\n_s5(useUserHasSubmittedClaim, \"VV0KKHrbuq348q6dk6Qn9MylTW8=\", false, function () {\n  return [useAllTransactions];\n});","map":{"version":3,"names":["useCelo","useCallback","useMemo","useDispatch","useSelector","addTransaction","useTransactionAdder","_s","network","address","account","chainId","dispatch","response","summary","approval","claim","arguments","length","undefined","hash","Error","from","useAllTransactions","_s2","_state$chainId","state","transactions","useIsTransactionPending","transactionHash","_s3","receipt","isTransactionRecent","tx","Date","getTime","addedTime","useHasPendingApproval","tokenAddress","spender","_s4","allTransactions","Object","keys","some","useUserHasSubmittedClaim","_s5","claimTxn","txnIndex","find","recipient","claimSubmitted","Boolean"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/transactions/hooks.tsx"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { ChainId } from '@ubeswap/sdk'\nimport { useCallback, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { AppDispatch, AppState } from '../index'\nimport { addTransaction } from './actions'\nimport { TransactionDetails } from './reducer'\n\n// helper that can take a ethers library transaction response and add it to the list of transactions\nexport function useTransactionAdder(): (\n  response: TransactionResponse,\n  customData?: { summary?: string; approval?: { tokenAddress: string; spender: string }; claim?: { recipient: string } }\n) => void {\n  const { network, address: account } = useCelo()\n  const chainId = network.chainId as unknown as ChainId\n  const dispatch = useDispatch<AppDispatch>()\n\n  return useCallback(\n    (\n      response: TransactionResponse,\n      {\n        summary,\n        approval,\n        claim,\n      }: { summary?: string; claim?: { recipient: string }; approval?: { tokenAddress: string; spender: string } } = {}\n    ) => {\n      if (!account) return\n      if (!chainId) return\n\n      const { hash } = response\n      if (!hash) {\n        throw Error('No transaction hash found.')\n      }\n      dispatch(addTransaction({ hash, from: account, chainId, approval, summary, claim }))\n    },\n    [dispatch, chainId, account]\n  )\n}\n\n// returns all the transactions for the current chain\nexport function useAllTransactions(): { [txHash: string]: TransactionDetails } {\n  const { network } = useCelo()\n  const chainId = network.chainId\n\n  const state = useSelector<AppState, AppState['transactions']>((state) => state.transactions)\n\n  return chainId ? state[chainId] ?? {} : {}\n}\n\nexport function useIsTransactionPending(transactionHash?: string): boolean {\n  const transactions = useAllTransactions()\n\n  if (!transactionHash || !transactions[transactionHash]) return false\n\n  return !transactions[transactionHash].receipt\n}\n\n/**\n * Returns whether a transaction happened in the last day (86400 seconds * 1000 milliseconds / second)\n * @param tx to check for recency\n */\nexport function isTransactionRecent(tx: TransactionDetails): boolean {\n  return new Date().getTime() - tx.addedTime < 86_400_000\n}\n\n// returns whether a token has a pending approval transaction\nexport function useHasPendingApproval(tokenAddress: string | undefined, spender: string | undefined): boolean {\n  const allTransactions = useAllTransactions()\n  return useMemo(\n    () =>\n      typeof tokenAddress === 'string' &&\n      typeof spender === 'string' &&\n      Object.keys(allTransactions).some((hash) => {\n        const tx = allTransactions[hash]\n        if (!tx) return false\n        if (tx.receipt) {\n          return false\n        } else {\n          const approval = tx.approval\n          if (!approval) return false\n          return approval.spender === spender && approval.tokenAddress === tokenAddress && isTransactionRecent(tx)\n        }\n      }),\n    [allTransactions, spender, tokenAddress]\n  )\n}\n\n// watch for submissions to claim\n// return null if not done loading, return undefined if not found\nexport function useUserHasSubmittedClaim(account?: string): {\n  claimSubmitted: boolean\n  claimTxn: TransactionDetails | undefined\n} {\n  const allTransactions = useAllTransactions()\n\n  // get the txn if it has been submitted\n  const claimTxn = useMemo(() => {\n    const txnIndex = Object.keys(allTransactions).find((hash) => {\n      const tx = allTransactions[hash]\n      return tx.claim && tx.claim.recipient === account\n    })\n    return txnIndex && allTransactions[txnIndex] ? allTransactions[txnIndex] : undefined\n  }, [account, allTransactions])\n\n  return { claimSubmitted: Boolean(claimTxn), claimTxn }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}