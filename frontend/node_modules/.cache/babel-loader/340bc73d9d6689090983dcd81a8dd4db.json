{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{JSBI,Token,TokenAmount}from'@ubeswap/sdk';import{UBE}from'constants/tokens';import{useMemo}from'react';import ERC20_INTERFACE from'../../constants/abis/erc20';import{useAllTokens}from'../../hooks/Tokens';import{isAddress}from'../../utils';import{useMultipleContractSingleData}from'../multicall/hooks';/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */export function useTokenBalancesWithLoadingIndicator(address,tokens){const validatedTokens=useMemo(()=>{var _tokens$filter;return(_tokens$filter=tokens===null||tokens===void 0?void 0:tokens.filter(t=>isAddress(t===null||t===void 0?void 0:t.address)!==false))!==null&&_tokens$filter!==void 0?_tokens$filter:[];},[tokens]);const validatedTokenAddresses=useMemo(()=>validatedTokens.map(vt=>vt.address),[validatedTokens]);const balances=useMultipleContractSingleData(validatedTokenAddresses,ERC20_INTERFACE,'balanceOf',[address]);const anyLoading=useMemo(()=>balances.some(callState=>callState.loading),[balances]);return[useMemo(()=>address&&validatedTokens.length>0?validatedTokens.reduce((memo,token,i)=>{var _balances$i,_balances$i$result;const value=balances===null||balances===void 0?void 0:(_balances$i=balances[i])===null||_balances$i===void 0?void 0:(_balances$i$result=_balances$i.result)===null||_balances$i$result===void 0?void 0:_balances$i$result[0];const amount=value?JSBI.BigInt(value.toString()):undefined;if(amount){memo[token.address]=new TokenAmount(token,amount);}return memo;},{}):{},[address,validatedTokens,balances]),anyLoading];}export function useTokenBalances(address,tokens){return useTokenBalancesWithLoadingIndicator(address,tokens)[0];}// get the balance for a single token/account combo\nexport function useTokenBalance(account,token){const tokenBalances=useTokenBalances(account,[token]);if(!token)return undefined;return tokenBalances[token.address];}export function useCurrencyBalances(account,currencies){const tokens=useMemo(()=>{var _currencies$filter;return(_currencies$filter=currencies===null||currencies===void 0?void 0:currencies.filter(currency=>currency instanceof Token))!==null&&_currencies$filter!==void 0?_currencies$filter:[];},[currencies]);const tokenBalances=useTokenBalances(account,tokens);return useMemo(()=>{var _currencies$map;return(_currencies$map=currencies===null||currencies===void 0?void 0:currencies.map(currency=>{if(!account||!currency)return undefined;if(currency instanceof Token)return tokenBalances[currency.address];return undefined;}))!==null&&_currencies$map!==void 0?_currencies$map:[];},[account,currencies,tokenBalances]);}export function useCurrencyBalance(account,currency){return useCurrencyBalances(account,[currency])[0];}// mimics useAllBalances\nexport function useAllTokenBalances(){const{address:account}=useCelo();const allTokens=useAllTokens();const allTokensArray=useMemo(()=>Object.values(allTokens!==null&&allTokens!==void 0?allTokens:{}),[allTokens]);const balances=useTokenBalances(account!==null&&account!==void 0?account:undefined,allTokensArray);return balances!==null&&balances!==void 0?balances:{};}// get the total owned, unclaimed, and unharvested UBE for account\nexport function useAggregateUbeBalance(){const{address,network:{chainId}}=useCelo();const ube=chainId?UBE[chainId]:undefined;const ubeBalance=useTokenBalance(address!==null&&address!==void 0?address:undefined,ube);if(!ube)return undefined;return ubeBalance;}","map":{"version":3,"names":["useCelo","JSBI","Token","TokenAmount","UBE","useMemo","ERC20_INTERFACE","useAllTokens","isAddress","useMultipleContractSingleData","useTokenBalancesWithLoadingIndicator","address","tokens","validatedTokens","_tokens$filter","filter","t","validatedTokenAddresses","map","vt","balances","anyLoading","some","callState","loading","length","reduce","memo","token","i","_balances$i","_balances$i$result","value","result","amount","BigInt","toString","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","_currencies$filter","currency","_currencies$map","useCurrencyBalance","useAllTokenBalances","allTokens","allTokensArray","Object","values","useAggregateUbeBalance","network","chainId","ube","ubeBalance"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/state/wallet/hooks.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { ChainId as UbeswapChainId, JSBI, Token, TokenAmount } from '@ubeswap/sdk'\nimport { UBE } from 'constants/tokens'\nimport { useMemo } from 'react'\n\nimport ERC20_INTERFACE from '../../constants/abis/erc20'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { isAddress } from '../../utils'\nimport { useMultipleContractSingleData } from '../multicall/hooks'\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: TokenAmount | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false) ?? [],\n    [tokens]\n  )\n\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map((vt) => vt.address), [validatedTokens])\n\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address])\n\n  const anyLoading: boolean = useMemo(() => balances.some((callState) => callState.loading), [balances])\n\n  return [\n    useMemo(\n      () =>\n        address && validatedTokens.length > 0\n          ? validatedTokens.reduce<{ [tokenAddress: string]: TokenAmount | undefined }>((memo, token, i) => {\n              const value = balances?.[i]?.result?.[0]\n              const amount = value ? JSBI.BigInt(value.toString()) : undefined\n              if (amount) {\n                memo[token.address] = new TokenAmount(token, amount)\n              }\n              return memo\n            }, {})\n          : {},\n      [address, validatedTokens, balances]\n    ),\n    anyLoading,\n  ]\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: TokenAmount | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): TokenAmount | undefined {\n  const tokenBalances = useTokenBalances(account, [token])\n  if (!token) return undefined\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(account?: string, currencies?: (Token | undefined)[]): (TokenAmount | undefined)[] {\n  const tokens = useMemo(\n    () => currencies?.filter((currency): currency is Token => currency instanceof Token) ?? [],\n    [currencies]\n  )\n\n  const tokenBalances = useTokenBalances(account, tokens)\n\n  return useMemo(\n    () =>\n      currencies?.map((currency) => {\n        if (!account || !currency) return undefined\n        if (currency instanceof Token) return tokenBalances[currency.address]\n        return undefined\n      }) ?? [],\n    [account, currencies, tokenBalances]\n  )\n}\n\nexport function useCurrencyBalance(account?: string, currency?: Token): TokenAmount | undefined {\n  return useCurrencyBalances(account, [currency])[0]\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): { [tokenAddress: string]: TokenAmount | undefined } {\n  const { address: account } = useCelo()\n  const allTokens = useAllTokens()\n  const allTokensArray = useMemo(() => Object.values(allTokens ?? {}), [allTokens])\n  const balances = useTokenBalances(account ?? undefined, allTokensArray)\n  return balances ?? {}\n}\n\n// get the total owned, unclaimed, and unharvested UBE for account\nexport function useAggregateUbeBalance(): TokenAmount | undefined {\n  const {\n    address,\n    network: { chainId },\n  } = useCelo()\n\n  const ube = chainId ? UBE[chainId as unknown as UbeswapChainId] : undefined\n\n  const ubeBalance: TokenAmount | undefined = useTokenBalance(address ?? undefined, ube)\n\n  if (!ube) return undefined\n\n  return ubeBalance\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}