{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitList: ordered variable-length collection of boolean values, limited to N bits\n * - Notation `Bitlist[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitListType extends bitArray_2.BitArrayType {\n  constructor(limitBits, opts) {\n    var _opts$typeName;\n    super();\n    this.limitBits = limitBits;\n    this.fixedSize = null;\n    this.minSize = 1; // +1 for the extra padding bit\n    this.isList = true;\n    if (limitBits === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"BitList[\".concat(limitBits, \"]\");\n    // TODO Check that itemsPerChunk is an integer\n    this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Depth includes the extra level for the length node\n    this.depth = 1 + this.chunkDepth;\n    this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);\n  }\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(0);\n  }\n  // Views: inherited from BitArrayType\n  // Serialization + deserialization\n  value_serializedSize(value) {\n    return bitLenToSerializedLength(value.bitLen);\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return applyPaddingBit(output.uint8Array, offset, value.bitLen);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    return new bitArray_1.BitArray(uint8Array, bitLen);\n  }\n  tree_serializedSize(node) {\n    return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n    const bitLen = arrayBasic_1.getLengthFromRootNode(node);\n    const byteLen = Math.ceil(bitLen / 8);\n    const chunkLen = Math.ceil(byteLen / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n    return applyPaddingBit(output.uint8Array, offset, bitLen);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);\n    return arrayBasic_1.addLengthNode(chunksNode, bitLen);\n  }\n  tree_getByteLen(node) {\n    if (!node) throw new Error(\"BitListType requires a node to get leaves\");\n    return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);\n  }\n  // Merkleization: inherited from BitArrayType\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);\n  }\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n  deserializeUint8ArrayBitListFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = deserializeUint8ArrayBitListFromBytes(data, start, end);\n    if (bitLen > this.limitBits) {\n      throw Error(\"bitLen over limit \".concat(bitLen, \" > \").concat(this.limitBits));\n    }\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n}\nexports.BitListType = BitListType;\nfunction deserializeUint8ArrayBitListFromBytes(data, start, end) {\n  if (end > data.length) {\n    throw Error(\"BitList attempting to read byte \".concat(end, \" of data length \").concat(data.length));\n  }\n  const lastByte = data[end - 1];\n  const size = end - start;\n  if (lastByte === 0) {\n    throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n  }\n  if (lastByte === 1) {\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);\n    const bitLen = (size - 1) * 8;\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n  // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n  // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n  const uint8Array = Uint8Array.prototype.slice.call(data, start, end);\n  // mask lastChunkByte\n  const lastByteBitLength = lastByte.toString(2).length - 1;\n  const bitLen = (size - 1) * 8 + lastByteBitLength;\n  const mask = 0xff >> 8 - lastByteBitLength;\n  uint8Array[size - 1] &= mask;\n  return {\n    uint8Array,\n    bitLen\n  };\n}\nfunction bitLenToSerializedLength(bitLen) {\n  const bytes = Math.ceil(bitLen / 8);\n  // +1 for the extra padding bit\n  return bitLen % 8 === 0 ? bytes + 1 : bytes;\n}\n/**\n * Apply padding bit to a serialized BitList already written to `output` at `offset`\n * @returns New offset after (maybe) writting a padding bit.\n */\nfunction applyPaddingBit(output, offset, bitLen) {\n  const byteLen = Math.ceil(bitLen / 8);\n  const newOffset = offset + byteLen;\n  if (bitLen % 8 === 0) {\n    output[newOffset] = 1;\n    return newOffset + 1;\n  } else {\n    output[newOffset - 1] |= 1 << bitLen % 8;\n    return newOffset;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}