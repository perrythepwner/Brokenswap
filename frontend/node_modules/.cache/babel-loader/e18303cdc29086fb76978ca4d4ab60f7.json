{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$();\nimport { useCelo } from '@celo/react-celo';\nimport { Trade } from '@ubeswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\nimport { isTradeBetter } from 'utils/trades';\nimport { BASES_TO_CHECK_TRADES_AGAINST, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../../../../constants';\nimport { PairState, usePairs } from '../../../../data/Reserves';\nimport { UbeswapTrade } from '../trade';\nfunction useAllCommonPairs(tokenA, tokenB) {\n  _s();\n  const {\n    network\n  } = useCelo();\n  const chainId = network.chainId;\n  const bases = useMemo(() => {\n    var _BASES_TO_CHECK_TRADE;\n    if (!chainId) return [];\n    const common = (_BASES_TO_CHECK_TRADE = BASES_TO_CHECK_TRADES_AGAINST[chainId]) !== null && _BASES_TO_CHECK_TRADE !== void 0 ? _BASES_TO_CHECK_TRADE : [];\n    return [...common];\n  }, [chainId]);\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])), [bases]);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [\n  // the direct pair\n  [tokenA, tokenB],\n  // token A against all bases\n  ...bases.map(base => [tokenA, base]),\n  // token B against all bases\n  ...bases.map(base => [tokenB, base]),\n  // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(_ref => {\n    let [t0, t1] = _ref;\n    return t0.address !== t1.address;\n  }) : [], [tokenA, tokenB, bases, basePairs]);\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(() => Object.values(allPairs\n  // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1]))\n  // filter out duplicated pairs\n  .reduce((memo, _ref2) => {\n    var _memo$curr$liquidityT;\n    let [, curr] = _ref2;\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n_s(useAllCommonPairs, \"hYPmqRm2Yc1h/PAM5L4mH2926qc=\", false, function () {\n  return [useCelo, usePairs];\n});\nconst MAX_HOPS = 3;\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useDirectTradeExactIn(currencyAmountIn, currencyOut) {\n  _s2();\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n        const bestTrade = (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n        return bestTrade ? UbeswapTrade.fromNormalTrade(bestTrade) : null;\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n        const currentTradeRaw = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n        const currentTrade = currentTradeRaw ? UbeswapTrade.fromNormalTrade(currentTradeRaw) : null;\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n_s2(useDirectTradeExactIn, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});\nexport function useDirectTradeExactOut(currencyIn, currencyAmountOut) {\n  _s3();\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n        const bestTrade = (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n        return bestTrade ? UbeswapTrade.fromNormalTrade(bestTrade) : null;\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n        const currentTradeRaw = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n        const currentTrade = currentTradeRaw ? UbeswapTrade.fromNormalTrade(currentTradeRaw) : null;\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\n_s3(useDirectTradeExactOut, \"ejonW4DBGFPCcnOf1J4aIemB/2E=\", false, function () {\n  return [useAllCommonPairs, useUserSingleHopOnly];\n});","map":{"version":3,"names":["useCelo","Trade","flatMap","useMemo","useUserSingleHopOnly","isTradeBetter","BASES_TO_CHECK_TRADES_AGAINST","BETTER_TRADE_LESS_HOPS_THRESHOLD","PairState","usePairs","UbeswapTrade","useAllCommonPairs","tokenA","tokenB","_s","network","chainId","bases","_BASES_TO_CHECK_TRADE","common","basePairs","base","map","otherBase","allPairCombinations","filter","tokens","Boolean","_ref","t0","t1","address","allPairs","Object","values","result","EXISTS","reduce","memo","_ref2","_memo$curr$liquidityT","curr","liquidityToken","MAX_HOPS","useDirectTradeExactIn","currencyAmountIn","currencyOut","_s2","allowedPairs","currency","singleHopOnly","length","_Trade$bestTradeExact","bestTrade","bestTradeExactIn","maxHops","maxNumResults","fromNormalTrade","bestTradeSoFar","i","_Trade$bestTradeExact2","currentTradeRaw","currentTrade","useDirectTradeExactOut","currencyIn","currencyAmountOut","_s3","_Trade$bestTradeExact3","bestTradeExactOut","_Trade$bestTradeExact4"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/components/swap/routing/hooks/directTrades.ts"],"sourcesContent":["import { useCelo } from '@celo/react-celo'\nimport { Pair, Token, TokenAmount, Trade } from '@ubeswap/sdk'\nimport flatMap from 'lodash.flatmap'\nimport { useMemo } from 'react'\nimport { useUserSingleHopOnly } from 'state/user/hooks'\nimport { isTradeBetter } from 'utils/trades'\n\nimport { BASES_TO_CHECK_TRADES_AGAINST, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../../../../constants'\nimport { PairState, usePairs } from '../../../../data/Reserves'\nimport { UbeswapTrade } from '../trade'\n\nfunction useAllCommonPairs(tokenA?: Token, tokenB?: Token): Pair[] {\n  const { network } = useCelo()\n  const chainId = network.chainId\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId) return []\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    return [...common]\n  }, [chainId])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () => flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])),\n    [bases]\n  )\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n        : [],\n    [tokenA, tokenB, bases, basePairs]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\nconst MAX_HOPS = 3\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useDirectTradeExactIn(currencyAmountIn?: TokenAmount, currencyOut?: Token): UbeswapTrade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        const bestTrade =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        return bestTrade ? UbeswapTrade.fromNormalTrade(bestTrade) : null\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: UbeswapTrade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTradeRaw: Trade | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        const currentTrade: UbeswapTrade | null = currentTradeRaw ? UbeswapTrade.fromNormalTrade(currentTradeRaw) : null\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useDirectTradeExactOut(currencyIn?: Token, currencyAmountOut?: TokenAmount): UbeswapTrade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        const bestTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        return bestTrade ? UbeswapTrade.fromNormalTrade(bestTrade) : null\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: UbeswapTrade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTradeRaw =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        const currentTrade = currentTradeRaw ? UbeswapTrade.fromNormalTrade(currentTradeRaw) : null\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n    return null\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}