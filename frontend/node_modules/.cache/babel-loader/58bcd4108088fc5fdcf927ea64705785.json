{"ast":null,"code":"import{useCelo}from'@celo/react-celo';import{Trade}from'@ubeswap/sdk';import flatMap from'lodash.flatmap';import{useMemo}from'react';import{useUserSingleHopOnly}from'state/user/hooks';import{isTradeBetter}from'utils/trades';import{BASES_TO_CHECK_TRADES_AGAINST,BETTER_TRADE_LESS_HOPS_THRESHOLD}from'../../../../constants';import{PairState,usePairs}from'../../../../data/Reserves';import{UbeswapTrade}from'../trade';function useAllCommonPairs(tokenA,tokenB){const{network}=useCelo();const chainId=network.chainId;const bases=useMemo(()=>{var _BASES_TO_CHECK_TRADE;if(!chainId)return[];const common=(_BASES_TO_CHECK_TRADE=BASES_TO_CHECK_TRADES_AGAINST[chainId])!==null&&_BASES_TO_CHECK_TRADE!==void 0?_BASES_TO_CHECK_TRADE:[];return[...common];},[chainId]);const basePairs=useMemo(()=>flatMap(bases,base=>bases.map(otherBase=>[base,otherBase])),[bases]);const allPairCombinations=useMemo(()=>tokenA&&tokenB?[// the direct pair\n[tokenA,tokenB],// token A against all bases\n...bases.map(base=>[tokenA,base]),// token B against all bases\n...bases.map(base=>[tokenB,base]),// each base against all bases\n...basePairs].filter(tokens=>Boolean(tokens[0]&&tokens[1])).filter(_ref=>{let[t0,t1]=_ref;return t0.address!==t1.address;}):[],[tokenA,tokenB,bases,basePairs]);const allPairs=usePairs(allPairCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(()=>Object.values(allPairs// filter out invalid pairs\n.filter(result=>Boolean(result[0]===PairState.EXISTS&&result[1]))// filter out duplicated pairs\n.reduce((memo,_ref2)=>{var _memo$curr$liquidityT;let[,curr]=_ref2;memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{})),[allPairs]);}const MAX_HOPS=3;/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useDirectTradeExactIn(currencyAmountIn,currencyOut){const allowedPairs=useAllCommonPairs(currencyAmountIn===null||currencyAmountIn===void 0?void 0:currencyAmountIn.currency,currencyOut);const[singleHopOnly]=useUserSingleHopOnly();return useMemo(()=>{if(currencyAmountIn&&currencyOut&&allowedPairs.length>0){if(singleHopOnly){var _Trade$bestTradeExact;const bestTrade=(_Trade$bestTradeExact=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact!==void 0?_Trade$bestTradeExact:null;return bestTrade?UbeswapTrade.fromNormalTrade(bestTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){var _Trade$bestTradeExact2;const currentTradeRaw=(_Trade$bestTradeExact2=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact2!==void 0?_Trade$bestTradeExact2:null;const currentTrade=currentTradeRaw?UbeswapTrade.fromNormalTrade(currentTradeRaw):null;// if current trade is best yet, save it\nif(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[allowedPairs,currencyAmountIn,currencyOut,singleHopOnly]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useDirectTradeExactOut(currencyIn,currencyAmountOut){const allowedPairs=useAllCommonPairs(currencyIn,currencyAmountOut===null||currencyAmountOut===void 0?void 0:currencyAmountOut.currency);const[singleHopOnly]=useUserSingleHopOnly();return useMemo(()=>{if(currencyIn&&currencyAmountOut&&allowedPairs.length>0){if(singleHopOnly){var _Trade$bestTradeExact3;const bestTrade=(_Trade$bestTradeExact3=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact3!==void 0?_Trade$bestTradeExact3:null;return bestTrade?UbeswapTrade.fromNormalTrade(bestTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){var _Trade$bestTradeExact4;const currentTradeRaw=(_Trade$bestTradeExact4=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact4!==void 0?_Trade$bestTradeExact4:null;const currentTrade=currentTradeRaw?UbeswapTrade.fromNormalTrade(currentTradeRaw):null;if(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[currencyIn,currencyAmountOut,allowedPairs,singleHopOnly]);}","map":null,"metadata":{},"sourceType":"module"}