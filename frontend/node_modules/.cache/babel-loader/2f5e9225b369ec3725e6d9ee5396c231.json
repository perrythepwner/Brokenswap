{"ast":null,"code":"import React, { useRef } from 'react';\n\n// vector add\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\nfunction calculateAllGeometry(movement, delta) {\n  if (delta === void 0) {\n    delta = movement;\n  }\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\nfunction calculateAllKinematics(movement, delta, dt) {\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var beta = dt === 0 ? 0 : 1 / dt;\n  var velocity = beta * dl;\n  var velocities = delta.map(function (v) {\n    return beta * v;\n  });\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    velocities: velocities,\n    velocity: velocity,\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */\n\nfunction chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {\n      var fn = _step.value;\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */\n\nfunction ensureVector(value, fallback) {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected');\n    }\n    value = fallback;\n  }\n  if (Array.isArray(value)) return value;\n  return [value, value];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */\n\nfunction valueFn(v) {\n  if (typeof v === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    // @ts-ignore\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\nfunction resolveWith(config, resolvers) {\n  if (config === void 0) {\n    config = {};\n  }\n  var result = {};\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n      key = _Object$entries$_i[0],\n      resolver = _Object$entries$_i[1];\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\n\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nfunction supportsTouchEvents() {\n  return typeof window !== 'undefined' && 'ontouchstart' in window;\n}\nfunction supportsPointerEvents() {\n  return typeof window !== 'undefined' && 'onpointerdown' in window;\n}\nfunction getEventTouches(event) {\n  if ('pointerId' in event) return null;\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches;\n}\nfunction getTouchIds(event) {\n  return Array.from(getEventTouches(event)).map(function (t) {\n    return t.identifier;\n  });\n}\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var shiftKey = event.shiftKey,\n    altKey = event.altKey,\n    metaKey = event.metaKey,\n    ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n\n  return {\n    buttons: buttons,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\nvar identity = function identity(xy) {\n  return xy;\n};\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\nfunction getPointerEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n  var touchEvents = getEventTouches(event);\n  var _ref = touchEvents ? touchEvents[0] : event,\n    clientX = _ref.clientX,\n    clientY = _ref.clientY;\n  return transform([clientX, clientY]);\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\nfunction getTwoTouchesEventValues(event, pointerIds, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n  var _Array$from$filter = Array.from(event.touches).filter(function (t) {\n      return pointerIds.includes(t.identifier);\n    }),\n    A = _Array$from$filter[0],\n    B = _Array$from$filter[1];\n  if (!A || !B) throw Error(\"The event doesn't have two pointers matching the pointerIds\");\n  var dx = B.clientX - A.clientX;\n  var dy = B.clientY - A.clientY;\n  var cx = (B.clientX + A.clientX) / 2;\n  var cy = (B.clientY + A.clientY) / 2; // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  var distance = Math.hypot(dx, dy); // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n\n  var angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var values = transform([distance, angle]);\n  var origin = transform([cx, cy]);\n  return {\n    values: values,\n    origin: origin\n  };\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\nfunction getScrollEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n    scrollX = _event$currentTarget.scrollX,\n    scrollY = _event$currentTarget.scrollY,\n    scrollLeft = _event$currentTarget.scrollLeft,\n    scrollTop = _event$currentTarget.scrollTop;\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0]);\n} // wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\nfunction getWheelEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n  var deltaX = event.deltaX,\n    deltaY = event.deltaY,\n    deltaMode = event.deltaMode; // normalize wheel values, especially for Firefox\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return transform([deltaX, deltaY]);\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n  return transform([event.scale, event.rotation]);\n}\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 50;\nvar DEFAULT_SWIPE_DURATION = 250;\nvar InternalGestureOptionsNormalizers = {\n  threshold: function threshold(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    return ensureVector(value);\n  },\n  rubberband: function rubberband(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND);\n      case false:\n        return ensureVector(0);\n      default:\n        return ensureVector(value);\n    }\n  },\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents(value) {\n    if (value === void 0) {\n      value = false;\n    }\n    return value;\n  },\n  initial: function initial(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    if (typeof value === 'function') return value;\n    return ensureVector(value);\n  },\n  transform: true\n};\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  axis: true,\n  lockDirection: function lockDirection(value) {\n    if (value === void 0) {\n      value = false;\n    }\n    return value;\n  },\n  bounds: function bounds(value) {\n    if (value === void 0) {\n      value = {};\n    }\n    if (typeof value === 'function') return function (state) {\n      return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n    };\n    var _value2 = value,\n      _value2$left = _value2.left,\n      left = _value2$left === void 0 ? -Infinity : _value2$left,\n      _value2$right = _value2.right,\n      right = _value2$right === void 0 ? Infinity : _value2$right,\n      _value2$top = _value2.top,\n      top = _value2$top === void 0 ? -Infinity : _value2$top,\n      _value2$bottom = _value2.bottom,\n      bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nvar InternalGenericOptionsNormalizers = {\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n    return value;\n  },\n  domTarget: true,\n  window: /*#__PURE__*/function (_window) {\n    function window(_x) {\n      return _window.apply(this, arguments);\n    }\n    window.toString = function () {\n      return _window.toString();\n    };\n    return window;\n  }(function (value) {\n    if (value === void 0) {\n      value = isBrowser ? window : undefined;\n    }\n    return value;\n  }),\n  eventOptions: function eventOptions(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$passive = _ref.passive,\n      passive = _ref$passive === void 0 ? true : _ref$passive,\n      _ref$capture = _ref.capture,\n      capture = _ref$capture === void 0 ? false : _ref$capture;\n    return {\n      passive: passive,\n      capture: capture\n    };\n  },\n  transform: true\n};\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  bounds: function bounds(_value, _key, _ref2) {\n    var _ref2$distanceBounds = _ref2.distanceBounds,\n      distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds,\n      _ref2$angleBounds = _ref2.angleBounds,\n      angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n    var _distanceBounds = function _distanceBounds(state) {\n      var D = assignDefault(valueFn(distanceBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(valueFn(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function') return [_distanceBounds(), _angleBounds()];\n    return function (state) {\n      return [_distanceBounds(state), _angleBounds(state)];\n    };\n  }\n});\nvar InternalDragOptionsNormalizers = /*#__PURE__*/_extends({}, InternalCoordinatesOptionsNormalizers, {\n  useTouch: function useTouch(value) {\n    if (value === void 0) {\n      value = false;\n    }\n    var supportsTouch = supportsTouchEvents();\n    var supportsPointer = supportsPointerEvents();\n    if (value && supportsTouch) return true;\n    if (supportsTouch && !supportsPointer) return true;\n    return false;\n  },\n  experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {\n    if (value === void 0) {\n      value = false;\n    }\n    return value;\n  },\n  threshold: function threshold(v, _k, _ref3) {\n    var _ref3$filterTaps = _ref3.filterTaps,\n      filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps,\n      _ref3$lockDirection = _ref3.lockDirection,\n      lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection,\n      _ref3$axis = _ref3.axis,\n      axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n    var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    return A;\n  },\n  swipeVelocity: function swipeVelocity(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_VELOCITY;\n    }\n    return ensureVector(v);\n  },\n  swipeDistance: function swipeDistance(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_DISTANCE;\n    }\n    return ensureVector(v);\n  },\n  swipeDuration: function swipeDuration(value) {\n    if (value === void 0) {\n      value = DEFAULT_SWIPE_DURATION;\n    }\n    return value;\n  },\n  delay: function delay(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  }\n});\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith(config, InternalGenericOptionsNormalizers);\n}\nfunction getInternalCoordinatesOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\nfunction getInternalDistanceAngleOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\nfunction getInternalDragOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  return resolveWith(config, InternalDragOptionsNormalizers);\n}\nfunction _buildMoveConfig(_ref) {\n  var domTarget = _ref.domTarget,\n    eventOptions = _ref.eventOptions,\n    window = _ref.window,\n    enabled = _ref.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.move = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction _buildHoverConfig(_ref2) {\n  var domTarget = _ref2.domTarget,\n    eventOptions = _ref2.eventOptions,\n    window = _ref2.window,\n    enabled = _ref2.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref2, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.hover = _extends({\n    enabled: true\n  }, rest);\n  return opts;\n}\nfunction _buildDragConfig(_ref3) {\n  var domTarget = _ref3.domTarget,\n    eventOptions = _ref3.eventOptions,\n    window = _ref3.window,\n    enabled = _ref3.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref3, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.drag = getInternalDragOptions(rest);\n  return opts;\n}\nfunction _buildPinchConfig(_ref4) {\n  var domTarget = _ref4.domTarget,\n    eventOptions = _ref4.eventOptions,\n    window = _ref4.window,\n    enabled = _ref4.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref4, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.pinch = getInternalDistanceAngleOptions(rest);\n  return opts;\n}\nfunction _buildScrollConfig(_ref5) {\n  var domTarget = _ref5.domTarget,\n    eventOptions = _ref5.eventOptions,\n    window = _ref5.window,\n    enabled = _ref5.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref5, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.scroll = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction _buildWheelConfig(_ref6) {\n  var domTarget = _ref6.domTarget,\n    eventOptions = _ref6.eventOptions,\n    window = _ref6.window,\n    enabled = _ref6.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref6, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.wheel = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction buildComplexConfig(config, actions) {\n  if (config === void 0) {\n    config = {};\n  }\n  if (actions === void 0) {\n    actions = new Set();\n  }\n  var _config = config,\n    drag = _config.drag,\n    wheel = _config.wheel,\n    move = _config.move,\n    scroll = _config.scroll,\n    pinch = _config.pinch,\n    hover = _config.hover,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    transform = _config.transform,\n    domTarget = _config.domTarget,\n    enabled = _config.enabled;\n  var mergedConfig = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    transform: transform,\n    window: window,\n    enabled: enabled\n  });\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag);\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move);\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  if (actions.has('onHover')) mergedConfig.hover = _extends({\n    enabled: true\n  }, hover);\n  return mergedConfig;\n}\nfunction getInitial(mixed) {\n  return _extends({\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],\n    _threshold: [0, 0],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }, mixed);\n}\nfunction getInitialState() {\n  var shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false\n  };\n  var drag = getInitial({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0]\n  });\n  var pinch = getInitial({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0],\n    vdva: [0, 0],\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0\n  });\n  var wheel = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var move = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var scroll = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  return {\n    shared: shared,\n    drag: drag,\n    pinch: pinch,\n    wheel: wheel,\n    move: move,\n    scroll: scroll\n  };\n}\nvar RecognizersMap = /*#__PURE__*/new Map();\nvar identity$1 = function identity(xy) {\n  return xy;\n};\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(controller, args) {\n    var _this = this;\n    if (args === void 0) {\n      args = [];\n    }\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n      if (ms === void 0) {\n        ms = 140;\n      }\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    };\n    /**\r\n     * Fires the gesture handler\r\n     */\n\n    this.fireGestureHandler = function (forceFlag) {\n      if (forceFlag === void 0) {\n        forceFlag = false;\n      }\n\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n          _this.clean();\n        }\n        return null;\n      } // If the gesture has no intentional dimension, don't fire the handler.\n\n      if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n      if (_this.state.intentional) {\n        var prev_active = _this.state.active;\n        var next_active = _this.state._active;\n        _this.state.active = next_active;\n        _this.state.first = next_active && !prev_active;\n        _this.state.last = prev_active && !next_active;\n        _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n      }\n\n      var touches = _this.controller.pointerIds.size || _this.controller.touchIds.size;\n      var down = _this.controller.state.shared.buttons > 0 || touches > 0;\n      var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state), {\n        locked: !!document.pointerLockElement,\n        touches: touches,\n        down: down\n      }); // @ts-expect-error\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo;\n      return state;\n    };\n    this.controller = controller;\n    this.args = args;\n  } // Returns the gesture config\n\n  var _proto = Recognizer.prototype;\n\n  // Convenience method to update the shared state\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Convenience method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */;\n\n  _proto.getMovement = function getMovement(values) {\n    var rubberband = this.config.rubberband;\n    var _this$state = this.state,\n      _bounds = _this$state._bounds,\n      _initial = _this$state._initial,\n      _active = _this$state._active,\n      wasIntentional = _this$state._intentional,\n      lastOffset = _this$state.lastOffset,\n      prevMovement = _this$state.movement,\n      _T = _this$state._threshold;\n    var M = this.getInternalMovement(values, this.state);\n    var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0];\n    var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], M);\n    if (intentionalityCheck._blocked) {\n      return _extends({}, intentionalityCheck, {\n        _movement: M,\n        delta: [0, 0]\n      });\n    }\n    var _intentional = intentionalityCheck._intentional;\n    var _movement = M;\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : 0, _intentional[1] !== false ? M[1] - _intentional[1] : 0];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n    return _extends({}, intentionalityCheck, {\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      values: values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n  };\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this.config.transform || this.controller.config.transform || identity$1;\n    }\n  }]);\n  return Recognizer;\n}(); //--------------------------------------------\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold;\n  } else {\n    return false;\n  }\n}\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var Vx = _ref[0],\n    Vy = _ref[1];\n  var Rx = _ref2[0],\n    Ry = _ref2[1];\n  var _bounds$ = bounds[0],\n    X1 = _bounds$[0],\n    X2 = _bounds$[1],\n    _bounds$2 = bounds[1],\n    Y1 = _bounds$2[0],\n    Y2 = _bounds$2[1];\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */\n\nfunction getGenericPayload(_ref3, event, isStartEvent) {\n  var state = _ref3.state;\n  var timeStamp = event.timeStamp,\n    _lastEventType = event.type;\n  var previous = state.values;\n  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n  return {\n    _lastEventType: _lastEventType,\n    event: event,\n    timeStamp: timeStamp,\n    elapsedTime: elapsedTime,\n    previous: previous\n  };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */\n\nfunction getStartGestureState(_ref4, values, event, initial) {\n  var state = _ref4.state,\n    config = _ref4.config,\n    stateKey = _ref4.stateKey,\n    args = _ref4.args,\n    transform = _ref4.transform;\n  var offset = state.offset;\n  var startTime = event.timeStamp;\n  var initialFn = config.initial,\n    bounds = config.bounds,\n    threshold = config.threshold; // the _threshold is the difference between a [0,0] offset converted to\n  // its new space coordinates\n\n  var _threshold = subV(transform(threshold), transform([0, 0])).map(Math.abs);\n  var _state = _extends({}, getInitialState()[stateKey], {\n    _active: true,\n    args: args,\n    values: values,\n    initial: initial != null ? initial : values,\n    _threshold: _threshold,\n    offset: offset,\n    lastOffset: offset,\n    startTime: startTime\n  });\n  return _extends({}, _state, {\n    _initial: valueFn(initialFn, _state),\n    _bounds: valueFn(bounds, _state)\n  });\n}\n\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */\n\nvar Controller = function Controller(classes) {\n  var _this = this;\n  this.classes = classes;\n  this.pointerIds = new Set(); // register Pointer Events pointerIds\n\n  this.touchIds = new Set(); // register Touch Events identifiers\n\n  this.supportsTouchEvents = supportsTouchEvents();\n  this.supportsGestureEvents = supportsGestureEvents();\n  this.bind = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var bindings = {};\n    for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;) {\n      var RecognizerClass = _step.value;\n      new RecognizerClass(_this, args).addBindings(bindings);\n    } // // we also add event bindings for native handlers\n\n    var _loop = function _loop(eventKey) {\n      addBindings(bindings, eventKey, function (event) {\n        return _this.nativeRefs[eventKey](_extends({}, _this.state.shared, {\n          event: event,\n          args: args\n        }));\n      });\n    };\n    for (var eventKey in _this.nativeRefs) {\n      _loop(eventKey);\n    }\n    if (_this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(_this, bindings);\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(_this, bindings);\n    }\n  };\n  this.effect = function () {\n    if (_this.config.domTarget) _this.bind();\n    return _this.clean;\n  };\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n  this.clean = function () {\n    var domTarget = getDomTargetFromConfig(_this.config);\n    var eventOptions = _this.config.eventOptions;\n    if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    clearAllWindowListeners(_this);\n  };\n  this.classes = classes;\n  this.state = getInitialState();\n  this.timeouts = {};\n  this.domListeners = [];\n  this.windowListeners = {};\n};\nfunction addEventIds(controller, event) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId);\n  } else {\n    controller.touchIds = new Set(getTouchIds(event));\n  }\n}\nfunction removeEventIds(controller, event) {\n  if ('pointerId' in event) {\n    controller.pointerIds[\"delete\"](event.pointerId);\n  } else {\n    getTouchIds(event).forEach(function (id) {\n      return controller.touchIds[\"delete\"](id);\n    });\n  }\n}\nfunction clearAllWindowListeners(controller) {\n  var _controller$config = controller.config,\n    el = _controller$config.window,\n    eventOptions = _controller$config.eventOptions,\n    windowListeners = controller.windowListeners;\n  if (!el) return;\n  for (var stateKey in windowListeners) {\n    var handlers = windowListeners[stateKey];\n    removeListeners(el, handlers, eventOptions);\n  }\n  controller.windowListeners = {};\n}\nfunction clearWindowListeners(_ref, stateKey, options) {\n  var config = _ref.config,\n    windowListeners = _ref.windowListeners;\n  if (options === void 0) {\n    options = config.eventOptions;\n  }\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], options);\n  delete windowListeners[stateKey];\n}\nfunction updateWindowListeners(_ref2, stateKey, listeners, options) {\n  var config = _ref2.config,\n    windowListeners = _ref2.windowListeners;\n  if (listeners === void 0) {\n    listeners = [];\n  }\n  if (options === void 0) {\n    options = config.eventOptions;\n  }\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], options);\n  addListeners(config.window, windowListeners[stateKey] = listeners, options);\n}\nfunction updateDomListeners(_ref3, bindings) {\n  var config = _ref3.config,\n    domListeners = _ref3.domListeners;\n  var domTarget = getDomTargetFromConfig(config);\n  if (!domTarget) throw new Error('domTarget must be defined');\n  var eventOptions = config.eventOptions;\n  removeListeners(domTarget, takeAll(domListeners), eventOptions);\n  for (var _i = 0, _Object$entries = Object.entries(bindings); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n      key = _Object$entries$_i[0],\n      fns = _Object$entries$_i[1];\n    var name = key.slice(2).toLowerCase();\n    domListeners.push([name, chainFns.apply(void 0, fns)]);\n  }\n  addListeners(domTarget, domListeners, eventOptions);\n}\nfunction getPropsListener(_ref4, bindings) {\n  var config = _ref4.config;\n  var props = {};\n  var captureString = config.eventOptions.capture ? 'Capture' : '';\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _Object$entries2[_i2],\n      event = _Object$entries2$_i[0],\n      fns = _Object$entries2$_i[1];\n    var fnsArray = Array.isArray(fns) ? fns : [fns];\n    var key = event + captureString;\n    props[key] = chainFns.apply(void 0, fnsArray);\n  }\n  return props;\n}\nfunction takeAll(array) {\n  if (array === void 0) {\n    array = [];\n  }\n  return array.splice(0, array.length);\n}\nfunction getDomTargetFromConfig(_ref5) {\n  var domTarget = _ref5.domTarget;\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */\n\nfunction addBindings(bindings, name, fn) {\n  if (!bindings[name]) bindings[name] = [];\n  bindings[name].push(fn);\n}\nfunction addListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;) {\n    var _step2$value = _step2.value,\n      eventName = _step2$value[0],\n      eventHandler = _step2$value[1];\n    el.addEventListener(eventName, eventHandler, options);\n  }\n}\nfunction removeListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;) {\n    var _step3$value = _step3.value,\n      eventName = _step3$value[0],\n      eventHandler = _step3$value[1];\n    el.removeEventListener(eventName, eventHandler, options);\n  }\n}\n\n/* eslint-disable react-hooks/exhaustive-deps */\n/**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */\n\nfunction useRecognizers(handlers, config, nativeHandlers) {\n  if (nativeHandlers === void 0) {\n    nativeHandlers = {};\n  }\n  var classes = resolveClasses(handlers);\n  var controller = React.useMemo(function () {\n    return new Controller(classes);\n  }, []);\n  controller.config = config;\n  controller.handlers = handlers;\n  controller.nativeRefs = nativeHandlers;\n  React.useEffect(controller.effect, []); // @ts-ignore\n\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n\n  return controller.bind;\n}\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n  }\n}\nfunction resolveClasses(internalHandlers) {\n  var classes = new Set();\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag'));\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel'));\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll'));\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move'));\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch'));\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover'));\n  return classes;\n}\n\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = CoordinatesRecognizer.prototype;\n\n  /**\r\n   * Returns the real movement (without taking intentionality into account)\r\n   */\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return {\n        _intentional: _intentional,\n        axis: this.state.axis\n      };\n    }\n    var _movement$map = _movement.map(Math.abs),\n      absX = _movement$map[0],\n      absY = _movement$map[1];\n    var axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n    if (!this.config.axis && !this.config.lockDirection) return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n    if (!axis) return {\n      _intentional: [false, false],\n      _blocked: false,\n      axis: axis\n    };\n    if (!!this.config.axis && axis !== this.config.axis) return {\n      _intentional: _intentional,\n      _blocked: true,\n      axis: axis\n    };\n    _intentional[axis === 'x' ? 1 : 0] = false;\n    return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n  };\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    if (!state._blocked) {\n      var dt = event.timeStamp - this.state.timeStamp;\n      Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n    }\n    return state;\n  };\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n  return CoordinatesRecognizer;\n}(Recognizer);\nvar TAP_DISTANCE_THRESHOLD = 3;\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n  function DragRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'dragging';\n    _this.stateKey = 'drag'; // TODO add back when setPointerCapture is widely wupported\n    // https://caniuse.com/#search=setPointerCapture\n\n    _this.setPointerCapture = function (event) {\n      // don't perform pointere capture when user wants to use touch events or\n      // when a pointerLockElement exists as this would throw an error\n      if (_this.config.useTouch || document.pointerLockElement) return;\n      var target = event.target,\n        pointerId = event.pointerId;\n      if (target && 'setPointerCapture' in target) {\n        // this would work in the DOM but doesn't with react three fiber\n        // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n        // @ts-expect-error\n        target.setPointerCapture(pointerId);\n      }\n      _this.updateGestureState({\n        _dragTarget: target,\n        _dragPointerId: pointerId\n      });\n    };\n    _this.releasePointerCapture = function () {\n      if (_this.config.useTouch || document.pointerLockElement) return;\n      var _this$state = _this.state,\n        _dragTarget = _this$state._dragTarget,\n        _dragPointerId = _this$state._dragPointerId;\n      if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n        // this would work in the DOM but doesn't with react three fiber\n        // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n        if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId)) try {\n          _dragTarget.releasePointerCapture(_dragPointerId);\n        } catch (e) {}\n      }\n    };\n    _this.preventScroll = function (event) {\n      if (_this.state._dragPreventScroll && event.cancelable) {\n        event.preventDefault();\n      }\n    };\n    _this.getEventId = function (event) {\n      if (_this.config.useTouch) return event.changedTouches[0].identifier;\n      return event.pointerId;\n    };\n    _this.isValidEvent = function (event) {\n      // if we were using pointer events only event.isPrimary === 1 would suffice\n      return _this.state._pointerId === _this.getEventId(event);\n    };\n    _this.shouldPreventWindowScrollY = _this.config.experimental_preventWindowScrollY && _this.controller.supportsTouchEvents;\n    _this.setUpWindowScrollDetection = function (event) {\n      persistEvent(event); // we add window listeners that will prevent the scroll when the user has started dragging\n\n      updateWindowListeners(_this.controller, _this.stateKey, [['touchmove', _this.preventScroll], ['touchend', _this.clean.bind(_assertThisInitialized(_this))], ['touchcancel', _this.clean.bind(_assertThisInitialized(_this))]], {\n        passive: false\n      });\n      _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), 250, event);\n    };\n    _this.setUpDelayedDragTrigger = function (event) {\n      _this.state._dragDelayed = true;\n      persistEvent(event);\n      _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n    };\n    _this.setStartState = function (event) {\n      var values = getPointerEventValues(event, _this.transform);\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        _pointerId: _this.getEventId(event)\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n    };\n    _this.onDragStart = function (event) {\n      addEventIds(_this.controller, event);\n      if (!_this.enabled || _this.state._active) return;\n      _this.setStartState(event);\n      _this.setPointerCapture(event);\n      if (_this.shouldPreventWindowScrollY) _this.setUpWindowScrollDetection(event);else if (_this.config.delay > 0) _this.setUpDelayedDragTrigger(event);else _this.startDrag(event, true); // we pass the values to the startDrag event\n    };\n\n    _this.onDragChange = function (event) {\n      if (\n      // if the gesture was canceled or\n      _this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !_this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !_this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      _this.state._lastEventType === event.type && event.timeStamp === _this.state.timeStamp) return;\n      var values;\n      if (document.pointerLockElement) {\n        var movementX = event.movementX,\n          movementY = event.movementY;\n        values = addV(_this.transform([movementX, movementY]), _this.state.values);\n      } else values = getPointerEventValues(event, _this.transform);\n      var kinematics = _this.getKinematics(values, event); // if startDrag hasn't fired\n\n      if (!_this.state._dragStarted) {\n        // If the gesture isn't active then respond to the event only if\n        // it's been delayed via the `delay` option, in which case start\n        // the gesture immediately.\n        if (_this.state._dragDelayed) {\n          _this.startDrag(event);\n          return;\n        } // if the user wants to prevent vertical window scroll when user starts dragging\n\n        if (_this.shouldPreventWindowScrollY) {\n          if (!_this.state._dragPreventScroll && kinematics.axis) {\n            // if the user is dragging horizontally then we should allow the drag\n            if (kinematics.axis === 'x') {\n              _this.startDrag(event);\n            } else {\n              _this.state._active = false;\n              return;\n            }\n          } else return;\n        } else return;\n      }\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n      // if the real distance of the drag (ie not accounting for the threshold) is\n      // greater than the TAP_DISTANCE_THRESHOLD.\n\n      var realDistance = calculateDistance(kinematics._movement);\n      var _dragIsTap = _this.state._dragIsTap;\n      if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false;\n      _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n        _dragIsTap: _dragIsTap\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onDragEnd = function (event) {\n      removeEventIds(_this.controller, event); // if the event pointerId doesn't match the one that initiated the drag\n      // we don't want to end the drag\n\n      if (!_this.isValidEvent(event)) return;\n      _this.clean(); // if the gesture is no longer active (ie canceled)\n      // don't do anything\n\n      if (!_this.state._active) return;\n      _this.state._active = false;\n      var tap = _this.state._dragIsTap;\n      var _this$state$velocitie = _this.state.velocities,\n        vx = _this$state$velocitie[0],\n        vy = _this$state$velocitie[1];\n      var _this$state$movement = _this.state.movement,\n        mx = _this$state$movement[0],\n        my = _this$state$movement[1];\n      var _this$state$_intentio = _this.state._intentional,\n        ix = _this$state$_intentio[0],\n        iy = _this$state$_intentio[1];\n      var _this$config$swipeVel = _this.config.swipeVelocity,\n        svx = _this$config$swipeVel[0],\n        svy = _this$config$swipeVel[1];\n      var _this$config$swipeDis = _this.config.swipeDistance,\n        sx = _this$config$swipeDis[0],\n        sy = _this$config$swipeDis[1];\n      var sd = _this.config.swipeDuration;\n      var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n      var swipe = [0, 0];\n      if (endState.elapsedTime < sd) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n      _this.updateSharedState({\n        buttons: 0\n      });\n      _this.updateGestureState(_extends({}, endState, {\n        tap: tap,\n        swipe: swipe\n      }));\n      _this.fireGestureHandler(_this.config.filterTaps && tap === true);\n    };\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n      _this.state._dragStarted = false;\n      _this.releasePointerCapture();\n      clearWindowListeners(_this.controller, _this.stateKey);\n    };\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n      _this.updateGestureState({\n        canceled: true,\n        _active: false\n      });\n      _this.updateSharedState({\n        buttons: 0\n      });\n      setTimeout(function () {\n        return _this.fireGestureHandler();\n      }, 0);\n    };\n    _this.onClick = function (event) {\n      if (!_this.state._dragIsTap) event.stopPropagation();\n    };\n    return _this;\n  }\n  var _proto = DragRecognizer.prototype;\n  _proto.startDrag = function startDrag(event, onDragIsStart) {\n    if (onDragIsStart === void 0) {\n      onDragIsStart = false;\n    }\n\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n    if (\n    // if the gesture isn't active (probably means)\n    !this.state._active ||\n    // if the drag has already started we should ignore subsequent attempts\n    this.state._dragStarted) return;\n    if (!onDragIsStart) this.setStartState(event);\n    this.updateGestureState({\n      _dragStarted: true,\n      _dragPreventScroll: true,\n      cancel: this.onCancel\n    });\n    this.clearTimeout();\n    this.fireGestureHandler();\n  };\n  _proto.addBindings = function addBindings$1(bindings) {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart);\n      addBindings(bindings, 'onTouchMove', this.onDragChange); // this is needed for react-three-fiber\n\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd);\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd);\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart);\n      addBindings(bindings, 'onPointerMove', this.onDragChange); // this is needed for react-three-fiber\n\n      addBindings(bindings, 'onPointerUp', this.onDragEnd);\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd);\n    }\n    if (this.config.filterTaps) {\n      var handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture';\n      addBindings(bindings, handler, this.onClick);\n    }\n  };\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */\nfunction memoizeOne(resultFn, isEqual) {\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n  function memoized() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n  return memoized;\n}\n\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */\nfunction equal(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n      return true;\n    }\n    var it;\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n      it = a.entries();\n      while (!(i = it.next()).done) {\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      }\n      return true;\n    }\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n      return true;\n    }\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n    if (typeof Element !== 'undefined' && a instanceof Element) return false;\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) continue;\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n    return true;\n  } // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n\n  return a !== a && b !== b;\n}\nfunction isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      // eslint-disable-next-line no-console\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n    throw error;\n  }\n}\n\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('drag', DragRecognizer);\n  var buildDragConfig = useRef();\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n  }\n  return useRecognizers({\n    drag: handler\n  }, buildDragConfig.current(config));\n}\n\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = DistanceAngleRecognizer.prototype;\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n\n    var d = values[0],\n      _values$ = values[1],\n      a = _values$ === void 0 ? prev_a : _values$;\n    var delta_a = a - prev_a;\n    var next_turns = state.turns;\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n    return subV([d, a - 360 * next_turns], state.initial);\n  };\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    var turns = (values[1] - state._movement[1] - this.state.initial[1]) / 360;\n    var dt = event.timeStamp - this.state.timeStamp;\n    var _calculateAllKinemati = calculateAllKinematics(state.movement, state.delta, dt),\n      kinematics = _objectWithoutPropertiesLoose(_calculateAllKinemati, [\"distance\", \"velocity\"]);\n    return _extends({\n      turns: turns\n    }, state, kinematics);\n  };\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n  return DistanceAngleRecognizer;\n}(Recognizer);\nvar ZOOM_CONSTANT = 7;\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n  function PinchRecognizer() {\n    var _this;\n    _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n    _this.ingKey = 'pinching';\n    _this.stateKey = 'pinch';\n    _this.onPinchStart = function (event) {\n      addEventIds(_this.controller, event);\n      var touchIds = _this.controller.touchIds;\n      if (!_this.enabled) return;\n      if (_this.state._active) {\n        // check that the pointerIds that initiated the gesture\n        // are still enabled. This is useful for when the page\n        // loses track of the pointers (minifying gesture on iPad).\n        if (_this.state._pointerIds.every(function (id) {\n          return touchIds.has(id);\n        })) return; // something was wrong with the pointers but we let it go.\n      } // until we reach two fingers on the target don't react\n\n      if (touchIds.size < 2) return;\n      var _pointerIds = Array.from(touchIds).slice(0, 2);\n      var _getTwoTouchesEventVa = getTwoTouchesEventValues(event, _pointerIds, _this.transform),\n        values = _getTwoTouchesEventVa.values,\n        origin = _getTwoTouchesEventVa.origin;\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        _pointerIds: _pointerIds,\n        cancel: _this.onCancel,\n        origin: origin\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n        canceled = _this$state.canceled,\n        _active = _this$state._active;\n      if (canceled || !_active ||\n      // if the event has the same timestamp as the previous event\n      event.timeStamp === _this.state.timeStamp) return;\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      try {\n        var _getTwoTouchesEventVa2 = getTwoTouchesEventValues(event, _this.state._pointerIds, _this.transform),\n          values = _getTwoTouchesEventVa2.values,\n          origin = _getTwoTouchesEventVa2.origin;\n        var kinematics = _this.getKinematics(values, event);\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n          origin: origin\n        }));\n        _this.fireGestureHandler();\n      } catch (e) {\n        _this.onPinchEnd(event);\n      }\n    };\n    _this.onPinchEnd = function (event) {\n      removeEventIds(_this.controller, event);\n      var pointerIds = getTouchIds(event); // if none of the lifted pointerIds is in the state pointerIds don't do anything\n\n      if (_this.state._pointerIds.every(function (id) {\n        return !pointerIds.includes(id);\n      })) return;\n      _this.clean();\n      if (!_this.state._active) return;\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        _active: false\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n      _this.updateGestureState({\n        _active: false,\n        canceled: true\n      });\n      setTimeout(function () {\n        return _this.fireGestureHandler();\n      }, 0);\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n      var values = getWebkitGestureEventValues(event, _this.transform);\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        origin: [event.clientX, event.clientY],\n        cancel: _this.onCancel\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n        canceled = _this$state2.canceled,\n        _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData); // this normalizes the values of the Safari's WebKitEvent by calculating\n      // the delta and then multiplying it by a constant.\n\n      var values = getWebkitGestureEventValues(event, _this.transform);\n      values[0] = (values[0] - _this.state.event.scale) * WEBKIT_DISTANCE_SCALE_FACTOR + _this.state.values[0];\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: [event.clientX, event.clientY]\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onGestureEnd = function (event) {\n      _this.clean();\n      if (!_this.state._active) return;\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        _active: false,\n        origin: [event.clientX, event.clientY]\n      }));\n      _this.fireGestureHandler();\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event, _this.transform),\n        delta_d = _getWheelEventValues[1];\n      var _this$state$values = _this.state.values,\n        prev_d = _this$state$values[0],\n        prev_a = _this$state$values[1]; // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n\n      var _delta_d = -delta_d * ZOOM_CONSTANT; // new distance is the previous state distance added to the delta\n\n      var d = prev_d + _delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [_delta_d, a]\n      };\n    };\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n      _this.setTimeout(_this.onWheelEnd);\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n        values = _this$getWheelValuesF.values,\n        delta = _this$getWheelValuesF.delta,\n        origin = _this$getWheelValuesF.origin;\n      if (event.cancelable) event.preventDefault();else if (process.env.NODE_ENV === 'development') {\n        // eslint-disable-next-line no-console\n        console.warn('To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.');\n      }\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event, _this.state.values), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelChange = function (event) {\n      if (event.cancelable) event.preventDefault();\n      _this.updateSharedState(getGenericEventData(event));\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n        values = _this$getWheelValuesF2.values,\n        origin = _this$getWheelValuesF2.origin,\n        delta = _this$getWheelValuesF2.delta;\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n        origin: origin,\n        delta: delta\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelEnd = function () {\n      _this.clean();\n      if (!_this.state._active) return;\n      _this.state._active = false;\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !this.controller.supportsTouchEvents && this.controller.supportsGestureEvents) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart);\n      addBindings(bindings, 'onGestureChange', this.onGestureChange);\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd);\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart);\n      addBindings(bindings, 'onTouchMove', this.onPinchChange);\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd);\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd);\n      addBindings(bindings, 'onWheel', this.onWheel);\n    }\n  };\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('pinch', PinchRecognizer);\n  var buildPinchConfig = useRef();\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n  }\n  return useRecognizers({\n    pinch: handler\n  }, buildPinchConfig.current(config));\n}\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n  function WheelRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'wheeling';\n    _this.stateKey = 'wheel';\n    _this.debounced = true;\n    _this.handleEvent = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return;\n      if (!_this.enabled) return;\n      _this.setTimeout(_this.onEnd);\n      _this.updateSharedState(getGenericEventData(event));\n      var values = addV(getWheelEventValues(event, _this.transform), _this.state.values);\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event, _this.state.values), getGenericPayload(_assertThisInitialized(_this), event, true)));\n        var movement = _this.getMovement(values);\n        var geometry = calculateAllGeometry(movement.delta);\n        _this.updateGestureState(movement);\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n      _this.fireGestureHandler();\n    };\n    _this.onEnd = function () {\n      _this.clean();\n      if (!_this.state._active) return;\n      var movement = _this.getMovement(_this.state.values);\n      _this.updateGestureState(movement);\n      _this.updateGestureState({\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      });\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = WheelRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onWheel', this.handleEvent);\n  };\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var buildWheelConfig = useRef();\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n  }\n  return useRecognizers({\n    wheel: handler\n  }, buildWheelConfig.current(config));\n}\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n  function MoveRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'moving';\n    _this.stateKey = 'move';\n    _this.debounced = true;\n    _this.onMove = function (event) {\n      if (!_this.enabled) return;\n      _this.setTimeout(_this.onMoveEnd);\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n    _this.onMoveStart = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n      var values = getPointerEventValues(event, _this.transform);\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onMoveChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n      var values = getPointerEventValues(event, _this.transform);\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      _this.fireGestureHandler();\n    };\n    _this.onMoveEnd = function () {\n      _this.clean();\n      if (!_this.state._active) return;\n      var values = _this.state.values;\n      _this.updateGestureState(_this.getMovement(values));\n      _this.updateGestureState({\n        velocities: [0, 0],\n        velocity: 0,\n        _active: false\n      });\n      _this.fireGestureHandler();\n    };\n    _this.hoverTransform = function () {\n      return _this.controller.config.hover.transform || _this.controller.config.transform;\n    };\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n      if (_this.controller.config.hover.enabled) {\n        var values = getPointerEventValues(event, _this.hoverTransform());\n        var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n          args: _this.args,\n          values: values,\n          active: true,\n          hovering: true\n        });\n        _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n      }\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (!_this.controller.config.hover.enabled) return;\n      var values = getPointerEventValues(event, _this.hoverTransform());\n      var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n        args: _this.args,\n        values: values,\n        active: false\n      });\n      _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n    };\n    return _this;\n  }\n  var _proto = MoveRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove);\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter);\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave);\n    }\n  };\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('move', MoveRecognizer);\n  var buildMoveConfig = useRef();\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n  }\n  return useRecognizers({\n    move: handler\n  }, buildMoveConfig.current(config));\n}\n\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('hover', MoveRecognizer);\n  var buildHoverConfig = useRef();\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n  }\n  return useRecognizers({\n    hover: handler\n  }, buildHoverConfig.current(config));\n}\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n  function ScrollRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'scrolling';\n    _this.stateKey = 'scroll';\n    _this.debounced = true;\n    _this.handleEvent = function (event) {\n      if (!_this.enabled) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onEnd);\n      var values = getScrollEventValues(event, _this.transform);\n      _this.updateSharedState(getGenericEventData(event));\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event, _this.state.values), getGenericPayload(_assertThisInitialized(_this), event, true)));\n        var movementDetection = _this.getMovement(values);\n        var geometry = calculateAllGeometry(movementDetection.delta);\n        _this.updateGestureState(movementDetection);\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n      _this.fireGestureHandler();\n    };\n    _this.onEnd = function () {\n      _this.clean();\n      if (!_this.state._active) return;\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      }));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = ScrollRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onScroll', this.handleEvent);\n  };\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  var buildScrollConfig = useRef();\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n  }\n  return useRecognizers({\n    scroll: handler\n  }, buildScrollConfig.current(config));\n}\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(handlers) {\n  var _native = {};\n  var handle = {};\n  var actions = new Set();\n  for (var key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handle[key] = handlers[key];\n    } else {\n      _native[key] = handlers[key];\n    }\n  }\n  return [handle, _native, actions];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useGesture(_handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _sortHandlers = sortHandlers(_handlers),\n    handlers = _sortHandlers[0],\n    nativeHandlers = _sortHandlers[1],\n    actions = _sortHandlers[2];\n  RecognizersMap.set('drag', DragRecognizer);\n  RecognizersMap.set('hover', MoveRecognizer);\n  RecognizersMap.set('move', MoveRecognizer);\n  RecognizersMap.set('pinch', PinchRecognizer);\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var mergedConfig = buildComplexConfig(config, actions);\n  var internalHandlers = {};\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag');\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel');\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll');\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove');\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch');\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover;\n  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\nfunction includeStartEndHandlers(handlers, handlerKey) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  return fn;\n}\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"sources":["../src/utils/math.ts","../src/utils/rubberband.ts","../src/utils/utils.ts","../src/utils/resolveOptionsWith.ts","../src/utils/event.ts","../src/utils/config.ts","../src/hooks/buildConfig.ts","../src/utils/state.ts","../src/recognizers/Recognizer.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/memoize-one.ts","../src/utils/react-fast-compare.ts","../src/hooks/useDrag.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/hooks/usePinch.ts","../src/recognizers/WheelRecognizer.ts","../src/hooks/useWheel.ts","../src/recognizers/MoveRecognizer.ts","../src/hooks/useMove.ts","../src/hooks/useHover.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useScroll.ts","../src/hooks/useGesture.ts"],"names":["addV","v1","v2","map","v","i","subV","calculateDistance","movement","Math","hypot","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","minMax","value","min","max","rubberband2","constant","pow","rubberband","dimension","abs","Infinity","rubberbandIfOutOfBounds","position","noop","chainFns","fns","length","result","fn","apply","arguments","ensureVector","fallback","undefined","Error","Array","isArray","assignDefault","Object","assign","valueFn","args","resolveWith","config","resolvers","key","resolver","entries","call","supportsGestureEvents","GestureEvent","e","supportsTouchEvents","window","supportsPointerEvents","getEventTouches","event","type","changedTouches","targetTouches","getTouchIds","from","t","identifier","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","xy","getPointerEventValues","transform","touchEvents","clientX","clientY","getTwoTouchesEventValues","pointerIds","A","B","touches","filter","includes","dx","dy","cx","cy","angle","atan2","PI","values","origin","getScrollEventValues","scrollX","scrollY","scrollLeft","scrollTop","currentTarget","LINE_HEIGHT","PAGE_HEIGHT","getWheelEventValues","deltaX","deltaY","deltaMode","getWebkitGestureEventValues","scale","rotation","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","DEFAULT_SWIPE_DURATION","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","state","left","right","top","bottom","isBrowser","document","createElement","InternalGenericOptionsNormalizers","domTarget","eventOptions","passive","capture","InternalDistanceAngleOptionsNormalizers","_value","_key","distanceBounds","angleBounds","_distanceBounds","D","_angleBounds","InternalDragOptionsNormalizers","useTouch","supportsTouch","supportsPointer","experimental_preventWindowScrollY","_k","filterTaps","swipeVelocity","swipeDistance","swipeDuration","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","_buildMoveConfig","rest","opts","move","_buildHoverConfig","hover","_buildDragConfig","drag","_buildPinchConfig","pinch","_buildScrollConfig","scroll","_buildWheelConfig","wheel","buildComplexConfig","actions","Set","mergedConfig","has","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_threshold","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","down","locked","_pointerId","vxvy","tap","swipe","_pointerIds","da","vdva","turns","RecognizersMap","Map","Recognizer","controller","stateKey","handlers","updateSharedState","sharedState","updateGestureState","gestureState","callback","ms","clearTimeout","timeouts","setTimeout","checkIntentionality","getMovement","wasIntentional","prevMovement","_T","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","clean","forceFlag","debounced","prev_active","next_active","ingKey","size","touchIds","mapStateValues","pointerLockElement","newMemo","handler","Vx","Vy","Rx","Ry","X1","X2","Y1","Y2","getGenericPayload","isStartEvent","getStartGestureState","initialFn","_state","Controller","classes","domListeners","windowListeners","bindings","RecognizerClass","addBindings","eventKey","nativeRefs","updateDomListeners","getPropsListener","bind","getDomTargetFromConfig","removeListeners","takeAll","forEach","clearAllWindowListeners","addEventIds","add","pointerId","removeEventIds","id","el","clearWindowListeners","options","updateWindowListeners","listeners","addListeners","name","slice","toLowerCase","push","props","captureString","fnsArray","array","splice","current","eventName","eventHandler","addEventListener","removeEventListener","useRecognizers","nativeHandlers","resolveClasses","useMemo","React","useEffect","effect","deprecationNoticeForDomTarget","process","env","NODE_ENV","console","warn","internalHandlers","get","CoordinatesRecognizer","absX","absY","getKinematics","TAP_DISTANCE_THRESHOLD","persistEvent","persist","DragRecognizer","target","setPointerCapture","_dragTarget","_dragPointerId","hasPointerCapture","releasePointerCapture","cancelable","preventDefault","getEventId","preventScroll","startDrag","setStartState","shouldPreventWindowScrollY","setUpWindowScrollDetection","setUpDelayedDragTrigger","onDragIsStart","onCancel","fireGestureHandler","isValidEvent","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","vx","vy","mx","my","ix","iy","svx","svy","sx","sy","sd","endState","stopPropagation","onDragStart","onDragChange","onDragEnd","onClick","memoizeOne","resultFn","isEqual","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","equal","a","b","constructor","keys","it","next","done","RegExp","source","flags","valueOf","prototype","toString","hasOwnProperty","Element","$$typeof","error","message","match","useDrag","set","buildDragConfig","useRef","memoize","DistanceAngleRecognizer","prev_a","d","delta_a","next_turns","ZOOM_CONSTANT","WEBKIT_DISTANCE_SCALE_FACTOR","PinchRecognizer","every","onPinchEnd","delta_d","prev_d","_delta_d","wheelShouldRun","onWheelEnd","onWheelStart","onWheelChange","getWheelValuesFromEvent","onGestureStart","onGestureChange","onGestureEnd","onPinchStart","onPinchChange","onWheel","usePinch","buildPinchConfig","WheelRecognizer","onEnd","geometry","handleEvent","useWheel","buildWheelConfig","MoveRecognizer","onMoveEnd","onMoveStart","onMoveChange","hoverTransform","onMove","onPointerEnter","onPointerLeave","useMove","buildMoveConfig","useHover","buildHoverConfig","ScrollRecognizer","movementDetection","useScroll","buildScrollConfig","RE_NOT_NATIVE","sortHandlers","native","handle","test","lastMatch","useGesture","_handlers","includeStartEndHandlers","onHover","handlerKey","startKey","endKey"],"mappings":"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","sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nexport function supportsPointerEvents(): boolean {\n  return typeof window !== 'undefined' && 'onpointerdown' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getTouchIds(event: TouchEvent | React.TouchEvent): number[] {\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  if (!A || !B) throw Error(`The event doesn't have two pointers matching the pointerIds`)\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale, event.rotation])\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents, supportsPointerEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 50\nexport const DEFAULT_SWIPE_DURATION = 250\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    const supportsTouch = supportsTouchEvents()\n    const supportsPointer = supportsPointerEvents()\n    if (value && supportsTouch) return true\n    if (supportsTouch && !supportsPointer) return true\n    return false\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n  swipeDuration(value = DEFAULT_SWIPE_DURATION) {\n    return value\n  },\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _threshold: [0, 0],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {\n    this.controller = controller\n    this.args = args\n  }\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband } = this.config\n\n    const {\n      _bounds,\n      _initial,\n      _active,\n      _intentional: wasIntentional,\n      lastOffset,\n      movement: prevMovement,\n      _threshold: _T,\n    } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args, transform }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T],\n  initial?: Vector2\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial: initialFn, bounds, threshold } = config\n\n  // the _threshold is the difference between a [0,0] offset converted to\n  // its new space coordinates\n  const _threshold = subV(transform(threshold), transform([0, 0])).map(Math.abs)\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: initial ?? values,\n    _threshold,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initialFn, _state), _bounds: valueFn(bounds, _state) }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getTouchIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.classes = classes\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // // we also add event bindings for native handlers\n    for (let eventKey in this.nativeRefs) {\n      addBindings(bindings, eventKey, (event: any) => this.nativeRefs[eventKey]({ ...this.state.shared, event, args }))\n    }\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId)\n  } else {\n    controller.touchIds = new Set(getTouchIds(event))\n  }\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.delete(event.pointerId)\n  } else {\n    getTouchIds(event).forEach(id => controller.touchIds.delete(id))\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      (this.state._lastEventType === event.type && event.timeStamp === this.state.timeStamp)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n    const sd = this.config.swipeDuration\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < sd) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n","/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n","/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      // eslint-disable-next-line no-console\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n","import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = useRef<any>()\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.current(config))\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state._movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const { distance, velocity, ...kinematics } = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventValues,\n  getWheelEventValues,\n  getWebkitGestureEventValues,\n  getTouchIds,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, addEventIds, removeEventIds } from '../Controller'\n\nconst ZOOM_CONSTANT = 7\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    addEventIds(this.controller, event)\n    const touchIds = this.controller.touchIds\n\n    if (!this.enabled) return\n\n    if (this.state._active) {\n      // check that the pointerIds that initiated the gesture\n      // are still enabled. This is useful for when the page\n      // loses track of the pointers (minifying gesture on iPad).\n      if (this.state._pointerIds.every(id => touchIds.has(id))) return\n      // something was wrong with the pointers but we let it go.\n    }\n    // until we reach two fingers on the target don't react\n    if (touchIds.size < 2) return\n    const _pointerIds = Array.from(touchIds).slice(0, 2) as [number, number]\n\n    const { values, origin } = getTwoTouchesEventValues(event, _pointerIds, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerIds,\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (\n      canceled ||\n      !_active ||\n      // if the event has the same timestamp as the previous event\n      event.timeStamp === this.state.timeStamp\n    )\n      return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    try {\n      const { values, origin } = getTwoTouchesEventValues(event, this.state._pointerIds, this.transform)\n      const kinematics = this.getKinematics(values, event)\n\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...kinematics,\n        origin,\n      })\n\n      this.fireGestureHandler()\n    } catch (e) {\n      this.onPinchEnd(event)\n    }\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    removeEventIds(this.controller, event)\n    const pointerIds = getTouchIds(event)\n\n    // if none of the lifted pointerIds is in the state pointerIds don't do anything\n    if (this.state._pointerIds.every(id => !pointerIds.includes(id))) return\n\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ _active: false, canceled: true })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    // this normalizes the values of the Safari's WebKitEvent by calculating\n    // the delta and then multiplying it by a constant.\n    const values = getWebkitGestureEventValues(event, this.transform)\n    values[0] =\n      (values[0] - (this.state.event as WebKitGestureEvent).scale) * WEBKIT_DISTANCE_SCALE_FACTOR + this.state.values[0]\n\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event, this.transform)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n    const _delta_d = -delta_d * ZOOM_CONSTANT\n    // new distance is the previous state distance added to the delta\n    const d = prev_d + _delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [_delta_d, a] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event, this.state.values),\n      ...getGenericPayload(this, event, true),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.cancelable) event.preventDefault()\n\n    this.updateSharedState(getGenericEventData(event))\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (\n      this.controller.config.domTarget &&\n      !this.controller.supportsTouchEvents &&\n      this.controller.supportsGestureEvents\n    ) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n","import { UsePinchConfig, Handler, EventTypes } from '../types'\nimport { _buildPinchConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Pinch hook.\n *\n * @param handler - the function fired every time the pinch gesture updates\n * @param [config={}] - the config object including generic options and pinch options\n */\nexport function usePinch<K = EventTypes['pinch']>(handler: Handler<'pinch', K>, config: UsePinchConfig | {} = {}) {\n  RecognizersMap.set('pinch', PinchRecognizer)\n  const buildPinchConfig = useRef<any>()\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoize(_buildPinchConfig, isEqual)\n  }\n  return useRecognizers<UsePinchConfig>({ pinch: handler }, buildPinchConfig.current(config))\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event, this.transform), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n","import { UseWheelConfig, Handler, EventTypes } from '../types'\nimport { _buildWheelConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Wheel hook.\n *\n * @param handler - the function fired every time the wheel gesture updates\n * @param the config object including generic options and wheel options\n */\nexport function useWheel<K = EventTypes['wheel']>(handler: Handler<'wheel', K>, config: UseWheelConfig | {} = {}) {\n  RecognizersMap.set('wheel', WheelRecognizer)\n  const buildWheelConfig = useRef<any>()\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoize(_buildWheelConfig, isEqual)\n  }\n  return useRecognizers<UseWheelConfig>({ wheel: handler }, buildWheelConfig.current(config))\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  hoverTransform = () => {\n    return this.controller.config.hover!.transform || this.controller.config.transform\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event, this.hoverTransform())\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        args: this.args,\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event, this.hoverTransform())\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      args: this.args,\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import { UseMoveConfig, Handler, EventTypes } from '../types'\nimport { _buildMoveConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Move hook.\n *\n * @param handler - the function fired every time the move gesture updates\n * @param [config={}] - the config object including generic options and move options\n */\nexport function useMove<K = EventTypes['move']>(handler: Handler<'move', K>, config: UseMoveConfig | {} = {}) {\n  RecognizersMap.set('move', MoveRecognizer)\n  const buildMoveConfig = useRef<any>()\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoize(_buildMoveConfig, isEqual)\n  }\n  return useRecognizers<UseMoveConfig>({ move: handler }, buildMoveConfig.current(config))\n}\n","import { Handler, UseHoverConfig, EventTypes } from '../types'\nimport { _buildHoverConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Hover hook.\n *\n * @param handler - the function fired every time the hover gesture updates\n * @param [config={}] - the config object including generic options and hover options\n */\nexport function useHover<K = EventTypes['hover']>(handler: Handler<'hover', K>, config: UseHoverConfig | {} = {}) {\n  RecognizersMap.set('hover', MoveRecognizer)\n  const buildHoverConfig = useRef<any>()\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoize(_buildHoverConfig, isEqual)\n  }\n  return useRecognizers<UseHoverConfig>({ hover: handler }, buildHoverConfig.current(config))\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.updateGestureState({ ...this.getMovement(this.state.values), _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n","import { UseScrollConfig, Handler, EventTypes } from '../types'\nimport { _buildScrollConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Scroll hook.\n *\n * @param handler - the function fired every time the scroll gesture updates\n * @param [config={}] - the config object including generic options and scroll options\n */\nexport function useScroll<K = EventTypes['scroll']>(handler: Handler<'scroll', K>, config: UseScrollConfig | {} = {}) {\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  const buildScrollConfig = useRef<any>()\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoize(_buildScrollConfig, isEqual)\n  }\n  return useRecognizers<UseScrollConfig>({ scroll: handler }, buildScrollConfig.current(config))\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"]},"metadata":{},"sourceType":"module"}