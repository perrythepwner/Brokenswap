{"ast":null,"code":"import _objectSpread from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n  a: _0n,\n  b: BigInt(7),\n  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  splitScalar(k) {\n    const {\n      n\n    } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg) k1 = n - k1;\n    if (k2neg) k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    };\n  }\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n  const {\n    a,\n    b\n  } = CURVE;\n  const x2 = mod(x * x);\n  const x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nfunction assertJacPoint(other) {\n  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('JacobianPoint#fromAffine: expected Point');\n    }\n    if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n    return new JacobianPoint(p.x, p.y, _1n);\n  }\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n  static normalizeZ(points) {\n    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n  }\n  equals(other) {\n    assertJacPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const Z1Z1 = mod(Z1 * Z1);\n    const Z2Z2 = mod(Z2 * Z2);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    return U1 === U2 && S1 === S2;\n  }\n  negate() {\n    return new JacobianPoint(this.x, mod(-this.y), this.z);\n  }\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const A = mod(X1 * X1);\n    const B = mod(Y1 * Y1);\n    const C = mod(B * B);\n    const x1b = X1 + B;\n    const D = mod(_2n * (mod(x1b * x1b) - A - C));\n    const E = mod(_3n * A);\n    const F = mod(E * E);\n    const X3 = mod(F - _2n * D);\n    const Y3 = mod(E * (D - X3) - _8n * C);\n    const Z3 = mod(_2n * Y1 * Z1);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n  add(other) {\n    assertJacPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    if (X2 === _0n || Y2 === _0n) return this;\n    if (X1 === _0n || Y1 === _0n) return other;\n    const Z1Z1 = mod(Z1 * Z1);\n    const Z2Z2 = mod(Z2 * Z2);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    const H = mod(U2 - U1);\n    const r = mod(S2 - S1);\n    if (H === _0n) {\n      if (r === _0n) {\n        return this.double();\n      } else {\n        return JacobianPoint.ZERO;\n      }\n    }\n    const HH = mod(H * H);\n    const HHH = mod(H * HH);\n    const V = mod(U1 * HH);\n    const X3 = mod(r * r - HHH - _2n * V);\n    const Y3 = mod(r * (V - X3) - S1 * HHH);\n    const Z3 = mod(Z1 * Z2 * H);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiplyUnsafe(scalar) {\n    const P0 = JacobianPoint.ZERO;\n    if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n    let n = normalizeScalar(scalar);\n    if (n === _1n) return this;\n    if (!USE_ENDOMORPHISM) {\n      let p = P0;\n      let d = this;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    }\n    let {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    } = endo.splitScalar(n);\n    let k1p = P0;\n    let k2p = P0;\n    let d = this;\n    while (k1 > _0n || k2 > _0n) {\n      if (k1 & _1n) k1p = k1p.add(d);\n      if (k2 & _1n) k2p = k2p.add(d);\n      d = d.double();\n      k1 >>= _1n;\n      k2 >>= _1n;\n    }\n    if (k1neg) k1p = k1p.negate();\n    if (k2neg) k2p = k2p.negate();\n    k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n    return k1p.add(k2p);\n  }\n  precomputeWindow(W) {\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    const points = [];\n    let p = this;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n      if (affinePoint && W !== 1) {\n        precomputes = JacobianPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n    let p = JacobianPoint.ZERO;\n    let f = JacobianPoint.BASE;\n    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n      const offset1 = offset;\n      const offset2 = offset + Math.abs(wbits) - 1;\n      const cond1 = window % 2 !== 0;\n      const cond2 = wbits < 0;\n      if (wbits === 0) {\n        f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n      } else {\n        p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n      }\n    }\n    return {\n      p,\n      f\n    };\n  }\n  multiply(scalar, affinePoint) {\n    let n = normalizeScalar(scalar);\n    let point;\n    let fake;\n    if (USE_ENDOMORPHISM) {\n      const {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(n);\n      let {\n        p: k1p,\n        f: f1p\n      } = this.wNAF(k1, affinePoint);\n      let {\n        p: k2p,\n        f: f2p\n      } = this.wNAF(k2, affinePoint);\n      k1p = constTimeNegate(k1neg, k1p);\n      k2p = constTimeNegate(k2neg, k2p);\n      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n      point = k1p.add(k2p);\n      fake = f1p.add(f2p);\n    } else {\n      const {\n        p,\n        f\n      } = this.wNAF(n, affinePoint);\n      point = p;\n      fake = f;\n    }\n    return JacobianPoint.normalizeZ([point, fake])[0];\n  }\n  toAffine(invZ) {\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const is0 = this.equals(JacobianPoint.ZERO);\n    if (invZ == null) invZ = is0 ? _8n : invert(z);\n    const iz1 = invZ;\n    const iz2 = mod(iz1 * iz1);\n    const iz3 = mod(iz2 * iz1);\n    const ax = mod(x * iz2);\n    const ay = mod(y * iz3);\n    const zz = mod(z * iz1);\n    if (is0) return Point.ZERO;\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n  hasEvenY() {\n    return this.y % _2n === _0n;\n  }\n  static fromCompressedHex(bytes) {\n    const isShort = bytes.length === 32;\n    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n    if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n    const y2 = weierstrass(x);\n    let y = sqrtMod(y2);\n    const isYOdd = (y & _1n) === _1n;\n    if (isShort) {\n      if (isYOdd) y = mod(-y);\n    } else {\n      const isFirstByteOdd = (bytes[0] & 1) === 1;\n      if (isFirstByteOdd !== isYOdd) y = mod(-y);\n    }\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n  static fromUncompressedHex(bytes) {\n    const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n    const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    const len = bytes.length;\n    const header = bytes[0];\n    if (len === fieldLen) return this.fromCompressedHex(bytes);\n    if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n      return this.fromCompressedHex(bytes);\n    }\n    if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n    throw new Error(\"Point.fromHex: received invalid point. Expected 32-\".concat(compressedLen, \" compressed bytes or \").concat(uncompressedLen, \" uncompressed bytes, not \").concat(len));\n  }\n  static fromPrivateKey(privateKey) {\n    return Point.BASE.multiply(normalizePrivateKey(privateKey));\n  }\n  static fromSignature(msgHash, signature, recovery) {\n    const {\n      r,\n      s\n    } = normalizeSignature(signature);\n    if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');\n    const h = truncateHash(ensureBytes(msgHash));\n    const {\n      n\n    } = CURVE;\n    const radj = recovery === 2 || recovery === 3 ? r + n : r;\n    const rinv = invert(radj, n);\n    const u1 = mod(-h * rinv, n);\n    const u2 = mod(s * rinv, n);\n    const prefix = recovery & 1 ? '03' : '02';\n    const R = Point.fromHex(prefix + numTo32bStr(radj));\n    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n    if (!Q) throw new Error('Cannot recover signature: point at infinify');\n    Q.assertValidity();\n    return Q;\n  }\n  toRawBytes() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return hexToBytes(this.toHex(isCompressed));\n  }\n  toHex() {\n    let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const x = numTo32bStr(this.x);\n    if (isCompressed) {\n      const prefix = this.hasEvenY() ? '02' : '03';\n      return \"\".concat(prefix).concat(x);\n    } else {\n      return \"04\".concat(x).concat(numTo32bStr(this.y));\n    }\n  }\n  toHexX() {\n    return this.toHex(true).slice(2);\n  }\n  toRawX() {\n    return this.toRawBytes(true).slice(1);\n  }\n  assertValidity() {\n    const msg = 'Point is not on elliptic curve';\n    const {\n      x,\n      y\n    } = this;\n    if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n    const left = mod(y * y);\n    const right = weierstrass(x);\n    if (mod(left - right) !== _0n) throw new Error(msg);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  negate() {\n    return new Point(this.x, mod(-this.y));\n  }\n  double() {\n    return JacobianPoint.fromAffine(this).double().toAffine();\n  }\n  add(other) {\n    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiply(scalar) {\n    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n  multiplyAndAddUnsafe(Q, a, b) {\n    const P = JacobianPoint.fromAffine(this);\n    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n    const sum = aP.add(bQ);\n    return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n  }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(\"Invalid signature integer tag: \".concat(bytesToHex(data)));\n  }\n  const len = data[1];\n  const res = data.subarray(2, len + 2);\n  if (!len || res.length !== len) {\n    throw new Error(\"Invalid signature integer: wrong length\");\n  }\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(\"Invalid signature tag: \".concat(bytesToHex(data)));\n  }\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n  const {\n    data: r,\n    left: sBytes\n  } = parseDERInt(data.subarray(2));\n  const {\n    data: s,\n    left: rBytesLeft\n  } = parseDERInt(sBytes);\n  if (rBytesLeft.length) {\n    throw new Error(\"Invalid signature: left bytes after parsing: \".concat(bytesToHex(rBytesLeft)));\n  }\n  return {\n    r,\n    s\n  };\n}\nexport class Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromCompact(hex) {\n    const arr = hex instanceof Uint8Array;\n    const name = 'Signature.fromCompact';\n    if (typeof hex !== 'string' && !arr) throw new TypeError(\"\".concat(name, \": Expected string or Uint8Array\"));\n    const str = arr ? bytesToHex(hex) : hex;\n    if (str.length !== 128) throw new Error(\"\".concat(name, \": Expected 64-byte hex\"));\n    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n  }\n  static fromDER(hex) {\n    const arr = hex instanceof Uint8Array;\n    if (typeof hex !== 'string' && !arr) throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");\n    const {\n      r,\n      s\n    } = parseDERSignature(arr ? hex : hexToBytes(hex));\n    return new Signature(r, s);\n  }\n  static fromHex(hex) {\n    return this.fromDER(hex);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n    if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n  }\n  hasHighS() {\n    const HALF = CURVE.n >> _1n;\n    return this.s > HALF;\n  }\n  normalizeS() {\n    return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n  }\n  toDERRawBytes() {\n    return hexToBytes(this.toDERHex());\n  }\n  toDERHex() {\n    const sHex = sliceDER(numberToHexUnpadded(this.s));\n    const rHex = sliceDER(numberToHexUnpadded(this.r));\n    const sHexL = sHex.length / 2;\n    const rHexL = rHex.length / 2;\n    const sLen = numberToHexUnpadded(sHexL);\n    const rLen = numberToHexUnpadded(rHexL);\n    const length = numberToHexUnpadded(rHexL + sHexL + 4);\n    return \"30\".concat(length, \"02\").concat(rLen).concat(rHex, \"02\").concat(sLen).concat(sHex);\n  }\n  toRawBytes() {\n    return this.toDERRawBytes();\n  }\n  toHex() {\n    return this.toDERHex();\n  }\n  toCompactRawBytes() {\n    return hexToBytes(this.toCompactHex());\n  }\n  toCompactHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n}\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (!arrays.every(b => b instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n  const b = hexToBytes(numTo32bStr(num));\n  if (b.length !== 32) throw new Error('Error: expected 32 bytes');\n  return b;\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(\"0x\".concat(hex));\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction sqrtMod(x) {\n  const {\n    P\n  } = CURVE;\n  const _6n = BigInt(6);\n  const _11n = BigInt(11);\n  const _22n = BigInt(22);\n  const _23n = BigInt(23);\n  const _44n = BigInt(44);\n  const _88n = BigInt(88);\n  const b2 = x * x * x % P;\n  const b3 = b2 * b2 * x % P;\n  const b6 = pow2(b3, _3n) * b3 % P;\n  const b9 = pow2(b6, _3n) * b3 % P;\n  const b11 = pow2(b9, _2n) * b2 % P;\n  const b22 = pow2(b11, _11n) * b11 % P;\n  const b44 = pow2(b22, _22n) * b22 % P;\n  const b88 = pow2(b44, _44n) * b44 % P;\n  const b176 = pow2(b88, _88n) * b88 % P;\n  const b220 = pow2(b176, _44n) * b44 % P;\n  const b223 = pow2(b220, _3n) * b3 % P;\n  const t1 = pow2(b223, _23n) * b22 % P;\n  const t2 = pow2(t1, _6n) * b2 % P;\n  const rt = pow2(t2, _2n);\n  const xc = rt * rt % P;\n  if (xc !== x) throw new Error('Cannot find square root');\n  return rt;\n}\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums) {\n  let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const scratch = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\nfunction bits2int_2(bytes) {\n  const delta = bytes.length * 8 - groupLen * 8;\n  const num = bytesToNumber(bytes);\n  return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash) {\n  let truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const h = bits2int_2(hash);\n  if (truncateOnly) return h;\n  const {\n    n\n  } = CURVE;\n  return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n  constructor(hashLen, qByteLen) {\n    this.hashLen = hashLen;\n    this.qByteLen = qByteLen;\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    this.v = new Uint8Array(hashLen).fill(1);\n    this.k = new Uint8Array(hashLen).fill(0);\n    this.counter = 0;\n  }\n  hmac() {\n    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      values[_key2] = arguments[_key2];\n    }\n    return utils.hmacSha256(this.k, ...values);\n  }\n  hmacSync() {\n    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n    return _hmacSha256Sync(this.k, ...values);\n  }\n  checkSync() {\n    if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');\n  }\n  incr() {\n    if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');\n    this.counter += 1;\n  }\n  reseed() {\n    var _arguments = arguments,\n      _this = this;\n    return _asyncToGenerator(function* () {\n      let seed = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : new Uint8Array();\n      _this.k = yield _this.hmac(_this.v, Uint8Array.from([0x00]), seed);\n      _this.v = yield _this.hmac(_this.v);\n      if (seed.length === 0) return;\n      _this.k = yield _this.hmac(_this.v, Uint8Array.from([0x01]), seed);\n      _this.v = yield _this.hmac(_this.v);\n    })();\n  }\n  reseedSync() {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n    this.checkSync();\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n    this.v = this.hmacSync(this.v);\n    if (seed.length === 0) return;\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n    this.v = this.hmacSync(this.v);\n  }\n  generate() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.incr();\n      let len = 0;\n      const out = [];\n      while (len < _this2.qByteLen) {\n        _this2.v = yield _this2.hmac(_this2.v);\n        const sl = _this2.v.slice();\n        out.push(sl);\n        len += _this2.v.length;\n      }\n      return concatBytes(...out);\n    })();\n  }\n  generateSync() {\n    this.checkSync();\n    this.incr();\n    let len = 0;\n    const out = [];\n    while (len < this.qByteLen) {\n      this.v = this.hmacSync(this.v);\n      const sl = this.v.slice();\n      out.push(sl);\n      len += this.v.length;\n    }\n    return concatBytes(...out);\n  }\n}\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n  let lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const {\n    n\n  } = CURVE;\n  const k = truncateHash(kBytes, true);\n  if (!isWithinCurveOrder(k)) return;\n  const kinv = invert(k, n);\n  const q = Point.BASE.multiply(k);\n  const r = mod(q.x, n);\n  if (r === _0n) return;\n  const s = mod(kinv * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  let sig = new Signature(r, s);\n  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  if (lowS && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n  return {\n    sig,\n    recovery\n  };\n}\nfunction normalizePrivateKey(key) {\n  let num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\nexport function getPublicKey(privateKey) {\n  let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery) {\n  let isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n  const arr = item instanceof Uint8Array;\n  const str = typeof item === 'string';\n  const len = (arr || str) && item.length;\n  if (arr) return len === compressedLen || len === uncompressedLen;\n  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n  if (item instanceof Point) return true;\n  return false;\n}\nexport function getSharedSecret(privateA, publicB) {\n  let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  const b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n  const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n  return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n  const z1 = bits2int(bytes);\n  const z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n  return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(\"sign: expected valid message hash, not \\\"\".concat(msgHash, \"\\\"\"));\n  const h1 = ensureBytes(msgHash);\n  const d = normalizePrivateKey(privateKey);\n  const seedArgs = [int2octets(d), bits2octets(h1)];\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);\n    const e = ensureBytes(extraEntropy);\n    if (e.length !== fieldLen) throw new Error(\"sign: Expected \".concat(fieldLen, \" bytes of extra data\"));\n    seedArgs.push(e);\n  }\n  const seed = concatBytes(...seedArgs);\n  const m = bits2int(h1);\n  return {\n    seed,\n    m,\n    d\n  };\n}\nfunction finalizeSig(recSig, opts) {\n  const {\n    sig,\n    recovery\n  } = recSig;\n  const {\n    der,\n    recovered\n  } = Object.assign({\n    canonical: true,\n    der: true\n  }, opts);\n  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\nfunction sign(_x, _x2) {\n  return _sign.apply(this, arguments);\n}\nfunction _sign() {\n  _sign = _asyncToGenerator(function* (msgHash, privKey) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      seed,\n      m,\n      d\n    } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    yield drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(yield drbg.generate(), m, d, opts.canonical))) yield drbg.reseed();\n    return finalizeSig(sig, opts);\n  });\n  return _sign.apply(this, arguments);\n}\nfunction signSync(msgHash, privKey) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  const drbg = new HmacDrbg(hashLen, groupLen);\n  drbg.reseedSync(seed);\n  let sig;\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();\n  return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = {\n  strict: true\n};\nexport function verify(signature, msgHash, publicKey) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  let sig;\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n  const {\n    r,\n    s\n  } = sig;\n  if (opts.strict && sig.hasHighS()) return false;\n  const h = truncateHash(msgHash);\n  let P;\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n  const {\n    n\n  } = CURVE;\n  const sinv = invert(s, n);\n  const u1 = mod(h * sinv, n);\n  const u2 = mod(r * sinv, n);\n  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  const v = mod(R.x, n);\n  return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    if (bytes.length !== 64) throw new TypeError(\"SchnorrSignature.fromHex: expected 64 bytes, not \".concat(bytes.length));\n    const r = bytesToNumber(bytes.subarray(0, 32));\n    const s = bytesToNumber(bytes.subarray(32, 64));\n    return new SchnorrSignature(r, s);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n  }\n  toHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n  toRawBytes() {\n    return hexToBytes(this.toHex());\n  }\n}\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n  constructor(message, privateKey) {\n    let auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.randomBytes();\n    if (message == null) throw new TypeError(\"sign: Expected valid message, not \\\"\".concat(message, \"\\\"\"));\n    this.m = ensureBytes(message);\n    const {\n      x,\n      scalar\n    } = this.getScalar(normalizePrivateKey(privateKey));\n    this.px = x;\n    this.d = scalar;\n    this.rand = ensureBytes(auxRand);\n    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  }\n  getScalar(priv) {\n    const point = Point.fromPrivateKey(priv);\n    const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n    return {\n      point,\n      scalar,\n      x: point.toRawX()\n    };\n  }\n  initNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n  }\n  finalizeNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n    const {\n      point: R,\n      x: rx,\n      scalar: k\n    } = this.getScalar(k0);\n    return {\n      R,\n      rx,\n      k\n    };\n  }\n  finalizeSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n  }\n  error() {\n    throw new Error('sign: Invalid signature produced');\n  }\n  calc() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        m,\n        d,\n        px,\n        rand\n      } = _this3;\n      const tag = utils.taggedHash;\n      const t = _this3.initNonce(d, yield tag(TAGS.aux, rand));\n      const {\n        R,\n        rx,\n        k\n      } = _this3.finalizeNonce(yield tag(TAGS.nonce, t, px, m));\n      const e = schnorrChallengeFinalize(yield tag(TAGS.challenge, rx, px, m));\n      const sig = _this3.finalizeSig(R, k, e, d);\n      if (!(yield schnorrVerify(sig, m, px))) _this3.error();\n      return sig;\n    })();\n  }\n  calcSync() {\n    const {\n      m,\n      d,\n      px,\n      rand\n    } = this;\n    const tag = utils.taggedHashSync;\n    const t = this.initNonce(d, tag(TAGS.aux, rand));\n    const {\n      R,\n      rx,\n      k\n    } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n    const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n    const sig = this.finalizeSig(R, k, e, d);\n    if (!schnorrVerifySync(sig, m, px)) this.error();\n    return sig;\n  }\n}\nfunction schnorrSign(_x3, _x4, _x5) {\n  return _schnorrSign.apply(this, arguments);\n}\nfunction _schnorrSign() {\n  _schnorrSign = _asyncToGenerator(function* (msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n  });\n  return _schnorrSign.apply(this, arguments);\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n  const raw = signature instanceof SchnorrSignature;\n  const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return _objectSpread(_objectSpread({}, sig), {}, {\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  });\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !R.hasEvenY() || R.x !== r) return false;\n  return true;\n}\nfunction schnorrVerify(_x6, _x7, _x8) {\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction _schnorrVerify() {\n  _schnorrVerify = _asyncToGenerator(function* (signature, message, publicKey) {\n    try {\n      const {\n        r,\n        s,\n        m,\n        P\n      } = initSchnorrVerify(signature, message, publicKey);\n      const e = schnorrChallengeFinalize(yield utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n      return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n      return false;\n    }\n  });\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    if (error instanceof ShaError) throw error;\n    return false;\n  }\n}\nexport const schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nconst TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  mod,\n  invert,\n  isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  _bigintTo32Bytes: numTo32b,\n  _normalizePrivateKey: normalizePrivateKey,\n  hashToPrivateKey: hash => {\n    hash = ensureBytes(hash);\n    const minLen = groupLen + 8;\n    if (hash.length < minLen || hash.length > 1024) {\n      throw new Error(\"Expected valid bytes of private key as per FIPS 186\");\n    }\n    const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n    return numTo32b(num);\n  },\n  randomBytes: function randomBytes() {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_3n);\n    return cached;\n  },\n  sha256: function () {\n    var _sha = _asyncToGenerator(function* () {\n      for (var _len4 = arguments.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        messages[_key4] = arguments[_key4];\n      }\n      if (crypto.web) {\n        const buffer = yield crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n        return new Uint8Array(buffer);\n      } else if (crypto.node) {\n        const {\n          createHash\n        } = crypto.node;\n        const hash = createHash('sha256');\n        messages.forEach(m => hash.update(m));\n        return Uint8Array.from(hash.digest());\n      } else {\n        throw new Error(\"The environment doesn't have sha256 function\");\n      }\n    });\n    function sha256() {\n      return _sha.apply(this, arguments);\n    }\n    return sha256;\n  }(),\n  hmacSha256: function () {\n    var _hmacSha = _asyncToGenerator(function* (key) {\n      for (var _len5 = arguments.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        messages[_key5 - 1] = arguments[_key5];\n      }\n      if (crypto.web) {\n        const ckey = yield crypto.web.subtle.importKey('raw', key, {\n          name: 'HMAC',\n          hash: {\n            name: 'SHA-256'\n          }\n        }, false, ['sign']);\n        const message = concatBytes(...messages);\n        const buffer = yield crypto.web.subtle.sign('HMAC', ckey, message);\n        return new Uint8Array(buffer);\n      } else if (crypto.node) {\n        const {\n          createHmac\n        } = crypto.node;\n        const hash = createHmac('sha256', key);\n        messages.forEach(m => hash.update(m));\n        return Uint8Array.from(hash.digest());\n      } else {\n        throw new Error(\"The environment doesn't have hmac-sha256 function\");\n      }\n    });\n    function hmacSha256(_x9) {\n      return _hmacSha.apply(this, arguments);\n    }\n    return hmacSha256;\n  }(),\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: function () {\n    var _taggedHash = _asyncToGenerator(function* (tag) {\n      let tagP = TAGGED_HASH_PREFIXES[tag];\n      if (tagP === undefined) {\n        const tagH = yield utils.sha256(Uint8Array.from(tag, c => c.charCodeAt(0)));\n        tagP = concatBytes(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n      }\n      for (var _len6 = arguments.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        messages[_key6 - 1] = arguments[_key6];\n      }\n      return utils.sha256(tagP, ...messages);\n    });\n    function taggedHash(_x10) {\n      return _taggedHash.apply(this, arguments);\n    }\n    return taggedHash;\n  }(),\n  taggedHashSync: function taggedHashSync(tag) {\n    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      const tagH = _sha256Sync(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n    return _sha256Sync(tagP, ...messages);\n  },\n  _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(utils, {\n  sha256Sync: {\n    configurable: false,\n    get() {\n      return _sha256Sync;\n    },\n    set(val) {\n      if (!_sha256Sync) _sha256Sync = val;\n    }\n  },\n  hmacSha256Sync: {\n    configurable: false,\n    get() {\n      return _hmacSha256Sync;\n    },\n    set(val) {\n      if (!_hmacSha256Sync) _hmacSha256Sync = val;\n    }\n  }\n});","map":{"version":3,"names":["nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","CURVE","Object","freeze","a","b","P","n","h","Gx","Gy","beta","divNearest","endo","splitScalar","k","a1","b1","a2","b2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","Error","fieldLen","groupLen","hashLen","compressedLen","uncompressedLen","weierstrass","x","x2","x3","USE_ENDOMORPHISM","ShaError","constructor","message","assertJacPoint","other","JacobianPoint","TypeError","y","z","fromAffine","p","Point","equals","ZERO","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","A","B","C","x1b","D","E","F","X3","Y3","Z3","add","H","r","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","d","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","Math","abs","cond1","cond2","constTimeNegate","multiply","point","fake","f1p","f2p","invZ","is0","invert","iz1","iz2","iz3","ax","ay","zz","condition","item","neg","WeakMap","_setWindowSize","delete","hasEvenY","fromCompressedHex","bytes","isShort","length","bytesToNumber","subarray","isValidFieldElement","y2","sqrtMod","isYOdd","isFirstByteOdd","assertValidity","fromUncompressedHex","fromHex","hex","ensureBytes","len","header","concat","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","s","normalizeSignature","includes","truncateHash","radj","rinv","u1","u2","prefix","R","numTo32bStr","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","arguments","undefined","hexToBytes","toHex","toHexX","slice","toRawX","msg","left","right","aP","bQ","sum","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","sBytes","rBytesLeft","Signature","fromCompact","arr","Uint8Array","name","str","hexToNumber","fromDER","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","sHexL","rHexL","sLen","rLen","toCompactRawBytes","toCompactHex","concatBytes","_len","arrays","Array","_key","every","reduce","result","pad","hexes","from","v","toString","padStart","uint8a","POW_2_256","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","rt","xc","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","bits2int_2","delta","hash","truncateOnly","_sha256Sync","_hmacSha256Sync","HmacDrbg","qByteLen","fill","counter","hmac","_len2","values","_key2","utils","hmacSha256","hmacSync","_len3","_key3","checkSync","incr","reseed","_arguments","_this","_asyncToGenerator","seed","reseedSync","generate","_this2","out","sl","generateSync","kmdToSig","kBytes","lowS","kinv","sig","key","normalizePublicKey","publicKey","error","getPublicKey","recoverPublicKey","isProbPub","getSharedSecret","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","der","recovered","assign","canonical","hashed","sign","_x","_x2","_sign","apply","privKey","drbg","signSync","vopts","strict","verify","sinv","schnorrChallengeFinalize","ch","SchnorrSignature","schnorrGetPublicKey","InternalSchnorrSignature","auxRand","getScalar","px","rand","priv","initNonce","t0h","finalizeNonce","k0h","k0","rx","calc","_this3","tag","taggedHash","t","TAGS","aux","nonce","challenge","schnorrVerify","calcSync","taggedHashSync","schnorrVerifySync","schnorrSign","_x3","_x4","_x5","_schnorrSign","schnorrSignSync","initSchnorrVerify","raw","_objectSpread","finalizeSchnorrVerify","_x6","_x7","_x8","_schnorrVerify","schnorr","verifySync","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","minLen","bytesLength","getRandomValues","randomPrivateKey","precompute","cached","sha256","_sha","_len4","messages","_key4","buffer","subtle","digest","createHash","forEach","update","_hmacSha","_len5","_key5","ckey","importKey","createHmac","_x9","sha256Sync","hmacSha256Sync","_taggedHash","tagP","tagH","c","charCodeAt","_len6","_key6","_x10","_len7","_key7","_JacobianPoint","defineProperties","configurable","val"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}