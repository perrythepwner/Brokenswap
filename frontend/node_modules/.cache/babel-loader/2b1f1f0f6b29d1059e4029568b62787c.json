{"ast":null,"code":"import _objectSpread from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{useCelo,useProvider}from'@celo/react-celo';import{currencyEquals,JSBI,Pair,Percent,Price,Token,TokenAmount,TradeType}from'@ubeswap/sdk';import{ERC20_ABI}from'constants/abis/erc20';import{BASES_TO_CHECK_TRADES_AGAINST,BETTER_TRADE_LESS_HOPS_THRESHOLD,DEXES_TO_EXCLUDE,FETCH_MINIMA_ROUTER_TIMER,MINIMA_API_URL,UBESWAP_MOOLA_ROUTER_ADDRESS}from'constants/index';import{PairState,usePairs}from'data/Reserves';import{BigNumber,ethers}from'ethers';import{useAllTokens}from'hooks/Tokens';import _ from'lodash';import flatMap from'lodash.flatmap';import React,{useMemo}from'react';import{useUserDisableSmartRouting,useUserSingleHopOnly,useUserSlippageTolerance}from'state/user/hooks';import{getProviderOrSigner,isBTest}from'utils';import{isTradeBetter}from'utils/trades';import{MoolaDirectTrade}from'../moola/MoolaDirectTrade';import{getMoolaDual}from'../moola/useMoola';import{useMoolaDirectRoute}from'../moola/useMoolaDirectRoute';import{UbeswapTrade}from'../trade';import{MinimaRouterTrade}from'./../trade';import{bestTradeExactIn,bestTradeExactOut}from'./calculateBestTrades';import{useDirectTradeExactIn,useDirectTradeExactOut}from'./directTrades';/**\n * Uses all common pairs between the two tokens, plus searches the moola duals\n * @param tokenA\n * @param tokenB\n * @returns\n */export function useAllCommonPairsWithMoolaDuals(tokenA,tokenB){const{network}=useCelo();const chainId=network.chainId;const bases=useMemo(()=>chainId?BASES_TO_CHECK_TRADES_AGAINST[chainId]:[],[chainId]);const basePairs=useMemo(()=>flatMap(bases,base=>bases.map(otherBase=>[base,otherBase])).filter(_ref=>{var _getMoolaDual,_getMoolaDual2;let[t0,t1]=_ref;return t0.address!==t1.address&&// ensure we don't fetch duals\nt0.address!==((_getMoolaDual=getMoolaDual(t1))===null||_getMoolaDual===void 0?void 0:_getMoolaDual.address)&&t1.address!==((_getMoolaDual2=getMoolaDual(t0))===null||_getMoolaDual2===void 0?void 0:_getMoolaDual2.address);}),[bases]);const tokenADual=tokenA&&getMoolaDual(tokenA);const tokenBDual=tokenB&&getMoolaDual(tokenB);const allPairCombinations=useMemo(()=>tokenA&&tokenB?[// the direct pair\n[tokenA,tokenB],// token A against all bases\n...bases.map(base=>[tokenA,base]),// token B against all bases\n...bases.map(base=>[tokenB,base]),// each base against all bases\n...basePairs,// handle duals\n// direct pair\n...(tokenADual?[[tokenADual,tokenB]]:[]),...(tokenBDual?[[tokenA,tokenBDual]]:[]),...(tokenADual&&tokenBDual?[[tokenADual,tokenBDual]]:[]),// token A against all bases\n...bases.map(base=>[tokenA,base]),...(tokenADual?bases.map(base=>[tokenADual,base]):[]),// token B against all bases\n...bases.map(base=>[tokenB,base]),...(tokenBDual?bases.map(base=>[tokenBDual,base]):[])].filter(tokens=>Boolean(tokens[0]&&tokens[1])).filter(_ref2=>{let[t0,t1]=_ref2;return t0.address!==t1.address;}):[],[tokenA,tokenB,bases,basePairs,tokenADual,tokenBDual]);const allPairs=usePairs(allPairCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(()=>Object.values(allPairs// filter out invalid pairs\n.filter(result=>Boolean(result[0]===PairState.EXISTS&&result[1]))// filter out duplicated pairs\n.reduce((memo,_ref3)=>{var _memo$curr$liquidityT;let[,curr]=_ref3;memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{})),[allPairs]);}const MAX_HOPS=3;const moolaRouter={routerAddress:UBESWAP_MOOLA_ROUTER_ADDRESS};export class MoolaRouterTrade extends UbeswapTrade{/**\n   *\n   * @param originalTokenIn If null, the original token is the path token\n   * @param originalTokenOut If null, the original token is the path token\n   * @param innerTrade\n   */constructor(originalTokenIn,originalTokenOut,innerTrade){super(innerTrade.route,innerTrade.tradeType===TradeType.EXACT_INPUT?innerTrade.inputAmount:innerTrade.outputAmount,innerTrade.tradeType,moolaRouter,[...(originalTokenIn?[originalTokenIn]:[]),...innerTrade.route.path,...(originalTokenOut?[originalTokenOut]:[])]);this.originalTokenIn=originalTokenIn;this.originalTokenOut=originalTokenOut;this.innerTrade=innerTrade;this.inputAmount=void 0;this.outputAmount=void 0;this.executionPrice=void 0;this.inputAmount=new TokenAmount(originalTokenIn!==null&&originalTokenIn!==void 0?originalTokenIn:innerTrade.inputAmount.token,innerTrade.inputAmount.raw);this.outputAmount=new TokenAmount(originalTokenOut!==null&&originalTokenOut!==void 0?originalTokenOut:innerTrade.outputAmount.token,innerTrade.outputAmount.raw);const baseIsInput=currencyEquals(innerTrade.executionPrice.baseCurrency,innerTrade.inputAmount.token);this.executionPrice=new Price(baseIsInput?this.inputAmount.token:this.outputAmount.token,!baseIsInput?this.inputAmount.token:this.outputAmount.token,innerTrade.executionPrice.denominator,innerTrade.executionPrice.numerator);}/**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */minimumAmountOut(slippageTolerance){var _this$originalTokenOu;const amt=this.innerTrade.minimumAmountOut(slippageTolerance);return new TokenAmount((_this$originalTokenOu=this.originalTokenOut)!==null&&_this$originalTokenOu!==void 0?_this$originalTokenOu:amt.token,amt.raw);}/**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */maximumAmountIn(slippageTolerance){var _this$originalTokenIn;const amt=this.innerTrade.maximumAmountIn(slippageTolerance);return new TokenAmount((_this$originalTokenIn=this.originalTokenIn)!==null&&_this$originalTokenIn!==void 0?_this$originalTokenIn:amt.token,amt.raw);}}/**\n * Converts the trade to a Moola Router trade, if the original tokens are lost\n * @param originalTokenIn\n * @param originalTokenOut\n * @param trade\n * @returns\n */const convertToMoolaRouterTradeIfApplicable=(originalTokenIn,originalTokenOut,trade)=>{const inUnchanged=trade.inputAmount.token.address===originalTokenIn.address;const outUnchanged=trade.outputAmount.token.address===originalTokenOut.address;if(inUnchanged&&outUnchanged){return trade;}return new MoolaRouterTrade(inUnchanged?originalTokenIn:null,outUnchanged?originalTokenOut:null,trade);};/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useUbeswapTradeExactIn(tokenAmountIn,tokenOut){const[disableSmartRouting]=useUserDisableSmartRouting();const directTrade=useDirectTradeExactIn(tokenAmountIn,tokenOut);const allowedPairs=useAllCommonPairsWithMoolaDuals(tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.token,tokenOut);const[singleHopOnly]=useUserSingleHopOnly();const moolaRoute=useMoolaDirectRoute(tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.token,tokenOut);return useMemo(()=>{const bestTrade=(()=>{if(disableSmartRouting){return directTrade;}if(tokenAmountIn&&tokenOut&&allowedPairs.length>0){if(singleHopOnly){const singleHopTrade=bestTradeExactIn(allowedPairs.slice(),tokenAmountIn,tokenOut,directTrade,{maxHops:1,maxNumResults:1,minimumDelta:BETTER_TRADE_LESS_HOPS_THRESHOLD});return singleHopTrade?convertToMoolaRouterTradeIfApplicable(tokenAmountIn.token,tokenOut,singleHopTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){const currentTrade=bestTradeExactIn(allowedPairs.slice(),tokenAmountIn,tokenOut,directTrade,{maxHops:i,maxNumResults:1,minimumDelta:BETTER_TRADE_LESS_HOPS_THRESHOLD});// if current trade is best yet, save it\nif(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;})();if(moolaRoute&&tokenAmountIn){try{const moolaTrade=MoolaDirectTrade.fromIn(moolaRoute,tokenAmountIn);if(isTradeBetter(bestTrade,moolaTrade,new Percent('0'))){return moolaTrade;}}catch(e){console.warn(e);}}return bestTrade;},[allowedPairs,tokenAmountIn,tokenOut,singleHopOnly,directTrade,disableSmartRouting,moolaRoute]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useUbeswapTradeExactOut(tokenIn,tokenAmountOut){const[disableSmartRouting]=useUserDisableSmartRouting();const directTrade=useDirectTradeExactOut(tokenIn,tokenAmountOut);const allowedPairs=useAllCommonPairsWithMoolaDuals(tokenIn,tokenAmountOut===null||tokenAmountOut===void 0?void 0:tokenAmountOut.token);const[singleHopOnly]=useUserSingleHopOnly();const moolaRoute=useMoolaDirectRoute(tokenIn,tokenAmountOut===null||tokenAmountOut===void 0?void 0:tokenAmountOut.token);return useMemo(()=>{const bestTrade=(()=>{if(disableSmartRouting){return directTrade;}if(tokenIn&&tokenAmountOut&&allowedPairs.length>0){if(singleHopOnly){const singleHopTrade=bestTradeExactOut(allowedPairs.slice(),tokenIn,tokenAmountOut,directTrade,{maxHops:1,maxNumResults:1});return singleHopTrade?convertToMoolaRouterTradeIfApplicable(tokenIn,tokenAmountOut.token,singleHopTrade):null;}// search through trades with varying hops, find best trade out of them\nlet bestTradeSoFar=null;for(let i=1;i<=MAX_HOPS;i++){const currentTrade=bestTradeExactOut(allowedPairs.slice(),tokenIn,tokenAmountOut,directTrade,{maxHops:i,maxNumResults:1});if(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;})();if(moolaRoute&&tokenAmountOut){try{const moolaTrade=MoolaDirectTrade.fromOut(moolaRoute,tokenAmountOut);if(isTradeBetter(bestTrade,moolaTrade,new Percent('0'))){return moolaTrade;}}catch(e){console.warn(e);}}return bestTrade;},[tokenIn,tokenAmountOut,allowedPairs,singleHopOnly,directTrade,disableSmartRouting,moolaRoute]);}export function useMinimaTrade(tokenAmountIn,tokenOut){const[minimaTrade,setMinimaTrade]=React.useState(undefined);const[deps,setDeps]=React.useState(undefined);const[singleHopOnly]=useUserSingleHopOnly();const[allowedSlippage]=useUserSlippageTolerance();const[fetchUpdatedData,setFetchUpdatedData]=React.useState(true);const[fetchTimeout,setFetchTimeout]=React.useState(undefined);const{address:account,network}=useCelo();const chainId=network.chainId;const library=useProvider();const provider=getProviderOrSigner(library,account||undefined);const tokens=useAllTokens();const call=React.useCallback(/*#__PURE__*/_asyncToGenerator(function*(){var _tokenAmountIn$curren,_tokenOut$address,_process$env$REACT_AP;if(!(tokenAmountIn!==null&&tokenAmountIn!==void 0&&tokenAmountIn.currency.address)||!(tokenAmountIn!==null&&tokenAmountIn!==void 0&&tokenAmountIn.raw)||!(tokenOut!==null&&tokenOut!==void 0&&tokenOut.address)){setMinimaTrade(null);setDeps(undefined);return;}const curDeps={chainId,account:account||null,allowedSlippage,singleHopOnly,inputAddr:tokenAmountIn.currency.address,outputAddr:tokenOut.address,inputAmount:tokenAmountIn.raw.toString()};if(_.isEqual(deps,curDeps)&&!fetchUpdatedData){return;}if(!fetchUpdatedData){setMinimaTrade(undefined);}setDeps(curDeps);setFetchUpdatedData(false);// fetch information of minima router\nyield fetch(\"\".concat(MINIMA_API_URL,\"?exclude=\").concat(DEXES_TO_EXCLUDE,\"&tokenIn=\").concat((_tokenAmountIn$curren=tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.currency.address)!==null&&_tokenAmountIn$curren!==void 0?_tokenAmountIn$curren:'',\"&tokenOut=\").concat((_tokenOut$address=tokenOut===null||tokenOut===void 0?void 0:tokenOut.address)!==null&&_tokenOut$address!==void 0?_tokenOut$address:'',\"&amountIn=\").concat(tokenAmountIn===null||tokenAmountIn===void 0?void 0:tokenAmountIn.raw,\"&slippage=\").concat(allowedSlippage,\"&maxHops=\").concat(singleHopOnly?1:MAX_HOPS,\"&includeTxn=true&priceImpact=true\").concat(account?'&from='+account:''),{method:'GET',headers:{'Content-Type':'application/json','X-API-KEY':(_process$env$REACT_AP=process.env.REACT_APP_MINIMA_KEY)!==null&&_process$env$REACT_AP!==void 0?_process$env$REACT_AP:''}}).then(/*#__PURE__*/function(){var _ref5=_asyncToGenerator(function*(res){if(res.status!==200){setMinimaTrade(null);return;}yield res.json().then(/*#__PURE__*/function(){var _ref6=_asyncToGenerator(function*(data){if(data.details){var _data$minimumExpected;const path=yield Promise.all(data.details.path.map(/*#__PURE__*/function(){var _ref7=_asyncToGenerator(function*(pathItem){if(!tokens[pathItem]){// in case of a token address cannot be found on Ubeswap or Uniswap tokenlists\nconst tokenContract=new ethers.Contract(pathItem,ERC20_ABI,provider);const[tokenName,symbol,decimals]=yield Promise.all([tokenContract.name(),tokenContract.symbol(),tokenContract.decimals()]);return new Token(chainId,pathItem,decimals,symbol,tokenName);}return tokens[pathItem];});return function(_x3){return _ref7.apply(this,arguments);};}()));const trade=MinimaRouterTrade.fromMinimaTradePayload([new Pair(new TokenAmount(tokenAmountIn.currency,JSBI.BigInt(10000)),new TokenAmount(tokenOut,JSBI.BigInt(20000)))],tokenAmountIn,new TokenAmount(tokenOut,JSBI.BigInt(data.details.expectedOutputAmount.toString())),data.routerAddress,new Percent(JSBI.BigInt(data.priceImpact.numerator),JSBI.BigInt(data.priceImpact.denominator)),path,_objectSpread(_objectSpread({},data.details),{},{inputAmount:BigNumber.from(data.details.inputAmount),minOutputAmount:BigNumber.from((_data$minimumExpected=data.minimumExpectedOut)!==null&&_data$minimumExpected!==void 0?_data$minimumExpected:'0'),expectedOutputAmount:BigNumber.from(data.details.expectedOutputAmount),deadline:BigNumber.from(data.details.deadline)}));if(account&&isBTest(account)&&data.txn){var _data$txn,_data$txn2;trade.txn={to:(_data$txn=data.txn)===null||_data$txn===void 0?void 0:_data$txn.to,data:(_data$txn2=data.txn)===null||_data$txn2===void 0?void 0:_data$txn2.data};}setMinimaTrade(trade);clearTimeout(fetchTimeout);setFetchTimeout(setTimeout(()=>{setFetchUpdatedData(true);},FETCH_MINIMA_ROUTER_TIMER));}});return function(_x2){return _ref6.apply(this,arguments);};}()).catch(e=>{console.error(e);setMinimaTrade(null);});});return function(_x){return _ref5.apply(this,arguments);};}()).catch(e=>{console.error(e);setMinimaTrade(null);});}),[account,allowedSlippage,chainId,deps,fetchTimeout,fetchUpdatedData,provider,singleHopOnly,tokenAmountIn,tokenOut,tokens]);React.useEffect(()=>{call();},[call]);return minimaTrade;}","map":null,"metadata":{},"sourceType":"module"}