{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;\nconst gindex_1 = require(\"../gindex\");\n// Not currently in use, but simpler implementation useful for testing\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofGindices(gindex) {\n  const path = new Set();\n  const branch = new Set();\n  let g = gindex;\n  while (g > 1) {\n    path.add(g);\n    branch.add(gindex_1.gindexSibling(g));\n    g = gindex_1.gindexParent(g);\n  }\n  return {\n    path,\n    branch\n  };\n}\nexports.computeProofGindices = computeProofGindices;\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofBitstrings(gindex) {\n  const path = new Set();\n  const branch = new Set();\n  let g = gindex;\n  while (g.length > 1) {\n    path.add(g);\n    const lastBit = g[g.length - 1];\n    const parent = g.substring(0, g.length - 1);\n    branch.add(parent + (Number(lastBit) ^ 1));\n    g = parent;\n  }\n  return {\n    path,\n    branch\n  };\n}\nexports.computeProofBitstrings = computeProofBitstrings;\n/**\n * Sort generalized indices in-order\n * @param bitLength maximum bit length of generalized indices to sort\n */\nfunction sortInOrderBitstrings(gindices, bitLength) {\n  if (!gindices.length) {\n    return [];\n  }\n  return gindices.map(g => g.padEnd(bitLength)).sort().map(g => g.trim());\n}\nexports.sortInOrderBitstrings = sortInOrderBitstrings;\n/**\n * Sort generalized indices in decreasing order\n */\nfunction sortDecreasingBitstrings(gindices) {\n  if (!gindices.length) {\n    return [];\n  }\n  return gindices.sort((a, b) => {\n    if (a.length < b.length) {\n      return 1;\n    } else if (b.length < a.length) {\n      return -1;\n    }\n    let aPos0 = a.indexOf(\"0\");\n    let bPos0 = b.indexOf(\"0\");\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (aPos0 === -1) {\n        return -1;\n      } else if (bPos0 === -1) {\n        return 1;\n      }\n      if (aPos0 < bPos0) {\n        return 1;\n      } else if (bPos0 < aPos0) {\n        return -1;\n      }\n      aPos0 = a.indexOf(\"0\", aPos0 + 1);\n      bPos0 = b.indexOf(\"0\", bPos0 + 1);\n    }\n  });\n}\nexports.sortDecreasingBitstrings = sortDecreasingBitstrings;\n/**\n * Filter out parent generalized indices\n */\nfunction filterParentBitstrings(gindices) {\n  const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);\n  const filtered = [];\n  outer: for (let i = 0; i < sortedBitstrings.length; i++) {\n    const bsA = sortedBitstrings[i];\n    for (let j = i + 1; j < sortedBitstrings.length; j++) {\n      const bsB = sortedBitstrings[j];\n      if (bsB.startsWith(bsA)) {\n        continue outer;\n      }\n    }\n    filtered.push(bsA);\n  }\n  return filtered;\n}\nexports.filterParentBitstrings = filterParentBitstrings;\nvar SortOrder;\n(function (SortOrder) {\n  SortOrder[SortOrder[\"InOrder\"] = 0] = \"InOrder\";\n  SortOrder[SortOrder[\"Decreasing\"] = 1] = \"Decreasing\";\n  SortOrder[SortOrder[\"Unsorted\"] = 2] = \"Unsorted\";\n})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));\n/**\n * Return the set of generalized indices required for a multiproof\n * This may include all leaves and any necessary witnesses\n * @param gindices leaves to include in proof\n * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted\n */\nfunction computeMultiProofBitstrings(gindices) {\n  let includeLeaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let sortOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SortOrder.InOrder;\n  const leaves = filterParentBitstrings(gindices);\n  // Maybe initialize the proof indices with the leaves\n  const proof = new Set(includeLeaves ? leaves : []);\n  const paths = new Set();\n  const branches = new Set();\n  // Collect all path indices and all branch indices\n  let maxBitLength = 1;\n  for (const gindex of leaves) {\n    if (gindex.length > maxBitLength) maxBitLength = gindex.length;\n    const {\n      path,\n      branch\n    } = computeProofBitstrings(gindex);\n    path.forEach(g => paths.add(g));\n    branch.forEach(g => branches.add(g));\n  }\n  // Remove all branches that are included in the paths\n  paths.forEach(g => branches.delete(g));\n  // Add all remaining branches to the leaves\n  branches.forEach(g => proof.add(g));\n  switch (sortOrder) {\n    case SortOrder.InOrder:\n      return sortInOrderBitstrings(Array.from(proof), maxBitLength);\n    case SortOrder.Decreasing:\n      return sortDecreasingBitstrings(Array.from(proof));\n    case SortOrder.Unsorted:\n      return Array.from(proof);\n  }\n}\nexports.computeMultiProofBitstrings = computeMultiProofBitstrings;","map":{"version":3,"names":["Object","defineProperty","exports","value","computeMultiProofBitstrings","SortOrder","filterParentBitstrings","sortDecreasingBitstrings","sortInOrderBitstrings","computeProofBitstrings","computeProofGindices","gindex_1","require","gindex","path","Set","branch","g","add","gindexSibling","gindexParent","length","lastBit","parent","substring","Number","gindices","bitLength","map","padEnd","sort","trim","a","b","aPos0","indexOf","bPos0","sortedBitstrings","slice","filtered","outer","i","bsA","j","bsB","startsWith","push","includeLeaves","arguments","undefined","sortOrder","InOrder","leaves","proof","paths","branches","maxBitLength","forEach","delete","Array","from","Decreasing","Unsorted"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeMultiProofBitstrings = exports.SortOrder = exports.filterParentBitstrings = exports.sortDecreasingBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;\nconst gindex_1 = require(\"../gindex\");\n// Not currently in use, but simpler implementation useful for testing\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofGindices(gindex) {\n    const path = new Set();\n    const branch = new Set();\n    let g = gindex;\n    while (g > 1) {\n        path.add(g);\n        branch.add(gindex_1.gindexSibling(g));\n        g = gindex_1.gindexParent(g);\n    }\n    return { path, branch };\n}\nexports.computeProofGindices = computeProofGindices;\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofBitstrings(gindex) {\n    const path = new Set();\n    const branch = new Set();\n    let g = gindex;\n    while (g.length > 1) {\n        path.add(g);\n        const lastBit = g[g.length - 1];\n        const parent = g.substring(0, g.length - 1);\n        branch.add(parent + (Number(lastBit) ^ 1));\n        g = parent;\n    }\n    return { path, branch };\n}\nexports.computeProofBitstrings = computeProofBitstrings;\n/**\n * Sort generalized indices in-order\n * @param bitLength maximum bit length of generalized indices to sort\n */\nfunction sortInOrderBitstrings(gindices, bitLength) {\n    if (!gindices.length) {\n        return [];\n    }\n    return gindices\n        .map((g) => g.padEnd(bitLength))\n        .sort()\n        .map((g) => g.trim());\n}\nexports.sortInOrderBitstrings = sortInOrderBitstrings;\n/**\n * Sort generalized indices in decreasing order\n */\nfunction sortDecreasingBitstrings(gindices) {\n    if (!gindices.length) {\n        return [];\n    }\n    return gindices.sort((a, b) => {\n        if (a.length < b.length) {\n            return 1;\n        }\n        else if (b.length < a.length) {\n            return -1;\n        }\n        let aPos0 = a.indexOf(\"0\");\n        let bPos0 = b.indexOf(\"0\");\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (aPos0 === -1) {\n                return -1;\n            }\n            else if (bPos0 === -1) {\n                return 1;\n            }\n            if (aPos0 < bPos0) {\n                return 1;\n            }\n            else if (bPos0 < aPos0) {\n                return -1;\n            }\n            aPos0 = a.indexOf(\"0\", aPos0 + 1);\n            bPos0 = b.indexOf(\"0\", bPos0 + 1);\n        }\n    });\n}\nexports.sortDecreasingBitstrings = sortDecreasingBitstrings;\n/**\n * Filter out parent generalized indices\n */\nfunction filterParentBitstrings(gindices) {\n    const sortedBitstrings = gindices.slice().sort((a, b) => a.length - b.length);\n    const filtered = [];\n    outer: for (let i = 0; i < sortedBitstrings.length; i++) {\n        const bsA = sortedBitstrings[i];\n        for (let j = i + 1; j < sortedBitstrings.length; j++) {\n            const bsB = sortedBitstrings[j];\n            if (bsB.startsWith(bsA)) {\n                continue outer;\n            }\n        }\n        filtered.push(bsA);\n    }\n    return filtered;\n}\nexports.filterParentBitstrings = filterParentBitstrings;\nvar SortOrder;\n(function (SortOrder) {\n    SortOrder[SortOrder[\"InOrder\"] = 0] = \"InOrder\";\n    SortOrder[SortOrder[\"Decreasing\"] = 1] = \"Decreasing\";\n    SortOrder[SortOrder[\"Unsorted\"] = 2] = \"Unsorted\";\n})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));\n/**\n * Return the set of generalized indices required for a multiproof\n * This may include all leaves and any necessary witnesses\n * @param gindices leaves to include in proof\n * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted\n */\nfunction computeMultiProofBitstrings(gindices, includeLeaves = true, sortOrder = SortOrder.InOrder) {\n    const leaves = filterParentBitstrings(gindices);\n    // Maybe initialize the proof indices with the leaves\n    const proof = new Set(includeLeaves ? leaves : []);\n    const paths = new Set();\n    const branches = new Set();\n    // Collect all path indices and all branch indices\n    let maxBitLength = 1;\n    for (const gindex of leaves) {\n        if (gindex.length > maxBitLength)\n            maxBitLength = gindex.length;\n        const { path, branch } = computeProofBitstrings(gindex);\n        path.forEach((g) => paths.add(g));\n        branch.forEach((g) => branches.add(g));\n    }\n    // Remove all branches that are included in the paths\n    paths.forEach((g) => branches.delete(g));\n    // Add all remaining branches to the leaves\n    branches.forEach((g) => proof.add(g));\n    switch (sortOrder) {\n        case SortOrder.InOrder:\n            return sortInOrderBitstrings(Array.from(proof), maxBitLength);\n        case SortOrder.Decreasing:\n            return sortDecreasingBitstrings(Array.from(proof));\n        case SortOrder.Unsorted:\n            return Array.from(proof);\n    }\n}\nexports.computeMultiProofBitstrings = computeMultiProofBitstrings;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}