{"ast":null,"code":"import _asyncToGenerator from \"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useCelo, useConnectedSigner, useProvider } from '@celo/react-celo';\nimport { JSBI, Percent, Router } from '@ubeswap/sdk';\nimport { MoolaRouterTrade } from 'components/swap/routing/hooks/useTrade';\nimport { useMemo } from 'react';\nimport { useTransactionAdder } from 'state/transactions/hooks';\nimport invariant from 'tiny-invariant';\nimport { BIPS_BASE, INITIAL_ALLOWED_SLIPPAGE } from '../constants';\nimport { calculateGasMargin, getMoolaRouterContract, getRouterContract, isAddress, shortenAddress } from '../utils';\nimport isZero from '../utils/isZero';\nimport useENS from './useENS';\nimport useTransactionDeadline from './useTransactionDeadline';\nexport let SwapCallbackState = /*#__PURE__*/function (SwapCallbackState) {\n  SwapCallbackState[SwapCallbackState[\"INVALID\"] = 0] = \"INVALID\";\n  SwapCallbackState[SwapCallbackState[\"LOADING\"] = 1] = \"LOADING\";\n  SwapCallbackState[SwapCallbackState[\"VALID\"] = 2] = \"VALID\";\n  return SwapCallbackState;\n}({});\n/**\n * Returns the swap calls that can be used to make the trade\n * @param trade trade to execute\n * @param allowedSlippage user allowed slippage\n * @param recipientAddressOrName\n */\nfunction useSwapCallArguments(trade) {\n  _s();\n  let allowedSlippage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INITIAL_ALLOWED_SLIPPAGE;\n  let\n  // in bips\n  recipientAddressOrName = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    address: account,\n    network\n  } = useCelo();\n  const library = useProvider();\n  const chainId = network.chainId;\n  const {\n    address: recipientAddress\n  } = useENS(recipientAddressOrName);\n  const recipient = recipientAddressOrName === null ? account : recipientAddress;\n  const deadline = useTransactionDeadline();\n  return useMemo(() => {\n    if (!trade || !recipient || !library || !account || !chainId || !deadline) return [];\n    const contract = trade instanceof MoolaRouterTrade ? getMoolaRouterContract(chainId, library, account) : getRouterContract(chainId, library, account);\n    const swapCallParameters = Router.swapCallParameters(trade, {\n      feeOnTransfer: !(trade instanceof MoolaRouterTrade),\n      allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n      recipient,\n      deadline: deadline.toNumber()\n    });\n    invariant(Array.isArray(swapCallParameters.args[2]), 'arg 2 not path');\n    if (trade instanceof MoolaRouterTrade) {\n      swapCallParameters.args[2] = trade.path.map(p => p.address);\n    }\n    const swapMethods = [swapCallParameters];\n\n    // TODO(igm): figure out why this is failing\n    // if (trade.tradeType === TradeType.EXACT_INPUT) {\n    //   swapMethods.push(\n    //     Router.swapCallParameters(trade, {\n    //       feeOnTransfer: true,\n    //       allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n    //       recipient,\n    //       deadline: deadline.toNumber()\n    //     })\n    //   )\n    // }\n\n    return swapMethods.map(parameters => ({\n      parameters,\n      contract\n    }));\n  }, [account, allowedSlippage, chainId, deadline, library, recipient, trade]);\n}\n\n// returns a function that will execute a swap, if the parameters are all valid\n// and the user has approved the slippage adjusted input amount for the trade\n_s(useSwapCallArguments, \"wPqsH24A22x9TwrlAi0mGnxJ7d8=\", false, function () {\n  return [useCelo, useProvider, useENS, useTransactionDeadline];\n});\nexport function useSwapCallback(trade) {\n  _s2();\n  let allowedSlippage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INITIAL_ALLOWED_SLIPPAGE;\n  let\n  // in bips\n  recipientAddressOrName = arguments.length > 2 ? arguments[2] : undefined;\n  const {\n    network,\n    address: account\n  } = useCelo();\n  const chainId = network.chainId;\n  const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName);\n  const addTransaction = useTransactionAdder();\n  const {\n    address: recipientAddress\n  } = useENS(recipientAddressOrName);\n  const recipient = recipientAddressOrName === null ? account : recipientAddress;\n  const signer = useConnectedSigner();\n  return useMemo(() => {\n    if (!trade || !account || !chainId) {\n      return {\n        state: SwapCallbackState.INVALID,\n        callback: null,\n        error: 'Missing dependencies'\n      };\n    }\n    if (!recipient) {\n      if (recipientAddressOrName !== null) {\n        return {\n          state: SwapCallbackState.INVALID,\n          callback: null,\n          error: 'Invalid recipient'\n        };\n      } else {\n        return {\n          state: SwapCallbackState.LOADING,\n          callback: null,\n          error: null\n        };\n      }\n    }\n    return {\n      state: SwapCallbackState.VALID,\n      callback: function () {\n        var _onSwap = _asyncToGenerator(function* () {\n          const estimatedCalls = yield Promise.all(swapCalls.map(call => {\n            const {\n              parameters: {\n                methodName,\n                args,\n                value\n              },\n              contract\n            } = call;\n            const options = !value || isZero(value) ? {} : {\n              value\n            };\n            return contract.estimateGas[methodName](...args, options).then(gasEstimate => {\n              return {\n                call,\n                gasEstimate\n              };\n            }).catch(gasError => {\n              console.debug('Gas estimate failed, trying eth_call to extract error', call);\n              return contract.callStatic[methodName](...args, options).then(result => {\n                console.debug('Unexpected successful call after failed estimate gas', call, gasError, result);\n                return {\n                  call,\n                  error: new Error('Unexpected issue with estimating the gas. Please try again.')\n                };\n              }).catch(callError => {\n                console.debug('Call threw error', call, callError);\n                let errorMessage;\n                switch (callError.reason) {\n                  case 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':\n                  case 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':\n                    errorMessage = 'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.';\n                    break;\n                  default:\n                    errorMessage = \"The transaction cannot succeed due to error: \".concat(callError.reason, \". This is probably an issue with one of the tokens you are swapping.\");\n                }\n                return {\n                  call,\n                  error: new Error(errorMessage)\n                };\n              });\n            });\n          }));\n\n          // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n          const successfulEstimation = estimatedCalls.find((el, ix, list) => 'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));\n          if (!successfulEstimation) {\n            const errorCalls = estimatedCalls.filter(call => 'error' in call);\n            if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error;\n            throw new Error('Unexpected error. Please contact support: none of the calls threw an error');\n          }\n          const {\n            call: {\n              contract: disconnectedContract,\n              parameters: {\n                methodName,\n                args,\n                value\n              }\n            },\n            gasEstimate\n          } = successfulEstimation;\n          const contract = disconnectedContract.connect(signer);\n          return contract[methodName](...args, {\n            gasLimit: calculateGasMargin(gasEstimate)\n          }).then(response => {\n            const inputSymbol = trade instanceof MoolaRouterTrade ? trade.path[0].symbol : trade.inputAmount.currency.symbol;\n            const outputSymbol = trade instanceof MoolaRouterTrade ? trade.path[trade.path.length - 1].symbol : trade.outputAmount.currency.symbol;\n            const inputAmount = trade.inputAmount.toSignificant(3);\n            const outputAmount = trade.outputAmount.toSignificant(3);\n            const base = \"Swap \".concat(inputAmount, \" \").concat(inputSymbol, \" for \").concat(outputAmount, \" \").concat(outputSymbol);\n            const withRecipient = recipient === account ? base : \"\".concat(base, \" to \").concat(recipientAddressOrName && isAddress(recipientAddressOrName) ? shortenAddress(recipientAddressOrName) : recipientAddressOrName);\n            addTransaction(response, {\n              summary: withRecipient\n            });\n            return response.hash;\n          }).catch(error => {\n            // if the user rejected the tx, pass this along\n            if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n              throw new Error('Transaction rejected.');\n            } else {\n              // otherwise, the error was unexpected and we need to convey that\n              console.error(\"Swap failed\", error, methodName, args, value);\n              throw new Error(\"Swap failed: \".concat(error.message));\n            }\n          });\n        });\n        function onSwap() {\n          return _onSwap.apply(this, arguments);\n        }\n        return onSwap;\n      }(),\n      error: null\n    };\n  }, [trade, account, chainId, recipient, recipientAddressOrName, swapCalls, signer, addTransaction]);\n}\n_s2(useSwapCallback, \"1SneP9fc3eltb+8jgPIArsH7jlQ=\", false, function () {\n  return [useCelo, useSwapCallArguments, useTransactionAdder, useENS, useConnectedSigner];\n});","map":{"version":3,"names":["useCelo","useConnectedSigner","useProvider","JSBI","Percent","Router","MoolaRouterTrade","useMemo","useTransactionAdder","invariant","BIPS_BASE","INITIAL_ALLOWED_SLIPPAGE","calculateGasMargin","getMoolaRouterContract","getRouterContract","isAddress","shortenAddress","isZero","useENS","useTransactionDeadline","SwapCallbackState","useSwapCallArguments","trade","_s","allowedSlippage","arguments","length","undefined","recipientAddressOrName","address","account","network","library","chainId","recipientAddress","recipient","deadline","contract","swapCallParameters","feeOnTransfer","BigInt","toNumber","Array","isArray","args","path","map","p","swapMethods","parameters","useSwapCallback","_s2","swapCalls","addTransaction","signer","state","INVALID","callback","error","LOADING","VALID","_onSwap","_asyncToGenerator","estimatedCalls","Promise","all","call","methodName","value","options","estimateGas","then","gasEstimate","catch","gasError","console","debug","callStatic","result","Error","callError","errorMessage","reason","concat","successfulEstimation","find","el","ix","list","errorCalls","filter","disconnectedContract","connect","gasLimit","response","inputSymbol","symbol","inputAmount","currency","outputSymbol","outputAmount","toSignificant","base","withRecipient","summary","hash","code","message","onSwap","apply"],"sources":["/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/src/hooks/useSwapCallback.ts"],"sourcesContent":["import { useCelo, useConnectedSigner, useProvider } from '@celo/react-celo'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { JsonRpcSigner } from '@ethersproject/providers'\nimport { JSBI, Percent, Router, SwapParameters, Trade } from '@ubeswap/sdk'\nimport { MoolaRouterTrade } from 'components/swap/routing/hooks/useTrade'\nimport { ContractTransaction } from 'ethers'\nimport { useMemo } from 'react'\nimport { useTransactionAdder } from 'state/transactions/hooks'\nimport invariant from 'tiny-invariant'\n\nimport { BIPS_BASE, INITIAL_ALLOWED_SLIPPAGE } from '../constants'\nimport { calculateGasMargin, getMoolaRouterContract, getRouterContract, isAddress, shortenAddress } from '../utils'\nimport isZero from '../utils/isZero'\nimport useENS from './useENS'\nimport useTransactionDeadline from './useTransactionDeadline'\n\nexport enum SwapCallbackState {\n  INVALID,\n  LOADING,\n  VALID,\n}\n\ninterface SwapCall {\n  contract: Contract\n  parameters: SwapParameters\n}\n\ninterface SuccessfulCall {\n  call: SwapCall\n  gasEstimate: BigNumber\n}\n\ninterface FailedCall {\n  call: SwapCall\n  error: Error\n}\n\ntype EstimatedSwapCall = SuccessfulCall | FailedCall\n\n/**\n * Returns the swap calls that can be used to make the trade\n * @param trade trade to execute\n * @param allowedSlippage user allowed slippage\n * @param recipientAddressOrName\n */\nfunction useSwapCallArguments(\n  trade: Trade | undefined, // trade to execute, required\n  allowedSlippage: number = INITIAL_ALLOWED_SLIPPAGE, // in bips\n  recipientAddressOrName: string | null // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\n): SwapCall[] {\n  const { address: account, network } = useCelo()\n  const library = useProvider()\n  const chainId = network.chainId\n\n  const { address: recipientAddress } = useENS(recipientAddressOrName)\n  const recipient = recipientAddressOrName === null ? account : recipientAddress\n  const deadline = useTransactionDeadline()\n\n  return useMemo(() => {\n    if (!trade || !recipient || !library || !account || !chainId || !deadline) return []\n\n    const contract =\n      trade instanceof MoolaRouterTrade\n        ? getMoolaRouterContract(chainId, library, account)\n        : getRouterContract(chainId, library, account)\n\n    const swapCallParameters = Router.swapCallParameters(trade, {\n      feeOnTransfer: !(trade instanceof MoolaRouterTrade),\n      allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n      recipient,\n      deadline: deadline.toNumber(),\n    })\n    invariant(Array.isArray(swapCallParameters.args[2]), 'arg 2 not path')\n    if (trade instanceof MoolaRouterTrade) {\n      swapCallParameters.args[2] = trade.path.map((p) => p.address)\n    }\n\n    const swapMethods = [swapCallParameters]\n\n    // TODO(igm): figure out why this is failing\n    // if (trade.tradeType === TradeType.EXACT_INPUT) {\n    //   swapMethods.push(\n    //     Router.swapCallParameters(trade, {\n    //       feeOnTransfer: true,\n    //       allowedSlippage: new Percent(JSBI.BigInt(allowedSlippage), BIPS_BASE),\n    //       recipient,\n    //       deadline: deadline.toNumber()\n    //     })\n    //   )\n    // }\n\n    return swapMethods.map((parameters) => ({ parameters, contract }))\n  }, [account, allowedSlippage, chainId, deadline, library, recipient, trade])\n}\n\n// returns a function that will execute a swap, if the parameters are all valid\n// and the user has approved the slippage adjusted input amount for the trade\nexport function useSwapCallback(\n  trade: Trade | undefined, // trade to execute, required\n  allowedSlippage: number = INITIAL_ALLOWED_SLIPPAGE, // in bips\n  recipientAddressOrName: string | null // the ENS name or address of the recipient of the trade, or null if swap should be returned to sender\n): { state: SwapCallbackState; callback: null | (() => Promise<string>); error: string | null } {\n  const { network, address: account } = useCelo()\n  const chainId = network.chainId\n\n  const swapCalls = useSwapCallArguments(trade, allowedSlippage, recipientAddressOrName)\n\n  const addTransaction = useTransactionAdder()\n\n  const { address: recipientAddress } = useENS(recipientAddressOrName)\n  const recipient = recipientAddressOrName === null ? account : recipientAddress\n\n  const signer = useConnectedSigner() as JsonRpcSigner\n\n  return useMemo(() => {\n    if (!trade || !account || !chainId) {\n      return { state: SwapCallbackState.INVALID, callback: null, error: 'Missing dependencies' }\n    }\n    if (!recipient) {\n      if (recipientAddressOrName !== null) {\n        return { state: SwapCallbackState.INVALID, callback: null, error: 'Invalid recipient' }\n      } else {\n        return { state: SwapCallbackState.LOADING, callback: null, error: null }\n      }\n    }\n\n    return {\n      state: SwapCallbackState.VALID,\n      callback: async function onSwap(): Promise<string> {\n        const estimatedCalls: EstimatedSwapCall[] = await Promise.all(\n          swapCalls.map((call) => {\n            const {\n              parameters: { methodName, args, value },\n              contract,\n            } = call\n            const options = !value || isZero(value) ? {} : { value }\n\n            return contract.estimateGas[methodName](...args, options)\n              .then((gasEstimate) => {\n                return {\n                  call,\n                  gasEstimate,\n                }\n              })\n              .catch((gasError) => {\n                console.debug('Gas estimate failed, trying eth_call to extract error', call)\n\n                return contract.callStatic[methodName](...args, options)\n                  .then((result) => {\n                    console.debug('Unexpected successful call after failed estimate gas', call, gasError, result)\n                    return { call, error: new Error('Unexpected issue with estimating the gas. Please try again.') }\n                  })\n                  .catch((callError) => {\n                    console.debug('Call threw error', call, callError)\n                    let errorMessage: string\n                    switch (callError.reason) {\n                      case 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT':\n                      case 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT':\n                        errorMessage =\n                          'This transaction will not succeed either due to price movement or fee on transfer. Try increasing your slippage tolerance.'\n                        break\n                      default:\n                        errorMessage = `The transaction cannot succeed due to error: ${callError.reason}. This is probably an issue with one of the tokens you are swapping.`\n                    }\n                    return { call, error: new Error(errorMessage) }\n                  })\n              })\n          })\n        )\n\n        // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n        const successfulEstimation = estimatedCalls.find(\n          (el, ix, list): el is SuccessfulCall =>\n            'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1])\n        )\n\n        if (!successfulEstimation) {\n          const errorCalls = estimatedCalls.filter((call): call is FailedCall => 'error' in call)\n          if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error\n          throw new Error('Unexpected error. Please contact support: none of the calls threw an error')\n        }\n\n        const {\n          call: {\n            contract: disconnectedContract,\n            parameters: { methodName, args, value },\n          },\n          gasEstimate,\n        } = successfulEstimation\n\n        const contract = disconnectedContract.connect(signer)\n        return contract[methodName](...args, {\n          gasLimit: calculateGasMargin(gasEstimate),\n        })\n          .then((response: ContractTransaction) => {\n            const inputSymbol =\n              trade instanceof MoolaRouterTrade ? trade.path[0].symbol : trade.inputAmount.currency.symbol\n            const outputSymbol =\n              trade instanceof MoolaRouterTrade\n                ? trade.path[trade.path.length - 1].symbol\n                : trade.outputAmount.currency.symbol\n            const inputAmount = trade.inputAmount.toSignificant(3)\n            const outputAmount = trade.outputAmount.toSignificant(3)\n\n            const base = `Swap ${inputAmount} ${inputSymbol} for ${outputAmount} ${outputSymbol}`\n            const withRecipient =\n              recipient === account\n                ? base\n                : `${base} to ${\n                    recipientAddressOrName && isAddress(recipientAddressOrName)\n                      ? shortenAddress(recipientAddressOrName)\n                      : recipientAddressOrName\n                  }`\n\n            addTransaction(response, {\n              summary: withRecipient,\n            })\n\n            return response.hash\n          })\n          .catch((error: any) => {\n            // if the user rejected the tx, pass this along\n            if (error?.code === 4001) {\n              throw new Error('Transaction rejected.')\n            } else {\n              // otherwise, the error was unexpected and we need to convey that\n              console.error(`Swap failed`, error, methodName, args, value)\n              throw new Error(`Swap failed: ${error.message}`)\n            }\n          })\n      },\n      error: null,\n    }\n  }, [trade, account, chainId, recipient, recipientAddressOrName, swapCalls, signer, addTransaction])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}