{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nconst error = {\n  message: _ref => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref;\n    return codegen_1.str(_templateObject || (_templateObject = _taggedTemplateLiteral([\"should be \", \" \", \"\"])), KWDs[keyword].okStr, schemaCode);\n  },\n  params: _ref2 => {\n    let {\n      keyword,\n      schemaCode\n    } = _ref2;\n    return codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{comparison: \", \", limit: \", \"}\"])), KWDs[keyword].okStr, schemaCode);\n  }\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      keyword,\n      it\n    } = cxt;\n    const {\n      opts,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fmt = gen.const(\"fmt\", codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), fmts, fCxt.schemaCode));\n      cxt.fail$data(codegen_1.or(codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"])), fmt), codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" instanceof RegExp\"])), fmt), codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"typeof \", \".compare != \\\"function\\\"\"])), fmt), compareCode(fmt)));\n    }\n    function validateFormat() {\n      const format = fCxt.schema;\n      const fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(\"\\\"\".concat(keyword, \"\\\": format \\\"\").concat(format, \"\\\" does not define \\\"compare\\\" function\"));\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"\", \"\"])), opts.code.formats, codegen_1.getProperty(format)) : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n    function compareCode(fmt) {\n      return codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".compare(\", \", \", \") \", \" 0\"])), fmt, data, schemaCode, KWDs[keyword].fail);\n    }\n  },\n  dependencies: [\"format\"]\n};\nconst formatLimitPlugin = ajv => {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\nexports.default = formatLimitPlugin;","map":{"version":3,"sources":["../src/limit.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != \"object\"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports.default = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map"]},"metadata":{},"sourceType":"script"}