{"ast":null,"code":"import _asyncToGenerator from\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";function wait(ms){return new Promise(resolve=>setTimeout(resolve,ms));}function waitRandom(min,max){return wait(min+Math.round(Math.random()*Math.max(0,max-min)));}/**\n * This error is thrown if the function is cancelled before completing\n */export class CancelledError extends Error{constructor(){super('Cancelled');}}/**\n * Throw this error if the function should retry\n */export class RetryableError extends Error{}/**\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\n * @param fn function to retry\n * @param n how many times to retry\n * @param minWait min wait between retries in ms\n * @param maxWait max wait between retries in ms\n */export function retry(fn,_ref){let{n,minWait,maxWait}=_ref;let completed=false;let rejectCancelled;const promise=new Promise((resolve,reject)=>{void _asyncToGenerator(function*(){rejectCancelled=reject;// eslint-disable-next-line no-constant-condition\nwhile(true){let result;try{result=yield fn();if(!completed){resolve(result);completed=true;}break;}catch(error){if(completed){break;}if(n<=0||!(error instanceof RetryableError)){reject(error);completed=true;break;}n--;}yield waitRandom(minWait,maxWait);}})();});return{promise,cancel:()=>{if(completed)return;completed=true;rejectCancelled(new CancelledError());}};}","map":null,"metadata":{},"sourceType":"module"}