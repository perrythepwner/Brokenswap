{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnionType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst none_1 = require(\"./none\");\nconst VALUE_GINDEX = BigInt(2);\nconst SELECTOR_GINDEX = BigInt(3);\n/**\n * Union: union type containing one of the given subtypes\n * - Notation: Union[type_0, type_1, ...], e.g. union[None, uint64, uint32]\n */\nclass UnionType extends composite_1.CompositeType {\n  constructor(types, opts) {\n    var _opts$typeName;\n    super();\n    this.types = types;\n    this.depth = 1;\n    this.maxChunkCount = 1;\n    this.fixedSize = null;\n    this.isList = true;\n    this.isViewMutable = true;\n    if (types.length >= 128) {\n      throw Error(\"Must have less than 128 types\");\n    }\n    if (types.length === 0) {\n      throw Error(\"Must have at least 1 type option\");\n    }\n    if (types[0] instanceof none_1.NoneType && types.length < 2) {\n      throw Error(\"Must have at least 2 type options if the first is None\");\n    }\n    for (let i = 1; i < types.length; i++) {\n      if (types[i] instanceof none_1.NoneType) {\n        throw Error(\"None may only be the first option\");\n      }\n    }\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : \"Union[\".concat(types.map(t => t.typeName).join(\",\"), \"]\");\n    const minLens = [];\n    const maxLens = [];\n    for (const _type of types) {\n      minLens.push(_type.minSize);\n      maxLens.push(_type.maxSize);\n    }\n    this.minSize = 1 + Math.min(...minLens);\n    this.maxSize = 1 + Math.max(...maxLens);\n    this.maxSelector = this.types.length - 1;\n  }\n  static named(types, opts) {\n    return new (named_1.namedClass(UnionType, opts.typeName))(types, opts);\n  }\n  defaultValue() {\n    return {\n      selector: 0,\n      value: this.types[0].defaultValue()\n    };\n  }\n  getView(tree) {\n    return this.tree_toValue(tree.rootNode);\n  }\n  getViewDU(node) {\n    return this.tree_toValue(node);\n  }\n  cacheOfViewDU() {\n    return;\n  }\n  commitView(view) {\n    return this.value_toTree(view);\n  }\n  commitViewDU(view) {\n    return this.value_toTree(view);\n  }\n  value_serializedSize(value) {\n    return 1 + this.types[value.selector].value_serializedSize(value.value);\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value.selector;\n    return this.types[value.selector].value_serializeToBytes(output, offset + 1, value.value);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const selector = data.uint8Array[start];\n    if (selector > this.maxSelector) {\n      throw Error(\"Invalid selector \".concat(selector));\n    }\n    return {\n      selector,\n      value: this.types[selector].value_deserializeFromBytes(data, start + 1, end)\n    };\n  }\n  tree_serializedSize(node) {\n    const selector = arrayBasic_1.getLengthFromRootNode(node);\n    const valueNode = node.left;\n    return 1 + this.types[selector].value_serializedSize(valueNode);\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const selector = arrayBasic_1.getLengthFromRootNode(node);\n    const valueNode = node.left;\n    output.uint8Array[offset] = selector;\n    return this.types[selector].tree_serializeToBytes(output, offset + 1, valueNode);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const selector = data.uint8Array[start];\n    if (selector > this.maxSelector) {\n      throw Error(\"Invalid selector \".concat(selector));\n    }\n    const valueNode = this.types[selector].tree_deserializeFromBytes(data, start + 1, end);\n    return arrayBasic_1.addLengthNode(valueNode, selector);\n  }\n  // Merkleization\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.selector);\n  }\n  getRoots(value) {\n    const valueRoot = this.types[value.selector].hashTreeRoot(value.value);\n    return [valueRoot];\n  }\n  // Proofs\n  getPropertyGindex(prop) {\n    switch (prop) {\n      case \"value\":\n        return VALUE_GINDEX;\n      case \"selector\":\n        return SELECTOR_GINDEX;\n      default:\n        throw new Error(\"Invalid Union type property \".concat(prop));\n    }\n  }\n  getPropertyType() {\n    // a Union has multiple types\n    throw new Error(\"Not applicable for Union type\");\n  }\n  getIndexProperty(index) {\n    if (index === 0) return \"value\";\n    if (index === 1) return \"selector\";\n    throw Error(\"Union index of out bounds\");\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    if (!rootNode) {\n      throw Error(\"rootNode required\");\n    }\n    const gindices = [persistent_merkle_tree_1.concatGindices([rootGindex, SELECTOR_GINDEX])];\n    const selector = arrayBasic_1.getLengthFromRootNode(rootNode);\n    const type = this.types[selector];\n    const extendedFieldGindex = persistent_merkle_tree_1.concatGindices([rootGindex, VALUE_GINDEX]);\n    if (composite_1.isCompositeType(type)) {\n      gindices.push(...type.tree_getLeafGindices(extendedFieldGindex, persistent_merkle_tree_1.getNode(rootNode, VALUE_GINDEX)));\n    } else {\n      gindices.push(extendedFieldGindex);\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw new Error(\"JSON must be of type object\");\n    }\n    const union = json;\n    if (typeof union.selector !== \"number\") {\n      throw new Error(\"Invalid JSON Union selector must be number\");\n    }\n    const type = this.types[union.selector];\n    if (!type) {\n      throw new Error(\"Invalid JSON Union selector out of range\");\n    }\n    return {\n      selector: union.selector,\n      value: type.toJson(union.value)\n    };\n  }\n  toJson(value) {\n    return {\n      selector: value.selector,\n      value: this.types[value.selector].toJson(value.value)\n    };\n  }\n  clone(value) {\n    return {\n      selector: value.selector,\n      value: this.types[value.selector].clone(value.value)\n    };\n  }\n  equals(a, b) {\n    if (a.selector !== b.selector) {\n      return false;\n    }\n    return this.types[a.selector].equals(a.value, b.value);\n  }\n}\nexports.UnionType = UnionType;","map":null,"metadata":{},"sourceType":"script"}