{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { captureException, showReportDialog, withScope } from '@sentry/browser';\nimport { logger } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nimport { IS_DEBUG_BUILD } from './flags';\nexport function isAtLeastReact17(version) {\n  var major = version.match(/^([^.]+)/);\n  return major !== null && parseInt(major[0]) >= 17;\n}\nexport var UNKNOWN_COMPONENT = 'unknown';\nvar INITIAL_STATE = {\n  componentStack: null,\n  error: null,\n  eventId: null\n};\n/**\n * A ErrorBoundary component that logs errors to Sentry. Requires React >= 16.\n * NOTE: If you are a Sentry user, and you are seeing this stack frame, it means the\n * Sentry React SDK ErrorBoundary caught an error invoking your application code. This\n * is expected behavior and NOT indicative of a bug with the Sentry React SDK.\n */\nvar ErrorBoundary = /** @class */function (_super) {\n  __extends(ErrorBoundary, _super);\n  function ErrorBoundary() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = INITIAL_STATE;\n    _this.resetErrorBoundary = function () {\n      var onReset = _this.props.onReset;\n      var _a = _this.state,\n        error = _a.error,\n        componentStack = _a.componentStack,\n        eventId = _a.eventId;\n      if (onReset) {\n        onReset(error, componentStack, eventId);\n      }\n      _this.setState(INITIAL_STATE);\n    };\n    return _this;\n  }\n  ErrorBoundary.prototype.componentDidCatch = function (error, _a) {\n    var _this = this;\n    var componentStack = _a.componentStack;\n    var _b = this.props,\n      beforeCapture = _b.beforeCapture,\n      onError = _b.onError,\n      showDialog = _b.showDialog,\n      dialogOptions = _b.dialogOptions;\n    withScope(function (scope) {\n      // If on React version >= 17, create stack trace from componentStack param and links\n      // to to the original error using `error.cause` otherwise relies on error param for stacktrace.\n      // Linking errors requires the `LinkedErrors` integration be enabled.\n      if (isAtLeastReact17(React.version)) {\n        var errorBoundaryError = new Error(error.message);\n        errorBoundaryError.name = \"React ErrorBoundary \" + errorBoundaryError.name;\n        errorBoundaryError.stack = componentStack;\n        // Using the `LinkedErrors` integration to link the errors together.\n        error.cause = errorBoundaryError;\n      }\n      if (beforeCapture) {\n        beforeCapture(scope, error, componentStack);\n      }\n      var eventId = captureException(error, {\n        contexts: {\n          react: {\n            componentStack: componentStack\n          }\n        }\n      });\n      if (onError) {\n        onError(error, componentStack, eventId);\n      }\n      if (showDialog) {\n        showReportDialog(__assign(__assign({}, dialogOptions), {\n          eventId: eventId\n        }));\n      }\n      // componentDidCatch is used over getDerivedStateFromError\n      // so that componentStack is accessible through state.\n      _this.setState({\n        error: error,\n        componentStack: componentStack,\n        eventId: eventId\n      });\n    });\n  };\n  ErrorBoundary.prototype.componentDidMount = function () {\n    var onMount = this.props.onMount;\n    if (onMount) {\n      onMount();\n    }\n  };\n  ErrorBoundary.prototype.componentWillUnmount = function () {\n    var _a = this.state,\n      error = _a.error,\n      componentStack = _a.componentStack,\n      eventId = _a.eventId;\n    var onUnmount = this.props.onUnmount;\n    if (onUnmount) {\n      onUnmount(error, componentStack, eventId);\n    }\n  };\n  ErrorBoundary.prototype.render = function () {\n    var _a = this.props,\n      fallback = _a.fallback,\n      children = _a.children;\n    var _b = this.state,\n      error = _b.error,\n      componentStack = _b.componentStack,\n      eventId = _b.eventId;\n    if (error) {\n      var element = undefined;\n      if (typeof fallback === 'function') {\n        element = fallback({\n          error: error,\n          componentStack: componentStack,\n          resetError: this.resetErrorBoundary,\n          eventId: eventId\n        });\n      } else {\n        element = fallback;\n      }\n      if (React.isValidElement(element)) {\n        return element;\n      }\n      if (fallback) {\n        IS_DEBUG_BUILD && logger.warn('fallback did not produce a valid ReactElement');\n      }\n      // Fail gracefully if no fallback provided or is not valid\n      return null;\n    }\n    if (typeof children === 'function') {\n      return children();\n    }\n    return children;\n  };\n  return ErrorBoundary;\n}(React.Component);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorBoundary(WrappedComponent, errorBoundaryOptions) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  var componentDisplayName = WrappedComponent.displayName || WrappedComponent.name || UNKNOWN_COMPONENT;\n  var Wrapped = function Wrapped(props) {\n    return React.createElement(ErrorBoundary, __assign({}, errorBoundaryOptions), React.createElement(WrappedComponent, __assign({}, props)));\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  Wrapped.displayName = \"errorBoundary(\" + componentDisplayName + \")\";\n  // Copy over static methods from Wrapped component to Profiler HOC\n  // See: https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over\n  hoistNonReactStatics(Wrapped, WrappedComponent);\n  return Wrapped;\n}\nexport { ErrorBoundary, withErrorBoundary };","map":null,"metadata":{},"sourceType":"module"}