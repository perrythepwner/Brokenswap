{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = require(\"@stablelib/int\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 1] << 8 | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 8;\n  out[offset + 1] = value >>> 0;\n  return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 24;\n  out[offset + 1] = value >>> 16;\n  out[offset + 2] = value >>> 8;\n  out[offset + 3] = value >>> 0;\n  return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  out[offset + 2] = value >>> 16;\n  out[offset + 3] = value >>> 24;\n  return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var hi = readInt32BE(array, offset);\n  var lo = readInt32BE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var hi = readUint32BE(array, offset);\n  var lo = readUint32BE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var lo = readInt32LE(array, offset);\n  var hi = readInt32LE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var lo = readUint32LE(array, offset);\n  var hi = readUint32LE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n  writeUint32BE(value >>> 0, out, offset + 4);\n  return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  writeUint32LE(value >>> 0, out, offset);\n  writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n  return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  }\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  }\n  var result = 0;\n  var mul = 1;\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n  return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  }\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  }\n  var result = 0;\n  var mul = 1;\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n  return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  }\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintBE value must be an integer\");\n  }\n  var div = 1;\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n  return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  }\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintLE value must be an integer\");\n  }\n  var div = 1;\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n  return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value);\n  return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value, true);\n  return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value);\n  return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value, true);\n  return out;\n}\nexports.writeFloat64LE = writeFloat64LE;","map":{"version":3,"sources":["../binary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = require(\"@stablelib/int\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readInt32BE(array, offset);\n    var lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readUint32BE(array, offset);\n    var lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readInt32LE(array, offset);\n    var hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readUint32LE(array, offset);\n    var hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\nexports.writeFloat64LE = writeFloat64LE;\n//# sourceMappingURL=binary.js.map"]},"metadata":{},"sourceType":"script"}