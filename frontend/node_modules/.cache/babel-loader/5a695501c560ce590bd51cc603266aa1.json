{"ast":null,"code":"\"use strict\";\n\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEventEmitter = void 0;\nconst events_1 = require(\"events\");\nfunction runInSeries(_x, _x2, _x3) {\n  return _runInSeries.apply(this, arguments);\n}\nfunction _runInSeries() {\n  _runInSeries = _asyncToGenerator(function* (context, tasks, data) {\n    let error;\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(tasks), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const task = _step.value;\n        {\n          try {\n            if (task.length < 2) {\n              //sync\n              task.call(context, data);\n            } else {\n              yield new Promise((resolve, reject) => {\n                task.call(context, data, error => {\n                  if (error) {\n                    reject(error);\n                  } else {\n                    resolve();\n                  }\n                });\n              });\n            }\n          } catch (e) {\n            error = e;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          yield _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if (error) {\n      throw error;\n    }\n  });\n  return _runInSeries.apply(this, arguments);\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n  emit(event) {\n    var _self$_events$event;\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let [data, callback] = args;\n    const self = this;\n    let listeners = (_self$_events$event = self._events[event]) !== null && _self$_events$event !== void 0 ? _self$_events$event : [];\n    // Optional data argument\n    if (callback === undefined && typeof data === 'function') {\n      callback = data;\n      data = undefined;\n    }\n    // Special treatment of internal newListener and removeListener events\n    if (event === 'newListener' || event === 'removeListener') {\n      data = {\n        event: data,\n        fn: callback\n      };\n      callback = undefined;\n    }\n    // A single listener is just a function not an array...\n    listeners = Array.isArray(listeners) ? listeners : [listeners];\n    runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n    return self.listenerCount(event) > 0;\n  }\n  once(event, listener) {\n    const self = this;\n    let _g2;\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Hack to support set arity\n    if (listener.length >= 2) {\n      _g2 = function g(e, next) {\n        self.removeListener(event, _g2);\n        void listener(e, next);\n      };\n    } else {\n      _g2 = function _g(e) {\n        self.removeListener(event, _g2);\n        void listener(e, _g2);\n      };\n    }\n    self.on(event, _g2);\n    return self;\n  }\n  first(event, listener) {\n    var _this$_events$event;\n    let listeners = (_this$_events$event = this._events[event]) !== null && _this$_events$event !== void 0 ? _this$_events$event : [];\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    listeners.unshift(listener);\n    return this;\n  }\n  before(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener);\n  }\n  after(event, target, listener) {\n    return this.beforeOrAfter(event, target, listener, 'after');\n  }\n  beforeOrAfter(event, target, listener, beforeOrAfter) {\n    var _this$_events$event2;\n    let listeners = (_this$_events$event2 = this._events[event]) !== null && _this$_events$event2 !== void 0 ? _this$_events$event2 : [];\n    let i;\n    let index;\n    const add = beforeOrAfter === 'after' ? 1 : 0;\n    // Contract\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n    if (typeof target !== 'function') {\n      throw new TypeError('target must be a function');\n    }\n    // Listeners are not always an array\n    if (!Array.isArray(listeners)) {\n      ;\n      this._events[event] = listeners = [listeners];\n    }\n    index = listeners.length;\n    for (i = listeners.length; i--;) {\n      if (listeners[i] === target) {\n        index = i + add;\n        break;\n      }\n    }\n    listeners.splice(index, 0, listener);\n    return this;\n  }\n  on(event, listener) {\n    return super.on(event, listener);\n  }\n  addListener(event, listener) {\n    return super.addListener(event, listener);\n  }\n  prependListener(event, listener) {\n    return super.prependListener(event, listener);\n  }\n  prependOnceListener(event, listener) {\n    return super.prependOnceListener(event, listener);\n  }\n  removeAllListeners(event) {\n    return super.removeAllListeners(event);\n  }\n  removeListener(event, listener) {\n    return super.removeListener(event, listener);\n  }\n  eventNames() {\n    return super.eventNames();\n  }\n  listeners(event) {\n    return super.listeners(event);\n  }\n  listenerCount(event) {\n    return super.listenerCount(event);\n  }\n  getMaxListeners() {\n    return super.getMaxListeners();\n  }\n  setMaxListeners(maxListeners) {\n    return super.setMaxListeners(maxListeners);\n  }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter;","map":null,"metadata":{},"sourceType":"script"}