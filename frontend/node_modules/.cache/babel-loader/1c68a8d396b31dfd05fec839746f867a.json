{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst case_1 = __importDefault(require(\"case\"));\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"../view/container\");\nconst container_2 = require(\"../viewDU/container\");\n/**\n * Container: ordered heterogeneous collection of values\n * - Notation: Custom name per instance\n */\nclass ContainerType extends composite_1.CompositeType {\n  constructor(fields, opts) {\n    var _opts$typeName, _opts$getContainerTre, _opts$getContainerTre2, _opts$getContainerTre3, _opts$getContainerTre4;\n    super(opts === null || opts === void 0 ? void 0 : opts.cachePermanentRootStruct);\n    this.fields = fields;\n    this.opts = opts;\n    this.isList = false;\n    this.isViewMutable = true;\n    // Render detailed typeName. Consumers should overwrite since it can get long\n    this.typeName = (_opts$typeName = opts === null || opts === void 0 ? void 0 : opts.typeName) !== null && _opts$typeName !== void 0 ? _opts$typeName : renderContainerTypeName(fields);\n    this.maxChunkCount = Object.keys(fields).length;\n    this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Precalculated data for faster serdes\n    this.fieldsEntries = [];\n    for (const fieldName of Object.keys(fields)) {\n      this.fieldsEntries.push({\n        fieldName,\n        fieldType: this.fields[fieldName],\n        jsonKey: precomputeJsonKey(fieldName, opts === null || opts === void 0 ? void 0 : opts.casingMap, opts === null || opts === void 0 ? void 0 : opts.jsonCase),\n        gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length))\n      });\n    }\n    if (this.fieldsEntries.length === 0) {\n      throw Error(\"Container must have > 0 fields\");\n    }\n    // Precalculate for Proofs API\n    this.fieldsGindex = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));\n    }\n    // To resolve JSON paths in fieldName notation and jsonKey notation\n    this.jsonKeyToFieldName = {};\n    for (const {\n      fieldName,\n      jsonKey\n    } of this.fieldsEntries) {\n      this.jsonKeyToFieldName[jsonKey] = fieldName;\n    }\n    const {\n      minLen,\n      maxLen,\n      fixedSize\n    } = precomputeSizes(fields);\n    this.minSize = minLen;\n    this.maxSize = maxLen;\n    this.fixedSize = fixedSize;\n    const {\n      isFixedLen,\n      fieldRangesFixedLen,\n      variableOffsetsPosition,\n      fixedEnd\n    } = precomputeSerdesData(fields);\n    this.isFixedLen = isFixedLen;\n    this.fieldRangesFixedLen = fieldRangesFixedLen;\n    this.variableOffsetsPosition = variableOffsetsPosition;\n    this.fixedEnd = fixedEnd;\n    // TODO: This options are necessary for ContainerNodeStruct to override this.\n    // Refactor this constructor to allow customization without pollutin the options\n    this.TreeView = (_opts$getContainerTre = opts === null || opts === void 0 || (_opts$getContainerTre2 = opts.getContainerTreeViewClass) === null || _opts$getContainerTre2 === void 0 ? void 0 : _opts$getContainerTre2.call(opts, this)) !== null && _opts$getContainerTre !== void 0 ? _opts$getContainerTre : container_1.getContainerTreeViewClass(this);\n    this.TreeViewDU = (_opts$getContainerTre3 = opts === null || opts === void 0 || (_opts$getContainerTre4 = opts.getContainerTreeViewDUClass) === null || _opts$getContainerTre4 === void 0 ? void 0 : _opts$getContainerTre4.call(opts, this)) !== null && _opts$getContainerTre3 !== void 0 ? _opts$getContainerTre3 : container_2.getContainerTreeViewDUClass(this);\n  }\n  static named(fields, opts) {\n    return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);\n  }\n  defaultValue() {\n    const value = {};\n    for (const {\n      fieldName,\n      fieldType\n    } of this.fieldsEntries) {\n      value[fieldName] = fieldType.defaultValue();\n    }\n    return value;\n  }\n  getView(tree) {\n    return new this.TreeView(this, tree);\n  }\n  getViewDU(node, cache) {\n    return new this.TreeViewDU(this, node, cache);\n  }\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n  commitView(view) {\n    return view.node;\n  }\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n  // Serialization + deserialization\n  // -------------------------------\n  // Containers can mix fixed length and variable length data.\n  //\n  // Fixed part                         Variable part\n  // [field1 offset][field2 data       ][field1 data               ]\n  // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]\n  value_serializedSize(value) {\n    let totalSize = 0;\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      // Offset (4 bytes) + size\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;\n    }\n    return totalSize;\n  }\n  value_serializeToBytes(output, offset, value) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4;\n        // write serialized element to variable section\n        variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);\n      } else {\n        fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);\n      }\n    }\n    return variableIndex;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const value = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n    return value;\n  }\n  tree_serializedSize(node) {\n    let totalSize = 0;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n      // Offset (4 bytes) + size\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;\n    }\n    return totalSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4;\n        // write serialized element to variable section\n        variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);\n      } else {\n        fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);\n      }\n    }\n    return variableIndex;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const nodes = new Array(this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n    return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);\n  }\n  // Merkleization\n  getRoots(struct) {\n    const roots = new Array(this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      roots[i] = fieldType.hashTreeRoot(struct[fieldName]);\n    }\n    return roots;\n  }\n  // Proofs\n  // getPropertyGindex\n  // getPropertyType\n  // tree_getLeafGindices\n  getPropertyGindex(prop) {\n    var _this$fieldsGindex$pr;\n    const gindex = (_this$fieldsGindex$pr = this.fieldsGindex[prop]) !== null && _this$fieldsGindex$pr !== void 0 ? _this$fieldsGindex$pr : this.fieldsGindex[this.jsonKeyToFieldName[prop]];\n    if (gindex === undefined) throw Error(\"Unknown container property \".concat(prop));\n    return gindex;\n  }\n  getPropertyType(prop) {\n    var _this$fields$prop;\n    const type = (_this$fields$prop = this.fields[prop]) !== null && _this$fields$prop !== void 0 ? _this$fields$prop : this.fields[this.jsonKeyToFieldName[prop]];\n    if (type === undefined) throw Error(\"Unknown container property \".concat(prop));\n    return type;\n  }\n  getIndexProperty(index) {\n    if (index >= this.fieldsEntries.length) {\n      return null;\n    }\n    return this.fieldsEntries[index].fieldName;\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    const gindices = [];\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldGindex = this.fieldsGindex[fieldName];\n      const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);\n      if (fieldType.isBasic) {\n        gindices.push(fieldGindexFromRoot);\n      } else {\n        const compositeType = fieldType;\n        if (fieldType.fixedSize === null) {\n          if (!rootNode) {\n            throw new Error(\"variable type requires tree argument to get leaves\");\n          }\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));\n        } else {\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));\n        }\n      }\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw Error(\"JSON must be of type object\");\n    }\n    if (json === null) {\n      throw Error(\"JSON must not be null\");\n    }\n    const value = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      const jsonValue = json[jsonKey];\n      if (jsonValue === undefined) {\n        throw Error(\"JSON expected key \".concat(jsonKey, \" is undefined\"));\n      }\n      value[fieldName] = fieldType.fromJson(jsonValue);\n    }\n    return value;\n  }\n  toJson(value) {\n    const json = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      json[jsonKey] = fieldType.toJson(value[fieldName]);\n    }\n    return json;\n  }\n  clone(value) {\n    const newValue = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      newValue[fieldName] = fieldType.clone(value[fieldName]);\n    }\n    return newValue;\n  }\n  equals(a, b) {\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      if (!fieldType.equals(a[fieldName], b[fieldName])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.\n   * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].\n   * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen\n   * - For variable size fields does a first pass over the fixed section to read offsets\n   */\n  getFieldRanges(data, start, end) {\n    if (this.variableOffsetsPosition.length === 0) {\n      // Validate fixed length container\n      const size = end - start;\n      if (size !== this.fixedEnd) {\n        throw Error(\"\".concat(this.typeName, \" size \").concat(size, \" not equal fixed size \").concat(this.fixedEnd));\n      }\n      return this.fieldRangesFixedLen;\n    }\n    // Read offsets in one pass\n    const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);\n    offsets.push(end - start); // The offsets are relative to the start\n    // Merge fieldRangesFixedLen + offsets in one array\n    let variableIdx = 0;\n    let fixedIdx = 0;\n    const fieldRanges = new Array(this.isFixedLen.length);\n    for (let i = 0; i < this.isFixedLen.length; i++) {\n      if (this.isFixedLen[i]) {\n        // push from fixLen ranges ++\n        fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];\n      } else {\n        // push from varLen ranges ++\n        fieldRanges[i] = {\n          start: offsets[variableIdx],\n          end: offsets[variableIdx + 1]\n        };\n        variableIdx++;\n      }\n    }\n    return fieldRanges;\n  }\n}\nexports.ContainerType = ContainerType;\n/**\n * Returns the byte ranges of all variable size fields.\n */\nfunction readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {\n  // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n  // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes\n  // Note: `fixedSizes[i] = null` if that field has variable length\n  const size = end - start;\n  // with the fixed sizes, we can read the offsets, and store for our single pass\n  const offsets = new Array(variableOffsetsPosition.length);\n  for (let i = 0; i < variableOffsetsPosition.length; i++) {\n    const offset = data.getUint32(start + variableOffsetsPosition[i], true);\n    // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size\n    if (offset > size) {\n      throw new Error(\"Offset out of bounds \".concat(offset, \" > \").concat(size));\n    }\n    if (i === 0) {\n      if (offset !== fixedEnd) {\n        throw new Error(\"First offset must equal to fixedEnd \".concat(offset, \" != \").concat(fixedEnd));\n      }\n    } else {\n      if (offset < offsets[i - 1]) {\n        throw new Error(\"Offsets must be increasing \".concat(offset, \" < \").concat(offsets[i - 1]));\n      }\n    }\n    offsets[i] = offset;\n  }\n  return offsets;\n}\n/**\n * Precompute fixed and variable offsets position for faster deserialization.\n * @returns Does a single pass over all fields and returns:\n * - isFixedLen: If field index [i] is fixed length\n * - fieldRangesFixedLen: For fields with fixed length, their range of bytes\n * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields\n * - fixedEnd: End of the fixed size range\n * -\n */\nfunction precomputeSerdesData(fields) {\n  const isFixedLen = [];\n  const fieldRangesFixedLen = [];\n  const variableOffsetsPosition = [];\n  let pointerFixed = 0;\n  for (const fieldType of Object.values(fields)) {\n    isFixedLen.push(fieldType.fixedSize !== null);\n    if (fieldType.fixedSize === null) {\n      // Variable length\n      variableOffsetsPosition.push(pointerFixed);\n      pointerFixed += 4;\n    } else {\n      fieldRangesFixedLen.push({\n        start: pointerFixed,\n        end: pointerFixed + fieldType.fixedSize\n      });\n      pointerFixed += fieldType.fixedSize;\n    }\n  }\n  return {\n    isFixedLen,\n    fieldRangesFixedLen,\n    variableOffsetsPosition,\n    fixedEnd: pointerFixed\n  };\n}\n/**\n * Precompute sizes of the Container doing one pass over fields\n */\nfunction precomputeSizes(fields) {\n  let minLen = 0;\n  let maxLen = 0;\n  let fixedSize = 0;\n  for (const fieldType of Object.values(fields)) {\n    minLen += fieldType.minSize;\n    maxLen += fieldType.maxSize;\n    if (fieldType.fixedSize === null) {\n      // +4 for the offset\n      minLen += 4;\n      maxLen += 4;\n      fixedSize = null;\n    } else if (fixedSize !== null) {\n      fixedSize += fieldType.fixedSize;\n    }\n  }\n  return {\n    minLen,\n    maxLen,\n    fixedSize\n  };\n}\n/**\n * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.\n * To transform JSON payloads to a casing that is different from the type's defined use external tooling.\n */\nfunction precomputeJsonKey(fieldName, casingMap, jsonCase) {\n  if (casingMap) {\n    const keyFromCaseMap = casingMap[fieldName];\n    if (keyFromCaseMap === undefined) {\n      throw Error(\"casingMap[\".concat(fieldName, \"] not defined\"));\n    }\n    return keyFromCaseMap;\n  } else if (jsonCase) {\n    if (jsonCase === \"eth2\") {\n      const snake = case_1.default.snake(fieldName);\n      return snake.replace(/(\\d)$/, \"_$1\");\n    } else {\n      return case_1.default[jsonCase](fieldName);\n    }\n  } else {\n    return fieldName;\n  }\n}\nexports.precomputeJsonKey = precomputeJsonKey;\n/**\n * Render field typeNames for a detailed typeName of this Container\n */\nfunction renderContainerTypeName(fields) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Container\";\n  const fieldNames = Object.keys(fields);\n  const fieldTypeNames = fieldNames.map(fieldName => \"\".concat(fieldName, \": \").concat(fields[fieldName].typeName)).join(\", \");\n  return \"\".concat(prefix, \"({\").concat(fieldTypeNames, \"})\");\n}\nexports.renderContainerTypeName = renderContainerTypeName;","map":{"version":3,"sources":["../../src/type/container.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAA,wBAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;AAUA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AA8BA;;;AAGG;AACH,MAAa,aAA4D,SAAQ,WAAA,CAAA,aAIhF,CAAA;EAyBC,WAAA,CAAqB,MAAc,EAAW,IAA+B,EAAA;IAAA,IAAA,cAAA,EAAA,qBAAA,EAAA,sBAAA,EAAA,sBAAA,EAAA,sBAAA;IAC3E,KAAK,CAAC,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,wBAAwB,CAAC;IADlB,IAAA,CAAA,MAAM,GAAN,MAAM;IAAmB,IAAA,CAAA,IAAI,GAAJ,IAAI;IAlBzC,IAAA,CAAA,MAAM,GAAG,KAAK;IACd,IAAA,CAAA,aAAa,GAAG,IAAI;IAoB3B;IACA,IAAI,CAAC,QAAQ,IAAA,cAAA,GAAG,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,QAAQ,cAAA,cAAA,cAAA,cAAA,GAAI,uBAAuB,CAAC,MAAM,CAAC;IAEjE,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM;IAC/C,IAAI,CAAC,KAAK,GAAG,WAAA,CAAA,gBAAgB,CAAC,IAAI,CAAC,aAAa,CAAC;IAEjD;IACA,IAAI,CAAC,aAAa,GAAG,EAAE;IACvB,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAqB,EAAE;MAC/D,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;QACtB,SAAS;QACT,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QACjC,OAAO,EAAE,iBAAiB,CAAC,SAAS,EAAE,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,SAAS,EAAE,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,QAAQ,CAAC;QACtE,MAAM,EAAE,wBAAA,CAAA,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;OAC/D,CAAC;IACH;IAED,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;MACnC,MAAM,KAAK,CAAC,gCAAgC,CAAC;IAC9C;IAED;IACA,IAAI,CAAC,YAAY,GAAG,CAAA,CAAkC;IACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,wBAAA,CAAA,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;IACrF;IAED;IACA,IAAI,CAAC,kBAAkB,GAAG,CAAA,CAAE;IAC5B,KAAK,MAAM;MAAC,SAAS;MAAE;IAAO,CAAC,IAAI,IAAI,CAAC,aAAa,EAAE;MACrD,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,GAAG,SAAS;IAC7C;IAED,MAAM;MAAC,MAAM;MAAE,MAAM;MAAE;IAAS,CAAC,GAAG,eAAe,CAAC,MAAM,CAAC;IAC3D,IAAI,CAAC,OAAO,GAAG,MAAM;IACrB,IAAI,CAAC,OAAO,GAAG,MAAM;IACrB,IAAI,CAAC,SAAS,GAAG,SAAS;IAE1B,MAAM;MAAC,UAAU;MAAE,mBAAmB;MAAE,uBAAuB;MAAE;IAAQ,CAAC,GAAG,oBAAoB,CAAC,MAAM,CAAC;IACzG,IAAI,CAAC,UAAU,GAAG,UAAU;IAC5B,IAAI,CAAC,mBAAmB,GAAG,mBAAmB;IAC9C,IAAI,CAAC,uBAAuB,GAAG,uBAAuB;IACtD,IAAI,CAAC,QAAQ,GAAG,QAAQ;IAExB;IACA;IACA,IAAI,CAAC,QAAQ,IAAA,qBAAA,GAAG,IAAI,aAAJ,IAAI,gBAAA,sBAAA,GAAJ,IAAI,CAAE,yBAAyB,cAAA,sBAAA,uBAA/B,sBAAA,CAAA,IAAA,CAAA,IAAI,EAA8B,IAAI,CAAC,cAAA,qBAAA,cAAA,qBAAA,GAAI,WAAA,CAAA,yBAAyB,CAAC,IAAI,CAAC;IAC1F,IAAI,CAAC,UAAU,IAAA,sBAAA,GAAG,IAAI,aAAJ,IAAI,gBAAA,sBAAA,GAAJ,IAAI,CAAE,2BAA2B,cAAA,sBAAA,uBAAjC,sBAAA,CAAA,IAAA,CAAA,IAAI,EAAgC,IAAI,CAAC,cAAA,sBAAA,cAAA,sBAAA,GAAI,WAAA,CAAA,2BAA2B,CAAC,IAAI,CAAC;EAClG;EAEA,OAAO,KAAK,CACV,MAAc,EACd,IAAmD,EAAA;IAEnD,OAAO,KAAK,OAAA,CAAA,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC;EACrE;EAEA,YAAY,CAAA,EAAA;IACV,MAAM,KAAK,GAAG,CAAA,CAA2B;IACzC,KAAK,MAAM;MAAC,SAAS;MAAE;IAAS,CAAC,IAAI,IAAI,CAAC,aAAa,EAAE;MACvD,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,YAAY,CAAA,CAAmC;IAC7E;IACD,OAAO,KAAK;EACd;EAEA,OAAO,CAAC,IAAU,EAAA;IAChB,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;EACtC;EAEA,SAAS,CAAC,IAAU,EAAE,KAAe,EAAA;IACnC,OAAO,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;EAC/C;EAEA,aAAa,CAAC,IAAqC,EAAA;IACjD,OAAO,IAAI,CAAC,KAAK;EACnB;EAEA,UAAU,CAAC,IAAmC,EAAA;IAC5C,OAAO,IAAI,CAAC,IAAI;EAClB;EAEA,YAAY,CAAC,IAAqC,EAAA;IAChD,IAAI,CAAC,MAAM,CAAA,CAAE;IACb,OAAO,IAAI,CAAC,IAAI;EAClB;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA,oBAAoB,CAAC,KAA4B,EAAA;IAC/C,IAAI,SAAS,GAAG,CAAC;IACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD;MACA,SAAS,IACP,SAAS,CAAC,SAAS,KAAK,IAAI,GAAG,CAAC,GAAG,SAAS,CAAC,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,GAAG,SAAS,CAAC,SAAS;IAC5G;IACD,OAAO,SAAS;EAClB;EAEA,sBAAsB,CAAC,MAAiB,EAAE,MAAc,EAAE,KAA4B,EAAA;IACpF,IAAI,UAAU,GAAG,MAAM;IACvB,IAAI,aAAa,GAAG,MAAM,GAAG,IAAI,CAAC,QAAQ;IAE1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,EAAE;QAChC;QACA,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,aAAa,GAAG,MAAM,EAAE,IAAI,CAAC;QACnE,UAAU,IAAI,CAAC;QACf;QACA,aAAa,GAAG,SAAS,CAAC,sBAAsB,CAAC,MAAM,EAAE,aAAa,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;OAC1F,MAAM;QACL,UAAU,GAAG,SAAS,CAAC,sBAAsB,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;MACpF;IACF;IACD,OAAO,aAAa;EACtB;EAEA,0BAA0B,CAAC,IAAe,EAAE,KAAa,EAAE,GAAW,EAAA;IACpE,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,CAAC;IAClE,MAAM,KAAK,GAAG,CAAA,CAAoC;IAElD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD,MAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC;MACjC,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,0BAA0B,CAAC,IAAI,EAAE,KAAK,GAAG,UAAU,CAAC,KAAK,EAAE,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC;IAChH;IAED,OAAO,KAA8B;EACvC;EAEA,mBAAmB,CAAC,IAAU,EAAA;IAC5B,IAAI,SAAS,GAAG,CAAC;IACjB,MAAM,KAAK,GAAG,wBAAA,CAAA,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,CAAW;IACvF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACzC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC;MACrB;MACA,SAAS,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,GAAG,CAAC,GAAG,SAAS,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,SAAS;IAC1G;IACD,OAAO,SAAS;EAClB;EAEA,qBAAqB,CAAC,MAAiB,EAAE,MAAc,EAAE,IAAU,EAAA;IACjE,IAAI,UAAU,GAAG,MAAM;IACvB,IAAI,aAAa,GAAG,MAAM,GAAG,IAAI,CAAC,QAAQ;IAE1C,MAAM,KAAK,GAAG,wBAAA,CAAA,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;IAE7E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACzC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC;MACrB,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,EAAE;QAChC;QACA,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,aAAa,GAAG,MAAM,EAAE,IAAI,CAAC;QACnE,UAAU,IAAI,CAAC;QACf;QACA,aAAa,GAAG,SAAS,CAAC,qBAAqB,CAAC,MAAM,EAAE,aAAa,EAAE,IAAI,CAAC;OAC7E,MAAM;QACL,UAAU,GAAG,SAAS,CAAC,qBAAqB,CAAC,MAAM,EAAE,UAAU,EAAE,IAAI,CAAC;MACvE;IACF;IACD,OAAO,aAAa;EACtB;EAEA,yBAAyB,CAAC,IAAe,EAAE,KAAa,EAAE,GAAW,EAAA;IACnE,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,CAAC;IAClE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAO,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;IAExD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACzC,MAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC;MACjC,KAAK,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,yBAAyB,CAAC,IAAI,EAAE,KAAK,GAAG,UAAU,CAAC,KAAK,EAAE,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC;IACvG;IAED,OAAO,wBAAA,CAAA,qBAAqB,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC;EACjD;EAEA;EAEU,QAAQ,CAAC,MAA6B,EAAA;IAC9C,MAAM,KAAK,GAAG,IAAI,KAAK,CAAa,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;IAE9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD,KAAK,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IACrD;IAED,OAAO,KAAK;EACd;EAEA;EAEA;EACA;EACA;EAEA,iBAAiB,CAAC,IAAY,EAAA;IAAA,IAAA,qBAAA;IAC5B,MAAM,MAAM,IAAA,qBAAA,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,cAAA,qBAAA,cAAA,qBAAA,GAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAC1F,IAAI,MAAM,KAAK,SAAS,EAAE,MAAM,KAAK,+BAAA,MAAA,CAA+B,IAAI,CAAE,CAAC;IAC3E,OAAO,MAAM;EACf;EAEA,eAAe,CAAC,IAAY,EAAA;IAAA,IAAA,iBAAA;IAC1B,MAAM,IAAI,IAAA,iBAAA,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,cAAA,iBAAA,cAAA,iBAAA,GAAI,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAC5E,IAAI,IAAI,KAAK,SAAS,EAAE,MAAM,KAAK,+BAAA,MAAA,CAA+B,IAAI,CAAE,CAAC;IACzE,OAAO,IAAI;EACb;EAEA,gBAAgB,CAAC,KAAa,EAAA;IAC5B,IAAI,KAAK,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE;MACtC,OAAO,IAAI;IACZ;IACD,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,SAAmB;EACtD;EAEA,oBAAoB,CAAC,UAAkB,EAAE,QAAe,EAAA;IACtD,MAAM,QAAQ,GAAa,EAAE;IAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC;MAChD,MAAM,mBAAmB,GAAG,wBAAA,CAAA,cAAc,CAAC,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;MAErE,IAAI,SAAS,CAAC,OAAO,EAAE;QACrB,QAAQ,CAAC,IAAI,CAAC,mBAAmB,CAAC;OACnC,MAAM;QACL,MAAM,aAAa,GAAG,SAAwC;QAC9D,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,EAAE;UAChC,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC;UACtE;UACD,QAAQ,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,oBAAoB,CAAC,mBAAmB,EAAE,wBAAA,CAAA,OAAO,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC,CAAC;SAC1G,MAAM;UACL,QAAQ,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;QAC1E;MACF;IACF;IAED,OAAO,QAAQ;EACjB;EAEA;EAEA,QAAQ,CAAC,IAAa,EAAA;IACpB,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;MAC5B,MAAM,KAAK,CAAC,6BAA6B,CAAC;IAC3C;IACD,IAAI,IAAI,KAAK,IAAI,EAAE;MACjB,MAAM,KAAK,CAAC,uBAAuB,CAAC;IACrC;IAED,MAAM,KAAK,GAAG,CAAA,CAA2B;IAEzC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE,SAAS;QAAE;MAAO,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MAC7D,MAAM,SAAS,GAAI,IAAgC,CAAC,OAAO,CAAC;MAC5D,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,MAAM,KAAK,sBAAA,MAAA,CAAsB,OAAO,kBAAe,CAAC;MACzD;MACD,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAkC;IAClF;IAED,OAAO,KAAK;EACd;EAEA,MAAM,CAAC,KAA4B,EAAA;IACjC,MAAM,IAAI,GAA4B,CAAA,CAAE;IAExC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE,SAAS;QAAE;MAAO,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MAC7D,IAAI,CAAC,OAAO,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACnD;IAED,OAAO,IAAI;EACb;EAEA,KAAK,CAAC,KAA4B,EAAA;IAChC,MAAM,QAAQ,GAAG,CAAA,CAA2B;IAE5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD,QAAQ,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAkC;IACzF;IAED,OAAO,QAAQ;EACjB;EAEA,MAAM,CAAC,CAAwB,EAAE,CAAwB,EAAA;IACvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAClD,MAAM;QAAC,SAAS;QAAE;MAAS,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;MACpD,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE;QACjD,OAAO,KAAK;MACb;IACF;IAED,OAAO,IAAI;EACb;EAEA;;;;;AAKG;EACK,cAAc,CAAC,IAAc,EAAE,KAAa,EAAE,GAAW,EAAA;IAC/D,IAAI,IAAI,CAAC,uBAAuB,CAAC,MAAM,KAAK,CAAC,EAAE;MAC7C;MACA,MAAM,IAAI,GAAG,GAAG,GAAG,KAAK;MACxB,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE;QAC1B,MAAM,KAAK,IAAA,MAAA,CAAI,IAAI,CAAC,QAAQ,YAAA,MAAA,CAAS,IAAI,4BAAA,MAAA,CAAyB,IAAI,CAAC,QAAQ,CAAE,CAAC;MACnF;MAED,OAAO,IAAI,CAAC,mBAAmB;IAChC;IAED;IACA,MAAM,OAAO,GAAG,mBAAmB,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,uBAAuB,CAAC;IAClG,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;IAE3B;IACA,IAAI,WAAW,GAAG,CAAC;IACnB,IAAI,QAAQ,GAAG,CAAC;IAChB,MAAM,WAAW,GAAG,IAAI,KAAK,CAAa,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;IAEjE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAC/C,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE;QACtB;QACA,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,CAAC;OACtD,MAAM;QACL;QACA,WAAW,CAAC,CAAC,CAAC,GAAG;UAAC,KAAK,EAAE,OAAO,CAAC,WAAW,CAAC;UAAE,GAAG,EAAE,OAAO,CAAC,WAAW,GAAG,CAAC;QAAC,CAAC;QAC7E,WAAW,EAAE;MACd;IACF;IACD,OAAO,WAAW;EACpB;AACD;AAtXD,OAAA,CAAA,aAAA,GAAA,aAAA;AAwXA;;AAEG;AACH,SAAS,mBAAmB,CAC1B,IAAc,EACd,KAAa,EACb,GAAW,EACX,QAAgB,EAChB,uBAAiC,EAAA;EAEjC;EACA;EACA;EAEA,MAAM,IAAI,GAAG,GAAG,GAAG,KAAK;EAExB;EACA,MAAM,OAAO,GAAG,IAAI,KAAK,CAAS,uBAAuB,CAAC,MAAM,CAAC;EACjE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,uBAAuB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACvD,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,uBAAuB,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;IAEvE;IACA,IAAI,MAAM,GAAG,IAAI,EAAE;MACjB,MAAM,IAAI,KAAK,yBAAA,MAAA,CAAyB,MAAM,SAAA,MAAA,CAAM,IAAI,CAAE,CAAC;IAC5D;IACD,IAAI,CAAC,KAAK,CAAC,EAAE;MACX,IAAI,MAAM,KAAK,QAAQ,EAAE;QACvB,MAAM,IAAI,KAAK,wCAAA,MAAA,CAAwC,MAAM,UAAA,MAAA,CAAO,QAAQ,CAAE,CAAC;MAChF;KACF,MAAM;MACL,IAAI,MAAM,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;QAC3B,MAAM,IAAI,KAAK,+BAAA,MAAA,CAA+B,MAAM,SAAA,MAAA,CAAM,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAE,CAAC;MAC5E;IACF;IAED,OAAO,CAAC,CAAC,CAAC,GAAG,MAAM;EACpB;EAED,OAAO,OAAO;AAChB;AAEA;;;;;;;;AAQG;AACH,SAAS,oBAAoB,CAAC,MAAqC,EAAA;EAMjE,MAAM,UAAU,GAAc,EAAE;EAChC,MAAM,mBAAmB,GAAiB,EAAE;EAC5C,MAAM,uBAAuB,GAAa,EAAE;EAC5C,IAAI,YAAY,GAAG,CAAC;EAEpB,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;IAC7C,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,KAAK,IAAI,CAAC;IAC7C,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,EAAE;MAChC;MACA,uBAAuB,CAAC,IAAI,CAAC,YAAY,CAAC;MAC1C,YAAY,IAAI,CAAC;KAClB,MAAM;MACL,mBAAmB,CAAC,IAAI,CAAC;QAAC,KAAK,EAAE,YAAY;QAAE,GAAG,EAAE,YAAY,GAAG,SAAS,CAAC;MAAS,CAAC,CAAC;MACxF,YAAY,IAAI,SAAS,CAAC,SAAS;IACpC;EACF;EAED,OAAO;IACL,UAAU;IACV,mBAAmB;IACnB,uBAAuB;IACvB,QAAQ,EAAE;GACX;AACH;AAEA;;AAEG;AACH,SAAS,eAAe,CAAC,MAAqC,EAAA;EAK5D,IAAI,MAAM,GAAG,CAAC;EACd,IAAI,MAAM,GAAG,CAAC;EACd,IAAI,SAAS,GAAkB,CAAC;EAEhC,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;IAC7C,MAAM,IAAI,SAAS,CAAC,OAAO;IAC3B,MAAM,IAAI,SAAS,CAAC,OAAO;IAE3B,IAAI,SAAS,CAAC,SAAS,KAAK,IAAI,EAAE;MAChC;MACA,MAAM,IAAI,CAAC;MACX,MAAM,IAAI,CAAC;MACX,SAAS,GAAG,IAAI;KACjB,MAAM,IAAI,SAAS,KAAK,IAAI,EAAE;MAC7B,SAAS,IAAI,SAAS,CAAC,SAAS;IACjC;EACF;EACD,OAAO;IAAC,MAAM;IAAE,MAAM;IAAE;EAAS,CAAC;AACpC;AAEA;;;AAGG;AACH,SAAgB,iBAAiB,CAC/B,SAAuB,EACvB,SAA6B,EAC7B,QAAkB,EAAA;EAElB,IAAI,SAAS,EAAE;IACb,MAAM,cAAc,GAAG,SAAS,CAAC,SAAS,CAAC;IAC3C,IAAI,cAAc,KAAK,SAAS,EAAE;MAChC,MAAM,KAAK,cAAA,MAAA,CAAc,SAAS,kBAAe,CAAC;IACnD;IACD,OAAO,cAAwB;GAChC,MAAM,IAAI,QAAQ,EAAE;IACnB,IAAI,QAAQ,KAAK,MAAM,EAAE;MACvB,MAAM,KAAK,GAAG,MAAA,CAAA,OAAI,CAAC,KAAK,CAAC,SAAmB,CAAC;MAC7C,OAAO,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC;KACrC,MAAM;MACL,OAAO,MAAA,CAAA,OAAI,CAAC,QAAQ,CAAC,CAAC,SAAmB,CAAC;IAC3C;GACF,MAAM;IACL,OAAO,SAAmB;EAC3B;AACH;AArBA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAuBA;;AAEG;AACH,SAAgB,uBAAuB,CACrC,MAAc,EACM;EAAA,IAApB,MAAM,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAG,WAAW;EAEpB,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAqB;EAC1D,MAAM,cAAc,GAAG,UAAU,CAAC,GAAG,CAAE,SAAS,OAAA,MAAA,CAAQ,SAAS,QAAA,MAAA,CAAK,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;EAC9G,UAAA,MAAA,CAAU,MAAM,QAAA,MAAA,CAAK,cAAc;AACrC;AAPA,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst case_1 = __importDefault(require(\"case\"));\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"../view/container\");\nconst container_2 = require(\"../viewDU/container\");\n/**\n * Container: ordered heterogeneous collection of values\n * - Notation: Custom name per instance\n */\nclass ContainerType extends composite_1.CompositeType {\n    constructor(fields, opts) {\n        super(opts?.cachePermanentRootStruct);\n        this.fields = fields;\n        this.opts = opts;\n        this.isList = false;\n        this.isViewMutable = true;\n        // Render detailed typeName. Consumers should overwrite since it can get long\n        this.typeName = opts?.typeName ?? renderContainerTypeName(fields);\n        this.maxChunkCount = Object.keys(fields).length;\n        this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n        // Precalculated data for faster serdes\n        this.fieldsEntries = [];\n        for (const fieldName of Object.keys(fields)) {\n            this.fieldsEntries.push({\n                fieldName,\n                fieldType: this.fields[fieldName],\n                jsonKey: precomputeJsonKey(fieldName, opts?.casingMap, opts?.jsonCase),\n                gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length)),\n            });\n        }\n        if (this.fieldsEntries.length === 0) {\n            throw Error(\"Container must have > 0 fields\");\n        }\n        // Precalculate for Proofs API\n        this.fieldsGindex = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));\n        }\n        // To resolve JSON paths in fieldName notation and jsonKey notation\n        this.jsonKeyToFieldName = {};\n        for (const { fieldName, jsonKey } of this.fieldsEntries) {\n            this.jsonKeyToFieldName[jsonKey] = fieldName;\n        }\n        const { minLen, maxLen, fixedSize } = precomputeSizes(fields);\n        this.minSize = minLen;\n        this.maxSize = maxLen;\n        this.fixedSize = fixedSize;\n        const { isFixedLen, fieldRangesFixedLen, variableOffsetsPosition, fixedEnd } = precomputeSerdesData(fields);\n        this.isFixedLen = isFixedLen;\n        this.fieldRangesFixedLen = fieldRangesFixedLen;\n        this.variableOffsetsPosition = variableOffsetsPosition;\n        this.fixedEnd = fixedEnd;\n        // TODO: This options are necessary for ContainerNodeStruct to override this.\n        // Refactor this constructor to allow customization without pollutin the options\n        this.TreeView = opts?.getContainerTreeViewClass?.(this) ?? container_1.getContainerTreeViewClass(this);\n        this.TreeViewDU = opts?.getContainerTreeViewDUClass?.(this) ?? container_2.getContainerTreeViewDUClass(this);\n    }\n    static named(fields, opts) {\n        return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);\n    }\n    defaultValue() {\n        const value = {};\n        for (const { fieldName, fieldType } of this.fieldsEntries) {\n            value[fieldName] = fieldType.defaultValue();\n        }\n        return value;\n    }\n    getView(tree) {\n        return new this.TreeView(this, tree);\n    }\n    getViewDU(node, cache) {\n        return new this.TreeViewDU(this, node, cache);\n    }\n    cacheOfViewDU(view) {\n        return view.cache;\n    }\n    commitView(view) {\n        return view.node;\n    }\n    commitViewDU(view) {\n        view.commit();\n        return view.node;\n    }\n    // Serialization + deserialization\n    // -------------------------------\n    // Containers can mix fixed length and variable length data.\n    //\n    // Fixed part                         Variable part\n    // [field1 offset][field2 data       ][field1 data               ]\n    // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]\n    value_serializedSize(value) {\n        let totalSize = 0;\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            // Offset (4 bytes) + size\n            totalSize +=\n                fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;\n        }\n        return totalSize;\n    }\n    value_serializeToBytes(output, offset, value) {\n        let fixedIndex = offset;\n        let variableIndex = offset + this.fixedEnd;\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            if (fieldType.fixedSize === null) {\n                // write offset\n                output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n                fixedIndex += 4;\n                // write serialized element to variable section\n                variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);\n            }\n            else {\n                fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);\n            }\n        }\n        return variableIndex;\n    }\n    value_deserializeFromBytes(data, start, end) {\n        const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n        const value = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            const fieldRange = fieldRanges[i];\n            value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n        }\n        return value;\n    }\n    tree_serializedSize(node) {\n        let totalSize = 0;\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldType } = this.fieldsEntries[i];\n            const node = nodes[i];\n            // Offset (4 bytes) + size\n            totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;\n        }\n        return totalSize;\n    }\n    tree_serializeToBytes(output, offset, node) {\n        let fixedIndex = offset;\n        let variableIndex = offset + this.fixedEnd;\n        const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldType } = this.fieldsEntries[i];\n            const node = nodes[i];\n            if (fieldType.fixedSize === null) {\n                // write offset\n                output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n                fixedIndex += 4;\n                // write serialized element to variable section\n                variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);\n            }\n            else {\n                fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);\n            }\n        }\n        return variableIndex;\n    }\n    tree_deserializeFromBytes(data, start, end) {\n        const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n        const nodes = new Array(this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldType } = this.fieldsEntries[i];\n            const fieldRange = fieldRanges[i];\n            nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n        }\n        return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);\n    }\n    // Merkleization\n    getRoots(struct) {\n        const roots = new Array(this.fieldsEntries.length);\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            roots[i] = fieldType.hashTreeRoot(struct[fieldName]);\n        }\n        return roots;\n    }\n    // Proofs\n    // getPropertyGindex\n    // getPropertyType\n    // tree_getLeafGindices\n    getPropertyGindex(prop) {\n        const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];\n        if (gindex === undefined)\n            throw Error(`Unknown container property ${prop}`);\n        return gindex;\n    }\n    getPropertyType(prop) {\n        const type = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];\n        if (type === undefined)\n            throw Error(`Unknown container property ${prop}`);\n        return type;\n    }\n    getIndexProperty(index) {\n        if (index >= this.fieldsEntries.length) {\n            return null;\n        }\n        return this.fieldsEntries[index].fieldName;\n    }\n    tree_getLeafGindices(rootGindex, rootNode) {\n        const gindices = [];\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            const fieldGindex = this.fieldsGindex[fieldName];\n            const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);\n            if (fieldType.isBasic) {\n                gindices.push(fieldGindexFromRoot);\n            }\n            else {\n                const compositeType = fieldType;\n                if (fieldType.fixedSize === null) {\n                    if (!rootNode) {\n                        throw new Error(\"variable type requires tree argument to get leaves\");\n                    }\n                    gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));\n                }\n                else {\n                    gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));\n                }\n            }\n        }\n        return gindices;\n    }\n    // JSON\n    fromJson(json) {\n        if (typeof json !== \"object\") {\n            throw Error(\"JSON must be of type object\");\n        }\n        if (json === null) {\n            throw Error(\"JSON must not be null\");\n        }\n        const value = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];\n            const jsonValue = json[jsonKey];\n            if (jsonValue === undefined) {\n                throw Error(`JSON expected key ${jsonKey} is undefined`);\n            }\n            value[fieldName] = fieldType.fromJson(jsonValue);\n        }\n        return value;\n    }\n    toJson(value) {\n        const json = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType, jsonKey } = this.fieldsEntries[i];\n            json[jsonKey] = fieldType.toJson(value[fieldName]);\n        }\n        return json;\n    }\n    clone(value) {\n        const newValue = {};\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            newValue[fieldName] = fieldType.clone(value[fieldName]);\n        }\n        return newValue;\n    }\n    equals(a, b) {\n        for (let i = 0; i < this.fieldsEntries.length; i++) {\n            const { fieldName, fieldType } = this.fieldsEntries[i];\n            if (!fieldType.equals(a[fieldName], b[fieldName])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.\n     * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].\n     * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen\n     * - For variable size fields does a first pass over the fixed section to read offsets\n     */\n    getFieldRanges(data, start, end) {\n        if (this.variableOffsetsPosition.length === 0) {\n            // Validate fixed length container\n            const size = end - start;\n            if (size !== this.fixedEnd) {\n                throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);\n            }\n            return this.fieldRangesFixedLen;\n        }\n        // Read offsets in one pass\n        const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);\n        offsets.push(end - start); // The offsets are relative to the start\n        // Merge fieldRangesFixedLen + offsets in one array\n        let variableIdx = 0;\n        let fixedIdx = 0;\n        const fieldRanges = new Array(this.isFixedLen.length);\n        for (let i = 0; i < this.isFixedLen.length; i++) {\n            if (this.isFixedLen[i]) {\n                // push from fixLen ranges ++\n                fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];\n            }\n            else {\n                // push from varLen ranges ++\n                fieldRanges[i] = { start: offsets[variableIdx], end: offsets[variableIdx + 1] };\n                variableIdx++;\n            }\n        }\n        return fieldRanges;\n    }\n}\nexports.ContainerType = ContainerType;\n/**\n * Returns the byte ranges of all variable size fields.\n */\nfunction readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {\n    // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n    // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes\n    // Note: `fixedSizes[i] = null` if that field has variable length\n    const size = end - start;\n    // with the fixed sizes, we can read the offsets, and store for our single pass\n    const offsets = new Array(variableOffsetsPosition.length);\n    for (let i = 0; i < variableOffsetsPosition.length; i++) {\n        const offset = data.getUint32(start + variableOffsetsPosition[i], true);\n        // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size\n        if (offset > size) {\n            throw new Error(`Offset out of bounds ${offset} > ${size}`);\n        }\n        if (i === 0) {\n            if (offset !== fixedEnd) {\n                throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);\n            }\n        }\n        else {\n            if (offset < offsets[i - 1]) {\n                throw new Error(`Offsets must be increasing ${offset} < ${offsets[i - 1]}`);\n            }\n        }\n        offsets[i] = offset;\n    }\n    return offsets;\n}\n/**\n * Precompute fixed and variable offsets position for faster deserialization.\n * @returns Does a single pass over all fields and returns:\n * - isFixedLen: If field index [i] is fixed length\n * - fieldRangesFixedLen: For fields with fixed length, their range of bytes\n * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields\n * - fixedEnd: End of the fixed size range\n * -\n */\nfunction precomputeSerdesData(fields) {\n    const isFixedLen = [];\n    const fieldRangesFixedLen = [];\n    const variableOffsetsPosition = [];\n    let pointerFixed = 0;\n    for (const fieldType of Object.values(fields)) {\n        isFixedLen.push(fieldType.fixedSize !== null);\n        if (fieldType.fixedSize === null) {\n            // Variable length\n            variableOffsetsPosition.push(pointerFixed);\n            pointerFixed += 4;\n        }\n        else {\n            fieldRangesFixedLen.push({ start: pointerFixed, end: pointerFixed + fieldType.fixedSize });\n            pointerFixed += fieldType.fixedSize;\n        }\n    }\n    return {\n        isFixedLen,\n        fieldRangesFixedLen,\n        variableOffsetsPosition,\n        fixedEnd: pointerFixed,\n    };\n}\n/**\n * Precompute sizes of the Container doing one pass over fields\n */\nfunction precomputeSizes(fields) {\n    let minLen = 0;\n    let maxLen = 0;\n    let fixedSize = 0;\n    for (const fieldType of Object.values(fields)) {\n        minLen += fieldType.minSize;\n        maxLen += fieldType.maxSize;\n        if (fieldType.fixedSize === null) {\n            // +4 for the offset\n            minLen += 4;\n            maxLen += 4;\n            fixedSize = null;\n        }\n        else if (fixedSize !== null) {\n            fixedSize += fieldType.fixedSize;\n        }\n    }\n    return { minLen, maxLen, fixedSize };\n}\n/**\n * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.\n * To transform JSON payloads to a casing that is different from the type's defined use external tooling.\n */\nfunction precomputeJsonKey(fieldName, casingMap, jsonCase) {\n    if (casingMap) {\n        const keyFromCaseMap = casingMap[fieldName];\n        if (keyFromCaseMap === undefined) {\n            throw Error(`casingMap[${fieldName}] not defined`);\n        }\n        return keyFromCaseMap;\n    }\n    else if (jsonCase) {\n        if (jsonCase === \"eth2\") {\n            const snake = case_1.default.snake(fieldName);\n            return snake.replace(/(\\d)$/, \"_$1\");\n        }\n        else {\n            return case_1.default[jsonCase](fieldName);\n        }\n    }\n    else {\n        return fieldName;\n    }\n}\nexports.precomputeJsonKey = precomputeJsonKey;\n/**\n * Render field typeNames for a detailed typeName of this Container\n */\nfunction renderContainerTypeName(fields, prefix = \"Container\") {\n    const fieldNames = Object.keys(fields);\n    const fieldTypeNames = fieldNames.map((fieldName) => `${fieldName}: ${fields[fieldName].typeName}`).join(\", \");\n    return `${prefix}({${fieldTypeNames}})`;\n}\nexports.renderContainerTypeName = renderContainerTypeName;\n//# sourceMappingURL=container.js.map"]},"metadata":{},"sourceType":"script"}