{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nvar _asyncToGenerator = require(\"/home/simone/Scrivania/progetti/HTB_challs/HackTheBoo_23/VeryEasy2/Brokenswap/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filterFromParam = exports.FilterPolyfill = void 0;\nconst types_1 = require(\"../types\");\nconst util_1 = require(\"../util\");\nconst TIMEOUT = 5 * 60 * 1000; // 5 minutes\nconst JSONRPC_TEMPLATE = {\n  jsonrpc: \"2.0\",\n  id: 0\n};\nclass FilterPolyfill {\n  constructor(provider) {\n    this.logFilters = new Map(); // <id, filter>\n    this.blockFilters = new Set(); // <id>\n    this.pendingTransactionFilters = new Set(); // <id, true>\n    this.cursors = new Map(); // <id, cursor>\n    this.timeouts = new Map(); // <id, setTimeout id>\n    this.nextFilterId = (0, types_1.IntNumber)(1);\n    this.provider = provider;\n  }\n  newFilter(param) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const filter = filterFromParam(param);\n      const id = _this.makeFilterId();\n      const cursor = yield _this.setInitialCursorPosition(id, filter.fromBlock);\n      console.log(\"Installing new log filter(\".concat(id, \"):\"), filter, \"initial cursor position:\", cursor);\n      _this.logFilters.set(id, filter);\n      _this.setFilterTimeout(id);\n      return (0, util_1.hexStringFromIntNumber)(id);\n    })();\n  }\n  newBlockFilter() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const id = _this2.makeFilterId();\n      const cursor = yield _this2.setInitialCursorPosition(id, \"latest\");\n      console.log(\"Installing new block filter (\".concat(id, \") with initial cursor position:\"), cursor);\n      _this2.blockFilters.add(id);\n      _this2.setFilterTimeout(id);\n      return (0, util_1.hexStringFromIntNumber)(id);\n    })();\n  }\n  newPendingTransactionFilter() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const id = _this3.makeFilterId();\n      const cursor = yield _this3.setInitialCursorPosition(id, \"latest\");\n      console.log(\"Installing new block filter (\".concat(id, \") with initial cursor position:\"), cursor);\n      _this3.pendingTransactionFilters.add(id);\n      _this3.setFilterTimeout(id);\n      return (0, util_1.hexStringFromIntNumber)(id);\n    })();\n  }\n  uninstallFilter(filterId) {\n    const id = (0, util_1.intNumberFromHexString)(filterId);\n    console.log(\"Uninstalling filter (\".concat(id, \")\"));\n    this.deleteFilter(id);\n    return true;\n  }\n  getFilterChanges(filterId) {\n    const id = (0, util_1.intNumberFromHexString)(filterId);\n    if (this.timeouts.has(id)) {\n      // extend timeout\n      this.setFilterTimeout(id);\n    }\n    if (this.logFilters.has(id)) {\n      return this.getLogFilterChanges(id);\n    } else if (this.blockFilters.has(id)) {\n      return this.getBlockFilterChanges(id);\n    } else if (this.pendingTransactionFilters.has(id)) {\n      return this.getPendingTransactionFilterChanges(id);\n    }\n    return Promise.resolve(filterNotFoundError());\n  }\n  getFilterLogs(filterId) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const id = (0, util_1.intNumberFromHexString)(filterId);\n      const filter = _this4.logFilters.get(id);\n      if (!filter) {\n        return filterNotFoundError();\n      }\n      return _this4.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n        method: \"eth_getLogs\",\n        params: [paramFromFilter(filter)]\n      }));\n    })();\n  }\n  makeFilterId() {\n    return (0, types_1.IntNumber)(++this.nextFilterId);\n  }\n  sendAsyncPromise(request) {\n    return new Promise((resolve, reject) => {\n      this.provider.sendAsync(request, (err, response) => {\n        if (err) {\n          return reject(err);\n        }\n        if (Array.isArray(response) || response == null) {\n          return reject(new Error(\"unexpected response received: \".concat(JSON.stringify(response))));\n        }\n        resolve(response);\n      });\n    });\n  }\n  deleteFilter(id) {\n    console.log(\"Deleting filter (\".concat(id, \")\"));\n    this.logFilters.delete(id);\n    this.blockFilters.delete(id);\n    this.pendingTransactionFilters.delete(id);\n    this.cursors.delete(id);\n    this.timeouts.delete(id);\n  }\n  getLogFilterChanges(id) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const filter = _this5.logFilters.get(id);\n      const cursorPosition = _this5.cursors.get(id);\n      if (!cursorPosition || !filter) {\n        return filterNotFoundError();\n      }\n      const currentBlockHeight = yield _this5.getCurrentBlockHeight();\n      const toBlock = filter.toBlock === \"latest\" ? currentBlockHeight : filter.toBlock;\n      if (cursorPosition > currentBlockHeight) {\n        return emptyResult();\n      }\n      if (cursorPosition > filter.toBlock) {\n        return emptyResult();\n      }\n      console.log(\"Fetching logs from \".concat(cursorPosition, \" to \").concat(toBlock, \" for filter \").concat(id));\n      const response = yield _this5.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n        method: \"eth_getLogs\",\n        params: [paramFromFilter(Object.assign(Object.assign({}, filter), {\n          fromBlock: cursorPosition,\n          toBlock\n        }))]\n      }));\n      if (Array.isArray(response.result)) {\n        const blocks = response.result.map(log => (0, util_1.intNumberFromHexString)(log.blockNumber || \"0x0\"));\n        const highestBlock = Math.max(...blocks);\n        if (highestBlock && highestBlock > cursorPosition) {\n          const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);\n          console.log(\"Moving cursor position for filter (\".concat(id, \") from \").concat(cursorPosition, \" to \").concat(newCursorPosition));\n          _this5.cursors.set(id, newCursorPosition);\n        }\n      }\n      return response;\n    })();\n  }\n  getBlockFilterChanges(id) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const cursorPosition = _this6.cursors.get(id);\n      if (!cursorPosition) {\n        return filterNotFoundError();\n      }\n      const currentBlockHeight = yield _this6.getCurrentBlockHeight();\n      if (cursorPosition > currentBlockHeight) {\n        return emptyResult();\n      }\n      console.log(\"Fetching blocks from \".concat(cursorPosition, \" to \").concat(currentBlockHeight, \" for filter (\").concat(id, \")\"));\n      const blocks = (yield Promise.all(\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      (0, util_1.range)(cursorPosition, currentBlockHeight + 1).map(i => _this6.getBlockHashByNumber((0, types_1.IntNumber)(i))))).filter(hash => !!hash);\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks.length);\n      console.log(\"Moving cursor position for filter (\".concat(id, \") from \").concat(cursorPosition, \" to \").concat(newCursorPosition));\n      _this6.cursors.set(id, newCursorPosition);\n      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n        result: blocks\n      });\n    })();\n  }\n  getPendingTransactionFilterChanges(_id) {\n    return _asyncToGenerator(function* () {\n      // pending transaction filters are not supported\n      return Promise.resolve(emptyResult());\n    })();\n  }\n  setInitialCursorPosition(id, startBlock) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const currentBlockHeight = yield _this7.getCurrentBlockHeight();\n      const initialCursorPosition = typeof startBlock === \"number\" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;\n      _this7.cursors.set(id, initialCursorPosition);\n      return initialCursorPosition;\n    })();\n  }\n  setFilterTimeout(id) {\n    const existing = this.timeouts.get(id);\n    if (existing) {\n      window.clearTimeout(existing);\n    }\n    const timeout = window.setTimeout(() => {\n      console.log(\"Filter (\".concat(id, \") timed out\"));\n      this.deleteFilter(id);\n    }, TIMEOUT);\n    this.timeouts.set(id, timeout);\n  }\n  getCurrentBlockHeight() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        result\n      } = yield _this8.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n        method: \"eth_blockNumber\",\n        params: []\n      }));\n      return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));\n    })();\n  }\n  getBlockHashByNumber(blockNumber) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const response = yield _this9.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n        method: \"eth_getBlockByNumber\",\n        params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false]\n      }));\n      if (response.result && typeof response.result.hash === \"string\") {\n        return (0, util_1.ensureHexString)(response.result.hash);\n      }\n      return null;\n    })();\n  }\n}\nexports.FilterPolyfill = FilterPolyfill;\nfunction filterFromParam(param) {\n  return {\n    fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),\n    toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),\n    addresses: param.address === undefined ? null : Array.isArray(param.address) ? param.address : [param.address],\n    topics: param.topics || []\n  };\n}\nexports.filterFromParam = filterFromParam;\nfunction paramFromFilter(filter) {\n  const param = {\n    fromBlock: hexBlockHeightFromIntBlockHeight(filter.fromBlock),\n    toBlock: hexBlockHeightFromIntBlockHeight(filter.toBlock),\n    topics: filter.topics\n  };\n  if (filter.addresses !== null) {\n    param.address = filter.addresses;\n  }\n  return param;\n}\nfunction intBlockHeightFromHexBlockHeight(value) {\n  if (value === undefined || value === \"latest\" || value === \"pending\") {\n    return \"latest\";\n  } else if (value === \"earliest\") {\n    return (0, types_1.IntNumber)(0);\n  } else if ((0, util_1.isHexString)(value)) {\n    return (0, util_1.intNumberFromHexString)(value);\n  }\n  throw new Error(\"Invalid block option: \".concat(String(value)));\n}\nfunction hexBlockHeightFromIntBlockHeight(value) {\n  if (value === \"latest\") {\n    return value;\n  }\n  return (0, util_1.hexStringFromIntNumber)(value);\n}\nfunction filterNotFoundError() {\n  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n    error: {\n      code: -32000,\n      message: \"filter not found\"\n    }\n  });\n}\nfunction emptyResult() {\n  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n    result: []\n  });\n}","map":null,"metadata":{},"sourceType":"script"}