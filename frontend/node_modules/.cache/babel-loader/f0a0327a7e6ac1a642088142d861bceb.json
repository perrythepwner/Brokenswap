{"ast":null,"code":"var _asyncToGenerator = require(\"/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst SafeEventEmitter = require('@metamask/safe-event-emitter').default;\nconst {\n  createAsyncMiddleware,\n  createScaffoldMiddleware\n} = require('json-rpc-engine');\nconst createFilterMiddleware = require('./index.js');\nconst {\n  unsafeRandomBytes,\n  incrementHexInt\n} = require('./hexUtils.js');\nconst getBlocksForRange = require('./getBlocksForRange.js');\nmodule.exports = createSubscriptionMiddleware;\nfunction createSubscriptionMiddleware(_ref) {\n  let {\n    blockTracker,\n    provider\n  } = _ref;\n  // state and utilities for handling subscriptions\n  const subscriptions = {};\n  const filterManager = createFilterMiddleware({\n    blockTracker,\n    provider\n  });\n\n  // internal flag\n  let isDestroyed = false;\n\n  // create subscriptionManager api object\n  const events = new SafeEventEmitter();\n  const middleware = createScaffoldMiddleware({\n    eth_subscribe: createAsyncMiddleware(subscribe),\n    eth_unsubscribe: createAsyncMiddleware(unsubscribe)\n  });\n  middleware.destroy = destroy;\n  return {\n    events,\n    middleware\n  };\n  function subscribe(_x, _x2) {\n    return _subscribe.apply(this, arguments);\n  }\n  function _subscribe() {\n    _subscribe = _asyncToGenerator(function* (req, res) {\n      if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n      const subscriptionType = req.params[0];\n      // subId is 16 byte hex string\n      const subId = unsafeRandomBytes(16);\n\n      // create sub\n      let sub;\n      switch (subscriptionType) {\n        case 'newHeads':\n          sub = createSubNewHeads({\n            subId\n          });\n          break;\n        case 'logs':\n          const filterParams = req.params[1];\n          const filter = yield filterManager.newLogFilter(filterParams);\n          sub = createSubFromFilter({\n            subId,\n            filter\n          });\n          break;\n        default:\n          throw new Error(\"SubscriptionManager - unsupported subscription type \\\"\".concat(subscriptionType, \"\\\"\"));\n      }\n      subscriptions[subId] = sub;\n      res.result = subId;\n      return;\n      function createSubNewHeads(_ref2) {\n        let {\n          subId\n        } = _ref2;\n        const sub = {\n          type: subscriptionType,\n          destroy: function () {\n            var _destroy = _asyncToGenerator(function* () {\n              blockTracker.removeListener('sync', sub.update);\n            });\n            function destroy() {\n              return _destroy.apply(this, arguments);\n            }\n            return destroy;\n          }(),\n          update: function () {\n            var _update = _asyncToGenerator(function* (_ref3) {\n              let {\n                oldBlock,\n                newBlock\n              } = _ref3;\n              // for newHeads\n              const toBlock = newBlock;\n              const fromBlock = incrementHexInt(oldBlock);\n              const rawBlocks = yield getBlocksForRange({\n                provider,\n                fromBlock,\n                toBlock\n              });\n              const results = rawBlocks.map(normalizeBlock).filter(block => block !== null);\n              results.forEach(value => {\n                _emitSubscriptionResult(subId, value);\n              });\n            });\n            function update(_x5) {\n              return _update.apply(this, arguments);\n            }\n            return update;\n          }()\n        };\n        // check for subscription updates on new block\n        blockTracker.on('sync', sub.update);\n        return sub;\n      }\n      function createSubFromFilter(_ref4) {\n        let {\n          subId,\n          filter\n        } = _ref4;\n        filter.on('update', result => _emitSubscriptionResult(subId, result));\n        const sub = {\n          type: subscriptionType,\n          destroy: function () {\n            var _destroy2 = _asyncToGenerator(function* () {\n              return yield filterManager.uninstallFilter(filter.idHex);\n            });\n            function destroy() {\n              return _destroy2.apply(this, arguments);\n            }\n            return destroy;\n          }()\n        };\n        return sub;\n      }\n    });\n    return _subscribe.apply(this, arguments);\n  }\n  function unsubscribe(_x3, _x4) {\n    return _unsubscribe.apply(this, arguments);\n  }\n  function _unsubscribe() {\n    _unsubscribe = _asyncToGenerator(function* (req, res) {\n      if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n      const id = req.params[0];\n      const subscription = subscriptions[id];\n      // if missing, return \"false\" to indicate it was not removed\n      if (!subscription) {\n        res.result = false;\n        return;\n      }\n      // cleanup subscription\n      delete subscriptions[id];\n      yield subscription.destroy();\n      res.result = true;\n    });\n    return _unsubscribe.apply(this, arguments);\n  }\n  function _emitSubscriptionResult(filterIdHex, value) {\n    events.emit('notification', {\n      jsonrpc: '2.0',\n      method: 'eth_subscription',\n      params: {\n        subscription: filterIdHex,\n        result: value\n      }\n    });\n  }\n  function destroy() {\n    events.removeAllListeners();\n    for (const id in subscriptions) {\n      subscriptions[id].destroy();\n      delete subscriptions[id];\n    }\n    isDestroyed = true;\n  }\n}\nfunction normalizeBlock(block) {\n  if (block === null || block === undefined) {\n    return null;\n  }\n  return {\n    hash: block.hash,\n    parentHash: block.parentHash,\n    sha3Uncles: block.sha3Uncles,\n    miner: block.miner,\n    stateRoot: block.stateRoot,\n    transactionsRoot: block.transactionsRoot,\n    receiptsRoot: block.receiptsRoot,\n    logsBloom: block.logsBloom,\n    difficulty: block.difficulty,\n    number: block.number,\n    gasLimit: block.gasLimit,\n    gasUsed: block.gasUsed,\n    nonce: block.nonce,\n    mixHash: block.mixHash,\n    timestamp: block.timestamp,\n    extraData: block.extraData\n  };\n}","map":null,"metadata":{},"sourceType":"script"}