"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCeloMethods = void 0;
const react_1 = require("react");
const react_device_detect_1 = require("react-device-detect");
const connectors_1 = require("./connectors");
const constants_1 = require("./constants");
const use_contracts_cache_1 = require("./hooks/use-contracts-cache");
const colors_1 = require("./utils/colors");
const logger_1 = require("./utils/logger");
const network_watcher_1 = __importDefault(require("./utils/network-watcher"));
const persistor_1 = __importDefault(require("./utils/persistor"));
const updater_1 = require("./utils/updater");
function useCeloMethods({ connector, networks, network, manualNetworkMode }, dispatch, buildContractsCache) {
    const initConnector = (0, react_1.useCallback)((nextConnector, lastUsedAddress) => __awaiter(this, void 0, void 0, function* () {
        try {
            // need to set the event listeners here before initialise()
            (0, updater_1.updater)(nextConnector, dispatch);
            (0, persistor_1.default)(nextConnector);
            (0, network_watcher_1.default)(nextConnector, networks, manualNetworkMode);
            const initialisedConnector = yield nextConnector.initialise(lastUsedAddress);
            dispatch('initialisedConnector', initialisedConnector);
        }
        catch (e) {
            if (typeof e === 'symbol') {
                (0, logger_1.getApplicationLogger)().debug('[initConnector]', 'Ignoring error initializing connector with reason', e.description);
                throw e;
            }
            (0, logger_1.getApplicationLogger)().error('[initConnector]', 'Error initializing connector', nextConnector.type, e);
            const error = e instanceof Error ? e : new Error('Failed to initialise connector');
            dispatch('setConnectorInitError', error);
            throw e;
        }
    }), [dispatch, networks, manualNetworkMode]);
    const disconnect = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {
        yield connector.close();
        const passiveConnector = new connectors_1.UnauthenticatedConnector(network);
        yield initConnector(passiveConnector);
    }), [connector, network, initConnector]);
    // This is just to be used to for users to explicitly change
    // the network. It doesn't work for all wallets.
    const updateNetwork = (0, react_1.useCallback)((newNetwork, dappOnly = false) => __awaiter(this, void 0, void 0, function* () {
        (0, logger_1.getApplicationLogger)().debug('[updateNetwork]', newNetwork, connector.type);
        if (dappOnly && connector.continueNetworkUpdateFromWallet) {
            connector.continueNetworkUpdateFromWallet(newNetwork);
        }
        else if (constants_1.STATIC_NETWORK_WALLETS.includes(connector.type)) {
            throw new Error("The connected wallet's network must be changed from the wallet.");
        }
        yield connector.startNetworkChangeFromApp(newNetwork);
    }), [connector]);
    const connect = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {
        const connectionResultPromise = new Promise((resolve) => {
            dispatch('setConnectionCallback', resolve);
        });
        const newConnector = yield connectionResultPromise;
        dispatch('setConnectionCallback', null);
        if (newConnector === false) {
            throw new Error('Connection cancelled');
        }
        return newConnector;
    }), [dispatch]);
    const getConnectedKit = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {
        let initialisedConnection = connector;
        if (connector.type === constants_1.WalletTypes.Unauthenticated) {
            initialisedConnection = yield connect();
        }
        else if (!initialisedConnection.initialised) {
            yield initConnector(initialisedConnection);
        }
        return initialisedConnection.kit;
    }), [connect, connector, initConnector]);
    const updateFeeCurrency = (0, react_1.useCallback)((newFeeCurrency) => __awaiter(this, void 0, void 0, function* () {
        try {
            if (connector.supportsFeeCurrency() && connector.updateFeeCurrency) {
                yield connector.updateFeeCurrency(newFeeCurrency);
                dispatch('setFeeCurrency', newFeeCurrency);
            }
        }
        catch (error) {
            (0, logger_1.getApplicationLogger)().warn('[updateFeeCurrency]', 'updating Fee Currency not supported by this wallet or network', error);
        }
    }), [connector, dispatch]);
    const updateTheme = (0, react_1.useCallback)((theme) => {
        if (!theme)
            return dispatch('setTheme', null);
        if (process.env.NODE_ENV !== 'production') {
            (0, colors_1.fixTheme)(theme);
            (0, colors_1.contrastCheck)(theme);
        }
        dispatch('setTheme', theme);
    }, [dispatch]);
    const performActions = (0, react_1.useCallback)((...operations) => __awaiter(this, void 0, void 0, function* () {
        const kit = yield getConnectedKit();
        dispatch('setPendingActionCount', operations.length);
        const results = [];
        for (const op of operations) {
            try {
                // When on mobile direct user to their wallet app.
                if (react_device_detect_1.isMobile && connector.getDeeplinkUrl) {
                    const url = connector.getDeeplinkUrl('');
                    if (url)
                        window.open(url, '_blank');
                }
                results.push(yield op(kit));
            }
            catch (e) {
                dispatch('setPendingActionCount', 0);
                throw e;
            }
            dispatch('decrementPendingActionCount');
        }
        return results;
    }), [getConnectedKit, dispatch, connector]);
    const contractsCache = (0, use_contracts_cache_1.useContractsCache)(buildContractsCache, connector);
    const resetInitError = (0, react_1.useCallback)(() => {
        dispatch('setConnectorInitError', null);
    }, [dispatch]);
    return {
        destroy: disconnect,
        disconnect,
        initConnector,
        resetInitError,
        updateNetwork,
        connect,
        getConnectedKit,
        performActions,
        updateFeeCurrency,
        contractsCache,
        updateTheme,
    };
}
exports.useCeloMethods = useCeloMethods;
//# sourceMappingURL=use-celo-methods.js.map