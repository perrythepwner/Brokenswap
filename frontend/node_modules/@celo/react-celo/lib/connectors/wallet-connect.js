"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mini_kit_1 = require("@celo/contractkit/lib/mini-kit");
const wallet_walletconnect_1 = require("@celo/wallet-walletconnect");
const bignumber_js_1 = require("bignumber.js");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
const common_1 = require("./common");
class WalletConnectConnector extends common_1.AbstractConnector {
    constructor(network, manualNetworkMode, feeCurrency, options, autoOpen = false, getDeeplinkUrl, version, walletId) {
        super();
        this.network = network;
        this.feeCurrency = feeCurrency;
        this.options = options;
        this.autoOpen = autoOpen;
        this.getDeeplinkUrl = getDeeplinkUrl;
        this.version = version;
        this.walletId = walletId;
        this.initialised = false;
        this.type = constants_1.WalletTypes.WalletConnect;
        this.onCallRequest = (error, payload) => {
            (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'onCallRequest', payload, error ? `Error ${error.name} ${error.message}` : '');
            if (error) {
                (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-call-request', payload, error);
                this.emit(common_1.ConnectorEvents.WC_ERROR, error);
            }
        };
        this.onSessionEvent = (_error, data) => {
            var _a, _b;
            (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-session-event', (_b = (_a = data === null || data === void 0 ? void 0 : data.params) === null || _a === void 0 ? void 0 : _a.event) === null || _b === void 0 ? void 0 : _b.name, data);
            if (_error) {
                this.emit(common_1.ConnectorEvents.WC_ERROR, _error);
                return;
            }
            switch (data === null || data === void 0 ? void 0 : data.params.event.name) {
                case 'accountsChanged': {
                    if (Array.isArray(data === null || data === void 0 ? void 0 : data.params.event.data) &&
                        (data === null || data === void 0 ? void 0 : data.params.event.data[0])) {
                        return this.onAddressChange(data === null || data === void 0 ? void 0 : data.params.event.data[0]);
                    }
                    break;
                }
                case 'chainChanged': {
                    // from https://docs.walletconnect.com/2.0/web/web3wallet/wallet-usage#chainchanged
                    const chainId = data.params.chainId.split('eip155:')[1];
                    this.emit(common_1.ConnectorEvents.WALLET_CHAIN_CHANGED, Number(chainId));
                    break;
                }
                default:
                    (0, logger_1.getApplicationLogger)().warn('unsupported session_event received', data === null || data === void 0 ? void 0 : data.params.event.name);
            }
        };
        this.onSessionUpdated = (error, data) => __awaiter(this, void 0, void 0, function* () {
            (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-session-update', data);
            if (error) {
                this.emit(common_1.ConnectorEvents.WC_ERROR, error);
            }
            try {
                // either there will be data or an error
                if (data) {
                    // session update is called when the wallet connects to the dapp.
                    // it might also be called to just update the session, however this is fine
                    // since the onConnect event just updates values in reducer and if they are the same
                    // it will not trigger a re-render.
                    yield this.onConnected(data);
                }
            }
            catch (e) {
                (0, logger_1.getApplicationLogger)().error('wallet-connect', 'on-session-update', e);
                this.emit(common_1.ConnectorEvents.WC_ERROR, e);
            }
        });
        this.onSessionDeleted = (_error, data) => __awaiter(this, void 0, void 0, function* () {
            (0, logger_1.getApplicationLogger)().debug('wallet-connect', 'on-session-delete', data, _error);
            // since dapps send the event both when they initiate disconnection and
            // when responding to disconnection requests, check if dapp initiated the
            // connection to avoid closing twice.
            try {
                yield this.close();
            }
            catch (e) {
                (0, logger_1.getApplicationLogger)().warn(e);
            }
        });
        this.updateFeeCurrency = common_1.updateFeeCurrency.bind(this);
        const wallet = new wallet_walletconnect_1.WalletConnectWallet(Object.assign(Object.assign({}, options), { chainId: network.chainId }));
        this.kit = (0, mini_kit_1.newKit)(network.rpcUrl, wallet);
    }
    // this is called automatically and is what gives us the uri for the qr code to be scanned
    initialise() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initialised) {
                return this;
            }
            const wallet = this.kit.getWallet();
            wallet.on('session_update', this.onSessionUpdated);
            wallet.on('session_event', this.onSessionEvent);
            wallet.on('session_delete', this.onSessionDeleted);
            wallet.on('session_request', this.onCallRequest);
            try {
                yield this.handleUri(wallet);
            }
            catch (e) {
                (0, logger_1.getApplicationLogger)().error('Error handling uri', e);
            }
            try {
                yield wallet.init();
            }
            catch (e) {
                (0, logger_1.getApplicationLogger)().error('error wallet init', e);
            }
            const [address] = wallet.getAccounts();
            const defaultAccount = yield this.fetchWalletAddressForAccount(address);
            this.kit.connection.defaultAccount = defaultAccount;
            this.initialised = true;
            this.emit(common_1.ConnectorEvents.WC_INITIALISED);
            return this;
        });
    }
    handleUri(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield wallet.getUri();
            if (uri) {
                this.emit(common_1.ConnectorEvents.WC_URI_RECEIVED, uri);
            }
            if (uri && this.autoOpen) {
                const deepLink = this.getDeeplinkUrl ? this.getDeeplinkUrl(uri) : uri;
                if (deepLink) {
                    location.href = deepLink;
                }
            }
        });
    }
    startNetworkChangeFromApp(network) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const wallet = this.kit.getWallet();
                const previousAddress = (_a = this.kit.connection.defaultAccount) === null || _a === void 0 ? void 0 : _a.slice();
                if (this.initialised) {
                    // if not initialised, we don't need to switch networks
                    const success = yield wallet.switchToChain(Object.assign(Object.assign({}, network), { networkId: network.chainId }));
                    (0, logger_1.getApplicationLogger)().debug('[startNetworkChangeFromApp] success?', success);
                }
                this.restartKit(network);
                const newAddress = this.kit.connection.defaultAccount;
                this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);
                // its theoretically possible that a wallet will change address when switching networks
                if (previousAddress !== newAddress) {
                    this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, newAddress);
                }
            }
            catch (e) {
                this.emit(common_1.ConnectorEvents.NETWORK_CHANGE_FAILED, e);
            }
        });
    }
    restartKit(network) {
        const wallet = this.kit.getWallet();
        this.network = network; // must set to prevent loop
        try {
            this.kit.connection.stop(); // this blows up if its already stopped
        }
        finally {
            this.kit = (0, mini_kit_1.newKit)(network.rpcUrl, wallet);
            // ensure we have a default account set
            this.kit.connection.defaultAccount = wallet.getAccounts()[0];
        }
    }
    // for when the wallet is already on the desired network and the kit / dapp need to catch up.
    continueNetworkUpdateFromWallet(network) {
        this.restartKit(network);
        this.emit(common_1.ConnectorEvents.NETWORK_CHANGED, network.name);
    }
    supportsFeeCurrency() {
        // If on WC 1 it will not work due to fields being dropped
        if (!this.version || this.version === 1) {
            return false;
        }
        // TODO when V2 is used again check based on wallet?
        return true;
    }
    onAddressChange(address) {
        return __awaiter(this, void 0, void 0, function* () {
            this.kit.connection.defaultAccount =
                yield this.fetchWalletAddressForAccount(address);
            this.emit(common_1.ConnectorEvents.ADDRESS_CHANGED, address);
        });
    }
    onConnected(data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // first look for an account on the current chain if not found use the first one
            const accountForChain = data.params.namespaces.eip155.accounts.find((eipChainAccount) => {
                return (eipChainAccount.split(':')[1] === this.network.chainId.toString());
            }) || data.params.namespaces.eip155.accounts[0];
            const [_eip, chainId, account] = (_a = accountForChain === null || accountForChain === void 0 ? void 0 : accountForChain.split(':')) !== null && _a !== void 0 ? _a : [];
            const walletAddress = yield this.fetchWalletAddressForAccount(account);
            if (!walletAddress) {
                this.emit(common_1.ConnectorEvents.WC_ERROR, new Error('No account found'));
                return; // in rare case that no account is found
            }
            if (this.kit.connection.defaultAccount !== walletAddress) {
                this.kit.connection.defaultAccount = walletAddress;
            }
            this.emit(common_1.ConnectorEvents.CONNECTED, {
                walletType: this.type,
                walletId: this.walletId,
                walletChainId: parseInt(chainId),
                networkName: this.network.name,
                address: walletAddress,
            });
        });
    }
    fetchWalletAddressForAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!address) {
                return undefined;
            }
            const accounts = yield this.kit.contracts.getAccounts();
            const walletAddress = yield accounts.getWalletAddress(address);
            return new bignumber_js_1.BigNumber(walletAddress).isZero() ? address : walletAddress;
        });
    }
    close(message) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, logger_1.getApplicationLogger)().log('wallet-connect', 'close', message);
            try {
                this.initialised = false;
                const wallet = this.kit.getWallet();
                yield wallet.close();
                this.kit.connection.stop();
            }
            finally {
                this.disconnect();
            }
        });
    }
}
exports.default = WalletConnectConnector;
//# sourceMappingURL=wallet-connect.js.map